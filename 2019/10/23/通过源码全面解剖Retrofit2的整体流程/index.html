<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>通过源码全面解剖Retrofit2的整体流程 | jianyu的博客 | 每天进步一点点</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#009688">
    
    
    <meta name="keywords" content="源码,retrofit">
    <meta name="description" content="前言上两篇文章：  okhttp3源码分析之请求流程 okhttp3源码分析之拦截器  Retrofit与Okhttp是Android开发中最最热门的网络请求库，它们都来自square公司，Okhttp在前面的两篇文章中已经通过源码从请求流程和拦截器两个角度分析过，本文的主角是Retrofit，经过这几天的研究，我发现Retrofit只是一个对Okhttp网络请求框架的巧妙包装，它通过注解去定义一">
<meta property="og:type" content="article">
<meta property="og:title" content="通过源码全面解剖Retrofit2的整体流程">
<meta property="og:url" content="http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="jianyu的博客">
<meta property="og:description" content="前言上两篇文章：  okhttp3源码分析之请求流程 okhttp3源码分析之拦截器  Retrofit与Okhttp是Android开发中最最热门的网络请求库，它们都来自square公司，Okhttp在前面的两篇文章中已经通过源码从请求流程和拦截器两个角度分析过，本文的主角是Retrofit，经过这几天的研究，我发现Retrofit只是一个对Okhttp网络请求框架的巧妙包装，它通过注解去定义一">
<meta property="og:image" content="http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/retrofit1.png">
<meta property="og:image" content="http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/retrofit2.png">
<meta property="og:image" content="http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/retrofit3.png">
<meta property="article:published_time" content="2019-10-23T14:00:22.000Z">
<meta property="article:modified_time" content="2023-01-07T10:44:49.294Z">
<meta property="article:author" content="rain9155">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="retrofit">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/retrofit1.png">
    
        <link rel="alternate" type="application/atom+xml" title="jianyu的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">rain9155</h5>
          <a href="mailto:jianyu9155@gmail.com" title="jianyu9155@gmail.com" class="mail">jianyu9155@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/rain9155" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://juejin.im/user/5b437173e51d45191d79c27a/posts" target="_blank" >
                <i class="icon icon-lg icon-gg"></i>
                Juejin
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://blog.csdn.net/Rain_9155" target="_blank" >
                <i class="icon icon-lg icon-eye"></i>
                CSDN
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.jianshu.com/u/93cb7ffd83e9" target="_blank" >
                <i class="icon icon-lg icon-book"></i>
                Jianshu
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/links"  >
                <i class="icon icon-lg icon-link"></i>
                Links
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">通过源码全面解剖Retrofit2的整体流程</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">通过源码全面解剖Retrofit2的整体流程</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-10-23T14:00:22.000Z" itemprop="datePublished" class="page-time">
  2019-10-23
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">优秀开源库分析</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一、Retrofit的简单使用"><span class="post-toc-text">一、Retrofit的简单使用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二、Retrofit的相关类介绍"><span class="post-toc-text">二、Retrofit的相关类介绍</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、Call"><span class="post-toc-text">1、Call</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2、CallAdapter"><span class="post-toc-text">2、CallAdapter</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3、Converter"><span class="post-toc-text">3、Converter</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4、面向接口设计"><span class="post-toc-text">4、面向接口设计</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#三、Retrofit的创建过程"><span class="post-toc-text">三、Retrofit的创建过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、构造Builder"><span class="post-toc-text">1、构造Builder</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2、配置Builder"><span class="post-toc-text">2、配置Builder</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3、创建Retrofit实例"><span class="post-toc-text">3、创建Retrofit实例</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4、小结"><span class="post-toc-text">4、小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#四、创建Api接口实例"><span class="post-toc-text">四、创建Api接口实例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#小结"><span class="post-toc-text">小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#五、调用Api接口实例的方法"><span class="post-toc-text">五、调用Api接口实例的方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#注释1、loadServiceMethod方法"><span class="post-toc-text">注释1、loadServiceMethod方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1、ServiceMethod的创建过程"><span class="post-toc-text">1、ServiceMethod的创建过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-1、构造Builder"><span class="post-toc-text">1.1、构造Builder</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-2、创建ServiceMethod实例"><span class="post-toc-text">1.2、创建ServiceMethod实例</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2、小结"><span class="post-toc-text">2、小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#注释2、创建一个okHttpCall实例"><span class="post-toc-text">注释2、创建一个okHttpCall实例</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#注释3、把OkHttpCall适配成另一个Call"><span class="post-toc-text">注释3、把OkHttpCall适配成另一个Call</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4、小结-1"><span class="post-toc-text">4、小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#六、发起网络请求（以异步为例）"><span class="post-toc-text">六、发起网络请求（以异步为例）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、创建Okhttp的Call"><span class="post-toc-text">1、创建Okhttp的Call</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2、解析返回结果"><span class="post-toc-text">2、解析返回结果</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3、小结"><span class="post-toc-text">3、小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#总结"><span class="post-toc-text">总结</span></a></li></ol>
        </nav>
    </aside>


<article id="post-通过源码全面解剖Retrofit2的整体流程"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">通过源码全面解剖Retrofit2的整体流程</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-10-23 22:00:22" datetime="2019-10-23T14:00:22.000Z"  itemprop="datePublished">2019-10-23</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">优秀开源库分析</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上两篇文章：</p>
<ul>
<li><a href="https://rain9155.github.io/2019/09/03/okhttp3源码分析之请求流程/" target="_blank" rel="noopener">okhttp3源码分析之请求流程</a></li>
<li><a href="https://rain9155.github.io/2019/09/07/okhttp3源码分析之拦截器/" target="_blank" rel="noopener">okhttp3源码分析之拦截器</a></li>
</ul>
<p>Retrofit与Okhttp是Android开发中最最热门的网络请求库，它们都来自square公司，Okhttp在前面的两篇文章中已经通过源码从请求流程和拦截器两个角度分析过，本文的主角是Retrofit，经过这几天的研究，我发现Retrofit只是一个对Okhttp网络请求框架的巧妙包装，它通过注解去定义一个HTTP请求，然后在底层通过Okhttp发起网络请求，就是这样的一个简单的过程，其间运用了很多的设计模式：外观模式、动态代理模式、适配器模式、装饰者模式等，其最核心的是动态代理模式，所以在此之前大家对动态代理要有一个了解：</p>
<p><a href="https://rain9155.github.io/2019/10/15/代理模式/" target="_blank" rel="noopener">静态和动态代理模式</a></p>
<p>其他的设计模式我会在讲解的过程中简单介绍，除了使用了大量的设计模式，Retrofit还应用了面向接口编程的思想，使得整个系统解耦彻底，本文会通过一个简单的Retrofit使用示例，然后引出Retrofit的核心类，面向接口思想、构建过程、动态代理和网络请求过程，通过这几部分来解剖Retrofit。</p>
<p>Retrofit的项目地址：<a href="https://github.com/square/Retrofit" target="_blank" rel="noopener">Retrofit</a></p>
<blockquote>
<p>本文源码基于Retrofit2.4</p>
</blockquote>
<a id="more"></a>

<h2 id="一、Retrofit的简单使用"><a href="#一、Retrofit的简单使用" class="headerlink" title="一、Retrofit的简单使用"></a>一、Retrofit的简单使用</h2><p>首先来回忆一下Retrofit的使用，我这里使用的是<a href="https://developer.github.com/" target="_blank" rel="noopener">Github</a>平台的开放api，这个api根据用户名获取一个用户信息，首先在你的AndroidManifest.xml中声明网络权限，然后：</p>
<p>1、创建一个Api接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GithubService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;"</span>)</span><br><span class="line">    <span class="function">Call&lt;ResponseBody&gt; <span class="title">getUserInfo</span><span class="params">(@Path(<span class="string">"user"</span>)</span> String user)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我用Retrofit的注解声明了一个GET请求的方法，Call是Retrofit中的Call，而不是Okhttp中的Call，而ResponseBody是Okhttp的ResponseBody。</p>
<p>2、创建Retrofit实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Retrofit Retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>使用Builder模式构建Retrofit实例，传入baseUrl，我们平常开发一般会添加Rxjava2CallAdapterFactory和GsonConverterFactory，但这里我没有使用addCallAdapterFactory(Factory)来添加CallAdapterFactory，也没有使用addConverterFactory(Factory)来添加ConverterFactory，都使用默认的CallAdapter和Converter，默认的CallAdapter返回的就是Retrofit中的Call类型，默认的Converter会把网络请求返回数据转化为Okhttp中的ResponseBody，这也就是我上面定义接口时，Cal<T>的T是ResponseBody的原因。</p>
<p>3、创建Api接口实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GithubService service = Retrofit.create(GithubService<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>通过Retrofit实例的create方法创建Api接口实例GithubService。</p>
<p>4、调用Api接口的方法，生成Call</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;ResponseBody&gt; call = service.getUserInfo(<span class="string">"rain9155"</span>);</span><br></pre></td></tr></table></figure>

<p>调用Api接口的方法，会返回一个Call实例。</p>
<p>5、通过Call发起同步或异步请求，然后获取返回结果Response</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步请求</span></span><br><span class="line">Response&lt;ResponseBody&gt; response = call.execute();</span><br><span class="line">或</span><br><span class="line"><span class="comment">//异步请求 </span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;ResponseBody&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response)</span></span>&#123;</span><br><span class="line">            	<span class="comment">//通过Response获取网络请求返回结果</span></span><br><span class="line">                ResponseBody body = response.body();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"请求结果："</span> +  body.string());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;ResponseBody&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>通过Call的execute或enqueue方法发起网络请求，当网络请求结果返回时，就可以通过Response的body方法获取，这里因为使用默认的Converter，所以获取到的body的是Okhttp的ResponseBody，log的输出结果是<strong>JSON数据</strong>。</p>
<p>这就是Retrofit发起网络请求的五步曲，如果除去第一步，和Okhttp的使用还是非常的相似的，因为Retrofit和Okhttp的类名有很多的重复，下面如果涉及Okhttp的相关类，我会特别说明，否则默认都是属于Retrofit的。</p>
<h2 id="二、Retrofit的相关类介绍"><a href="#二、Retrofit的相关类介绍" class="headerlink" title="二、Retrofit的相关类介绍"></a>二、Retrofit的相关类介绍</h2><p>先简单的介绍一下重要的类，会对后面的阅读有帮助，当我们把Retrofir的源码clone下来，发现里面有4个主要的模块，分别是：</p>
<ul>
<li>retrofit-adapter </li>
<li>retrofit-converters</li>
<li>retrofit-mock</li>
<li>retrofit</li>
</ul>
<p>其中retrofit-mock是测试时用的，不关我们的事，和我们开发相关的是retrofit-adapter、retrofit-converters和retrofit模块，当我们没有使用外置的CallAdapter和Converters时，我们只需要依赖retrofit模块，retrofit模块中有3个非常重要的接口，分别是：</p>
<ul>
<li><strong>Call</strong>: 网络请求执行器，用于执行同步或异步的网络请求，内部最终通过Okhttp的Call发起网络请求</li>
<li><strong>CallAdapter</strong>：网络请求适配器，它用于把默认的网络请求执行器的调用形式，适配成在不同平台下的网络请求执行器的调用形式，例如Retrofit默认通过Call，内部使用ExecutorCallbackCall通过handler来执行网络请求后的线程切换，通过添加RxjavaCallAdapter后，RxjavaCallAdapter把默认的网络请求执行器适配成Observerable或Flowable，这样我可以使用Rxjava的链式调用方式来执行网络请求后的线程切换。</li>
<li><strong>Converter</strong>：数据转化器，两个方向的转化，把Api接口方法的参数注解的值转化为网络请求执行器需要的数据类型，和把网络返回的数据转化为我们需要的数据类型。</li>
</ul>
<p>还有一个Callback接口，用于回调网络请求成功或失败，很简单，就不介绍了，其中CallAdapter和Converter内部都有一个Factory类，它都是通过<a href="https://blog.csdn.net/Rain_9155/article/details/82942275" target="_blank" rel="noopener">工厂模式</a>创建，工厂模式就是<strong>将复杂对象的实例化任务交给一个类去实现，使得使用者不用知道具体参数就可以实例化出所需要的对象</strong>，在Retrofit中，想要获得CallAdapter或Converter的实例都需要通过Factory来获取。下面分别简单的介绍一下Call、CallAdapter和Converter接口的作用和在Retrofit下的默认实现。</p>
<h3 id="1、Call"><a href="#1、Call" class="headerlink" title="1、Call"></a>1、Call</h3><p>网络请求执行器，用于执行同步或异步的网络请求，Call接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//发起同步请求，返回Response</span></span><br><span class="line">  <span class="function">Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发起异步请求，使用callback把Response回调出去</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback&lt;T&gt; callback)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//当执行了execute或enqueue后，该方法返回true</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isExecuted</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//取消这次网络请求</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当执行了cancel()后，这个方法返回true</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCanceled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//clone一个Call</span></span><br><span class="line">  <span class="function">Call&lt;T&gt; <span class="title">clone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回HTTP网络请求，这个Request是来自okhttp的</span></span><br><span class="line">  <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Retrofit的Call和Okhttp的Call接口定义的方法差不多，只是多了一个clone方法，在Retrofit中，Call的默认实现类是OkHttpCall，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceMethod&lt;T, ?&gt; serviceMethod;<span class="comment">//这个ServiceMethod很重要，它封装了Api接口方法中的注解和参数信息，一个ServiceMethod对应一个Method（在创建Api接口实例会讲到）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args;<span class="comment">//代表着Api接口方法中的参数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call rawCall;<span class="comment">//这是一个来自Okhttp的Call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Throwable creationFailure;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> executed;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> canceled;</span><br><span class="line"></span><br><span class="line">    Override </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        okhttp3.Call call;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        call = rawCall;</span><br><span class="line">        <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">        okhttp3.Call call;</span><br><span class="line">        call = rawCall;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">        call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">                callFailure(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个OkHttpCall实例就代表着一次网络请求，OkHttpCall里面大部分方法的逻辑都是转发给Okhttp的Call方法。</p>
<blockquote>
<p>在本文，不管来自Okhttp的Call，还是来自Retrofit的Call，都可以理解为网络请求执行器。</p>
</blockquote>
<h3 id="2、CallAdapter"><a href="#2、CallAdapter" class="headerlink" title="2、CallAdapter"></a>2、CallAdapter</h3><p>网络请求适配器，用于把默认的网络请求执行器的调用形式，适配成在不同平台下的网络请求执行器的调用形式，CallAdapter接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallAdapter</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//返回响应body转换为Java对象时使用的类型</span></span><br><span class="line">  <span class="comment">//例如Call&lt;ResponseBody&gt;, Type就是ResponseBody，Type是来自java.lang.reflect包的</span></span><br><span class="line">  <span class="function">Type <span class="title">responseType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把Call&lt;R&gt;适配成 T 类型，就是将Retrofit的Call适配成另外一个T类型的'Call'</span></span><br><span class="line">  <span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//用于创建CallAdapter实例，通过get方法可以返回一个CallAdapter实例或null</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据Api接口定义的方法的返回值和注解信息，创建一个CallAdapter实例返回，如果这个Factory不能处理这个方法的返回值和注解信息，返回null，</span></span><br><span class="line">    <span class="comment">//注意这里的returnType != 上面的responseType，例如Call&lt;ResponseBody&gt;，returnType的Type就是Call</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="meta">@Nullable</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations,</span><br><span class="line">        Retrofit Retrofit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回ParameterizedType的上限，即泛型类型的上限</span></span><br><span class="line">    <span class="comment">//例如Call&lt;? extends ResponseBody&gt;, Type就是ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Type <span class="title">getParameterUpperBound</span><span class="params">(<span class="keyword">int</span> index, ParameterizedType type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Utils.getParameterUpperBound(index, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//返回Type的原始类型</span></span><br><span class="line">   <span class="comment">//例如Type为Call&lt;ResponseBody&gt;，返回Call.class</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class="line">      <span class="keyword">return</span> Utils.getRawType(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CallAdapter接口很简单，只有两个方法responseType和adapt方法，和一个Factory类，其中Factory类的get方法可以获取一个CallAdapter示例，CallAdapter的responseType方法就是获得Call<T>中的T类型，这个Call<T>就是我们在定义Api接口方法时方法的返回参数，CallAdapter的<strong>adapt方法</strong>用于把传入的Call<R>适配成另外一个我们所期待的’Call’，这里使用到了<a href="https://blog.csdn.net/Rain_9155/article/details/87903640" target="_blank" rel="noopener">适配器模式</a>，适配器模式就是<strong>在两个因接口不兼容的类之间加一个适配器，将一个类的接口变成客户端所期待的另一种接口，从而使得它们工作在一起</strong>，至于怎么适配就需要看适配器中得adapt方法的实现，接下来我们看adapt方法在Retrofit中的默认实现。（在Android Platform下的默认实现，Platform的概念在构建过程中会讲到）</p>
<p>在Retrofit中，CallAdapter的默认实现是一个匿名类，可以通过CallAdapter的Factory获得，CallAdapter的Factory的默认实现是<strong>ExecutorCallAdapterFactory</strong>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//线程切换执行器（在Retrofit的创建过程中会讲）</span></span><br><span class="line">  <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">  ExecutorCallAdapterFactory(Executor callbackExecutor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit Retrofit) &#123;</span><br><span class="line">      <span class="keyword">if</span> (getRawType(returnType) != Call<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//可以通过returnType获得responseType</span></span><br><span class="line">      <span class="comment">//因为returnType = Call&lt;T&gt;, 有了Call&lt;T&gt;, 当然可以获得Call中的T，而T就是responseType</span></span><br><span class="line">      <span class="keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);</span><br><span class="line">      <span class="comment">//返回一个CallAdapter匿名类</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> </span><br><span class="line">          <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">//返回responseType</span></span><br><span class="line">              <span class="keyword">return</span> responseType;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span> </span><br><span class="line">          <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//默认CallAdapter的adapt方法返回</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">//网络请求执行器（在创建Api接口实例中会讲）</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">  &#125;  </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在ExecutorCallAdapterFactory的get方法中，new了一个CallAdapter返回，在CallAdapter的adapt方法实现中，new了一个ExecutorCallbackCall返回，并把入参call和callbackExecutor传进了ExecutorCallbackCall的构造中，ExecutorCallbackCall就是一个实现了Call接口的类，还是一个Call，它就是Retrofit的默认网络请求执行器，可以看到Retrofit的默认的网络请求执行器适配，即adapt方法的默认实现就是<strong>用ExecutorCallbackCall包装传进来的Call，并返回ExecutorCallbackCall，这个传进来的Call就是Call的默认实现OkHttpCall</strong>，待会在Retrofit的构建过程中还会讲到。</p>
<p>既然CallAdapter能把默认的网络请求执行器的调用形式，适配成在不同平台下的网络请求执行器的调用形式，那么它支持哪些平台呢？这个在retrofit-adapter 模块中可以找到答案，如下：</p>
<img src="/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/retrofit1.png" class="" title="retrofit">

<p>Retrofit还支持guava、java8、rxjava、scala这四个平台，它们里面都各自实现了retrofit模块暴露出去的CallAdapter接口和CallAdapter接口中的Factory接口，在CallAdapter的adapt方法中提供各自平台的适配，我们可以通过addCallAdapterFactory(Factory)来添加不同平台的CallAdapter工厂。</p>
<h3 id="3、Converter"><a href="#3、Converter" class="headerlink" title="3、Converter"></a>3、Converter</h3><p>数据转化器，把我们在Api接口定义的方法注解和参数转化为网络请求执行器需要的请求类型，和把网络返回的数据转化为我们需要的数据类型，Converter接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//把F 转化为 T，用于在网络请求中实现对象的转化</span></span><br><span class="line">  <span class="function">T <span class="title">convert</span><span class="params">(F value)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过Factory的responseBodyConverter或requestBodyConverter方法获得一个Converter实例或null</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回一个处理网络请求响应（Response）的body的Converter实例，如果不能处理这些类型(type)和注解，返回null</span></span><br><span class="line">    <span class="comment">//这个Converter会把 ResponseBody 转化成 ?，这个ResponseBody是来自okhttp的</span></span><br><span class="line">    <span class="comment">//例如使用GsonConverter，？代表某个java对象类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type,</span><br><span class="line">        Annotation[] annotations, Retrofit Retrofit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个处理网络请求（Request）的body的Converter实例，如果不能处理这些类型(type)和注解，返回null</span></span><br><span class="line">    <span class="comment">//这个Converter会把 ？转化成 RequestBody，这个RequestBody是来自okhttp的</span></span><br><span class="line">    <span class="comment">//这个Converter主要处理@Body、 @Part、@PartMap类型的注解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class="line">        Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit Retrofit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个处理网络请求（Request）的body的Converter实例</span></span><br><span class="line">    <span class="comment">//这个Converter会把 ？转化成 String</span></span><br><span class="line">    <span class="comment">//这个Converter主要处理@Field、@FieldMap、@Header、HeaderMap @HeaderMap、@Path、@Query、@QueryMap类型的注解</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@Nullable</span> Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,</span><br><span class="line">        Retrofit Retrofit) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面两个方法和上面CallAdapter的Factory中同名方法的意思一样</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Type <span class="title">getParameterUpperBound</span><span class="params">(<span class="keyword">int</span> index, ParameterizedType type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Utils.getParameterUpperBound(index, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Class&lt;?&gt; getRawType(Type type) &#123;</span><br><span class="line">      <span class="keyword">return</span> Utils.getRawType(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Converter接口也很简单，只有一个convert方法，和一个Factory类，因为Converter要提供两个方向的转化，所以Factory类就提供了两个方法用于获取不同方向的转化，其中responseBodyConverter方法就是获得一个把网络返回的数据转化为我们需要的数据类型的Converter实例，而requestBodyConverter方法就是获得一个把我们在Api接口定义的方法注解和参数转化为网络请求的Converter实例，那么要怎么转化呢？就要看Converter的convert方法的实现，convert方法把F类型 转化为 T类型，接下来我们看convert方法在Retrofit中的默认实现。</p>
<p>Converter在Retrofit的默认实现有五个，都是Converter的Factory的内部类，可通过Converter的Factory获得，Converter的Factory的默认实现是<strong>BuiltInConverters</strong>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuiltInConverters</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,</span><br><span class="line">      Retrofit Retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == ResponseBody<span class="class">.<span class="keyword">class</span>) </span>&#123;<span class="comment">//支持ResponseBody类型的转化</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//如果是二进制流形式，就返回StreamingResponseBodyConverter实例</span></span><br><span class="line">      <span class="comment">//如果是字符流形式，就返回BufferingResponseBodyConverter实例</span></span><br><span class="line">      <span class="keyword">return</span> Utils.isAnnotationPresent(annotations, Streaming<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">          ? <span class="title">StreamingResponseBodyConverter</span>.<span class="title">INSTANCE</span></span></span><br><span class="line">          : BufferingResponseBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (type == Void<span class="class">.<span class="keyword">class</span>) </span>&#123;<span class="comment">//支持Void类型的转化</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment">//返回VoidResponseBodyConverter实例</span></span><br><span class="line">      <span class="keyword">return</span> VoidResponseBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//除了以上两种类型，其他类型都不支持，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,</span><br><span class="line">      Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit Retrofit) &#123;</span><br><span class="line">    <span class="comment">//支持向RequestBody类型转化</span></span><br><span class="line">    <span class="keyword">if</span> (RequestBody<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Utils</span>.<span class="title">getRawType</span>(<span class="title">type</span>))) </span>&#123;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//返回RequestBodyConverter实例</span></span><br><span class="line">      <span class="keyword">return</span> RequestBodyConverter.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//除了RequestBody类型，不支持向其他类型转化，返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VoidResponseBodyConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> VoidResponseBodyConverter INSTANCE = <span class="keyword">new</span> VoidResponseBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Void <span class="title">convert</span><span class="params">(ResponseBody value)</span> </span>&#123;</span><br><span class="line">      value.close();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBodyConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">RequestBody</span>, <span class="title">RequestBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> RequestBodyConverter INSTANCE = <span class="keyword">new</span> RequestBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> RequestBody <span class="title">convert</span><span class="params">(RequestBody value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamingResponseBodyConverter</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">ResponseBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> StreamingResponseBodyConverter INSTANCE = <span class="keyword">new</span> StreamingResponseBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> ResponseBody <span class="title">convert</span><span class="params">(ResponseBody value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferingResponseBodyConverter</span></span></span><br><span class="line"><span class="class">      <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">ResponseBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> BufferingResponseBodyConverter INSTANCE = <span class="keyword">new</span> BufferingResponseBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> ResponseBody <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">        <span class="keyword">return</span> Utils.buffer(value);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        value.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">Object</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ToStringConverter INSTANCE = <span class="keyword">new</span> ToStringConverter();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value.toString();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BuiltInConverters实现了Factory中的responseBodyConverter和requestBodyConverter方法，内部含有五个Converter默认实现类，在Factory的responseBodyConverter和requestBodyConverter方法中分别返回这几Converter实例，其中只有ToStringConverter没有使用到，我们还发现了这五个Converter的convert方法的实现除了BufferingResponseBodyConverter，大部分都是，入参是是什么，返回就是什么，所以Retrofit中Converter默认实现的convert方法大部分<strong>都没有对数据进行转化，返回原始数据，这些原始数据是String或来自Okhttp的ResponseBody、RequestBody</strong>，例如ResponseBodyConverter的convert方法就是返回Okhttp的ResponseBody，RequestBodyConverter的convert方法就是返回Okhttp的RequestBody。</p>
<p>Converter除了默认的返回原始数据，它还支持哪些数据转化呢？这个在retrofit-converters模块中可以找到答案，如下：</p>
<img src="/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/retrofit2.png" class="" title="Retrofit">

<p>可以看到Retrofit还支持json、xml、protobuf等多种数据类型的转化，这些子模块都各自实现了retrofit模块暴露出来的Converter接口和Converter接口中的Factory接口，在Converter的adapt方法中实现不同数据类型的转化逻辑，我们可以通过addConverterFactory(Factory)来支持不同数据类型转化的Converter工厂。</p>
<h3 id="4、面向接口设计"><a href="#4、面向接口设计" class="headerlink" title="4、面向接口设计"></a>4、面向接口设计</h3><p>在retrofit模块中提供了<strong>Call、Callback、CallAdapter、Converter接口</strong>供外部模块使用，CallAdapter和Converter接口中还有相应的Factory接口，各模块之前通过接口依赖主模块Retrofit，将网络请求、网络请求适配、请求处理与返回解析完全解耦，当需要修改Retrofit中的默认实现时，只需要add一个外部模块提供的工厂，具体创建什么样的实例由工厂方法来负责，这样就能以最小的代价（不需要改动代码）换成其他模块上的实现，Retrofit本身并不参与这个过程，它只是负责提供一些主要的参数供它们进行决策，以及进行参数的处理，模块之间依赖于接口，而不依赖于具体的实现，这是一种很好的编程思路，面向接口编程。</p>
<blockquote>
<p>面向接口编程：也被熟知为基于接口的设计，是一种基于组件级别的，面向对象语言的模块化编程设计实现，面向接口编程是面向对象编程的一种模块化实现形式，理论上说具有对象概念的程序设计都可以称之为面向对象编程，而面向接口编程则是从组件的级别来设计代码，将抽象与实现分离。</p>
</blockquote>
<p>好了，在简单的了解了一下待会和构建过程涉及到的相关类，接下来分析Retrofit的构建过程。</p>
<h2 id="三、Retrofit的创建过程"><a href="#三、Retrofit的创建过程" class="headerlink" title="三、Retrofit的创建过程"></a>三、Retrofit的创建过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Retrofit Retrofit = <span class="keyword">new</span> Retrofit.Builder()<span class="comment">//1、构造Builder</span></span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)<span class="comment">//2、配置Builder</span></span><br><span class="line">    .build();<span class="comment">//3、创建Retrofit实例</span></span><br></pre></td></tr></table></figure>

<p>Retrofit是使用<a href="https://blog.csdn.net/Rain_9155/article/details/82936136" target="_blank" rel="noopener">Builder模式</a>构建出一个Retrofit实例的，Builder模式的好处<strong>就是将一个复杂对象的构建和它的表示分离，在用户在不知道内部构建细节的情况下，可以更加精准的控制对象的构造过程</strong>，所以我们直接看Retrofit的内部类Builder就行，因为在Builder中配置的字段最终都在build时赋值给Retrofit中相应的字段，Builder只是暂时保存这些配置字段而已，下面我们分注释的3步去看Retrofit的Builder.</p>
<h3 id="1、构造Builder"><a href="#1、构造Builder" class="headerlink" title="1、构造Builder"></a>1、构造Builder</h3><p>Builder类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Retrofit.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;<span class="comment">//Retrofit运行的平台</span></span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//根据Platform构造</span></span><br><span class="line">     Builder(Platform platform) &#123;</span><br><span class="line">         <span class="keyword">this</span>.platform = platform;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//调用Platform的get方法获取一个Platform</span></span><br><span class="line">         <span class="keyword">this</span>(Platform.get());</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//根据另外一个Retrofit构造</span></span><br><span class="line">     Builder(Retrofit Retrofit) &#123;</span><br><span class="line">         platform = Platform.get();</span><br><span class="line">         callFactory = Retrofit.callFactory;</span><br><span class="line">         baseUrl = Retrofit.baseUrl;</span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>new Retrofit.Builder()，我们使用了无参的构造函数来创建Builder，Builder的无参构造函数首先通过<strong>Platform.get()</strong>获取了一个Platform实例赋值给了platform字段，前面提到过Retrofit是有Platform的概念，Retrofit支持java和Android平台，我们来看一下Platform这个类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get方法</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Platform <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回Platform实例</span></span><br><span class="line">        <span class="keyword">return</span> PLATFORM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title">findPlatform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//android.os.Build这个类是Android独有的</span></span><br><span class="line">            <span class="comment">//这里要求JVM查找并加载Build.class对象</span></span><br><span class="line">            Class.forName(<span class="string">"android.os.Build"</span>);</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//如果是Android平台，创建一个Android实例返回，Android继承自Platform</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Android();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">            <span class="comment">//找不到android.os.Build，会抛出异常，捕捉，继续执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//java.util.Optional这个类是java8之后才有的，是java独有的</span></span><br><span class="line">            Class.forName(<span class="string">"java.util.Optional"</span>);</span><br><span class="line">            <span class="comment">//创建一个Java8实例返回，Java8继承自Platform</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Java8();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">            <span class="comment">//找不到java.util.Optional，会抛出异常，捕捉，继续执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回默认Platform实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Platform();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回默认的线程切换执行器</span></span><br><span class="line">    <span class="function">Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回默认的网络请求适配器工厂</span></span><br><span class="line">    CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(@Nullable Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callbackExecutor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> DefaultCallAdapterFactory.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDefaultMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span> <span class="function">Object <span class="title">invokeDefaultMethod</span><span class="params">(Method method, Class&lt;?&gt; declaringClass, Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         @Nullable Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@IgnoreJRERequirement</span> <span class="comment">// Only classloaded and used on Java 8.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先Platform的get方法通过<a href="https://rain9155.github.io/2019/11/16/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">单例模式</a>返回了一个Platform实例，单例模式就是<strong>保证单例对象的类在同一进程中，只有一个实例存在</strong>，Platform实例通过findPlatform方法创建，可以看到findPlatform方法里面区分了Android、java和其他平台返回了不同的Platform实现，由于我这里是Android平台，只关注Android平台的实现，Android类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Platform.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(@Nullable Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程切换执行器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造Handler时通过Looper.getMainLooper()来构造</span></span><br><span class="line">        <span class="comment">//所以Handler的消息都会执行在主线程</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            handler.post(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Android继承自Platform，重写了它其中的两个方法：defaultCallbackExecutor方法和defaultCallAdapterFactory方法，defaultCallbackExecutor方法返回了一个MainThreadExecutor，它是一个<a href="https://rain9155.github.io/2019/07/19/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/" target="_blank" rel="noopener">Executor</a>，它的execute方法的实现就是简单通过<a href="https://blog.csdn.net/Rain_9155/article/details/86684083" target="_blank" rel="noopener">Handler</a>把任务Runnable切换回主线程执行，就是说，线程池会把每一个线程提交的任务都切回主线程执行，我们再来看defaultCallAdapterFactory方法，这个方法返回了我们上面介绍过的ExecutorCallAdapterFactory，并把callbackExecutor传了进去，其实这个<strong>callbackExecutor就是MainThreadExecutor</strong>，待会在第3步构建Retrofit实例时就会讲到。</p>
<p><strong>这里我们来小结一下：</strong></p>
<p>new Retrofit.Builder()里面会通过Platform的get方法来获取一个Platform实例，在Android中，它会返回Android平台实例，这样就指定了Retrofit的运行平台是Android，然后就可以通过Android平台实例的<strong>defaultCallbackExecutor方法</strong>返回一个线程切换执行器MainThreadExecutor，它用于把任务切换回主线程执行，和通过<strong>defaultCallAdapterFactory方法</strong>返回一个网络请求适配器工厂ExecutorCallAdapterFactory，工厂中持有一个线程切换执行器实例，通过工厂就可以获取网络请求适配器实例。</p>
<p>有了Builder实例后，下面开始配置Builder.</p>
<h3 id="2、配置Builder"><a href="#2、配置Builder" class="headerlink" title="2、配置Builder"></a>2、配置Builder</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Retrofit.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Platform platform;<span class="comment">//Retrofit运行的平台</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call.Factory callFactory;<span class="comment">//网络请求执行器工厂，用创建网络请求执行器实例，来自okhttp, 不是Retrofit中的那个Call</span></span><br><span class="line">    <span class="keyword">private</span> HttpUrl baseUrl;<span class="comment">//网络请求的Url地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//数据转化器工厂列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//网络请求适配器工厂列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Executor callbackExecutor;<span class="comment">//线程切换执行器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> validateEagerly;<span class="comment">//标志位，是否提前对serviceMethod进行缓存(在创建Api接口实例会讲到)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">//我们传入的String类型的Url，最终还是会解析成HttpUrl类型，它是Retrofit中url的代表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(String baseUrl)</span> </span>&#123;</span><br><span class="line">        checkNotNull(baseUrl, <span class="string">"baseUrl == null"</span>);</span><br><span class="line">        HttpUrl httpUrl = HttpUrl.parse(baseUrl);</span><br><span class="line">        <span class="keyword">if</span> (httpUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal URL: "</span> + baseUrl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> baseUrl(httpUrl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">baseUrl</span><span class="params">(HttpUrl baseUrl)</span> </span>&#123;</span><br><span class="line">        checkNotNull(baseUrl, <span class="string">"baseUrl == null"</span>);</span><br><span class="line">        List&lt;String&gt; pathSegments = baseUrl.pathSegments();</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">""</span>.equals(pathSegments.get(pathSegments.size() - <span class="number">1</span>))) &#123;</span><br><span class="line">            <span class="comment">//baseUrl最后一定要接一个 /</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"baseUrl must end in /: "</span> + baseUrl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把ConverterFactory添加到数据转化器工厂列表中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">addConverterFactory</span><span class="params">(Converter.Factory factory)</span> </span>&#123;</span><br><span class="line">        converterFactories.add(checkNotNull(factory, <span class="string">"factory == null"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把CallAdapterFactory添加到网络请求适配器工厂列表中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">addCallAdapterFactory</span><span class="params">(CallAdapter.Factory factory)</span> </span>&#123;</span><br><span class="line">        callAdapterFactories.add(checkNotNull(factory, <span class="string">"factory == null"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//获取网络请求适配器工厂列表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CallAdapter.Factory&gt; callAdapterFactories() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.callAdapterFactories;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取数据转化器工厂列表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Converter.Factory&gt; converterFactories() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.converterFactories;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改validateEagerly标志位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">validateEagerly</span><span class="params">(<span class="keyword">boolean</span> validateEagerly)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.validateEagerly = validateEagerly;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Builder中所有的字段都贴出来了，方法只贴了几个常用的出来，我们调用Builder的相应方法，就是在为Builder的相应字段赋值，很简单，就不介绍了。</p>
<p>其中要注意的是：当我们添加ConverterFactory或CallAdapterFactory时，它们都是添加到各自的列表中，这说明在Retrofit中Converter和CallAdapter是可以存在多个的，为什么呢？这是因为Retrofit允许我们为Api接口里面定义的每一个方法都定义对应的Converter和CallAdapter，每当我们调用到Api接口的某个方法时，Retrofit都会遍历网络请求适配器工厂列表callAdapterFactories，把方法的返回值returnType和注解信息annotations传进每个Factory的get方法中，看某个Factory是否愿意处理这个方法，为这个方法创建对应CallAdapter实例；同理，当Retrofit解析某个Api接口方法的网络请求数据时，它同样会遍历数据转化器工厂列表converterFactories，把方法的相关信息传给Factory的responseBodyConverter或requestBodyConverter方法，看某个Factory是否愿意处理这个方法，为这个方法创建对应ResponseBodyBodyConverter或RequestBodyConverter实例，这两个过程在待会的源码分析都会体现到。由于我们平常开发都只添加了一个CallAdapter和一个Converter，所以Retrofit对Api接口定义的每一个方法的adapt和convert都是相同的处理。</p>
<p>配置好Builder后，接下来调用build方法创建Retrofit实例.</p>
<h3 id="3、创建Retrofit实例"><a href="#3、创建Retrofit实例" class="headerlink" title="3、创建Retrofit实例"></a>3、创建Retrofit实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Retrofit.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置网络请求执行器工厂callFactory</span></span><br><span class="line">        okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">        <span class="comment">//如果没有指定，使用默认的</span></span><br><span class="line">        <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//默认指定为OkHttpClient， OkHttpClient实现了Call.Factory接口，OkHttpClient和Call都是来自okhttp的</span></span><br><span class="line">            callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置线程切换执行器callbackExecutor</span></span><br><span class="line">        Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">        <span class="comment">//如果没有指定，使用默认的</span></span><br><span class="line">        <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//默认指定为运行平台默认的线程切换执行器</span></span><br><span class="line">            <span class="comment">//在Android中，defaultCallbackExecutor方法的返回值就是MainThreadExecutor实例</span></span><br><span class="line">            callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置网络请求适配器工厂列表</span></span><br><span class="line">        <span class="comment">//添加用户指定的网络请求适配器工厂列表</span></span><br><span class="line">        List&lt;CallAdapter.Factory&gt; callAdapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.callAdapterFactories);</span><br><span class="line">        <span class="comment">//添加运行平台默认的网络请适配器工厂到列表中</span></span><br><span class="line">        <span class="comment">//在Android中，defaultCallAdapterFactory方法返回值就是ExecutorCallAdapterFactory实例，并把MainThreadExecutor实例传进方法，所以ExecutorCallAdapterFactory持有MainThreadExecutor实例（回去看构造Builder阶段）</span></span><br><span class="line">        callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置数据转化器工厂列表</span></span><br><span class="line">        List&lt;Converter.Factory&gt; converterFactories =</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span> + <span class="keyword">this</span>.converterFactories.size());</span><br><span class="line">	   <span class="comment">//添加Retrofit默认的数据转化器工厂BuiltInConverters</span></span><br><span class="line">        converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">        <span class="comment">//添加用户指定的数据转化器工厂列表</span></span><br><span class="line">        converterFactories.addAll(<span class="keyword">this</span>.converterFactories);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个Retrofit实例返回，并把上面的配置好的字段传进构造</span></span><br><span class="line">        <span class="comment">//这些字段和Retrofit中相应的字段同名,unmodifiableList就是创建一个不可修改的列表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),</span><br><span class="line">                            unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>build方法中把没有在配置Builder阶段中赋值的字段指定了默认值，然后把网络请求Url地址baseUrl、网络请求执行器工厂callFactory、线程切换执行器callbackExecutor、网络请求适配器工厂列表callAdapterFactories、数据转化器工厂列表converterFactories、标志位validateEagerly这六件套传进了Retrofit的构造，创建一个Retrofit实例返回。</p>
<p>其中要注意的是，按照添加顺序，工厂列表的优先级为：用户指定的网络请适配器工厂列表 &gt; 运行平台默认的网络请求适配器工厂；Retrofit默认的数据转化器工厂 &gt; 用户指定的数据转化器工厂列表。在遍历这些列表时是从前往后遍历的，越靠前的越先被访问。</p>
<h3 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h3><p>经过这3步后，指定了Retrofit的运行平台，配置好了Retrofit的网络请求Url地址、网络请求执行器工厂、线程切换执行器、网络请求适配器工厂列表、数据转化器工厂列表等字段，并创建了一个Retrofit实例.</p>
<p>有了Retrofit实例后，就可以通过Retrofit的create方法创建一个Api接口实例，这也是整个Retrofit最核心的地方.</p>
<h2 id="四、创建Api接口实例"><a href="#四、创建Api接口实例" class="headerlink" title="四、创建Api接口实例"></a>四、创建Api接口实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GithubService service = Retrofit.create(GithubService<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>我先讲一下Retrofit的create方法的作用，Retrofit的create方法里面干了两件事，首先它会根据validateEagerly标志位是否为true，而从决定是否把Api接口里定义的所有方法的注解和参数信息提前封装到ServiceMethod中然后缓存起来，接着就通过Proxy的newProxyInstance方法为GithubService接口创建一个代理对象返回，这里就使用到了<a href="https://www.jianshu.com/p/1b027d9fc005" target="_blank" rel="noopener">外观模式</a>，外观模式就是<strong>定义一个统一接口，外部（用户）通过该统一的接口对子系统里的其他接口进行访问</strong>，这里的这个统一的接口就是<strong>Retrofit.create方法</strong>，我们只需要调用create方法，Retrofit内部就替我们把这两件事给做了，不用我们访问Retrofit的内部子系统，降低了我们使用的复杂度。</p>
<p> Retrofit的create方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Retrofit.java</span></span><br><span class="line"><span class="comment">//泛型T就是GithubService接口</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//传进来的必须是一个接口，并且这个接口没有继承其他接口，否则抛异常</span></span><br><span class="line">    Utils.validateServiceInterface(service);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1、判断validateEagerly标志位是否为true</span></span><br><span class="line">    <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">      <span class="comment">//如果为true，把Api接口里定义的所有方法的注解和参数信息封装到ServiceMethod中，提前缓存起来</span></span><br><span class="line">      eagerlyValidateMethods(service);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、通过Proxy的newProxyInstance方法为GithubService接口创建一个代理对象</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">         		<span class="comment">//...</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Retrofit.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">eagerlyValidateMethods</span><span class="params">(Class&lt;?&gt; service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先获取运行平台，这里为Android</span></span><br><span class="line">    Platform platform = Platform.get();</span><br><span class="line">    <span class="comment">//getDeclaredMethods方法会以 Method[] 形式返回接口定义的所有方法的Method对象，所以这里就是在遍历接口的所有方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : service.getDeclaredMethods()) &#123;</span><br><span class="line">      <span class="comment">//在Android平台，isDefaultMethod方法返回false</span></span><br><span class="line">      <span class="keyword">if</span> (!platform.isDefaultMethod(method)) &#123;</span><br><span class="line">        <span class="comment">//为每一个方法都调用一次loadServiceMethod方法</span></span><br><span class="line">        <span class="comment">//loadServiceMethod方法中就会把方法的注解和参数信息封装到ServiceMethod中，然后缓存起来</span></span><br><span class="line">        loadServiceMethod(method);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们先看create方法的注释1，validateEagerly这个标志位决定是否对serviceMethod进行提前缓存，默认为false，当为true时，create方法中就会调用eagerlyValidateMethods方法，里面会遍历Api接口的所有方法，为每一个方法都调用一次loadServiceMethod方法（invoke方法中会讲到这个方法），loadServiceMethod方法中就会把方法的注解和参数信息封装到ServiceMethod中，以方法method为键，ServiceMethod为值，放入一个名叫<strong>serviceMethodCache</strong>的Map中缓存起来，这个Map定义在Retrofit中，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Retrofit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, ServiceMethod&lt;?, ?&gt;&gt; serviceMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个Map是一个线程安全的HashMap，它的key = Method，value = ServiceMethod。所以可以根据需要设置validateEagerly标志位开启ServiceMethod的预加载，这样等到动态执行invoke方法时可以直接从缓存中获取ServiceMethod实例。</p>
<p>我们重点看create方法的注释2，通过Proxy的newProxyInstance方法为GithubService接口创建一个代理对象，这里就使用了<a href="https://juejin.im/post/5db2fbd0518825645a5ba18b" target="_blank" rel="noopener">动态代理模式</a>，Proxy的newProxyInstance方法会在<strong>代码运行时</strong>，根据第一个参数的ClassLoader，生成一个代理Class对象，该代理Class对象实现了传入的第二个参数对应的Interface列表，在获取到代理Class对象后，根据第三个参数InvocationHandler引用通过反射创建一个代理对象实例，所以<strong>newProxyInstance最终的结果是生成一个代理对象实例，该代理对象会实现给定的接口列表，同时内部持有一个InvocationHandler引用，我们调用代理对象的方法时，这个方法处理逻辑就会委托给InvocationHandler实例的invoke方法执行</strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>当我们调用Retrofit的create方法后，它返回了一个代理对象实例，这个代理对象实现了create方法传进去的接口，接下来当我们调用Api接口的方法时，就是在调用代理对象的同名方法，这个方法处理逻辑就会委托给InvocationHandler实例的invoke方法执行，使用了动态代理之后的好处就是我们可以把发起网络请求的参数获取都集中到invoke方法中处理，而不需要为每一个接口定义一个实现类，这样降低了实现的难度。</p>
<p>接下来我们开始调用Api接口的方法，它会返回一个网络请求执行器。</p>
<h2 id="五、调用Api接口实例的方法"><a href="#五、调用Api接口实例的方法" class="headerlink" title="五、调用Api接口实例的方法"></a>五、调用Api接口实例的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;ResponseBody&gt; call = service.getUserInfo(<span class="string">"rain9155"</span>);</span><br></pre></td></tr></table></figure>

<p>根据动态代理的知识，我们知道，当我们调用Api接口实例的方法，就是在调用代理对象的方法，这个方法处理逻辑就会委托给InvocationHandler实例的invoke方法执行，也就是说，当我们在外部调用Api接口的相应方法时，这些方法都会转到invoke方法执行，例如我调用service.getUserInfo(“rain9155”)时，这个方法会转到invoke方法去执行。</p>
<p>所以我们直接看InvocationHandler的invoke方法逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Retrofit.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">        <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            </span><br><span class="line">          <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">            </span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 当我调用service.getUserInfo("rain9155")时，这个方法会转到invoke方法去执行。</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@param</span> proxy 代理对象实例</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@param</span> method 被调用的方法，如这里的getUserInfo方法</span></span><br><span class="line"><span class="comment">           * <span class="doctag">@param</span> args 被调用的方法的参数，如这里的"rain9155"</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="meta">@Override</span> </span><br><span class="line">          <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">              </span><br><span class="line">            <span class="comment">//如果这个方法是Object类的，调用Object类的方法</span></span><br><span class="line">            <span class="keyword">if</span> (method.getDeclaringClass() == Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//在Android平台，isDefaultMethod方法返回false，不会进入这个分支</span></span><br><span class="line">            <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">              <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">            &#125;</span><br><span class="line">              </span><br><span class="line">            <span class="comment">//走到这里表示，调用的不是Object类的方法，而是GithubService接口的相应方法</span></span><br><span class="line">              </span><br><span class="line">            <span class="comment">//1、调用loadServiceMethod方法，为这个方法获取一个ServiceMethod</span></span><br><span class="line">            ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2、把该方法的ServiceMethod和args传进okHttpCall，创建一个okHttpCall实例</span></span><br><span class="line">            <span class="comment">//args就是方法的参数</span></span><br><span class="line">            OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//3、调用adapt方法，传入okHttpCall，把okHttpCall适配成另一个Call</span></span><br><span class="line">            <span class="comment">//里面其实调用的是CallAdapter的adapt方法</span></span><br><span class="line">            <span class="keyword">return</span> serviceMethod.adapt(okHttpCall);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>invoke方法中分为注释1、2、3，下面分别讲解：</p>
<h3 id="注释1、loadServiceMethod方法"><a href="#注释1、loadServiceMethod方法" class="headerlink" title="注释1、loadServiceMethod方法"></a>注释1、loadServiceMethod方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、调用loadServiceMethod方法，为这个方法获取一个ServiceMethod</span></span><br><span class="line">ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method);</span><br></pre></td></tr></table></figure>

<p>loadServiceMethod方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Retrofit.java </span></span><br><span class="line">ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123;</span><br><span class="line">    <span class="comment">//首先从serviceMethodCache根据方法method获取ServiceMethod</span></span><br><span class="line">    ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//如果获取得到就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果获取不到就为这个method创建一个ServiceMethod</span></span><br><span class="line">    <span class="comment">//上锁，所以创建的ServiceMethod是一个单例</span></span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//1、为method创建一个ServiceMethod</span></span><br><span class="line">        result = <span class="keyword">new</span> ServiceMethod.Builder&lt;&gt;(<span class="keyword">this</span>, method).build();</span><br><span class="line">         <span class="comment">//然后以方法method为键，ServiceMethod为值，放入serviceMethodCache缓存起来</span></span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里首先从serviceMethodCache根据方法method获取ServiceMethod，如果获取不到再为方法创建一个ServiceMethod，然后以方法method为键，ServiceMethod为值，放入serviceMethodCache缓存起来，并返回，我们重点来看注释1，看这个<strong>ServiceMethod是怎样根据方法的Method对象创建出来的</strong>。</p>
<h4 id="1、ServiceMethod的创建过程"><a href="#1、ServiceMethod的创建过程" class="headerlink" title="1、ServiceMethod的创建过程"></a>1、ServiceMethod的创建过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="keyword">new</span> ServiceMethod.Builder&lt;&gt;(<span class="keyword">this</span>, method)<span class="comment">//1</span></span><br><span class="line">      .build();<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>ServiceMethod同样是通过Builder模式创建，所以我们同样分注释的2步去看ServiceMethod的创建.</p>
<h5 id="1-1、构造Builder"><a href="#1-1、构造Builder" class="headerlink" title="1.1、构造Builder"></a>1.1、构造Builder</h5><p>所以我们先看ServiceMethod的Builder的构造，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServiceMethod.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Retrofit retrofit;</span><br><span class="line">    <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">final</span> Annotation[] methodAnnotations;</span><br><span class="line">    <span class="keyword">final</span> Annotation[][] parameterAnnotationsArray;</span><br><span class="line">    <span class="keyword">final</span> Type[] parameterTypes;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    Builder(Retrofit retrofit, Method method) &#123;</span><br><span class="line">      <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">      <span class="keyword">this</span>.method = method;</span><br><span class="line">      <span class="comment">//获取方法里的所有注解，如@GET、@POST，@PATCH等</span></span><br><span class="line">      <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">      <span class="comment">//获取方法里的所有参数类型，如int、String等</span></span><br><span class="line">      <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">      <span class="comment">//获取方法里所有参数的注解，如@Query，@Body、@PartMap等</span></span><br><span class="line">      <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>构造中依此获取方法的注解、参数类型、参数的注解并依此赋值给methodAnnotations、parameterAnnotationsArray、parameterTypes，注意parameterAnnotationsArray是一个二维数组，因为一个参数可以被多个注解修饰，一个注解可以修饰多个参数。</p>
<h5 id="1-2、创建ServiceMethod实例"><a href="#1-2、创建ServiceMethod实例" class="headerlink" title="1.2、创建ServiceMethod实例"></a>1.2、创建ServiceMethod实例</h5><p>我们接着看Builder的build方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServiceMethod.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Retrofit retrofit;</span><br><span class="line">    <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="keyword">final</span> Annotation[] methodAnnotations;</span><br><span class="line">    <span class="keyword">final</span> Annotation[][] parameterAnnotationsArray;</span><br><span class="line">    <span class="keyword">final</span> Type[] parameterTypes;</span><br><span class="line"></span><br><span class="line">    Type responseType;</span><br><span class="line">    ParameterHandler&lt;?&gt;[] parameterHandlers;</span><br><span class="line">    Converter&lt;ResponseBody, T&gt; responseConverter;</span><br><span class="line">    CallAdapter&lt;T, R&gt; callAdapter;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1、调用createCallAdapter方法创建网络请求适配器CallAdapter</span></span><br><span class="line">        callAdapter = createCallAdapter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过CallAdapter的responseType方法获取返回数据的响应body的类型</span></span><br><span class="line">        <span class="comment">//如Call&lt;ResponseBody&gt;，获取到ResponseBody类型</span></span><br><span class="line">        responseType = callAdapter.responseType();</span><br><span class="line">        <span class="comment">//....省略异常处理</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、调用createResponseConverter方法创建网络返回数据的数据转化器Converter</span></span><br><span class="line">        responseConverter = createResponseConverter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历该方法的所有注解</span></span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">            <span class="comment">//3、调用parseMethodAnnotation方法解析注解，如@GET、@POST，@PATCH等</span></span><br><span class="line">            parseMethodAnnotation(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...省略异常处理</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">        parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">        <span class="comment">//为方法中的每个参数创建一个ParameterHandler&lt;?&gt;对象并解析每个参数使用的注解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取参数类型，如int、String等</span></span><br><span class="line">            Type parameterType = parameterTypes[p];</span><br><span class="line">             <span class="comment">//...省略异常处理</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取修饰参数的注解，如@Query，@Body、@PartMap等</span></span><br><span class="line">            Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">            <span class="comment">//...省略异常处理</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//4、调用parseParameter方法解析每个参数使用的注解，并返回一个parameterHandlers</span></span><br><span class="line">            parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...省略异常处理</span></span><br><span class="line"></span><br><span class="line">  		<span class="comment">//创建ServiceMethod实例，并把Builder实例传进去</span></span><br><span class="line">        <span class="comment">//ServiceMethod构造里面会把Builder配置好的字段赋值给ServiceMethod中相应的字段</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>build方法里面分4步，我们先看注释1、2，注释1调用createCallAdapter方法创建网络请求适配器CallAdapter，并赋值给callAdapter字段，createCallAdapter方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServiceMethod::Builder.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CallAdapter&lt;T, R&gt; <span class="title">createCallAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取方法的返回值类型，如Call&lt;ResponseBody&gt;</span></span><br><span class="line">    Type returnType = method.getGenericReturnType();</span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取方法的所有注解，如@GET、@POST，@PATCH等</span></span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用Retrofit的callAdapter方法，返回一个CallAdapter实例</span></span><br><span class="line">        <span class="keyword">return</span> (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Retrofit.java</span></span><br><span class="line"> <span class="keyword">public</span> CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123;</span><br><span class="line">    <span class="keyword">return</span> nextCallAdapter(<span class="keyword">null</span>, returnType, annotations);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; nextCallAdapter(<span class="meta">@Nullable</span> CallAdapter.Factory skipPast, Type returnType,</span><br><span class="line">      Annotation[] annotations) &#123;</span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = callAdapterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//遍历网络请求适配器工厂callAdapterFactories</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">      <span class="comment">//把该方法的返回值类型returnType和注解信息annotations传给CallAdapterFactory的get方法，通过get方法获取一个CallAdapter实例或null</span></span><br><span class="line">      <span class="comment">//在Retrofit相关类介绍讲过，Android平台的CallAdapterFactor的默认实现是ExecutorCallAdapterFactory，ExecutorCallAdapterFactory的get方法返回一个CallAdapter匿名实现类或null</span></span><br><span class="line">      CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, <span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">if</span> (adapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> adapter;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>createCallAdapter方法中，获取到方法的返回值类型（如Call<ResponseBody>类型）和注解信息后，就调用Retrofit的callAdapter方法，callAdapter方法就调用nextCallAdapter方法，在nextCallAdapter方法中，会遍历Retrofit的网络请求适配器工厂callAdapterFactories，把方法的返回值returnType和注解信息annotations传进每个Factory的get方法中，看某个Factory是否愿意处理这个方法，如果愿意，就为这个方法创建对应CallAdapter实例，在Android平台中，CallAdapterFactor的默认实现是ExecutorCallAdapterFactory，ExecutorCallAdapterFactory的get方法返回一个CallAdapter匿名实现类。<strong>（查看前面讲过的Retrofit相关类介绍，里面有对ExecutorCallAdapterFactory的详细介绍）</strong></p>
<p>我们再看build方法里的注释2，注释2调用createResponseConverter方法创建网络返回数据的数据转化器Converter，赋值给responseConverter字段，createResponseConverter方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServiceMethod::Builder.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Converter&lt;ResponseBody, T&gt; <span class="title">createResponseConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取方法的所有注解，如@GET、@POST，@PATCH等</span></span><br><span class="line">    Annotation[] annotations = method.getAnnotations();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用Retrofit的responseBodyConverter方法，返回一个Converter实例</span></span><br><span class="line">        <span class="keyword">return</span> retrofit.responseBodyConverter(responseType, annotations);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Retrofit.java</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">responseBodyConverter</span><span class="params">(Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nextResponseBodyConverter(<span class="keyword">null</span>, type, annotations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Converter&lt;ResponseBody, T&gt; <span class="title">nextResponseBodyConverter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = converterFactories.indexOf(skipPast) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//遍历数据转化器工厂converterFactories</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, count = converterFactories.size(); i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">//把该方法的返回值的泛型类型和注解信息annotations传给ConverterFactory的responseBodyConverter方法，通过responseBodyConverter方法获取一个处理网络返回数据的数据转化器Converter实例或null</span></span><br><span class="line">        <span class="comment">//在Retrofit相关类介绍讲过，Retrofit的ConverterFactory的默认实现是BuiltInConverters，BuiltInConverters的responseBodyConverter方法返回一个处理网络返回数据的数据转化器Converter实例或null</span></span><br><span class="line">        Converter&lt;ResponseBody, ?&gt; converter =</span><br><span class="line">            converterFactories.get(i).responseBodyConverter(type, annotations, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (converter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            <span class="keyword">return</span> (Converter&lt;ResponseBody, T&gt;) converter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>createResponseConverter方法中的流程和createCallAdapter方法的流程差不多，最终是遍历Retrofit的数据转化器工厂converterFactories，把该方法的返回值的泛型类型（如Call<ResponseBody>，泛型类型就是ResponseBody类型）和注解信息annotations传给每个Factory的responseBodyConverter方法中，看某个Factory是否愿意处理这个方法，如果愿意，就为这个方法创建对应的网络返回数据的数据转化器Converter实例，在Android平台中ConverterFactory的默认实现是BuiltInConverters<strong>（查看前面讲过的Retrofit相关类介绍，里面有对BuiltInConverters的详细介绍）</strong>。有ResponseConverter就有相应的RequestConverter，RequestConverter用来处理网络请求数据的数据转化，RequestConverter并不在ServiceMethod的build方法中创建，而是在parseParameter方法中创建。</p>
<p>至于build方法的注释3、4的parseMethodAnnotation方法和parseParameter方法，限于篇幅，就留给大家自己探索了，我讲一下里面的大体逻辑：</p>
<ul>
<li><strong>parseMethodAnnotation方法</strong>：该方法里面首先判断是哪种HTTP请求的注解，然后为不同的HTTP请求注解调用parseHttpMethodAndPath方法，该方法里面会获取注解中省略域名的Url和把Url里面需要替换地方用正则找出来放到一个Set中，如：@GET(“users/{user}”)，省略域名的Url = users/{user}，需要替换的地方是{user}，把user找出来，最终parseMethodAnnotation方法获取到的信息是： <strong>HTTP请求方式、省略域名的Url和Url中需要替换值的地方</strong>。</li>
<li><strong>parseParameter方法</strong>：这个方法是解析方法参数的注解，如@Quary、@Path等，里面会判断是哪种类型的注解，根据不同类型的注解，<strong>取出注解中的值，创建一个RequestConverter实例，最后把注解的值和RequestConverter实例传进ParameterHandler构造，为这个注解创建一个ParameterHandler实例返回</strong>，不同的注解有不同的ParameterHandler类型，如@Quary就有ParameterHandler.Quary，@Path就有ParameterHandler.Path。</li>
</ul>
<p>都是通过注解解析出注解参数，然后一并封装到ServiceMethod中去，build方法执行完毕，就创建了一个ServiceMethod实例返回。</p>
<p><strong>我们来小结一下ServiceMethod的创建过程：</strong></p>
<p>经过这2步后，为这个方法method创建了一个对应的ServiceMethod实例，这个ServiceMethod封装了网络请求所需要的所有参数和持有CallAdapter实例、处理网络返回数据转化的Converter实例，同时这个ServiceMethod是一个单例，也就是说<strong>Api接口里的每一个方法都分别对应着一个ServiceMethod实例，这个ServiceMethod实例持有着网络请求所需要的所有参数</strong>。</p>
<p>我们继续回到loadServiceMethod方法中。</p>
<h4 id="2、小结"><a href="#2、小结" class="headerlink" title="2、小结"></a>2、小结</h4><p>调用loadServiceMethod方法后，创建了一个ServiceMethod实例并缓存到一个Map中，第二次使用时直接从缓存获取ServiceMethod实例，不必重复创建，提高效率。</p>
<p>我们回到invoke方法，有了ServiceMethod实例后，就可以创建一个okHttpCall实例.</p>
<h3 id="注释2、创建一个okHttpCall实例"><a href="#注释2、创建一个okHttpCall实例" class="headerlink" title="注释2、创建一个okHttpCall实例"></a>注释2、创建一个okHttpCall实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、把该方法的ServiceMethod和args(args就是方法的参数)传进okHttpCall，创建一个okHttpCall实例</span></span><br><span class="line">OkHttpCall&lt;Object&gt; okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br></pre></td></tr></table></figure>

<p>OkHttpCall的构造如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceMethod&lt;T, ?&gt; serviceMethod;<span class="comment">//封装了Api接口方法中的注解和参数信息，一个ServiceMethod对应一个Method</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args;<span class="comment">//代表着Api接口方法中的参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call rawCall;<span class="comment">//这是一个来自Okhttp的Call</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, <span class="meta">@Nullable</span> Object[] args) &#123;</span><br><span class="line">    <span class="keyword">this</span>.serviceMethod = serviceMethod;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>可以看到Okhttp把刚刚得到的ServiceMethod实例和接口方法的参数保存起来，OkHttpCall在前面的Retrofit的相关类介绍已经简单介绍过了，它就是实现了Call的一个类，它里面的方法大部分逻辑都转发给Okhttp的Call 。</p>
<p>得到okHttpCall实例后，通过adapt方法把它适配成另外一个Call.</p>
<h3 id="注释3、把OkHttpCall适配成另一个Call"><a href="#注释3、把OkHttpCall适配成另一个Call" class="headerlink" title="注释3、把OkHttpCall适配成另一个Call"></a>注释3、把OkHttpCall适配成另一个Call</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//3、调用adapt方法，传入okHttpCall，把okHttpCall适配成另一个Call</span></span><br><span class="line"><span class="keyword">return</span> serviceMethod.adapt(okHttpCall);</span><br></pre></td></tr></table></figure>

<p>ServiceMethod的adapt方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServiceMethod.java</span></span><br><span class="line"><span class="function">T <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callAdapter.adapt(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>adapt方法传进来的call是OkhttpCall实例，callAdapter就是刚刚用createCallAdapter方法创建的CallAdapter实例，在Android平台中，这个CallAdapter实例的adapt方法的默认实现就是用ExecutorCallbackCall包装传进来的OkHttpCall，并返回ExecutorCallbackCall实例，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallAdapterFactory</span> <span class="keyword">extends</span> <span class="title">CallAdapter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程切换执行器, 在创建Retrofit实例时传进ExecutorCallAdapterFactory中</span></span><br><span class="line">    <span class="comment">//在Android平台，就是MainThreadExecutor实例</span></span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line"></span><br><span class="line">    ExecutorCallAdapterFactory(Executor callbackExecutor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit Retrofit) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);</span><br><span class="line">        <span class="comment">//返回一个CallAdapter匿名类</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> responseType;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">//adapt方法</span></span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//创建了一个ExecutorCallbackCall，并把线程切换执行器实例和OkhttpCall实例传进构造</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//网络请求执行器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以callAdapter.adapt(call)就是<strong>把OkhttpCall 适配成 ExecutorCallbackCall</strong>，我们来看一下ExecutorCallbackCall，它是ExecutorCallAdapterFactory的内部类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExecutorCallAdapterFactory.java</span></span><br><span class="line"><span class="comment">//网络请求执行器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;<span class="comment">//线程切换执行器实例, 在get方法通过构造传进</span></span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; delegate;<span class="comment">//OkhttpCall实例,  在get方法通过构造传进</span></span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">        <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">        checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ExecutorCallbackCall的enqueue方法委托给OkhttpCall执行</span></span><br><span class="line">        delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//当网络数据返回时，通过线程切换执行器callbackExecutor，切换到主线程执行callback回调</span></span><br><span class="line">                callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">                            callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//当网络数据返回时，通过线程切换执行器callbackExecutor，切换到主线程执行callback回调</span></span><br><span class="line">                callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//ExecutorCallbackCall的execute方法委托给OkhttpCall执行</span></span><br><span class="line">        <span class="keyword">return</span> delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，ExecutorCallbackCall和OkhttpCall一样都实现了Call接口中的方法，并且ExecutorCallbackCall中持有OkhttpCall的实例，它的enqueue方法和execute方法都委托给OkhttpCall的enqueue方法和execute方法执行，当网络数据返回时，通过线程切换执行器callbackExecutor，切换到主线程执行callback回调，这里采用了<a href="https://juejin.im/post/5db2fbd0518825645a5ba18b" target="_blank" rel="noopener">装饰者模式</a>，采用装饰者模式的好处就是<strong>不用通过继承就可以扩展一个对象的功能，动态的给一个对象添加一些额外的操作</strong>，这里额外的操作就是通过线程切换执行器切换回主线程后再执行callback回调，因为OkHttpCall的enqueue方法是进行网络的异步请求，当异步请求结果返回时，回调是在子线程中，需要通过线程切换执行器转换到主线程中再进行callback回调。</p>
<p>最终，ServiceMethod的adapt方法把<strong>OkhttpCall 适配成不同平台的网络请求执行器，并返回</strong>，在Android平台中，OkhttpCall 适配成了 ExecutorCallbackCall实例。</p>
<h3 id="4、小结-1"><a href="#4、小结-1" class="headerlink" title="4、小结"></a>4、小结</h3><p>当我们调用Api接口实例中的方法时，这些方法的处理逻辑都会转发给invoke方法，在invoke方法中，会为每一个方法创建一个ServiceMethod，这个ServiceMethod封装了网络请求所需要的所有参数和持有CallAdapter实例、处理网络返回数据转化的Converter实例，接着就会把这个ServiceMethod实例和接口方法的参数传进OkhttpCall的构造中，创建一个OkhttpCall实例，接着把这个OkhttpCall实例传给ServiceMethod的adapt方法，ServiceMethod的adapt方法就会调用CallAdapter实例的adapt方法，把OkhttpCall适配成不同平台的网络请求执行器，所以如果你添加了其他平台的CallAdapterFactory，你就可以得到不同平台下的网络请求执行器，在Android平台中，CallAdapter实例的adapt方法会把OkhttpCall适配成ExecutorCallbackCall，这个ExecutorCallbackCall持有OkhttpCall实例和线程切换器MainThreadExecutor实例，当我们发起网络请求时，ExecutorCallbackCall就会委托OkhttpCall发起网络请求，当网络请求数据返回时，ExecutorCallbackCall就会通过MainThreadExecutor把线程切换主线程执行回调。</p>
<p>得到网络请求执行器之后，就可以发起，网络请求了.</p>
<h2 id="六、发起网络请求（以异步为例）"><a href="#六、发起网络请求（以异步为例）" class="headerlink" title="六、发起网络请求（以异步为例）"></a>六、发起网络请求（以异步为例）</h2><p>不同平台下的网络请求执行器不同，在Android平台，调用Api接口实例的方法后返回的是ExecutorCallbackCall，有了ExecutorCallbackCall后，我们就可以发起同步或异步请求，同步和异步请求的流程类型，唯一不同的是异步请求需要把结果通过Callback回调给上层，而同步请求则是直接return结果给上层。</p>
<p>下面以异步请求为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户发起异步请求 </span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;ResponseBody&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response)</span></span>&#123;</span><br><span class="line">            	<span class="comment">//通过Response获取网络请求返回结果</span></span><br><span class="line">                ResponseBody body = response.body();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"请求结果："</span> +  body.string());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;ResponseBody&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>调用的是ExecutorCallbackCall的enqueue方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExecutorCallAdapterFactory::ExecutorCallbackCall.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ExecutorCallbackCall的enqueue方法委托给OkhttpCall执行</span></span><br><span class="line">    delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//当网络数据返回时，通过线程切换执行器callbackExecutor，切换到主线程执行callback回调</span></span><br><span class="line">            callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">                        callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//当网络数据返回时，通过线程切换执行器callbackExecutor，切换到主线程执行callback回调</span></span><br><span class="line">            callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>调用的是OkhttpCall的enqueue方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OkhttpCall.java</span></span><br><span class="line"><span class="keyword">private</span> <span class="meta">@Nullable</span> okhttp3.Call rawCall;<span class="comment">//这是一个来自Okhttp的Call</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">    checkNotNull(callback, <span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//来自Okhttp的Call</span></span><br><span class="line">    okhttp3.Call call;</span><br><span class="line">    Throwable failure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">      executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//1、获取Okhttp的Call实例</span></span><br><span class="line">      call = rawCall;</span><br><span class="line">      failure = creationFailure;</span><br><span class="line">      <span class="keyword">if</span> (call == <span class="keyword">null</span> &amp;&amp; failure == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//第一次发起网络请求，创建Okhttp的Call</span></span><br><span class="line">          call = rawCall = createRawCall();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          throwIfFatal(t);</span><br><span class="line">          failure = creationFailure = t;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (failure != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//通过callback把错误回调出去</span></span><br><span class="line">      callback.onFailure(<span class="keyword">this</span>, failure);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">      call.cancel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、调用Okhttp的Call的enqueue方法发起异步请求</span></span><br><span class="line">    <span class="comment">//传入的是Okhttp的Callback</span></span><br><span class="line">    call.enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//Okhttp的结果回调</span></span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response rawResponse)</span> </span>&#123;</span><br><span class="line">        Response&lt;T&gt; response;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//3、调用parseResponse方法把Okhttp的Response解析成Retrofit的Response</span></span><br><span class="line">          response = parseResponse(rawResponse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">          callFailure(e);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过callback把结果回调出去</span></span><br><span class="line">          callback.onResponse(OkHttpCall.<span class="keyword">this</span>, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//Okhttp的错误回调</span></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</span><br><span class="line">        callFailure(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callFailure</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//通过callback把错误回调出去</span></span><br><span class="line">          callback.onFailure(OkHttpCall.<span class="keyword">this</span>, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>OkhttpCall的enqueue方法大体分为3步：</p>
<p>1、获取Okhttp的Call实例，赋值给临时变量call：</p>
<p>​    1.1、如果是第一次发起网络请求，就调用createRawCall方法就创建来自Okhttp的Call，赋值给临时变量call和成员变量rawCall;</p>
<p>​    1.2、如果不是第一次发起网络请求，就把上次的rawCall实例赋值给临时变量call.</p>
<p>2、调用Okhttp的Call的enqueue方法发起异步请求（更多细节请查看上一篇文章<a href="https://rain9155.github.io/2019/09/03/okhttp3源码分析之请求流程/" target="_blank" rel="noopener">okhttp3源码分析之请求流程</a>）；</p>
<p>3、当网络请求结果正确返回时，用parseResponse方法把Okhttp的Response解析成Retrofit的Response.</p>
<p>所以我们来看一下两个关键的办法，createRawCall方法和parseResponse方法：</p>
<h3 id="1、创建Okhttp的Call"><a href="#1、创建Okhttp的Call" class="headerlink" title="1、创建Okhttp的Call"></a>1、创建Okhttp的Call</h3><p>createRawCall方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OkhttpCall.java</span></span><br><span class="line"><span class="keyword">private</span> okhttp3.<span class="function">Call <span class="title">createRawCall</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//调用serviceMethod的toCall方法，并把args即接口方法参数传了进去</span></span><br><span class="line">    <span class="comment">//args在创建OkhttpCall实例时通过构造传进来的</span></span><br><span class="line">    okhttp3.Call call = serviceMethod.toCall(args);</span><br><span class="line">    <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Call.Factory returned null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>createRawCall方法调用ServiceMethod的toCall方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServiceMethod.java</span></span><br><span class="line">okhttp3.<span class="function">Call <span class="title">toCall</span><span class="params">(@Nullable Object... args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1、创建一个用于构造Request的Builder，并把ServiceMethod中封装的参数传进去</span></span><br><span class="line">    RequestBuilder requestBuilder = <span class="keyword">new</span> RequestBuilder(httpMethod, baseUrl, relativeUrl, headers,</span><br><span class="line">                                                       contentType, hasBody, isFormEncoded, isMultipart);</span><br><span class="line">    </span><br><span class="line">    ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> argumentCount = args != <span class="keyword">null</span> ? args.length : <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//...省略异常处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、遍历每个方法参数的ParameterHandler</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; argumentCount; p++) &#123;</span><br><span class="line">        <span class="comment">//调用ParameterHandler的apply方法，把ParameterHandler中的参数apply到requestBuilder中</span></span><br><span class="line">        handlers[p].apply(requestBuilder, args[p]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、requestBuilder.build方法创建一个Request实例传进newCall方法，这个Request是来自Okhttp的</span></span><br><span class="line">    <span class="comment">//然后调用callFactory的newCall方法创建一个Call</span></span><br><span class="line">    <span class="comment">//这个callFactory就是OkHttpClient时，在创建Retorfit时配置</span></span><br><span class="line">    <span class="comment">//所以这里返回的是来自Okhttp的Call</span></span><br><span class="line">    <span class="keyword">return</span> callFactory.newCall(requestBuilder.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先创建一个用于构造Request的requestBuilder，并把ServiceMethod中封装的参数传进去，然后遍历每个方法参数的ParameterHandler，通过apply方法取出ParameterHandler中的参数放入requestBuilder中，ParameterHandler前面讲过，它里面保存了每个方法参数的注解的值和处理这些值的Converter实例，构造Request的参数都有了，接着就通过requestBuilder.build方法创建一个Okhttp的Request实例并传进newCall方法，最后通过OkHttpClient的newCall方法创建一个Okhttp的Call实例返回。</p>
<p>最终createRawCall方法返回一个来自Okhttp的Call实例。</p>
<h3 id="2、解析返回结果"><a href="#2、解析返回结果" class="headerlink" title="2、解析返回结果"></a>2、解析返回结果</h3><p>parseResponse方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServiceMethod.java</span></span><br><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//取出Okhttp的Response的body</span></span><br><span class="line">    ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...省略的是一些状态码处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用ExceptionCatchingRequestBody包装一下rawBody</span></span><br><span class="line">    ExceptionCatchingRequestBody catchingBody = <span class="keyword">new</span> ExceptionCatchingRequestBody(rawBody);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用ServiceMethod的toResponse方法把原始的body转化成我们需要的数据类型</span></span><br><span class="line">        T body = serviceMethod.toResponse(catchingBody);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先把Okhttp的Response的body取处理，然后用ExceptionCatchingRequestBody包装一下，这个ExceptionCatchingRequestBody是继承自Okhttp的ResponseBody，接着把这个ResponseBody传进ServiceMethod的toResponse方法，里面会使用ServiceMethod保存的处理网络返回数据的Converter实例来把这个ResponseBody转化成我们需要的数据类型，ServiceMethod的toResponse方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ServiceMethod.java</span></span><br><span class="line"><span class="function">R <span class="title">toResponse</span><span class="params">(ResponseBody body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> responseConverter.convert(body);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个responseConverter就是在创建ServiceMethod时用createResponseConverter方法创建的Converter实例，把body转化成R类型，不同的数据转化有不同的实现，在Retrofit的默认实现中，它就是直接返回ResponseBody。</p>
<p>我们再回到parseResponse方法，调用完ServiceMethod的toResponse方法，得到了转化后的body，最后调用了Response的success方法，把Okhttp的Response和转化后的body传了进去，最终返回一个Retrofit的Response。</p>
<h3 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h3><p>以异步为例，Retrofit通过ExecutorCallbackCall的enqueue方法发起网络请求，最终会通过OkhttpCall的enqueue方法来发起网络请求，OkhttpCall的enqueue方法中，首先会调用创建一个来自Okhttp的Call实例，然后通过这个Okhttp的Call实例的enqueue方法来发起异步请求，当网络结果Okhttp的Response返回时，调用parseResponse方法解析Response，parseResponse方法里面还会调用ServiceMethod的toResponse方法通过Converter实例的convert方法把ResponseBody转化成我们想要的数据，不同的数据转化有不同的实现，在Retrofit的默认实现中，它就是直接返回Okhttp的ResponseBody，最后把这个转化后的body和原始的Okhttp的Response一并封装成Retrofit的Response返回，最后把parseResponse方法返回的Response通过callback回调出去，这时ExecutorCallbackCall收到回调，通过线程切换执行器callbackExecutor，切换到主线程执行callback回调，一次异步请求就完成了，同步请求也是大同小异，只是少了个回调，就留给大家自己分析了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>能够阅读到这里，说明你对Retrofit的理解又更上一层楼了，其实从整体去看Retrofit，它的流程并不复杂，它的使用也非常的简单，这得益于它优秀的架构，和运用得当的设计模式，其中最核心的当属动态代理模式，通过一个代理类InvocationHandler代理N多个接口，它把每一个方法的处理逻辑都集中到了invoke方法中，这样就能在同一处地方处理所有方法的注解解析，还有它那面向接口的设计，使得各个子模块之间降低耦合，让我们以最小的代价替换成我们需要的实现，Retrofit的整体流程图如下：</p>
<img src="/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/retrofit3.png" class="" title="Retrofit">

<p>一句话概括Retrofit：它是一个通过动态代理把Api接口方法的注解解析成网络请求所需参数，最后通过Okhttp执行网络请求的封装库。</p>
<p>以上就是本文的所有内容，如有错误，欢迎指出。</p>
<p>参考资料：</p>
<p><a href="https://www.jianshu.com/p/3855eee03793" target="_blank" rel="noopener">Retrofit解析之面向接口编程</a></p>
<p>​    </p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2023-01-07T10:44:49.294Z" itemprop="dateUpdated">2023-01-07 18:44:49</time>
</span><br>


        
        谢谢大家的阅读！
        
    </div>
    
    <footer>
        <a href="http://yoursite.com">
            <img src="/img/avatar.jpg" alt="rain9155">
            rain9155
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/retrofit/" rel="tag">retrofit</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/&title=《通过源码全面解剖Retrofit2的整体流程》 — jianyu的博客&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/&title=《通过源码全面解剖Retrofit2的整体流程》 — jianyu的博客&source=前言上两篇文章：

okhttp3源码分析之请求流程
okhttp3源码分析之拦截器

Retrofit与Okhttp是Android开发中最最热门的网络..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《通过源码全面解剖Retrofit2的整体流程》 — jianyu的博客&url=http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/11/05/java%E9%9B%86%E5%90%88/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">java学习总结之集合框架</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/10/21/%E4%BD%BF%E7%94%A8AIDL%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">使用AIDL来进行进程间通信</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢打赏!
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>rain9155 &copy; 2018 - 2023</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/&title=《通过源码全面解剖Retrofit2的整体流程》 — jianyu的博客&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/&title=《通过源码全面解剖Retrofit2的整体流程》 — jianyu的博客&source=前言上两篇文章：

okhttp3源码分析之请求流程
okhttp3源码分析之拦截器

Retrofit与Okhttp是Android开发中最最热门的网络..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《通过源码全面解剖Retrofit2的整体流程》 — jianyu的博客&url=http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2019/10/23/%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E5%85%A8%E9%9D%A2%E8%A7%A3%E5%89%96Retrofit2%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAT4AAAE+CAAAAAAxUyPsAAAFMklEQVR42u3a0Y7TWhQD0Pn/nwbdZ2hre2fgSqw8ITFNTlYq1cc7X1/x8ePF8evfvPrsr+d59b/v1/D+zO/X/H49769+OvDhw4cPH76A5v1t5zfQXjG/Snv+RCA3wYcPHz58+C58SeDI48j7xSUhJo8s+QNOsNqV4MOHDx8+fH+eL9mot0vPz5OcoS0s8OHDhw8fvv8bXxtKoqUErXgSnnKU5FP48OHDhw/fd/AlUeCyFc+jSRt92vI953t41oEPHz58+PBNoeFf+PfDBz58+PDhwxf8PCc/2O2LZVsRn69/Kzu2Ax8+fPjw4ds0kh/sHKit5ret+FZtbIP/D6vFhw8fPnz4HuXLg8s9suTnbAPKVusXsw58+PDhw4fvIb627M7jS1sitEP0vErIz3PKffjw4cOHD18QC767Ut8INqYW6324wYcPHz58+Fq+pyrvZyHu2/t76Ik6AXz48OHDh6/ka+PFFj7uD2wbe7fDhuQv8eHDhw8fvgtfGx22xbUPLB8DPDWeb8ftLysDfPjw4cOHL+DLB8OXLXq7yW9LivZs93vHhw8fPnz4Nr58G38fgddNxmFUcBknJFfEhw8fPnz4Wr62zm63+skLYe1QvB2Bb8TFlwkfPnz48OHbc0hRvm833w7U2+DybMWfjw3w4cOHDx++ja8t3Ntb2rbxz1YVbVnfliD48OHDhw9f3jO3t9SGg3Yr3oaMrbzIV4gPHz58+PBd+LbN/BZ62vPnAaitMy7XwocPHz58+C58P4KjjS8XsssI/KmYVcQXfPjw4cOH71Ac5Nvsp8JH+zDua7h8CfDhw4cPH747X7vQtnZvt/33TX5b7m9X/9qeMz58+PDh++f57lV7ApE8nnbTnkeunO+BsgMfPnz48OEr57z54vINeRto8tsrKvX4tYAi7uDDhw8fPnwT33eU2luh0AadHPESmD68ZYAPHz58+PBNfPdeui33L6+stef/9moeHz58+PDhOxDkm/CnYkE+FM+jyWWIHo0i8OHDhw8fvkf5LuPkvCbI64b8UV1eAijiET58+PDhw3fg236R2xfCtmH2/XHmpUZx1/jw4cOHD9+BLwkcT1XkbXBpcfOwst01Pnz48OHDd+dLfsK30XW7gc//t40sLfSHO8KHDx8+fPgmvmgkXI66t/CxXaV9+SwfDHy4Fj58+PDhwzfxXQbYp7L7EIMuZUdy3fEFNXz48OHDhy8+z3aTl1Ig39hvw+/7uL14iQ0fPnz48OGb+LbQ0I6rL/FlizsbWbFyfPjw4cOHL+ZrP7aNxtuxdxJZ2u9IDloMKvDhw4cPH76Y7/4aWV4c5JV6+/dtBNleyxtbFnz48OHDhy8OHNsrX1sF39YQl7J+q/JfyuDDhw8fPnwHvmQb327mt2o+v1byAPKqoi4U8OHDhw8fvqWLPm3789jRLj2pFS7lwiWE4cOHDx8+fC1fW3m3gSDZwOeP5BKDtnj0Yc348OHDhw/fxLdxtKV2Xka044F2HL4NJH5zZnz48OHDh+/Ml2/j2+VeCvTkivnIIQ8oH4oGfPjw4cOHr+Qbf7CnbfZ9DHB5fe0SxfJCBB8+fPjw4Us+m9fx+eK2ZW30l7izBRd8+PDhw4fvzpff9paGktu7l/X5eOB+XXz48OHDh+/v8m1wLUQeXO4jhyii4cOHDx8+fH+Eb7tkXpfnV2lx24f3IWDhw4cPHz58E18SHfL40t5qe7b8Ltpiov4y4cOHDx8+fHsOqU/6FGU+DLhXAHkweqzox4cPHz58+P47fgIq72loRMJICAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>








<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '去哪里了?';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎光临!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
