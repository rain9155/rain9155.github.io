<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>okhttp3源码分析之拦截器 | jianyu的博客 | 每天进步一点点</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#009688">
    
    
    <meta name="keywords" content="源码,okhttp">
    <meta name="description" content="前言 上一篇文章：okhttp3源码分析之请求流程  本篇文章继续通过源码来探讨okhttp的另外一个重要知识点：拦截器，在上一篇文章我们知道，在请求发送到服务器之前有一系列的拦截器对请求做了处理后才发送出去，在服务器返回响应之后，同样的有一系列拦截器对响应做了处理后才返回给发起请求的调用者，可见，拦截器是okhttp的一个重要的核心功能，在分析各个拦截器功能的同时又会牵扯出okhttp的缓存机制">
<meta property="og:type" content="article">
<meta property="og:title" content="okhttp3源码分析之拦截器">
<meta property="og:url" content="http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/index.html">
<meta property="og:site_name" content="jianyu的博客">
<meta property="og:description" content="前言 上一篇文章：okhttp3源码分析之请求流程  本篇文章继续通过源码来探讨okhttp的另外一个重要知识点：拦截器，在上一篇文章我们知道，在请求发送到服务器之前有一系列的拦截器对请求做了处理后才发送出去，在服务器返回响应之后，同样的有一系列拦截器对响应做了处理后才返回给发起请求的调用者，可见，拦截器是okhttp的一个重要的核心功能，在分析各个拦截器功能的同时又会牵扯出okhttp的缓存机制">
<meta property="og:image" content="http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/okhttp1.png">
<meta property="og:image" content="http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/okhttp2.png">
<meta property="og:image" content="http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/okhttp3.png">
<meta property="og:image" content="http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/okhttp4.png">
<meta property="article:published_time" content="2019-09-07T07:01:40.000Z">
<meta property="article:modified_time" content="2023-01-07T10:44:48.945Z">
<meta property="article:author" content="rain9155">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="okhttp">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/okhttp1.png">
    
        <link rel="alternate" type="application/atom+xml" title="jianyu的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">rain9155</h5>
          <a href="mailto:jianyu9155@gmail.com" title="jianyu9155@gmail.com" class="mail">jianyu9155@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/rain9155" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://juejin.im/user/5b437173e51d45191d79c27a/posts" target="_blank" >
                <i class="icon icon-lg icon-gg"></i>
                Juejin
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://blog.csdn.net/Rain_9155" target="_blank" >
                <i class="icon icon-lg icon-eye"></i>
                CSDN
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.jianshu.com/u/93cb7ffd83e9" target="_blank" >
                <i class="icon icon-lg icon-book"></i>
                Jianshu
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/links"  >
                <i class="icon icon-lg icon-link"></i>
                Links
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">okhttp3源码分析之拦截器</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="搜尋">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">okhttp3源码分析之拦截器</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-09-07T07:01:40.000Z" itemprop="datePublished" class="page-time">
  2019-09-07
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">优秀开源库分析</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#拦截器的简单使用"><span class="post-toc-text">拦截器的简单使用</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RealCall-getResponseWithInterceptorChain"><span class="post-toc-text">RealCall  :: getResponseWithInterceptorChain()</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、添加拦截器到interceptors列表中"><span class="post-toc-text">1、添加拦截器到interceptors列表中</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2、构造第一个Chain"><span class="post-toc-text">2、构造第一个Chain</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3、调用Chain的proceed-Request-方法处理请求"><span class="post-toc-text">3、调用Chain的proceed(Request)方法处理请求</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#RetryAndFollowUpInterceptor"><span class="post-toc-text">RetryAndFollowUpInterceptor</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、Transmitter"><span class="post-toc-text">1、Transmitter</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#BridgeInterceptor"><span class="post-toc-text">BridgeInterceptor</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CacheInterceptor"><span class="post-toc-text">CacheInterceptor</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、Cache-缓存实现"><span class="post-toc-text">1、Cache - 缓存实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2、CacheStrategy-缓存策略"><span class="post-toc-text">2、CacheStrategy - 缓存策略</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3、缓存机制"><span class="post-toc-text">3、缓存机制</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ConnectInterceptor"><span class="post-toc-text">ConnectInterceptor</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、RealConnection-连接实现"><span class="post-toc-text">1、RealConnection - 连接实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2、RealConnectionPool-连接池"><span class="post-toc-text">2、RealConnectionPool -  连接池</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3、连接创建（连接机制）"><span class="post-toc-text">3、连接创建（连接机制）</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CallServerInterceptor"><span class="post-toc-text">CallServerInterceptor</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结语"><span class="post-toc-text">结语</span></a></li></ol>
        </nav>
    </aside>


<article id="post-okhttp3源码分析之拦截器"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">okhttp3源码分析之拦截器</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-09-07 15:01:40" datetime="2019-09-07T07:01:40.000Z"  itemprop="datePublished">2019-09-07</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E4%BC%98%E7%A7%80%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/">优秀开源库分析</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>上一篇文章：<a href="https://rain9155.github.io/2019/09/03/okhttp3源码分析之请求流程/" target="_blank" rel="noopener">okhttp3源码分析之请求流程</a></li>
</ul>
<p>本篇文章继续通过源码来探讨okhttp的另外一个重要知识点：拦截器，在上一篇文章我们知道，在请求发送到服务器之前有一系列的拦截器对请求做了处理后才发送出去，在服务器返回响应之后，同样的有一系列拦截器对响应做了处理后才返回给发起请求的调用者，可见，拦截器是okhttp的一个重要的核心功能，在分析各个拦截器功能的同时又会牵扯出okhttp的缓存机制、连接机制。</p>
<blockquote>
<p>本文源码基于okhttp3.14.x</p>
</blockquote>
<p>okhttp项目地址：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fsquare%2Fokhttp">okhttp</a></p>
<a id="more"></a>

<h2 id="拦截器的简单使用"><a href="#拦截器的简单使用" class="headerlink" title="拦截器的简单使用"></a>拦截器的简单使用</h2><p>自定义一个拦截器需要实现Interceptor接口，接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//我们需要实现这个intercept(chain)方法，在里面定义我们的拦截逻辑</span></span><br><span class="line">  <span class="function">Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Chain</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">     <span class="comment">//返回Request对象</span></span><br><span class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用Chain的proceed(Request)方法处理请求，最终返回Response</span></span><br><span class="line">    <span class="function">Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前是网络拦截器，该方法返回Request执行后建立的连接</span></span><br><span class="line">    <span class="comment">//如果当前是应用拦截器，该方法返回null</span></span><br><span class="line">    <span class="meta">@Nullable</span> <span class="function">Connection <span class="title">connection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回对应的Call对象</span></span><br><span class="line">    <span class="function">Call <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//下面的方法见名知意，返回或写入超时</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">connectTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Chain <span class="title">withConnectTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">readTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Chain <span class="title">withReadTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">writeTimeoutMillis</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Chain <span class="title">withWriteTimeout</span><span class="params">(<span class="keyword">int</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到Interceptor由两部分组成：intercept(Chain)方法和内部接口Chain，下面是自定义一个拦截器的通用逻辑，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1、通过传进来的Chain获取Request</span></span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">//2、 处理Request，逻辑自己写</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、调用Chain的proceed(Request)方法处理请求，得到Response</span></span><br><span class="line">        Response response = chain.proceed(request);</span><br><span class="line">     </span><br><span class="line">        <span class="comment">//4、 处理Response，逻辑自己写</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5、返回Response</span></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述就是一个拦截器的通用逻辑，首先我们继承Interceptor实现intercept(Chain)方法，完成我们自己的拦截逻辑，即根据需要进行1、2、3、4、5步，不管是自定义拦截器还是后面介绍的okhttp默认的拦截器大概都是这个模板实现，定义完拦截器后，我们在构造OkhttpClient时就可以通过addInterceptor(Interceptor)或addNetworkInterceptor(Interceptor)添加自定义拦截器，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">     .addInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">     .build();</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">     .addNetworkInterceptor(<span class="keyword">new</span> MyInterceptor())</span><br><span class="line">     .build();</span><br></pre></td></tr></table></figure>

<p>这样okhttp在链式调用拦截器处理请求时就会调用到我们自定义的拦截器，那么addInterceptor(Interceptor)和addNetworkInterceptor(Interceptor)有什么不一样呢？它们一个是添加应用拦截器，一个是添加网络拦截器，主要是调用的时机不一样，更多区别可以参考官方WIKI文档<a href="https://www.jianshu.com/p/2710ed1e6b48" target="_blank" rel="noopener">Okhttp-wiki 之 Interceptors 拦截器</a>，当我们平时做应用开发使用addInterceptor(Interceptor)就行了。</p>
<p>上述是我们自定义的拦截器，下面我们来看看okhttp默认的拦截器都干了什么。</p>
<h2 id="RealCall-getResponseWithInterceptorChain"><a href="#RealCall-getResponseWithInterceptorChain" class="headerlink" title="RealCall  :: getResponseWithInterceptorChain()"></a>RealCall  :: getResponseWithInterceptorChain()</h2><p>在上一篇文章知道RealCall的getResponseWithInterceptorChain()是处理、发送请求并且返回响应的地方，我们再看一遍getResponseWithInterceptorChain()方法的源码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall.java</span></span><br><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//新建一个List用来保存拦截器</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//添加我们自定义的应用拦截器</span></span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    <span class="comment">//添加负责重试重定向的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> RetryAndFollowUpInterceptor(client));</span><br><span class="line">    <span class="comment">//添加负责转换请求响应的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</span><br><span class="line">    <span class="comment">//添加负责缓存的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    <span class="comment">//添加负责管理连接的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;<span class="comment">//没有特殊要求，不使用WebSocket协议，WebSocket是什么？自行百度</span></span><br><span class="line">      <span class="comment">//添加我们自定义的网络拦截器</span></span><br><span class="line">      interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加负责发起请求获取响应的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造第一个Chain</span></span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">        originalRequest, <span class="keyword">this</span>, client.connectTimeoutMillis(),</span><br><span class="line">        client.readTimeoutMillis(), client.writeTimeoutMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> calledNoMoreExchanges = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//调用Chain的proceed(Request)方法处理请求</span></span><br><span class="line">      Response response = chain.proceed(originalRequest);</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="comment">//返回响应</span></span><br><span class="line">      <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>getResponseWithInterceptorChain()干了三件事：1、添加拦截器到interceptors列表中；2、构造第一个Chain；3、调用Chain的proceed(Request)方法处理请求。下面分别介绍:</p>
<h3 id="1、添加拦截器到interceptors列表中"><a href="#1、添加拦截器到interceptors列表中" class="headerlink" title="1、添加拦截器到interceptors列表中"></a>1、添加拦截器到interceptors列表中</h3><p>除了添加我们自定义的拦截器外，还添加了默认的拦截器，如下：</p>
<ul>
<li>1、RetryAndFollowUpInterceptor：负责失败重试和重定向。</li>
<li>2、BridgeInterceptor：负责把用户构造的Request转换为发送给服务器的Request和把服务器返回的Response转换为对用户友好的Response。</li>
<li>3、CacheInterceptor：负责读取缓存以及更新缓存。</li>
<li>4、ConnectInterceptor：负责与服务器建立连接并管理连接。</li>
<li>5、CallServerInterceptor：负责向服务器发送请求和从服务器读取响应。</li>
</ul>
<p>这几个默认的拦截器是本文的重点，在后面会分别介绍。</p>
<h3 id="2、构造第一个Chain"><a href="#2、构造第一个Chain" class="headerlink" title="2、构造第一个Chain"></a>2、构造第一个Chain</h3><p>Chain是Interceptor的一个内部接口，它的实现类是RealInterceptorChain，我们要对它的传进来的前6个构造参数有个印象，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Chain</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealInterceptorChain</span><span class="params">(List&lt;Interceptor&gt; interceptors, Transmitter transmitter, @Nullable Exchange exchange, <span class="keyword">int</span> index, Request request, Call call, <span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.interceptors = interceptors;<span class="comment">//interceptors列表</span></span><br><span class="line">        <span class="keyword">this</span>.transmitter = transmitter;<span class="comment">//Transmitter对象，后面会介绍</span></span><br><span class="line">        <span class="keyword">this</span>.exchange = exchange;<span class="comment">//Exchange对象，后面会介绍</span></span><br><span class="line">        <span class="keyword">this</span>.index = index;<span class="comment">//interceptor索性，用于获取interceptors列表中的interceptor</span></span><br><span class="line">        <span class="keyword">this</span>.request = request;<span class="comment">//请求request</span></span><br><span class="line">        <span class="keyword">this</span>.call = call;<span class="comment">//Call对象</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在后面的拦截器中都可以通过Chain获取这些传进来的参数。我们知道，为了让每个拦截器都有机会处理请求，okhttp使用了责任链模式来把各个拦截器串联起来，拦截器就是责任链的节点，而Chain就是责任链中各个节点之间的连接点，负责把各个拦截器连接起来。那么是怎么连接的？看下面的Chain的proceed方法。</p>
<h3 id="3、调用Chain的proceed-Request-方法处理请求"><a href="#3、调用Chain的proceed-Request-方法处理请求" class="headerlink" title="3、调用Chain的proceed(Request)方法处理请求"></a>3、调用Chain的proceed(Request)方法处理请求</h3><p>实际是RealInterceptorChain的proceed(Request)方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Chain</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proceed(request, transmitter, exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, Transmitter transmitter, @Nullable Exchange exchange)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//index不能越界</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//再新建一个Chain，这里注意index加1，</span></span><br><span class="line">        RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, transmitter, exchange,</span><br><span class="line">                                                             index + <span class="number">1</span>, request, call, connectTimeout, readTimeout, writeTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取interceptors列表中的下一个拦截器</span></span><br><span class="line">        Interceptor interceptor = interceptors.get(index);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用下一个拦截器的intercept(Chain)方法，传入刚才新建的RealInterceptorChain，返回Response</span></span><br><span class="line">        Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回响应</span></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>proceed方法里面首先会再新建一个Chain并且<strong>index + 1</strong>作为构造参数传了进去，然后通过index从interceptors列表中获取了一个拦截器，接着就会调用拦截器的intercept方法，并把刚刚新建的Chain作为参数传给拦截器，我们再回顾一下上面所讲的拦截器intercept方法的模板，intercept方法处理完Request逻辑后，会再次调用传入的Chain的proceed(Request)方法，这样又会重复Chain的proceed方法中的逻辑，由于index已经加1了，所以这次Chain就会通过index获取下一个拦截器，并调用下一个拦截器的intercept(Chain)方法，然后如此循环重复下去，这样就把每个拦截器通过一个个Chain连接起来，形成一条链，把Request沿着链传递下去，直到请求被处理，然后返回Response，响应同样的沿着链传递上去，如下：</p>
<img src="/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/okhttp1.png" class="" title="okhttp">

<p>从上图可知，当没有自定义拦截器时，责任链首节点就是RetryAndFollowUpInterceptor，尾节点就是CallServerInterceptor，Request按照拦截器的顺序正向处理，Response则逆向处理，每个拦截器都有机会处理Request和Response，一个完美的责任链模式的实现。</p>
<p>知道了getResponseWithInterceptorChain()的整体流程后，下面分别介绍各个默认拦截器的功能。</p>
<h2 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h2><p>在自定义拦截器的时候就讲过，Interceptor的intercept(Chain)方法就是拦截器的拦截实现，RetryAndFollowUpInterceptor的intercept(Chain)方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RetryAndFollowUpInterceptor.java</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取Request</span></span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    <span class="comment">//获取Transmitter</span></span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重定向次数</span></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个死循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用Transmitter的prepareToConnect方法，做好连接建立的准备</span></span><br><span class="line">        transmitter.prepareToConnect(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (transmitter.isCanceled()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Response response;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用proceed方法，里面调用下一个拦截器BridgeInterceptor的intercept方法</span></span><br><span class="line">            response = realChain.proceed(request, transmitter, <span class="keyword">null</span>);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RouteException e) &#123;<span class="comment">//出现RouteException异常</span></span><br><span class="line">            <span class="comment">//调用recover方法检测连接是否可以继续使用</span></span><br><span class="line">            <span class="keyword">if</span> (!recover(e.getLastConnectException(), transmitter, <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.getFirstConnectException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;<span class="comment">//出现IOException异常，和服务端建立连接失败</span></span><br><span class="line">            <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">            <span class="comment">//调用recover方法检测连接是否可以继续使用</span></span><br><span class="line">            <span class="keyword">if</span> (!recover(e, transmitter, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;<span class="comment">//出现其他未知异常</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="comment">//调用Transmitter的exchangeDoneDueToException()方法释放连接</span></span><br><span class="line">                transmitter.exchangeDoneDueToException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行到这里，没有出现任何异常，连接成功, 响应返回</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据响应码来处理请求头</span></span><br><span class="line">        Request followUp = followUpRequest(response, route);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//followUp为空，不需要重定向，直接返回Response</span></span><br><span class="line">        <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//followUp不为空，需要重定向</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//MAX_FOLLOW_UPS值为20，重定向次数不能大于20次</span></span><br><span class="line">        <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以重定向后的Request再次重试</span></span><br><span class="line">        request = followUp;</span><br><span class="line">        priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RetryAndFollowUpInterceptor的intercept(Chain)方法中主要是失败重试和重定向的逻辑，该方法流程如下：</p>
<p>1、首先获取Transmitter类；</p>
<p>2、然后进入一个死循环，先调用Transmitter的prepareToConnect方法，准备建立连接；（连接真正的建立在ConnectInterceptor中）</p>
<p>3、接着调用Chain的proceed方法，继续执行下一个拦截器BridgeInterceptor的intercept方法：</p>
<p>​    3.1、如果在请求的过程中抛出RouteException异常或IOException异常，就会调用recover方法检测连接是否可以继续使用，如果不可以继续使用就抛出异常，整个过程结束，否则就再次重试，这就是失败重试；</p>
<p>​    3.2、如果在请求的过程中抛出除了3.1之外的异常，就会调用Transmitter的exchangeDoneDueToException()方法释放连接，整个过程结束。</p>
<p>4、没有任何异常抛出，当响应Response返回后，就会调用followUpRequest方法，里面根据返回的Response的响应码来决定是否需要重定向（构造followUp请求），如果不需要重定向，就直接返回Response，如果需要重定向，那么以重定向后的Request再次重试，重定向次数不能大于20次。</p>
<h3 id="1、Transmitter"><a href="#1、Transmitter" class="headerlink" title="1、Transmitter"></a>1、Transmitter</h3><p>在整个方法的流程中出现了一个Transmitter，这里介绍一下，它是okhttp中应用层和网络层的桥梁，管理同一个Cal的所有连接、请求、响应和IO流之间的关系，它在RealCall创建后就被创建了，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建RealCall</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    <span class="comment">//创建Transmitter，赋值给call的transmitter字段</span></span><br><span class="line">    call.transmitter = <span class="keyword">new</span> Transmitter(client, call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建后，在构造节点Chain时作为参数传了进去，在getResponseWithInterceptorChain方法中有讲到，所以在intercept方法中它可以通过chain.transmitter()获得，它的整个生命周期贯穿了所有拦截器，在接下来的ConnectInterceptor和CallServerInterceptor中你都可以见到它的身影，我们看一下它的主要成员，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Transmitter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OkHttpClient client;<span class="comment">//OkHttpClient大管家</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RealConnectionPool connectionPool;<span class="comment">//连接池，管理着连接</span></span><br><span class="line">    <span class="keyword">public</span> RealConnection connection;<span class="comment">//本次连接对象</span></span><br><span class="line">    <span class="keyword">private</span> ExchangeFinder exchangeFinder;<span class="comment">//负责连接的创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Nullable</span> Exchange exchange;<span class="comment">//负责连接IO流读写</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Call call;<span class="comment">//Call对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Transmitter</span><span class="params">(OkHttpClient client, Call call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.client = client;</span><br><span class="line">        <span class="keyword">this</span>.connectionPool = Internal.instance.realConnectionPool(client.connectionPool());</span><br><span class="line">        <span class="keyword">this</span>.call = call;</span><br><span class="line">        <span class="keyword">this</span>.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">        <span class="keyword">this</span>.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareToConnect</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.request != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sameConnection(<span class="keyword">this</span>.request.url(), request.url()) &amp;&amp; exchangeFinder.hasRouteToTry()) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// Already ready.</span></span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">        <span class="comment">//创建ExchangeFinder</span></span><br><span class="line">        <span class="keyword">this</span>.exchangeFinder = <span class="keyword">new</span> ExchangeFinder(<span class="keyword">this</span>, connectionPool, createAddress(request.url()), call, eventListener);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Transmitter中client和call我们都认识，剩下的RealConnectionPool、RealConnection、ExchangeFinder、Exchange都和okhttp的连接机制有关，都会在ConnectInterceptor中介绍，Transmitter就是负责管理它们之间的关系。这里我们只要记住，Transmitter的prepareToConnect方法中主要是创建了一个ExchangeFinder，为在ConnectInterceptor中连接的建立做了一个准备。</p>
<h2 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h2><p>BridgeInterceptor的intercept(Chain)方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BridgeInterceptor.java</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取Request</span></span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//下面都是根据需要为Request的header添加或移除一些信息</span></span><br><span class="line">    </span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">      MediaType contentType = body.contentType();</span><br><span class="line">      <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">      requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">      requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用proceed方法，里面调用下一个拦截器CacheInterceptor的intercept方法</span></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回Response后</span></span><br><span class="line">    <span class="comment">//下面都是根据需要为Response的header添加或移除一些信息</span></span><br><span class="line">    </span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>)) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">      Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">          .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">          .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">          .build();</span><br><span class="line">      responseBuilder.headers(strippedHeaders);</span><br><span class="line">      String contentType = networkResponse.header(<span class="string">"Content-Type"</span>);</span><br><span class="line">      responseBuilder.body(<span class="keyword">new</span> RealResponseBody(contentType, -<span class="number">1L</span>, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>BridgeInterceptor中的逻辑是在所有默认拦截器中是最简单，它主要就是对Request或Response的header做了一些处理，把用户构造的Request转换为发送给服务器的Request，还有把服务器返回的Response转换为对用户友好的Response。例如，对于Request，当开发者没有添加Accept-Encoding时，它会自动添加Accept-Encoding : gzip，表示客户端支持使用gzip；对于Response，当Content-Encoding是gzip方式并且客户端是自动添加gzip支持时，它会移除Content-Encoding、Content-Length，然后重新解压缩响应的内容。</p>
<h2 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h2><p>CacheInterceptor的intercept(Chain)方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheInterceptor.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据Request得到Cache中缓存的Response，Cache是什么，后面介绍</span></span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span> ? cache.get(chain.request()) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建缓存策略：网络、缓存、或两者都使用，CacheStrategy是什么，后面介绍</span></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    <span class="comment">//得到networkRequest</span></span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    <span class="comment">//得到cacheResponse，cacheResponse等于上面的cacheCandidate</span></span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个Response缓存无效，close掉它</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body()); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、networkRequest为null且cacheResponse为null：表示强制使用缓存，但是没有缓存，所以构造状态码为504，body为空的Response</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">            .request(chain.request())</span><br><span class="line">            .protocol(Protocol.HTTP_1_1)</span><br><span class="line">            .code(<span class="number">504</span>)<span class="comment">//状态码504</span></span><br><span class="line">            .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">            .body(Util.EMPTY_RESPONSE)</span><br><span class="line">            .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2、networkRequest为null但cacheResponse不为null：表示强制使用缓存，并且有缓存，所以直接返回缓存的Response</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//networkRequest不为null，所以可以发起网络请求，调用chain.proceed(Request)，里面调用下一个拦截器BridgeInterceptor的intercept方法，会返回网络请求得到的networkResponse</span></span><br><span class="line">        networkResponse = chain.proceed(networkRequest);</span><br><span class="line">       </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//发起网络请求出现IO异常或其他异常的处理</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、networkRequest不为null且cacheResponse不为null：因为cacheResponse不为null，所以根据网络请求得到的networkResponse和缓存的cacheResponse做比较，来决定是否使用cacheResponse</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;<span class="comment">//HTTP_NOT_MODIFIED等于304，304表示服务器资源没有更新，所以客户端可以直接使用本地缓存cacheResponse</span></span><br><span class="line">            <span class="comment">//下面根据cacheResponse构造Response返回，并且更新cacheResponse的头部信息</span></span><br><span class="line">            Response response = cacheResponse.newBuilder()</span><br><span class="line">                .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .networkResponse(stripBody(networkResponse))</span><br><span class="line">                .build();</span><br><span class="line">            networkResponse.body().close();</span><br><span class="line">            <span class="comment">//在本地缓存更新cacheResponse</span></span><br><span class="line">            cache.trackConditionalCacheHit();</span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            <span class="comment">//返回构造的Response</span></span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//服务器返回了200，服务器资源更新了，所以客户端cacheResponse无效，close掉它</span></span><br><span class="line">            closeQuietly(cacheResponse.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、networkRequest不为null但cacheResponse为null或者服务器返回了200：cacheResponse为null，没有缓存使用，服务器返回了200，本地缓存失效，这两种情况都要从networkResponse读取网络响应，构造Response准备返回</span></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .networkResponse(stripBody(networkResponse))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;<span class="comment">//如果Cache不为null，表示使用缓存</span></span><br><span class="line">        <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">            <span class="comment">//把Response缓存到Cache中</span></span><br><span class="line">            CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">            <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cache.remove(networkRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                <span class="comment">// The cache cannot be written.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回Response</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CacheInterceptor的intercept(Chain)里面定义了okhttp的缓存机制，我们先来了解两个类：Cache和CacheStrategy，这样才能看懂intercept(Chain)里面的逻辑。</p>
<h3 id="1、Cache-缓存实现"><a href="#1、Cache-缓存实现" class="headerlink" title="1、Cache - 缓存实现"></a>1、Cache - 缓存实现</h3><p>Cache是okhttp中缓存的实现，内部使用了DiskLruCache，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//内部都是通过DiskLruCache实现</span></span><br><span class="line">    <span class="keyword">final</span> DiskLruCache cache;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//有一个InternalCache实现，都调用了Cache中的方法</span></span><br><span class="line">    <span class="keyword">final</span> InternalCache internalCache = <span class="keyword">new</span> InternalCache() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Cache.<span class="keyword">this</span>.get(request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Cache.<span class="keyword">this</span>.put(response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Cache.<span class="keyword">this</span>.remove(request);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Response cached, Response network)</span> </span>&#123;</span><br><span class="line">            Cache.<span class="keyword">this</span>.update(cached, network);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackConditionalCacheHit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Cache.<span class="keyword">this</span>.trackConditionalCacheHit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackResponse</span><span class="params">(CacheStrategy cacheStrategy)</span> </span>&#123;</span><br><span class="line">            Cache.<span class="keyword">this</span>.trackResponse(cacheStrategy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可以通过下面两个构造函数构造一个Cache</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cache</span><span class="params">(File directory, <span class="keyword">long</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(directory, maxSize, FileSystem.SYSTEM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cache(File directory, <span class="keyword">long</span> maxSize, FileSystem fileSystem) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面是主要方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Nullable</span> <span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span> <span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Response cached, Response network)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trackConditionalCacheHit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">trackResponse</span><span class="params">(CacheStrategy cacheStrategy)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cache中有一个内部实现类InternalCache，见名知意，它是okhttp内部使用的，它实现了InternalCache接口，接口中的方法都和Cache中的方法同名，而且这个实现类的所有方法都是调用了Cache中相应的方法，也就是说InternalCache的方法实现和Cache相应的方法一样，但Cache和InternalCache不一样的是，Cache比InternalCache多了一些方法供外部调用如flush()、 close()等，提供了更多对缓存的控制，而InternalCache中的方法都只是缓存的基本操作，如get、put、remove、update等方法，这些方法的逻辑都是基于Cache中的DiskLruCache实现，详情可以看<a href="https://blog.csdn.net/guolin_blog/article/details/28863651" target="_blank" rel="noopener">DiskLruCache</a>的原理实现。</p>
<p>要知道，okhttp默认是不使用缓存，也就是Cache为null，如果要使用缓存，我们需要自行配置，通过下面方法使用okhttp的缓存机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存的路径</span></span><br><span class="line">File cacheDir = <span class="keyword">new</span> File(Constant.PATH_NET_CACHE);</span><br><span class="line"><span class="comment">//这里通过带有两个参数的构造函数构造一个Cache</span></span><br><span class="line">Cache cache = <span class="keyword">new</span> Cache(cacheDir, <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>);<span class="comment">//缓存的最大尺寸10M</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后设置给OkHttpClient</span></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">    .cache(cache)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<p>通过上面全局设置后，Cache和InternalCache都不会为null，因为在创建Cache时InternalCache也一起创建了，okhttp的缓存机制就会生效。</p>
<p>我们先回到CacheInterceptor的intercept方法，它首先一开始就要判断cache是否等于null，那么CacheInterceptor的cache在哪里来的呢？是在构造函数中，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="meta">@Nullable</span> InternalCache cache;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheInterceptor</span><span class="params">(@Nullable InternalCache cache)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = cache;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可用看到它是InternalCache实例，在 getResponseWithInterceptorChain()中添加拦截器时就通过client为这个InternalCache赋值了，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealCall.java</span></span><br><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//添加负责缓存的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到new CacheInterceptor(client.internalCache())，所以我们看client的internalCache方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OkHttpClient.java</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="function">InternalCache <span class="title">internalCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache != <span class="keyword">null</span> ? cache.internalCache : internalCache;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>cache就是上面全局设置的cache实例，所以不为null，返回cache中的internalCache实例，这样CacheInterceptor中就持有internalCache实例。</p>
<h3 id="2、CacheStrategy-缓存策略"><a href="#2、CacheStrategy-缓存策略" class="headerlink" title="2、CacheStrategy - 缓存策略"></a>2、CacheStrategy - 缓存策略</h3><p>CacheStrategy是okhttp缓存策略的实现，okhttp缓存策略遵循了HTTP缓存策略，因此了解okhttp缓存策略前需要有HTTP缓存相关基础：<a href="https://my.oschina.net/leejun2005/blog/369148" target="_blank" rel="noopener">HTTP 协议缓存机制详解</a>，了解了HTTP缓存策略后，我们再来看CacheStrategy，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CacheStrategy两个主要的成员变量：networkRequest、cacheResponse</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Request networkRequest;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> Response cacheResponse;</span><br><span class="line"></span><br><span class="line">    CacheStrategy(Request networkRequest, Response cacheResponse) &#123;</span><br><span class="line">        <span class="keyword">this</span>.networkRequest = networkRequest;</span><br><span class="line">        <span class="keyword">this</span>.cacheResponse = cacheResponse;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过工厂模式创建CacheStrategy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> nowMillis;</span><br><span class="line">        <span class="keyword">final</span> Request request;</span><br><span class="line">        <span class="keyword">final</span> Response cacheResponse;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(<span class="keyword">long</span> nowMillis, Request request, Response cacheResponse)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.nowMillis = nowMillis;</span><br><span class="line">            <span class="keyword">this</span>.request = request;</span><br><span class="line">            <span class="keyword">this</span>.cacheResponse = cacheResponse;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            CacheStrategy candidate = getCandidate();</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CacheStrategy是通过<a href="https://rain9155.github.io/2019/09/07/工厂模式/#more" target="_blank" rel="noopener">工厂模式</a>创建的，它有两个主要的成员变量：networkRequest、cacheResponse，CacheInterceptor的intercept方法通过CacheStrategy的networkRequest和cacheResponse的组合来判断执行什么策略，networkRequest是否为空决定是否请求网络，cacheResponse是否为空决定是否使用缓存，networkRequest和cacheResponse的4种组合和对应的缓存策略如下：</p>
<ul>
<li>1、networkRequest为null且cacheResponse为null：没有缓存使用，又不进行网络请求，构造状态码为504的Response。</li>
<li>2、networkRequest为null但cacheResponse不为null：有缓存使用，且缓存在有效期内，所以直接返回缓存的Response。</li>
<li>3、networkRequest不为null且cacheResponse不为null：有缓存使用，但缓存在客户端的判断中表示过期了，所以请求服务器进行决策，来决定是否使用缓存的Response。</li>
<li>4、networkRequest不为null但cacheResponse为null：没有缓存使用，所以直接使用服务器返回的Response</li>
</ul>
<p>networkRequest和cacheResponse在创建CacheStrategy时通过构造参数赋值，那么CacheStrategy在那里被创建呢？当调用CacheStrategy.Factory(long, Request, Response).get()时就会返回一个CacheStrategy实例，所以CacheStrategy在Factory的get方法中被创建，我们来看Factory的get方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheStrategy.Factory</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CacheStrategy candidate = getCandidate();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到CacheStrategy通过Factory的getCandidate方法创建，getCandidate方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CacheStrategy.Factory</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、没有Response缓存，直接进行网络请求</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、如果TLS握手信息丢失，直接进行网络请求</span></span><br><span class="line">    <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、根据Response状态码，Expired和Cache-Control的no-Store进行判断Response缓存是否可用</span></span><br><span class="line">    <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">        <span class="comment">//Response缓存不可用，直接进行网络请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得Request的缓存控制字段CacheControl</span></span><br><span class="line">    CacheControl requestCaching = request.cacheControl();</span><br><span class="line">    <span class="comment">//4、根据Request中的Cache-Control的noCache和header是否设置If-Modified-Since或If-None-Match进行判断是否可以使用Response缓存</span></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">        <span class="comment">//不可以使用Response缓存，直接进行网络请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> 	<span class="comment">//走到这里表示Response缓存可用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得Response的缓存控制字段CacheControl</span></span><br><span class="line">    CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得该Response已经缓存的时长</span></span><br><span class="line">    <span class="keyword">long</span> ageMillis = cacheResponseAge();</span><br><span class="line">    <span class="comment">//获得该Response可以缓存的时长</span></span><br><span class="line">    <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) </span><br><span class="line">        <span class="comment">//一般取max-age</span></span><br><span class="line">        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//一般取0</span></span><br><span class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//取max-stale，</span></span><br><span class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//5、判断缓存是否过期，决定是否使用Response缓存：Response已经缓存的时长 &lt; max-stale + max-age</span></span><br><span class="line">    <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">        Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"110 HttpURLConnection \"Response is stale\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">            builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"113 HttpURLConnection \"Heuristic expiration\""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.1、缓存没有过期，直接使用该Response缓存</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//5.2、缓存过期了，判断是否设置了Etag或Last-Modified等标记</span></span><br><span class="line">    String conditionName;</span><br><span class="line">    String conditionValue;</span><br><span class="line">    <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">"If-None-Match"</span>;</span><br><span class="line">        conditionValue = etag;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">"If-Modified-Since"</span>;</span><br><span class="line">        conditionValue = lastModifiedString;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        conditionName = <span class="string">"If-Modified-Since"</span>;</span><br><span class="line">        conditionValue = servedDateString;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//缓存没有设置Etag或Last-Modified等标记，所以直接进行网络请求</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//缓存设置了Etag或Last-Modified等标记，所以添加If-None-Match或If-Modified-Since请求头，构造请求，交给服务器判断缓存是否可用</span></span><br><span class="line">    Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</span><br><span class="line">    Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line"></span><br><span class="line">    Request conditionalRequest = request.newBuilder()</span><br><span class="line">        .headers(conditionalRequestHeaders.build())</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//networkRequest和cacheResponse都不为null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> getCandidate()方法中根据<a href="https://my.oschina.net/leejun2005/blog/369148" target="_blank" rel="noopener"><strong>HTTP的缓存策略</strong></a>决定networkRequest和cacheResponse的组合，从getCandidate()方法中我们可以看到HTTP的缓存策略分为两种：</p>
<ul>
<li>1、强制缓存：<strong>客户端参与决策决定是否继续使用缓存</strong>，客户端第一次请求数据时，服务端返回了缓存的过期时间：Expires或Cache-Control，当客户端再次请求时，就判断缓存的过期时间，没有过期就可以继续使用缓存，否则就不使用，重新请求服务端。</li>
<li>2、对比缓存：<strong>服务端参与决策决定是否继续使用缓存</strong>，客户端第一次请求数据时，服务端会将缓存标识：Last-Modified/If-Modified-Since、Etag/If-None-Match和数据一起返回给客户端 ，当客户端再次请求时，客户端将缓存标识发送给服务端，服务端根据缓存标识进行判断，如果缓存还没有更新，可以使用，则返回304，表示客户端可以继续使用缓存，否则客户端不能继续使用缓存，只能使用服务器返回的新的响应。</li>
</ul>
<p>而且强制缓存优先于对比缓存，我们再贴出来自<a href="https://my.oschina.net/leejun2005/blog/369148" target="_blank" rel="noopener">HTTP 协议缓存机制详解</a>的一张图，它很好的解释了getCandidate()方法中1~5步骤流程，如下：</p>
<img src="/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/okhttp2.png" class="" title="okhttp">

<h3 id="3、缓存机制"><a href="#3、缓存机制" class="headerlink" title="3、缓存机制"></a>3、缓存机制</h3><p>我们再回到CacheInterceptor的intercept方法，它的1~4步骤就是CacheStrategy的networkRequest和cacheResponse的4种组合情况，都有详细的注释，每一种组合对应一种缓存策略，而缓存策略又是基于getCandidate()方法中写死的HTTP缓存策略，再结合okhttp本地缓存的实现Cache，我们得出结论：<strong>okhttp的缓存机制 = Cache缓存实现 + 基于HTTP的缓存策略</strong>，整个流程图如下：</p>
<img src="/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/okhttp3.png" class="" title="okhttp">

<p>了解了okhttp的缓存机制后，我们接着下一个拦截器ConnectInterceptor。</p>
<h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><p>ConnectInterceptor的intercept(Chain)方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConnectInterceptor.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   </span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    <span class="comment">//获取Transmitter</span></span><br><span class="line">    Transmitter transmitter = realChain.transmitter();</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">//1、新建一个Exchange</span></span><br><span class="line">    Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用proceed方法，里面调用下一个拦截器CallServerInterceptor的intercept方法</span></span><br><span class="line">    <span class="comment">//这里调用的proceed方法是带有三个参数的，它传进了Request、Transmitter和刚刚新建的Exchange</span></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, transmitter, exchange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConnectInterceptor的intercept(Chain)方法很简洁，里面定义了okhttp的连接机制，它首先获取Transmitter，然后通过Transmitter的newExchange方法创建一个Exchange，把它传到下一个拦截器CallServerInterceptor，Exchange是什么？Exchange负责从创建的连接的IO流中写入请求和读取响应，完成一次请求/响应的过程，在CallServerInterceptor中你会看到它真正的作用，这里先忽略。所以注释1的newExchange方法是连接机制的主要逻辑实现，我们继续看Transmitter的newExchange方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Transmitter.java</span></span><br><span class="line"><span class="function">Exchange <span class="title">newExchange</span><span class="params">(Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、通过ExchangeFinder的find方法找到一个ExchangeCodec</span></span><br><span class="line">    ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Exchange，并把ExchangeCodec实例codec传进去，所以Exchange内部持有ExchangeCodec实例</span></span><br><span class="line">    Exchange result = <span class="keyword">new</span> Exchange(<span class="keyword">this</span>, call, eventListener, exchangeFinder, codec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点是注释1，ExchangeFinder对象早在RetryAndFollowUpInterceptor中通过Transmitter的prepareToConnect方法创建，它的find方法是连接真正创建的地方，ExchangeFinder是什么？ExchangeFinder就是负责连接的创建，把创建好的连接放入连接池，如果连接池中已经有该连接，就直接取出复用，所以ExchangeFinder管理着两个重要的角色：RealConnection、RealConnectionPool，下面讲解一下RealConnectionPool和RealConnection，有助于连接机制的理解。</p>
<h3 id="1、RealConnection-连接实现"><a href="#1、RealConnection-连接实现" class="headerlink" title="1、RealConnection - 连接实现"></a>1、RealConnection - 连接实现</h3><p>连接的真正实现，实现了Connection接口，内部利用Socket建立连接，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回这个连接使用的Route</span></span><br><span class="line">    <span class="function">Route <span class="title">route</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回这个连接使用的Socket</span></span><br><span class="line">    <span class="function">Socket <span class="title">socket</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是HTTPS，返回TLS握手信息用于建立连接，否则返回null</span></span><br><span class="line">    <span class="meta">@Nullable</span> <span class="function">Handshake <span class="title">handshake</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回应用层使用的协议，Protocol是一个枚举，如HTTP1.1、HTTP2</span></span><br><span class="line">    <span class="function">Protocol <span class="title">protocol</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealConnection</span> <span class="keyword">extends</span> <span class="title">Http2Connection</span>.<span class="title">Listener</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> RealConnectionPool connectionPool;</span><br><span class="line">    <span class="comment">//路由</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Route route;</span><br><span class="line">    <span class="comment">//内部使用这个rawSocket在TCP层建立连接</span></span><br><span class="line">    <span class="keyword">private</span> Socket rawSocket;</span><br><span class="line">    <span class="comment">//如果没有使用HTTPS，那么socket == rawSocket，否则这个socket == SSLSocket</span></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="comment">//TLS握手</span></span><br><span class="line">    <span class="keyword">private</span> Handshake handshake;</span><br><span class="line">    <span class="comment">//应用层协议</span></span><br><span class="line">    <span class="keyword">private</span> Protocol protocol;</span><br><span class="line">    <span class="comment">//HTTP2连接</span></span><br><span class="line">    <span class="keyword">private</span> Http2Connection http2Connection;</span><br><span class="line">    <span class="comment">//okio库的BufferedSource和BufferedSink，相当于javaIO的输入输出流</span></span><br><span class="line">    <span class="keyword">private</span> BufferedSource source;</span><br><span class="line">    <span class="keyword">private</span> BufferedSink sink;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealConnection</span><span class="params">(RealConnectionPool connectionPool, Route route)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connectionPool = connectionPool;</span><br><span class="line">        <span class="keyword">this</span>.route = route;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled, Call call, EventListener eventListener)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RealConnection中有一个connect方法，外部可以调用该方法建立连接，connect方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealConnection.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled, Call call, EventListener eventListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (protocol != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"already connected"</span>);</span><br><span class="line"></span><br><span class="line">    RouteException routeException = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;ConnectionSpec&gt; connectionSpecs = route.address().connectionSpecs();</span><br><span class="line">    ConnectionSpecSelector connectionSpecSelector = <span class="keyword">new</span> ConnectionSpecSelector(connectionSpecs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//路由选择</span></span><br><span class="line">    <span class="keyword">if</span> (route.address().sslSocketFactory() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</span><br><span class="line">            <span class="string">"CLEARTEXT communication not enabled for client"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      String host = route.address().url().host();</span><br><span class="line">      <span class="keyword">if</span> (!Platform.get().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</span><br><span class="line">            <span class="string">"CLEARTEXT communication to "</span> + host + <span class="string">" not permitted by network security policy"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(<span class="keyword">new</span> UnknownServiceException(</span><br><span class="line">            <span class="string">"H2_PRIOR_KNOWLEDGE cannot be used with HTTPS"</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始连接</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (route.requiresTunnel()) &#123;<span class="comment">//如果是通道模式，则建立通道连接</span></span><br><span class="line">          connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener);</span><br><span class="line">          <span class="keyword">if</span> (rawSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// We were unable to connect the tunnel but properly closed down our resources.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//1、否则进行Socket连接，大部分是这种情况</span></span><br><span class="line">          connectSocket(connectTimeout, readTimeout, call, eventListener);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建立HTTPS连接</span></span><br><span class="line">        establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//...省略异常处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (http2Connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        allocationLimit = http2Connection.maxConcurrentStreams();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们关注注释1，一般会调用connectSocket方法建立Socket连接，connectSocket方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealConnection.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, Call call,</span></span></span><br><span class="line"><span class="function"><span class="params">                           EventListener eventListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Proxy proxy = route.proxy();</span><br><span class="line">    Address address = route.address();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据代理类型的不同创建Socket</span></span><br><span class="line">    rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</span><br><span class="line">        ? address.socketFactory().createSocket()</span><br><span class="line">        : <span class="keyword">new</span> Socket(proxy);</span><br><span class="line"></span><br><span class="line">    eventListener.connectStart(call, route.socketAddress(), proxy);</span><br><span class="line">    rawSocket.setSoTimeout(readTimeout);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1、建立Socket连接</span></span><br><span class="line">        Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获得Socket的输入输出流</span></span><br><span class="line">        source = Okio.buffer(Okio.source(rawSocket));</span><br><span class="line">        sink = Okio.buffer(Okio.sink(rawSocket));</span><br><span class="line">    &#125; </span><br><span class="line">     <span class="comment">//...省略异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们关注注释1，Platform是okhttp中根据不同Android版本平台的差异实现的一个兼容类，这里就不细究，Platform的connectSocket方法最终会调用rawSocket的connect()方法建立其Socket连接，建立Socket连接后，就可以通过Socket连接获得输入输出流source和sink，okhttp就可以从source读取或往sink写入数据，source和sink是BufferedSource和BufferedSink类型，它们是来自于<a href="https://github.com/square/okio" target="_blank" rel="noopener">okio库</a>，它是一个封装了java.io和java.nio的库，okhttp底层依赖这个库读写数据，Okio好在哪里？详情可以看这篇文章<a href="https://www.jianshu.com/p/2fff6fe403dd" target="_blank" rel="noopener">Okio好在哪</a>。</p>
<h3 id="2、RealConnectionPool-连接池"><a href="#2、RealConnectionPool-连接池" class="headerlink" title="2、RealConnectionPool -  连接池"></a>2、RealConnectionPool -  连接池</h3><p>连接池，用来管理连接对象RealConnection，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealConnectionPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">0</span> <span class="comment">/* corePoolSize */</span>,</span><br><span class="line">        Integer.MAX_VALUE <span class="comment">/* maximumPoolSize */</span>, </span><br><span class="line">        <span class="number">60L</span> <span class="comment">/* keepAliveTime */</span>, </span><br><span class="line">        TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> SynchronousQueue&lt;&gt;(), </span><br><span class="line">        Util.threadFactory(<span class="string">"OkHttp ConnectionPool"</span>, <span class="keyword">true</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">boolean</span> cleanupRunning;</span><br><span class="line">    <span class="comment">//清理连接任务，在executor中执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//调用cleanup方法执行清理逻辑</span></span><br><span class="line">            <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</span><br><span class="line">            <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> waitMillis = waitNanos / <span class="number">1000000L</span>;</span><br><span class="line">                waitNanos -= (waitMillis * <span class="number">1000000L</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (RealConnectionPool.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//调用wait方法进入等待</span></span><br><span class="line">                        RealConnectionPool.<span class="keyword">this</span>.wait(waitMillis, (<span class="keyword">int</span>) waitNanos);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双端队列，保存连接</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cleanupRunning) &#123;</span><br><span class="line">            cleanupRunning = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//使用线程池执行清理任务</span></span><br><span class="line">            executor.execute(cleanupRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新建连接插入队列</span></span><br><span class="line">        connections.add(connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RealConnectionPool 在内部维护了一个线程池，用来执行清理连接任务cleanupRunnable，还维护了一个双端队列connections，用来缓存已经创建的连接。要知道创建一次连接要经历TCP握手，如果是HTTPS还要经历TLS握手，握手的过程都是耗时的，所以为了提高效率，就需要connections来对连接进行缓存，从而可以复用；还有如果连接使用完毕，长时间不释放，也会造成资源的浪费，所以就需要cleanupRunnable定时清理无用的连接，okhttp支持5个并发连接，默认每个连接keepAlive为5分钟，keepAlive就是连接空闲后，保持存活的时间。</p>
<p>当我们第一次调用RealConnectionPool 的put方法缓存新建连接时，如果cleanupRunnable还没执行，它首先会使用线程池执行cleanupRunnable，然后把新建连接放入双端队列，cleanupRunnable中会调用cleanup方法进行连接的清理，该方法返回现在到下次清理的时间间隔，然后调用wiat方法进入等待状态，等时间到了后，再次调用cleanup方法进行清理，就这样往复循环。我们来看一下cleanup方法的清理逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RealConnectionPool.java</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;<span class="comment">//正在使用连接数</span></span><br><span class="line">    <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;<span class="comment">//空闲连接数</span></span><br><span class="line">    RealConnection longestIdleConnection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历所有连接，记录空闲连接和正在使用连接各自的数量</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            RealConnection connection = i.next();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果该连接还在使用，pruneAndGetAllocationCount种通过引用计数的方式判断一个连接是否空闲</span></span><br><span class="line">            <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//使用连接数加1</span></span><br><span class="line">                inUseConnectionCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//该连接没有在使用</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//空闲连接数加1</span></span><br><span class="line">            idleConnectionCount++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//记录keepalive时间最长的那个空闲连接</span></span><br><span class="line">            <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</span><br><span class="line">            <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</span><br><span class="line">                longestIdleDurationNs = idleDurationNs;</span><br><span class="line">                <span class="comment">//这个连接很可能被移除，因为空闲时间太长</span></span><br><span class="line">                longestIdleConnection = connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//跳出循环后</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认keepalive时间keepAliveDurationNs最长为5分钟，空闲连接数idleConnectionCount最大为5个</span></span><br><span class="line">        <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;<span class="comment">//如果longestIdleConnection的keepalive时间大于5分钟 或 空闲连接数超过5个</span></span><br><span class="line">            <span class="comment">//把longestIdleConnection连接从队列清理掉</span></span><br><span class="line">            connections.remove(longestIdleConnection);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;<span class="comment">//如果空闲连接数小于5个 并且 longestIdleConnection连接还没到期清理</span></span><br><span class="line">            <span class="comment">//返回该连接的到期时间，下次再清理</span></span><br><span class="line">            <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;<span class="comment">//如果没有空闲连接 且 所有连接都还在使用</span></span><br><span class="line">            <span class="comment">//返回keepAliveDurationNs，5分钟后再清理</span></span><br><span class="line">            <span class="keyword">return</span> keepAliveDurationNs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有任何连接，把cleanupRunning复位</span></span><br><span class="line">            cleanupRunning = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把longestIdleConnection连接从队列清理掉后，关闭该连接的socket，返回0，立即再次进行清理</span></span><br><span class="line">    closeQuietly(longestIdleConnection.socket());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从cleanup方法得知，okhttp清理连接的逻辑如下：</p>
<p>1、首先遍历所有连接，记录空闲连接数idleConnectionCount和正在使用连接数inUseConnectionCount，在记录空闲连接数时，还要找出空闲时间最长的空闲连接longestIdleConnection，这个连接是很有可能被清理的；</p>
<p>2、遍历完后，根据最大空闲时长和最大空闲连接数来决定是否清理longestIdleConnection，</p>
<p>​    2.1、如果longestIdleConnection的空闲时间大于最大空闲时长 或 空闲连接数大于最大空闲连接数，那么该连接就会被从队列中移除，然后关闭该连接的socket，返回0，立即再次进行清理；</p>
<p>​    2.2、如果空闲连接数小于5个 并且 longestIdleConnection的空闲时间小于最大空闲时长即还没到期清理，那么返回该连接的到期时间，下次再清理；</p>
<p>​    2.3、如果没有空闲连接 且 所有连接都还在使用，那么返回默认的keepAlive时间，5分钟后再清理；</p>
<p>​    2.4、没有任何连接，idleConnectionCount和inUseConnectionCount都为0，把cleanupRunning复位，等待下一次put连接时，再次使用线程池执行cleanupRunnable。</p>
<p>了解了RealConnectionPool和RealConnection后，我们再回到ExchangeFinder的find方法，这里是连接创建的地方。</p>
<h3 id="3、连接创建（连接机制）"><a href="#3、连接创建（连接机制）" class="headerlink" title="3、连接创建（连接机制）"></a>3、连接创建（连接机制）</h3><p>ExchangeFinder的fing方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExchangeFinder.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ExchangeCodec <span class="title">find</span><span class="params">( OkHttpClient client, Interceptor.Chain chain, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//调用findHealthyConnection方法，返回RealConnection</span></span><br><span class="line">      RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,  writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">return</span> resultConnection.newCodec(client, chain);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略异常处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//一个死循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//调用findConnection方法，返回RealConnection</span></span><br><span class="line">      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">          pingIntervalMillis, connectionRetryEnabled);</span><br><span class="line">        </span><br><span class="line">	  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断连接是否可用</span></span><br><span class="line">        <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">            candidate.noNewExchanges();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>ExchangeFinder的find方法会调用findHealthyConnection方法，里面会不断调用findConnection方法，直到找到一个可用的连接返回。ExchangeFinder的findConnection方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExchangeFinder.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout, <span class="keyword">int</span> pingIntervalMillis, <span class="keyword">boolean</span> connectionRetryEnabled)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> foundPooledConnection = <span class="keyword">false</span>;</span><br><span class="line">    RealConnection result = <span class="keyword">null</span>;<span class="comment">//返回结果，可用的连接</span></span><br><span class="line">    Route selectedRoute = <span class="keyword">null</span>;</span><br><span class="line">    RealConnection releasedConnection;</span><br><span class="line">    Socket toClose;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">       <span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">      hasStreamFailure = <span class="keyword">false</span>; .</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//1、尝试使用已经创建过的连接，已经创建过的连接可能已经被限制创建新的流</span></span><br><span class="line">      releasedConnection = transmitter.connection;</span><br><span class="line">      <span class="comment">//1.1、如果已经创建过的连接已经被限制创建新的流，就释放该连接（releaseConnectionNoEvents中会把该连接置空），并返回该连接的Socket以关闭</span></span><br><span class="line">      toClose = transmitter.connection != <span class="keyword">null</span> &amp;&amp; transmitter.connection.noNewExchanges</span><br><span class="line">          ? transmitter.releaseConnectionNoEvents()</span><br><span class="line">          : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.2、已经创建过的连接还能使用，就直接使用它当作结果、</span></span><br><span class="line">        <span class="keyword">if</span> (transmitter.connection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = transmitter.connection;</span><br><span class="line">            releasedConnection = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、已经创建过的连接不能使用</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2.1、尝试从连接池中找可用的连接，如果找到，这个连接会赋值先保存在Transmitter中</span></span><br><span class="line">            <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, <span class="keyword">null</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                <span class="comment">//2.2、从连接池中找到可用的连接</span></span><br><span class="line">                foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">                result = transmitter.connection;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextRouteToTry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                selectedRoute = nextRouteToTry;</span><br><span class="line">                nextRouteToTry = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (retryCurrentRoute()) &#123;</span><br><span class="line">                selectedRoute = transmitter.connection.route();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	closeQuietly(toClose);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//3、如果在上面已经找到了可用连接，直接返回结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//走到这里没有找到可用连接</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//看看是否需要路由选择，多IP操作</span></span><br><span class="line">    <span class="keyword">boolean</span> newRouteSelection = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span> &amp;&amp; (routeSelection == <span class="keyword">null</span> || !routeSelection.hasNext())) &#123;</span><br><span class="line">        newRouteSelection = <span class="keyword">true</span>;</span><br><span class="line">        routeSelection = routeSelector.next();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Route&gt; routes = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        <span class="keyword">if</span> (transmitter.isCanceled()) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有下一个路由</span></span><br><span class="line">        <span class="keyword">if</span> (newRouteSelection) &#123;</span><br><span class="line">            routes = routeSelection.getAll();</span><br><span class="line">            <span class="comment">//4、这里第二次尝试从连接池中找可用连接</span></span><br><span class="line">            <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                <span class="comment">//4.1、从连接池中找到可用的连接</span></span><br><span class="line">                foundPooledConnection = <span class="keyword">true</span>;</span><br><span class="line">                result = transmitter.connection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在连接池中没有找到可用连接</span></span><br><span class="line">        <span class="keyword">if</span> (!foundPooledConnection) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</span><br><span class="line">                selectedRoute = routeSelection.next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//5、所以这里新创建一个连接，后面会进行Socket连接</span></span><br><span class="line">            result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</span><br><span class="line">            connectingConnection = result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.2、如果在连接池中找到可用的连接，直接返回该连接</span></span><br><span class="line">    <span class="keyword">if</span> (foundPooledConnection) &#123;</span><br><span class="line">        eventListener.connectionAcquired(call, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.1、调用RealConnection的connect方法进行Socket连接，这个在RealConnection中讲过</span></span><br><span class="line">    result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener);</span><br><span class="line">    </span><br><span class="line">    connectionPool.routeDatabase.connected(result.route());</span><br><span class="line"></span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        connectingConnection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果我们刚刚创建了同一地址的多路复用连接，释放这个连接并获取那个连接</span></span><br><span class="line">        <span class="keyword">if</span> (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            result.noNewExchanges = <span class="keyword">true</span>;</span><br><span class="line">            socket = result.socket();</span><br><span class="line">            result = transmitter.connection;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//5.2、把刚刚新建的连接放入连接池</span></span><br><span class="line">            connectionPool.put(result);</span><br><span class="line">            <span class="comment">//5.3、把刚刚新建的连接保存到Transmitter的connection字段</span></span><br><span class="line">            transmitter.acquireConnectionNoEvents(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    closeQuietly(socket);</span><br><span class="line">    eventListener.connectionAcquired(call, result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.4、返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个findConnection方法就是整个ConnectInterceptor的核心，我们忽略掉多IP操作和多路复用(HTTP2)，假设现在我们是第一次请求，连接池和Transmitter中没有该连接，所以跳过1、2、3，直接来到5，创建一个新的连接，然后把它放入连接池和Transmitter中；接着我们用同一个Call进行了第二次请求，这时连接池和Transmitter中有该连接，所以就会走1、2、3，如果Transmitter中的连接还可用就返回，否则从连接池获取一个可用连接返回，所以整个连接机制的大概过程如下：</p>
<img src="/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/okhttp4.png" class="" title="okhttp">

<p>Transmitter中的连接和连接池中的连接有什么区别？我们知道每创建一个Call，就会创建一个对应的Transmitter，一个Call可以发起多次请求（同步、异步），不同的Call有不同的Transmitter，连接池是在创建OkhttpClient时创建的，所以连接池是所有Call共享的，即连接池中的连接所有Call都可以复用，而Transmitter中的那个连接只是对应它相应的Call，只能被本次Call的所有请求复用。</p>
<p>了解了okhttp的连接机制后，我们接着下一个拦截器CallServerInterceptor。</p>
<h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><p>CallServerInterceptor的intercept(Chain)方法如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CallServerInterceptor.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    <span class="comment">//获取Exchange</span></span><br><span class="line">    Exchange exchange = realChain.exchange();</span><br><span class="line">    <span class="comment">//获取Request</span></span><br><span class="line">    Request request = realChain.request();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过Exchange的writeRequestHeaders(request)方法写入请求的header</span></span><br><span class="line">    exchange.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> responseHeadersStarted = <span class="keyword">false</span>;</span><br><span class="line">    Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//通过okio写入请求的body</span></span><br><span class="line">            <span class="keyword">if</span> (request.body().isDuplex()) &#123;</span><br><span class="line">                exchange.flushRequest();</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                    exchange.createRequestBody(request, <span class="keyword">true</span>));</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BufferedSink bufferedRequestBody = Okio.buffer(</span><br><span class="line">                    exchange.createRequestBody(request, <span class="keyword">false</span>));</span><br><span class="line">                request.body().writeTo(bufferedRequestBody);</span><br><span class="line">                bufferedRequestBody.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      exchange.noRequestBody();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下面开始获取网络请求返回的响应</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过Exchange的readResponseHeaders(boolean)方法读取响应的header</span></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        responseBuilder = exchange.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取响应后，通过Builder模式构造Response</span></span><br><span class="line">    Response response = responseBuilder</span><br><span class="line">        .request(request)</span><br><span class="line">        .handshake(exchange.connection().handshake())</span><br><span class="line">        .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造Response的body</span></span><br><span class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">        <span class="comment">//构造一个空的body的Response</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .body(Util.EMPTY_RESPONSE)</span><br><span class="line">            .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//通过Exchange的openResponseBody(Response)方法读取响应的body，然后通过响应的body继续构造Response</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">            .body(exchange.openResponseBody(response))</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回响应Response</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在ConnectInterceptor中我们已经建立了连接，连接到了服务器，获取了输入输出流，所以CallServerInterceptor的intercept(Chain)方法逻辑就是把请求发送到服务器，然后获取服务器的响应，如下：</p>
<p>1、发送请求：</p>
<p>​    1.1、通过Exchange的writeRequestHeaders(request)方法写入请求的header；</p>
<p>​    1.2、如果请求的body不为空，通过okio写入请求的body。</p>
<p>2、获取响应：</p>
<p>​    2.1、通过Exchange的readResponseHeaders(boolean)方法读取响应的header；</p>
<p>​    2.2、通过Exchange的openResponseBody(Response)方法读取响应的body。</p>
<p>这个发送获取的过程通过Exchange进行，前面已经讲过它在ConnectInterceptor中创建，在process方法中传进来，所以这里可以通过Chain获取Exchange，Exchange它是负责从IO流中写入请求和读取响应，完成一次请求/响应的过程，它内部的读写都是通过一个ExchangeCodec类型的codec来进行，而ExchangeCodec内部又是通过Okio的BufferedSource和BufferedSink进行IO读写，这个过程在上一篇文章已经分析过了，这里不在累述。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>结合上一篇文章，我们对okhttp已经有了一个深入的了解，首先，我们会在请求的时候初始化一个Call的实例，然后执行它的execute()方法或enqueue()方法，内部最后都会执行到getResponseWithInterceptorChain()方法，这个方法里面通过拦截器组成的责任链，依次经过用户自定义普通拦截器、重试拦截器、桥接拦截器、缓存拦截器、连接拦截器和用户自定义网络拦截器和访问服务器拦截器等拦截处理过程，来获取到一个响应并交给用户。okhttp的请求流程、缓存机制和连接机制是当中的重点，在阅读源码的过程中也学习到很多东西，下一次就来分析它的搭档Retrofit。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最後更新時間：<time datetime="2023-01-07T10:44:48.945Z" itemprop="dateUpdated">2023-01-07 18:44:48</time>
</span><br>


        
        谢谢大家的阅读！
        
    </div>
    
    <footer>
        <a href="http://yoursite.com">
            <img src="/img/avatar.jpg" alt="rain9155">
            rain9155
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/okhttp/" rel="tag">okhttp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/&title=《okhttp3源码分析之拦截器》 — jianyu的博客&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/&title=《okhttp3源码分析之拦截器》 — jianyu的博客&source=前言
上一篇文章：okhttp3源码分析之请求流程

本篇文章继续通过源码来探讨okhttp的另外一个重要知识点：拦截器，在上一篇文章我们知道，在请求发送..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《okhttp3源码分析之拦截器》 — jianyu的博客&url=http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/09/07/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">责任链模式</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/09/03/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">okhttp3源码分析之请求流程</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢打赏!
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>本部落格係採用<a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/deed.zh_TW" target="_blank">創用 CC 姓名標示 4.0 國際 授權條款授權</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>rain9155 &copy; 2018 - 2023</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/&title=《okhttp3源码分析之拦截器》 — jianyu的博客&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/&title=《okhttp3源码分析之拦截器》 — jianyu的博客&source=前言
上一篇文章：okhttp3源码分析之请求流程

本篇文章继续通过源码来探讨okhttp的另外一个重要知识点：拦截器，在上一篇文章我们知道，在请求发送..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《okhttp3源码分析之拦截器》 — jianyu的博客&url=http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2019/09/07/okhttp3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAAD7ElEQVR42u3ayW4bQQwFQP//TzuXHAIkkt8jOYYDlE7CeJbuGgMUl4+P+PP59vPqzPfX5vdvn/LnkY8nPjhw4MCBY73V9w9Lvv/9xFd3Ttb26q/tK/nHc3HgwIEDxxFHsuj3y03umd95Fh/boIsDBw4cOH4Cx2f8mW0gwU02jAMHDhw4/heO/Mg+rCZr2P9QwIEDBw4cT3AkZbhkEW3psG1TtY2rB2ulOHDgwIEjza1W2/uZ3x+Z78CBAwcOHPG4wGZYbfP0/bWzIubvq3DgwIEDx5oj30ZO0w43tGE+fyXtvnDgwIEDx56jLQK242hJAXFTyGt/ChQNJxw4cODAccSxHztICov5EpMBuGLD78udOHDgwIHjiKMt+bXja5twuxlWyMlw4MCBA8cVR/Lg586ZjU3kaV4LhwMHDhw4bjny4tqmkNcSbEL+7GcBDhw4cODYcLRjam2LqKW8akcNByZw4MCBA8fp7Fm7gbbYdzUGERX4yvXjwIEDB44rjrZ4l5fqks1vyGYlwi+Kjzhw4MCBY82RDwS0Zb52KOHq/ASr+MWBAwcOHDhKjpbgiTA5C8BXad7LthMOHDhw4Fhz5CMFs8SvLQ7OXkCbsOHAgQMHjluOvHmTp2qze+Zh+Gq44YvzceDAgQPHgiNv6rQp2SZs56W9tuEU1Upx4MCBA8cRR9TyL6/Nm1Lty8ifWKwNBw4cOHAs1rYZMsuHD/b3z4N6G2g/9nEbBw4cOHDMaodxoXB//02ad7ZyHDhw4MBxufKoydQG2pwmT97aAL9HxIEDBw4c7zmSpk7eRmqD5azANyOIyoU4cODAgeOUow1ObYNqtqVZWTN5nVGWiQMHDhw4RhyzwlmyiKvj+bUrGhw4cODAsebIH9COQeRhNU8X21XNwjMOHDhw4LjiSJbbEiQluXYkYhNQi3QRBw4cOHCMONqmURvk2rJj+2LaZPKLveDAgQMHjiOOPMObLfG59GzWJCvmO3DgwIEDx4LjNhnLafap3TCs5vMdOHDgwIFjxJEvNzmSFxnzZ83SvyIM48CBAweOI46rYbh2Y20QnYX5IqXEgQMHDhxrjs22N42r2eBCHlBz3C8mO3DgwIEDR8kxa9vk5+RFwPesReso/y/IBxpw4MCBA0fMsU+i8pGFWdspfzF5MrlvceHAgQMHjrwatgmc+ZG6YLceaCjuhgMHDhw4jjieiNtXxbur9lWU/uHAgQMHjm/naEcKZqlXsuEcru7C4cCBAweOb+TIQ+CsXZSXJvP1F6MbOHDgwIHjiKNt8Dw3uJYXKPdp3qrthAMHDhw41gMNbaupHXdI6PNkrH2dOHDgwIFjzfELHvTO4V/X1iYAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>








<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '去哪里了?';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎光临!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
