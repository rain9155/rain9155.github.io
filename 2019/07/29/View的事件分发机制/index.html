<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>View的事件分发机制 | jianyu的博客 | 每天进步一点点</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#009688">
    
    
    <meta name="keywords" content="源码,view">
    <meta name="description" content="前言前几天写过一篇文章View的工作原理，讲述的View工作的三大流程，其实与View的工作流程同样重要还有View的事件分发机制，平时我们经常通过setOnClickListener()方法来设置一个View的点击监听，那你有没有想过这个点击事件底层是怎么样传递到这个View的呢？当你自定义控件时，如果要处理滑动事件，那么到底返回true还是false？还有当你遇到了滑动嵌套的情景，你要怎么解决">
<meta property="og:type" content="article">
<meta property="og:title" content="View的事件分发机制">
<meta property="og:url" content="http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="jianyu的博客">
<meta property="og:description" content="前言前几天写过一篇文章View的工作原理，讲述的View工作的三大流程，其实与View的工作流程同样重要还有View的事件分发机制，平时我们经常通过setOnClickListener()方法来设置一个View的点击监听，那你有没有想过这个点击事件底层是怎么样传递到这个View的呢？当你自定义控件时，如果要处理滑动事件，那么到底返回true还是false？还有当你遇到了滑动嵌套的情景，你要怎么解决">
<meta property="og:image" content="http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/view1.png">
<meta property="og:image" content="http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/view2.png">
<meta property="og:image" content="http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/view3.png">
<meta property="og:image" content="http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/view4.png">
<meta property="og:image" content="http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/view5.png">
<meta property="article:published_time" content="2019-07-29T15:14:42.000Z">
<meta property="article:modified_time" content="2023-01-07T10:44:48.810Z">
<meta property="article:author" content="rain9155">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="view">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/view1.png">
    
        <link rel="alternate" type="application/atom+xml" title="jianyu的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">rain9155</h5>
          <a href="mailto:jianyu9155@gmail.com" title="jianyu9155@gmail.com" class="mail">jianyu9155@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/rain9155" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://juejin.im/user/5b437173e51d45191d79c27a/posts" target="_blank" >
                <i class="icon icon-lg icon-gg"></i>
                Juejin
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://blog.csdn.net/Rain_9155" target="_blank" >
                <i class="icon icon-lg icon-eye"></i>
                CSDN
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.jianshu.com/u/93cb7ffd83e9" target="_blank" >
                <i class="icon icon-lg icon-book"></i>
                Jianshu
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/links"  >
                <i class="icon icon-lg icon-link"></i>
                Links
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">View的事件分发机制</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="検索">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">View的事件分发机制</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-07-29T15:14:42.000Z" itemprop="datePublished" class="page-time">
  2019-07-29
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/View%E6%9C%BA%E5%88%B6/">View机制</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#准备知识"><span class="post-toc-text">准备知识</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、什么是触摸事件"><span class="post-toc-text">1、什么是触摸事件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2、什么是MotionEvent"><span class="post-toc-text">2、什么是MotionEvent</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3、一个事件序列"><span class="post-toc-text">3、一个事件序列</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4、事件分发的起点，事件从何而来"><span class="post-toc-text">4、事件分发的起点，事件从何而来</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#View的事件分发"><span class="post-toc-text">View的事件分发</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、View-dispatchTouchEvent"><span class="post-toc-text">1、View::dispatchTouchEvent()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2、View-onTouchEvent"><span class="post-toc-text">2、View::onTouchEvent()</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1、case-ACTION-DOWN"><span class="post-toc-text">2.1、case ACTION_DOWN:</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2、case-ACTION-UP"><span class="post-toc-text">2.2、case ACTION_UP:</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3、小结"><span class="post-toc-text">3、小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ViewGroup的事件分发"><span class="post-toc-text">ViewGroup的事件分发</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、ViewGroup-dispatchTouchEvent"><span class="post-toc-text">1、ViewGroup::dispatchTouchEvent()</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2、ViewGroup处理ACTION-DOWN事件的流程"><span class="post-toc-text">2、ViewGroup处理ACTION_DOWN事件的流程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1、intercepted-false"><span class="post-toc-text">2.1、intercepted &#x3D; false</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2、intercepted-true"><span class="post-toc-text">2.2、intercepted &#x3D; true</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3、ViewGroup处理除了ACTION-DOWN以外的事件的流程"><span class="post-toc-text">3、ViewGroup处理除了ACTION_DOWN以外的事件的流程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-1、mFirstTouchTarget-null"><span class="post-toc-text">3.1、mFirstTouchTarget &#x3D;&#x3D; null</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#3-2、mFirstTouchTarget-null"><span class="post-toc-text">3.2、mFirstTouchTarget !&#x3D; null</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4、子View如何禁止ViewGroup拦截事件"><span class="post-toc-text">4、子View如何禁止ViewGroup拦截事件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5、小结"><span class="post-toc-text">5、小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结语"><span class="post-toc-text">结语</span></a></li></ol>
        </nav>
    </aside>


<article id="post-View的事件分发机制"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">View的事件分发机制</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-07-29 23:14:42" datetime="2019-07-29T15:14:42.000Z"  itemprop="datePublished">2019-07-29</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/View%E6%9C%BA%E5%88%B6/">View机制</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天写过一篇文章<a href="https://rain9155.github.io/2019/07/22/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">View的工作原理</a>，讲述的View工作的三大流程，其实与View的工作流程同样重要还有View的事件分发机制，平时我们经常通过setOnClickListener()方法来设置一个View的点击监听，那你有没有想过这个点击事件底层是怎么样传递到这个View的呢？当你自定义控件时，如果要处理滑动事件，那么到底返回true还是false？还有当你遇到了滑动嵌套的情景，你要怎么解决滑动嵌套引起的冲突？所以，本文通过 源码 + 流程图 来深入了解一个事件分发机制，当你掌握了它之后，当你遇到与滑动相关的问题时就更加的游刃有余。</p>
<a id="more"></a>

<blockquote>
<p>本文源码基于Android8.0</p>
</blockquote>
<h2 id="准备知识"><a href="#准备知识" class="headerlink" title="准备知识"></a>准备知识</h2><h3 id="1、什么是触摸事件"><a href="#1、什么是触摸事件" class="headerlink" title="1、什么是触摸事件"></a>1、什么是触摸事件</h3><p>触摸事件事件就是当你的手触摸到手机屏幕时所产生的最小单元事件，所谓最小单元，就是不可再拆分的，它一般有4种类型：<strong>按下（down)、移动（move）、抬起（up）、取消(cancel)</strong>。然后由若干个不可再拆分的最小单元事件就组成了<strong>点击事件、长按事件、滑动事件</strong>等。</p>
<h3 id="2、什么是MotionEvent"><a href="#2、什么是MotionEvent" class="headerlink" title="2、什么是MotionEvent"></a>2、什么是MotionEvent</h3><p>MotionEvent就是Android对上面触摸事件相关信息的封装，View的事件分发中的<strong>事件</strong>就是这个MotionEvent，当这个MotionEvent产生后，那么系统就会将这个MotionEvent传递给View的层级，MotionEvent在View的层级传递的过程就是事件分发。MotionEvent封装了事件类型和坐标两类信息。</p>
<p>事件类型可以通过 <strong>motionEvent.getAction()</strong> 方法获得，它返回一个常量，对应着一个事件类型，事件类型主要有以下4种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MotionEvent.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MotionEvent</span> <span class="keyword">extends</span> <span class="title">InputEvent</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//按下（down)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_DOWN             = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//抬起（up）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_UP               = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//移动（move）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_MOVE             = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//取消(cancel)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ACTION_CANCEL           = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//还有很多就不一 一列举</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>坐标信息也是通过MotionEvent获取，<strong>motionEvent.getRawX()、motionEvent.getRawY()</strong> 可以获得以屏幕作为参考系的坐标值，<strong>motionEvent.getX()、motionEvent.getY()</strong> 可以获得以被触摸的 View 作为参考系的坐标值。参考下面的视图坐标：</p>
<img src="/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/view1.png" class="" title="view1">

<p>蓝色点想象成手指触摸屏幕的位置。</p>
<h3 id="3、一个事件序列"><a href="#3、一个事件序列" class="headerlink" title="3、一个事件序列"></a>3、一个事件序列</h3><p>从手指按下屏幕到抬起，在这个过程中所产生的一系列事件，就是一个事件序列，这个事件序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。所以可能会有下面两种事件序列：</p>
<ul>
<li>ACTION_DOWN -&gt; ACTION_UP：手指按下屏幕后又抬起</li>
<li>ACTION_DOWN -&gt; ACTION_MOVE -&gt; … -&gt; ACTION_MOVE -&gt; ACTION_UP：手指按下屏幕，滑动一会，然后抬起</li>
</ul>
<p>在分析事件分发的过程时，会有事件序列这个概念。</p>
<h3 id="4、事件分发的起点，事件从何而来"><a href="#4、事件分发的起点，事件从何而来" class="headerlink" title="4、事件分发的起点，事件从何而来"></a>4、事件分发的起点，事件从何而来</h3><p>我想大家都知道View的事件分发机制的起点是View的dispatchTouchEvent()方法，但是如果从View的dispatchTouchEvent()继续追溯上去，事件是从哪里来的呢？</p>
<p>Android的输入设备有很多种，如屏幕、键盘、鼠标、轨迹球等，而屏幕是我们接触最多的设备，当用户手指触摸屏幕时就会产生触摸事件，这时Android的输入系统就会为这个触摸事件在/dev/input/路径下写入以event[NUMBER]为名的输入设备节点，这时输入系统中的EventHub就会监听到这个输入事件，然后InputReader就会把这个原始输入事件读取并经过加工后交给输入系统中的InputDispatcher，InputDispatcher会在mWindowHandles列表（mWindowHandles列表在IMS中代表所有窗口）中会找到合适的WindowHandle(InputWindowHandle类型)，然后把输入事件经过WindowHandle中的InputChannel通过Socket发送给应用进程所在的ViewRootImp中的InputChannel，这时ViewRootImp会把接收到的事件通过内部类InputEventReceiver分发给ViewRootImp持有的顶级View，然后顶级View的dispatchTouchEvent方法就会回调，在该方法中会获取Window.Callback(Activity或Dialog等实现了这个接口)，然后把事件分发给Callback，这时Callback的dispatchTouchEvent方法回调，不同的实现类由不同的实现，在Activity的实现中，它会把事件交给PhoneWindow来分发，然后PhoneWindow又会把这个事件分发给顶级View，<strong>然后顶级View就调用super.dispatchTouchEvent方法，把这个输入事件在View树中层层分发下去，直到找到合适的View来处理这个事件，这来到了我们熟悉的View的事件分发机制</strong>。</p>
<p>这个事件传输的大概过程：<strong>IMS -&gt;  ViewRootImp -&gt; 顶级View -&gt; 实现Window.Callback的类 -&gt; Window -&gt; 顶级View</strong>。（更多细节可以查看<a href="https://www.jianshu.com/p/b7cef3b3e703" target="_blank" rel="noopener">原来Android触控机制竟是这样的？</a>）</p>
<p>上面的一些名词如EventHub、InputReader、InputReader都是属于Android的输入系统，这部分是一个很复杂的知识，我只是概括了一下，所以我们只要知道，<strong>输入系统监听到输入事件后，就会先交给Window，然后Window再交给顶级View，然后顶级View在把它分发下去</strong>。(关于Window和View的关系可以看这篇文章<a href="https://rain9155.github.io/2019/03/22/Window,%20WindowManager%E5%92%8CWindowManagerService%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/" target="_blank" rel="noopener">Window, WindowManager和WindowManagerService之间的关系</a>)</p>
<p>这个顶级View可能是View，也有可能是ViewGroup，具体情况看你添加Window到WMS时你的addView(View view, ViewGroup.LayoutParams params)方法中的View是View实例还是ViewGroup实例，所以本文接下来就分别分析View的事件分发和ViewGroup的事件分发。</p>
<h2 id="View的事件分发"><a href="#View的事件分发" class="headerlink" title="View的事件分发"></a>View的事件分发</h2><h3 id="1、View-dispatchTouchEvent"><a href="#1、View-dispatchTouchEvent" class="headerlink" title="1、View::dispatchTouchEvent()"></a>1、View::dispatchTouchEvent()</h3><p>View的事件分发比ViewGroup的简单，因为它只是一个单独的元素，所以它只需要处理自己的事件，View的事件分发从View的dispatchTouchEvent()方法开始，所以我们看它的dispatchTouchEvent方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//result默认为false</span></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">     ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        li != <span class="keyword">null</span><span class="comment">//如果ListenerInfo不为空</span></span><br><span class="line">        &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span><span class="comment">//如果触摸事件的监听不为空</span></span><br><span class="line">        &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED<span class="comment">//如果该控件是ENABLED状态</span></span><br><span class="line">        &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)<span class="comment">//如果onTouch方法返回了true</span></span><br><span class="line">    )&#123;</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        !result<span class="comment">//如果上面四个条件都不满足，result默认为false</span></span><br><span class="line">        &amp;&amp; onTouchEvent(event)<span class="comment">//如果onTouchEvent()方法返回了true</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerInfo</span> </span>&#123;</span><br><span class="line">     <span class="keyword">public</span> OnClickListener mOnClickListener;<span class="comment">//点击事件的监听</span></span><br><span class="line">     <span class="keyword">protected</span> OnLongClickListener mOnLongClickListener;<span class="comment">//长按事件的监听</span></span><br><span class="line">     <span class="keyword">private</span> OnTouchListener mOnTouchListener;<span class="comment">//触摸事件的监听</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从View的dispatchTouchEvent()方法的伪代码可以看出，dispatchTouchEvent()方法首先会根据4个条件来决定是否调用View的onTouchEvent方法，如下：</p>
<ul>
<li><p>1、如果ListenerInfo不为空：ListenerInfo里面有View的各种监听，那么mListenerInfo是什么时候被赋值的呢？答案是给View设置监听的时候，在我们给View设置任何监听的时候，如果这个mListenerInfo还没初始化就会先初始化，比如设置触摸事件的监听，我们看setOnTouchListener()方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnTouchListener</span><span class="params">(OnTouchListener l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先调用getListenerInfo方法初始化mListenerInfo，然后把触摸事件的监听赋值给mOnTouchListener</span></span><br><span class="line">    getListenerInfo().mOnTouchListener = l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function">ListenerInfo <span class="title">getListenerInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (mListenerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> mListenerInfo;</span><br><span class="line">      &#125;</span><br><span class="line">      mListenerInfo = <span class="keyword">new</span> ListenerInfo();</span><br><span class="line">      <span class="keyword">return</span> mListenerInfo;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、如果触摸事件的监听不为空：即ListenerInfo的mOnTouchListener不为空，从1可以看出，当你给View设置OnTouchListener时，就已经满足了1、2条件了。</p>
</li>
<li><p>3、如果该控件是ENABLED状态：即该Vew处于enable状态，如果你没有手动调用过View的setEnable(false)设置控件为不可用的话，这个条件就为true，控件默认为enable状态。</p>
</li>
<li><p>4、如果onTouch方法返回了true：当你给View设置OnTouchListener，并且在onTouch方法中返回了true，表示消费了这次事件，那么这个条件就为true。所以到这里，如果4个条件都满足的话，result就会等于true，就会导致下面无法调用View的onTouchEvent()方法。</p>
</li>
</ul>
<p>但是如果你<strong>没有给你给View设置OnTouchListener或者你给View设置了OnTouchListener，但是onTouch方法返回了false</strong>，只要满足这两个条件之一，就会让result保持默认值false，从而满足下面的条件调用View的onTouchEvent()方法。这里得出一个结论：<strong>OnTouchListener的onTouch方法的优先级高于onTouchEvent()方法</strong>。</p>
<p>假设现在不满足上面4个条件，从而调用View的onTouchEvent()方法，我们来看View的onTouchEvent()方法。</p>
<h3 id="2、View-onTouchEvent"><a href="#2、View-onTouchEvent" class="headerlink" title="2、View::onTouchEvent()"></a>2、View::onTouchEvent()</h3><p>onTouchEvent()方法里面会处理View点击事件、长按事件，即回调你设置的OnClickListener的onClick()方法和OnLongClickListener的OnLongClick()方法，在你设置OnClickListener或OnLongClickListener回调时会同时把你的View设置为可点击状态即clickable状态，有些控件默认可点击如Button，而有些控件需要设置点击回调或setClickable(true)才可以点击如TextView。</p>
<p>接下来我们看View的onTouchEvent()方法的主要源码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> y = event.getY();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">	<span class="comment">//该View是否可点击，可以看到这里点击包含3种点击：CLICKABLE、LONG_CLICKABLE和CONTEXT_CLICKABLE(回调OnContextClickListener)</span></span><br><span class="line">    <span class="comment">//这里我们关注CLICKABLE和LONG_CLICKABLE就行，即点击和长按</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">        || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">        || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line">    <span class="comment">//1、如果View处于disabled状态，即不可用状态</span></span><br><span class="line">    <span class="keyword">if</span> ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span>) &#123;</span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">        <span class="comment">//这里说明了即使View处于不可用状态，但是如果它可以点击，它还是会消费点击事件</span></span><br><span class="line">        <span class="keyword">return</span> clickable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2、如果View设置有代理机制，那么就会执行TouchDelegate的onTouchEvent()方法</span></span><br><span class="line">    <span class="keyword">if</span> (mTouchDelegate != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3、下面是onTouchEvent()对点击事件和长按事件的处理</span></span><br><span class="line">    <span class="comment">//如果控件可以点击</span></span><br><span class="line">    <span class="keyword">if</span> (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL:</span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">               <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从这里看出，如果我们的View是可以点击的，最终一定返回true，表示消费了此事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4、最终虽然控件可用，但是不可点击，返回false，不消费此事件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个onTouchEvent()方法有点长，这里我截取了整体框架，这里我们先明确一点的是onTochEvent()中返回true就表示这个事件由这个View消费，返回false就表示这个View不消费这个事件然后它的父容器会继续找合适的View消费。首先我们看注释1，它说明了即使View处于不可用状态，但是如果它可以点击即clickable = true，它会返回true，表明不可用状态下的View它还是会消费事件，即使这个View会没有响应，反之返回false；接着注释2，如果设置了mTouchDelegate，则会将事件交给代理者处理，直接return true，如果大家希望自己的View增加它的touch范围，可以尝试使用TouchDelegate；接着注释3，如果控件可以点击，就判断事件类型：ACTION_UP、ACTION_DOWN、ACTION_CANCEL、ACTION_MOVE，然后根据不同的事件类型做出不同的行为，然后都返回了true，表示消费了此事件；最后注释4如果控件不可点击，就返回false，不消费此事件。</p>
<p>接下来我们重点看注释3，看onTouchEvent()是如何在ACTION_UP、ACTION_DOWN、ACTION_CANCEL、ACTION_MOVE中触发onClick()和onLingClick()回调的。</p>
<h4 id="2-1、case-ACTION-DOWN"><a href="#2-1、case-ACTION-DOWN" class="headerlink" title="2.1、case ACTION_DOWN:"></a>2.1、case ACTION_DOWN:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">      <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="comment">//1、设置mHasPerformedLongPress为false</span></span><br><span class="line">          mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="comment">//2、给mPrivateFlags设置一个PREPRESSED标识</span></span><br><span class="line">           mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">          <span class="comment">//3、通过postDelayed发送一个延时100毫秒后执行的任务mPendingCheckForTap</span></span><br><span class="line">          postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>

<p>我们想象一下，我们的手指按下这个View，这时进入ACTION_DOWN分支，在这个分支里，在注释1中它首先设置mHasPerformedLongPress为false，表示长按事件还没有触发，然后在注释2给mPrivateFlags设置一个PREPRESSED的标识，表示开始检查长按事件，然后在注释3通过postDelayed发送了一个延时消息，ViewConfiguration.getTapTimeout()返回100毫秒，即100毫秒后会执行任务mPendingCheckForTap，它一个CheckForTap类型任务，它是用来<strong>检测长按事件</strong>的。我们看这个任务是什么，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java </span></span><br><span class="line"><span class="comment">//用来检测长按事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckForTap</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">float</span> x;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">float</span> y;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//1、mPrivateFlags清除PFLAG_PREPRESSED标识</span></span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_PREPRESSED;</span><br><span class="line">            <span class="comment">//2、见下面调用链，这里传入true，即给mPrivateFlags设置一个PFLAG_PRESSED标识</span></span><br><span class="line">            setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">            <span class="comment">//3、调用checkForLongClick()方法，传入100毫秒</span></span><br><span class="line">            checkForLongClick(ViewConfiguration.getTapTimeout(), x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPressed</span><span class="params">(<span class="keyword">boolean</span> pressed, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//主要调用了带一个参数的setPressed(pressed)方法</span></span><br><span class="line">        setPressed(pressed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置控件是否处于按下状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPressed</span><span class="params">(<span class="keyword">boolean</span> pressed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (pressed) &#123;<span class="comment">//如果pressed为true</span></span><br><span class="line">        <span class="comment">//给mPrivateFlags设置一个PFLAG_PRESSED标识</span></span><br><span class="line">        mPrivateFlags |= PFLAG_PRESSED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果pressed为false</span></span><br><span class="line">        <span class="comment">//清除mPrivateFlags之前设置的PFLAG_PRESSED标识</span></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_PRESSED;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mPendingCheckForTap的run方法里面在注释1首先会先清除mPrivateFlags中PFLAG_PREPRESSED标识，然后在注释2设置PFLAG_PRESSED标识，表示准备执行长按事件，最主要的是注释3，我们看checkForLongClick方法里面干了什么，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForLongClick</span><span class="params">(<span class="keyword">int</span> delayOffset, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1、检查mViewFlags，如果可以进行长按事件LONG_CLICKABLE</span></span><br><span class="line">    <span class="keyword">if</span> ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE || (mViewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">        <span class="comment">//此时mHasPerformedLongPress标志位还是false</span></span><br><span class="line">        mHasPerformedLongPress = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mPendingCheckForLongPress == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2、创建了一个CheckForLongPress类型的任务</span></span><br><span class="line">            mPendingCheckForLongPress = <span class="keyword">new</span> CheckForLongPress();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//3、ViewConfiguration.getLongPressTimeout()返回500毫秒，再减100毫秒等于400毫秒</span></span><br><span class="line">        <span class="comment">//通过postDelayed()发送延时400毫秒后执行的任务mPendingCheckForLongPress</span></span><br><span class="line">        postDelayed(mPendingCheckForLongPress,</span><br><span class="line">                    ViewConfiguration.getLongPressTimeout() - delayOffset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法在注释1首先检测该View是否可以进行长按事件，View的LONG_CLICKABLE属性默认为false，但是在setOnLongClickListener（）时就会把它设置为true，然后在注释2创建了一个CheckForLongPress类型的任务，然后在注释3通过postDelayed()发送了一个延时消息，即400毫秒后执行mPendingCheckForLongPress任务，它是用来<strong>执行长按事件</strong>的，我们看这个任务的具体实现，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="comment">//用来执行长按事件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckForLongPress</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> mX;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> mY;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((mOriginalPressedState == isPressed())<span class="comment">//1、首先检查mPrivateFlags中是否清除了PFLAG_PRESSED标识，如果清除了表示长按事件取消</span></span><br><span class="line">                &amp;&amp; (mParent != <span class="keyword">null</span>)</span><br><span class="line">                &amp;&amp; mOriginalWindowAttachCount == mWindowAttachCount) &#123;</span><br><span class="line">                <span class="comment">//2、调用performLongClick()方法</span></span><br><span class="line">                <span class="keyword">if</span> (performLongClick(mX, mY)) &#123;</span><br><span class="line">                    <span class="comment">//3、设置mHasPerformedLongPress为true</span></span><br><span class="line">                    mHasPerformedLongPress = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (performLongClick(mX, mY)) &#123;</span><br><span class="line">                mHasPerformedLongPress = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回true表示检测mPrivateFlags中清除了PFLAG_PRESSED标识，false反之</span></span><br><span class="line">    <span class="keyword">return</span> (mPrivateFlags &amp; PFLAG_PRESSED) == PFLAG_PRESSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CheckForLongPress就是用于执行长按事件的，它的run方法里面会先检查mPrivateFlags中是否清除了PFLAG_PRESSED标识，如果清除了就表示长按事件取消，否则就调用performLongClick()方法，里面会最终回调onLongClick()方法回调，如果performLongClick()返回true，就会设置mHasPerformedLongPress为true，否则mHasPerformedLongPress还是为false，即<strong>mHasPerformedLongPress是否为true取决performLongClick(float x, float y)是否返回true</strong>，接下来我们看performLongClick(float x, float y)方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performLongClick</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> handled = performLongClick();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performLongClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> performLongClickInternal(mLongClickX, mLongClickY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performLongClickInternal</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="comment">//如果设置了OnLongClickListener回调</span></span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLongClickListener != <span class="keyword">null</span>) &#123;       </span><br><span class="line">        <span class="comment">//回调OnLongClickListener的onLongClick方法</span></span><br><span class="line">        handled = li.mOnLongClickListener.onLongClick(View.<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个方法中一路跟进，最终来到了performLongClickInternal(float x, float y)方法中，在performLongClickInternal()方法中，如果我们通过setOnLongClickListener()设置了OnLongClickListener回调，这里就会回调我们熟悉的onLongClick()方法，而performLongClickInternal()是否返回true取决于我们在onLongClick()方法中是否返回true，performLongClick()是否返回true取决于performLongClickInternal()是否返回true，然后这里结合上面的黑体字得出一个结论：<strong>如果你设置了onLongClickListener，mHasPerformedLongPress是否为true取决我们在onLongClick()方法中是否返回true，如果没有设置，mHasPerformedLongPress就一直为false</strong>，这个mHasPerformedLongPress是否为true会影响我们在ACTION_UP是否能够回调onClick()方法的关键。</p>
<p>现在我们通过case ACTION_DOWN知道：<strong>如果我们按下手指在500毫秒内没有抬起，就会触发长按事件</strong>。下面分析ACTION_UP。</p>
<h4 id="2-2、case-ACTION-UP"><a href="#2-2、case-ACTION-UP" class="headerlink" title="2.2、case ACTION_UP:"></a>2.2、case ACTION_UP:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (action) &#123;</span><br><span class="line">    <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">boolean</span> prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//1、如果mPrivateFlags中包含PFLAG_PRESSED或PFLAG_PREPRESSED标识，都会进入if分支</span></span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_PRESSED) != <span class="number">0</span> || prepressed) &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (prepressed) &#123;<span class="comment">//如果mPrivateFlags中只包含PFLAG_PREPRESSED标识，表示用户在100毫秒内抬起了手指，还没执行CheckForTap任务</span></span><br><span class="line">                <span class="comment">//2、这里传入为true，即给mPrivateFlags设置一个PFLAG_PRESSED标识</span></span><br><span class="line">                <span class="comment">//这里主要让用户看到控件还是按下状态</span></span><br><span class="line">                setPressed(<span class="keyword">true</span>, x, y);</span><br><span class="line">            &#125;</span><br><span class="line">		   <span class="comment">//3、这个mHasPerformedLongPress为false就进入if分支，mIgnoreNextUpEvent默认为false</span></span><br><span class="line">            <span class="keyword">if</span> (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                <span class="comment">//4、移除长按事件CheckForLongPress任务消息，即取消长按事件</span></span><br><span class="line">                removeLongPressCallback();</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">if</span> (mPerformClick == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//5、如果mPerformClick为null，初始化一个实例</span></span><br><span class="line">                    mPerformClick = <span class="keyword">new</span> PerformClick();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//6、通过Handler把mPerformClick添加到消息队列，但其实PerformClick中的run方法还是执行performClick()方法，所以我们只要看performClick()方法就行</span></span><br><span class="line">                <span class="keyword">if</span> (!post(mPerformClick)) &#123;</span><br><span class="line">                    <span class="comment">//如果post一个PerformClick失败就执行performClick()方法</span></span><br><span class="line">                    performClick();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//7、移除检测长按事件CheckForTap任务消息，即取消检测长按事件</span></span><br><span class="line">            removeTapCallback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="comment">//PerformClick中的run方法还是执行performClick()方法</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PerformClick</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         performClick();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>我们想象一下，现在我们抬起了手指，分三个时间段抬起：</p>
<ul>
<li><p>1、如果你在<strong>100毫秒内</strong>抬起手指，那么mPrivateFlags肯定只有PFLAG_PREPRESSED标识，且mHasPerformedLongPress为false，根据注释1和3，这样就会执行PerformClick()方法，在执行PerformClick()方法前，在注释4调用removeLongPressCallback()移除长按事件CheckForLongPress任务，即不会触发onLongClick()回调。</p>
</li>
<li><p>2、如果你在<strong>100毫秒后到500毫秒</strong>才抬起，那么mPrivateFlags肯定只有PFLAG_PRESSED标识，且mHasPerformedLongPress为false，接下来的逻辑和1一样。</p>
</li>
<li><p>3、如果你在<strong>500毫秒后</strong>才抬起，那么mPrivateFlags肯定只有PFLAG_PRESSED标识，而mHasPerformedLongPress是否为true取决我们是否设置onLongClickListener并在onLongClick()方法中是否返回true。如果你设置了onLongClickListener回调并在onLongClick()方法中返回了false或者你没有设置onLongClickListener回调，那么你还是可以走到注释6执行performClick()方法；但是如果你设置了onLongClickListener回调并在onLongClick()方法中返回了true，那么你就不能执行performClick()方法了。</p>
</li>
</ul>
<p>对照ACTION_DOWN的流程和ACTION_UP的流程就能更好的理解上面3个时间段，所以从这里我们知道：<strong>如果你在500毫秒内抬起手指，那么你就只能执行点击事件，不能执行长按事件；如果你在500毫秒后抬起，并且你设置了onLongClickListener并在onLongClick()方法中返回了false 或者 你没有设置onLongClickListener回调，那么你执行完长按事件后还可以执行点击事件，但是如果你设置了onLongClickListener回调并在onLongClick()方法中返回了true，那么你就不能执行点击事件</strong>。performClick()和 performLongClick()方法类似，它里面最终回调onClick()方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> result;</span><br><span class="line">     <span class="keyword">final</span> ListenerInfo li = mListenerInfo;</span><br><span class="line">     <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">//1、执行了OnClickListener的onClick()方法</span></span><br><span class="line">         li.mOnClickListener.onClick(<span class="keyword">this</span>);</span><br><span class="line">         result = <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         result = <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>performClick()方法中的逻辑是，如果你设置了OnClickListener回调，那么就会执行onClick(）方法，大家也注意到performClick()会返回一个true或者false，但是这个返回值对于onTouchEvent()方法没有任何意义，因为上面提到switch语句块的后面一定返回true。这里我们再得出一个结论：<strong>OnLongClickListener的onLongClick()方法的优先级高于onClickListener的onClick()方法</strong>。</p>
<p>好了现在我们的手指从按下到抬起，就已经分析完onTouchEvent()中的ACTION_DOWN和ACTION_UP分支，如果你的手指在抬起前，不小心移动了一下，就会触发ACTION_CANCEL或ACTION_MOVE，这个时候它就会根据条件(手指是否移出View的范围)通过调用 removeLongPressCallback()或 removeTapCallback()方法移除CheckForLongPress或CheckForTap任务，即取消长按或点击，这里限于篇幅就不再展开分析，大家可自行分析。</p>
<h3 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h3><p>1、View没有子View，所以它的的分发比较简单，从View的dispatchTouchEvent()方法开始进入View的事件分发流程，该方法只负责事件的分发，没有进行实际事件的处理，进行实际事件的处理有两处地方：1、通过外部设置的onTouchListener的onTouch()方法，2、View的onTouchEvent()方法。</p>
<p>2、当一个View要处理点击事件时，如果它设置了onTouchListener，那么onTouch方法就会回调，这时事件如何处理还要看onTouch()方法的返回值，如果返回true，那么onTouchEvent()方法将不会被调用，dispatchTouchEvent()方法直接返回true；如果返回false，onTouchEvent()方法会被调用，这时事件如何处理就要看onTouchEvent()的返回值，在onTouchEvent()中，不管控件可用还是不可用，返回值取决于控件是否可点击，如果控件可点击(clickabale或longClickabale，只要有一个为true)，onTouchEvent()返回true，如果控件不可点击(clickabale和longClickabale都为false)，onTouchEvent()返回false。</p>
<p>3、如果我们同时设置了OnTouchListener、OnLongClickListener和OnClickListener回调，根据优先级，事件的传递顺序是：<strong>onTouch() -&gt; onLongClick() -&gt; onClick()</strong>，其中除了onClick()都有boolean返回值，返回值能决定下一个方法是否被调用，onClick()优先级最低，连返回值都没有。</p>
<p>4、 对于ViewGroup（也就是当前 View 的父容器）而言，它只认识子 View的dispatchTouchEvent()方法，不认识另外两个处理事件的方法。子View的 onTouch()  和 onTouchEvent() 都是在自己的 dispatchTouchEvent() 里面调用的，他们两个会影响 dispatchTouchEvent() 的返回值，但是对于上级 ViewGroup 而言，它只认识 dispatchTouchEvent() 的返回值。</p>
<p>流程图：</p>
<img src="/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/view2.png" class="" title="view2">

<h2 id="ViewGroup的事件分发"><a href="#ViewGroup的事件分发" class="headerlink" title="ViewGroup的事件分发"></a>ViewGroup的事件分发</h2><h3 id="1、ViewGroup-dispatchTouchEvent"><a href="#1、ViewGroup-dispatchTouchEvent" class="headerlink" title="1、ViewGroup::dispatchTouchEvent()"></a>1、ViewGroup::dispatchTouchEvent()</h3><p>ViewGroup是View的子类，它是一组View的集合，它包含很多子View和子ViewGroup，所以ViewGroup的事件分发比View的复杂，但是ViewGroup的事件分发才是整个事件分发机制的精髓，和View一样ViewGroup的事件分发的起点也是dispatchTouchEvent()，虽然这个方法在View中，但是ViewGroup重写了它，因为它们的分发逻辑不一样。所以我们看ViewGroup的dispatchTouchEvent()方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//本次事件处理结果</span></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line">        <span class="comment">//1、如果本次事件是ACTION_DOWN</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">//置空mFirstTouchTarget，mFirstTouchTarget是TouchTarget类型，是一个单链表结构</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            <span class="comment">//清除mGroupFlags中的FLAG_DISALLOW_INTERCEPT标志位，这个标志等同于下面的disallowIntercept</span></span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ViewGroup是否拦截本次事件标志</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line">        <span class="comment">//2、如果本次事件是ACTION_DOWN 或者 mFirstTouchTarget为空</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">            || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//子View是否禁止ViewGroup拦截事件标志</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!disallowIntercept) &#123;<span class="comment">//如果子View允许ViewGroup拦截事件</span></span><br><span class="line">                <span class="comment">//调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent(ev)决定</span></span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果子View禁止ViewGroup拦截事件</span></span><br><span class="line">                intercepted = <span class="keyword">false</span>;<span class="comment">//intercepted值为false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果本次事件不是ACTION_DOWN又没有target</span></span><br><span class="line">            <span class="comment">//intercepted值为true，在此之后，当前事件序列中的所有事件序列都由ViewGroup处理，不会再传递给子View</span></span><br><span class="line">            intercepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//检查本次事件是否是ACTION_CANCEL</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>) || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line">        <span class="comment">//split默认为true</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//newTouchTarget用于记录本次事件的target</span></span><br><span class="line">        TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//表示事件是否已经分发给target对应的子View，默认为false</span></span><br><span class="line">        <span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//3、如果本次事件不取消并且不拦截，就寻找合适的子View处理</span></span><br><span class="line">        <span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">            <span class="comment">//取出按下手指的index</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">            <span class="comment">//getPointerId表示根据index取出按下手指的id，第一根手指为0，第二根手指为1，以此类推</span></span><br><span class="line">    	   <span class="comment">//idBitsToAssign与多点触控相关，本文不重点讨论</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">//如果本次事件是ACTION_DOWN 或 ACTION_POINTER_DOWN 或ACTION_HOVER_MOVE</span></span><br><span class="line">            <span class="comment">//本文重点关注ACTION_DOWN事件，ACTION_POINTER_DOWN与多点触控相关</span></span><br><span class="line">            <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE</span><br><span class="line">               ) &#123;</span><br><span class="line">			  <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">                <span class="comment">//如果target是null并且ViewGroup有子View，就寻找某个子View当target</span></span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">                    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">                    <span class="comment">//从后往前逐个取出子View</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">                        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">                        <span class="comment">//判断子View能否接受点击事件：子View可见或在播放动画，并且触摸点在子View范围内</span></span><br><span class="line">                        <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                            || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">					  <span class="comment">//走到这里表示子View满足处理事件的条件</span></span><br><span class="line">                        <span class="comment">//...</span></span><br><span class="line">                        <span class="comment">//dispatchTransformedTouchEvent()里面会调用子View的dispatchTouchEvent()方法，在这个方法里把事件分发给子View</span></span><br><span class="line">                         <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                             <span class="comment">//...</span></span><br><span class="line">                             <span class="comment">//如果dispatchTransformedTouchEvent()返回true，表示找到子View消费本次事件了，就会走到这里, 所以这个子View就被当作target，这里会调用addTouchTarget()方法为这个子View创建一个TouchTarget，并把这个target插入mFirstTouchTarget链表的表头，并把表头返回赋值给newTouchTarget</span></span><br><span class="line">                             newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                             <span class="comment">//alreadyDispatchedToNewTouchTarget赋值为true，表示事件已经分发给target对应的子View</span></span><br><span class="line">                             alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                             <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">						<span class="comment">//...</span></span><br><span class="line">                    &#125;<span class="comment">//end...for（）</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                    </span><br><span class="line">                &#125;<span class="comment">//end...if(newTouchTarget == null &amp;&amp; childrenCount != 0)</span></span><br><span class="line">                </span><br><span class="line">            &#125;<span class="comment">//end...if(actionMasked == MotionEvent.ACTION_DOWN...)</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="comment">///end...if(!canceled &amp;&amp; !intercepted)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4、根据mFirstTouchTarget是否为null做出不同行为</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;<span class="comment">//这一般有三种情况导致mFirstTouchTarget为空：</span></span><br><span class="line">            <span class="comment">//1、ViewGroup没有子View；</span></span><br><span class="line">            <span class="comment">//2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false；</span></span><br><span class="line">            <span class="comment">//3、ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true</span></span><br><span class="line">       		<span class="comment">//在这三种情况下ViewGroup就会自己处理事件</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                                                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//有两种情况mFirstTouchTarget不为空，表示找到合适的子View为target：</span></span><br><span class="line">            <span class="comment">//1、本次事件是ACTION_DOWN，遍历完ViewGroup所有的子View后找到了合适的子View为target；</span></span><br><span class="line">            <span class="comment">//2、本次事件是除了ACTION_DOWN以外的其他事件，但是在ACTION_DOWN时已经找到了合适的子View为target，所以接下来就直接把事件分发给mFirstTouchTarget的child处理处理就行</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="comment">//mFirstTouchTarget是一个单链表结构，下面是链表的遍历</span></span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;<span class="comment">//情况1的处理</span></span><br><span class="line">                    <span class="comment">//因为在找到target时已经调用过dispatchTransformedTouchEvent()了，表示该target的View已经消费了该事件，handle直接等于true</span></span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//情况2的处理</span></span><br><span class="line">                    <span class="comment">//注意这个intercepted，如果为true，cancelChild就会为true，会导致子View收到一个ACTION_CANCEL, 表示子View的本次事件取消</span></span><br><span class="line">                     <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                                || intercepted;</span><br><span class="line">                    <span class="comment">//调用dispatchTransformedTouchEvent()方法把事件分发给target对应的子View</span></span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        <span class="comment">//handle的是否为true取决于子View的dispatchTouchEvent()返回值</span></span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果需要取消本次事件，清空这个子View对应的target，并把这个tareget从链表中取消，导致该事件序列的后序事件该子View都无法再收到</span></span><br><span class="line">                     <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                         <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                             mFirstTouchTarget = next;</span><br><span class="line">                         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                             predecessor.next = next;</span><br><span class="line">                         &#125;</span><br><span class="line">                         target.recycle();</span><br><span class="line">                         target = next;</span><br><span class="line">                         <span class="keyword">continue</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                <span class="comment">//继续分发给下一个target</span></span><br><span class="line">                target = next;</span><br><span class="line">            &#125;<span class="comment">//end...while (target != null) </span></span><br><span class="line">            </span><br><span class="line">         &#125;<span class="comment">//end...if (mFirstTouchTarget == null)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">    &#125;<span class="comment">//end...if (onFilterTouchEventForSecurity(ev))</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法特别长，里面就是整个ViewGroup的事件分发逻辑，我知道大家也没有想看的欲望了，这个方法对应的流程图如下：</p>
<img src="/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/view3.png" class="" title="view3">

<p>可以看到，<strong>在同一个事件序列内（从down开始，到up结束）</strong>，ViewGroup的dispatchTouchEvent()方法可以分为两大过程：<strong>1、ACTION_DOWN事件的处理流程；2、除了ACTION_DOWN以外的事件处理流程</strong>。下面跟着这两个流程分别走一遍。</p>
<h3 id="2、ViewGroup处理ACTION-DOWN事件的流程"><a href="#2、ViewGroup处理ACTION-DOWN事件的流程" class="headerlink" title="2、ViewGroup处理ACTION_DOWN事件的流程"></a>2、ViewGroup处理ACTION_DOWN事件的流程</h3><p>ACTION_DOWN事件的处理流程又可以分为两个流程即：<strong>ViewGroup拦截事件(intercepted = true)与不拦截事件（intercepted = false）</strong>。</p>
<img src="/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/view4.png" class="" title="view4">

<p>看流程图，在dispatchTouchEvent()方法注释2中的if语句会决定 intercepted 的值，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup是否拦截本次事件标志</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="comment">//2、如果本次事件是ACTION_DOWN 或者 mFirstTouchTarget为空</span></span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//2.1、子View是否禁止ViewGroup拦截事件标志</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;<span class="comment">//如果子View允许ViewGroup拦截事件</span></span><br><span class="line">        <span class="comment">//调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent(ev)决定</span></span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果子View禁止ViewGroup拦截事件</span></span><br><span class="line">        intercepted = <span class="keyword">false</span>;<span class="comment">//intercepted值为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果本次事件是ACTION_DOWN也会进入这个if分支，看注释2.1检查 mGroupFlags 中是否包含FLAG_DISALLOW_INTERCEPT标识，默认没有，即默认disallowIntercept为false，所以就会调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent()决定，onInterceptTouchEvent()默认返回false，所以<strong>intercepted = false</strong>。</p>
<h4 id="2-1、intercepted-false"><a href="#2-1、intercepted-false" class="headerlink" title="2.1、intercepted = false"></a>2.1、intercepted = false</h4><p>当DOWN事件没有被ViewGroup拦截，<strong>intercepted = false</strong>，它就会进入dispatchTouchEvent()方法注释3的if语句，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//检查本次事件是否是ACTION_CANCEL</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>) || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">//newTouchTarget用于记录本次事件的target</span></span><br><span class="line">TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//表示事件是否已经分发给target对应的子View，默认为false</span></span><br><span class="line"><span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//3、如果本次事件不取消并且不拦截，就寻找合适的子View处理</span></span><br><span class="line"><span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//如果本次事件是ACTION_DOWN 或 ACTION_POINTER_DOWN 或ACTION_HOVER_MOVE</span></span><br><span class="line">    <span class="comment">//本文重点关注ACTION_DOWN事件，ACTION_POINTER_DOWN与多点触控相关</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">        <span class="comment">//如果target是null并且ViewGroup有子View，就寻找某个子View当target</span></span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line">            <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">            <span class="comment">//从后往前逐个取出子View</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">                <span class="keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">                <span class="comment">//3.1、判断子View能否接受点击事件：子View可见或在播放动画，并且触摸点在子View范围内</span></span><br><span class="line">                <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                    || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//走到这里表示子View满足处理事件的条件</span></span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="comment">//3.2、dispatchTransformedTouchEvent()里面会调用子View的dispatchTouchEvent()方法，在这个方法里把事件分发给子View</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                    <span class="comment">//3.3、如果dispatchTransformedTouchEvent()返回true，表示找到子View消费本次事件了，就会走到这里, 所以这个子View就被当作target，这里会调用addTouchTarget()方法为这个子View创建一个TouchTarget，并把这个target插入mFirstTouchTarget链表的表头，并把表头返回赋值给newTouchTarget</span></span><br><span class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//alreadyDispatchedToNewTouchTarget赋值为true，表示事件已经分发给target对应的子View</span></span><br><span class="line">                    alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;<span class="comment">//end...for（）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="comment">//end...if(newTouchTarget == null &amp;&amp; childrenCount != 0)</span></span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">//end...if(actionMasked == MotionEvent.ACTION_DOWN...)</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">///end...if(!canceled &amp;&amp; !intercepted)</span></span><br></pre></td></tr></table></figure>

<p>如果是DOWN事件，假设ViewGroup有子View，就会进入for循环，ViewGroup就会遍历所有子View，先在注释3.1中判断这个子View是否满足接收事件的条件，如果不满足，就再找下一个子View，如果满足，就来到了注释3.2，然后调用dispatchTransformedTouchEvent()方法看这个子View是否消费DOWN事件。</p>
<p>dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="comment">//dispatchTransformedTouchEvent（）只需要关注两个参数：</span></span><br><span class="line"><span class="comment">//@params cancel 是否取消本次事件</span></span><br><span class="line"><span class="comment">//@params child 准备接收分发事件的子View</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel, View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="comment">//1、如果cancel为true，进入这个if分支</span></span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        <span class="comment">//设置ACTION_CANCEL事件</span></span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...省略的是多点触控的处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、如果cancel为false，进入这个if分支</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;<span class="comment">//如果child为空</span></span><br><span class="line">        <span class="comment">//调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件</span></span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果child不为空</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件</span></span><br><span class="line">        handled = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为传入cancel为false，所以来带注释2的if分支，因为传入的child不为空，所以调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件，<strong>到这里DOWN事件就传递给子View，如果子View是一个View，那么它的处理流程就像前面介绍的View的事件分发一样，如果子View是一个ViewGroup，那么它的处理流程就又是ViewGroup的事件分发</strong>。</p>
<p>好了，假设子View消费这个事件，返回true，则dispatchTransformedTouchEvent()返回true，ViewGrou找到了要消费这个DOWN事件的子View，这时到了dispatchTouchEvent方法的注释3.3，调用addTouchTarget(child, idBitsToAssign)方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TouchTarget <span class="title">addTouchTarget</span><span class="params">(@NonNull View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先为传进来的View获取一个target关联</span></span><br><span class="line">    <span class="keyword">final</span> TouchTarget target = TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">    <span class="comment">//然后把这个target插入mFirstTouchTarget链表的表头</span></span><br><span class="line">    target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;<span class="comment">//mFirstTouchTarget重新移动到链表表头</span></span><br><span class="line">    <span class="comment">//返回链表表头的target</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ViewGroup::TouchTarget</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TouchTarget <span class="title">obtain</span><span class="params">(@NonNull View child, <span class="keyword">int</span> pointerIdBits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    target.child = child;</span><br><span class="line">    target.pointerIdBits = pointerIdBits;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果找到了要消费这个DOWN事件的子View，就会为这个子View创建一个target关联，同时这个子View会赋值给<strong>target</strong>的<strong>child</strong>字段，最后这个<strong>target</strong>就会插入链表的表头并返回，addTouchTarget方法返回后赋值给<strong>newTouchTarget</strong>字段。target的作用就是：做了一个记录，当下一个事件到来时，如果发现<strong>mFirstTouchTarget</strong>不为空，就会遍历链表找到对应的target，直接把事件分发给<strong>target</strong>中记录的View，就不用再去遍历ViewGroup中子View了。</p>
<p>那么我们上面所谈到的target、mFirstTouchTarget、newTouchTarget是什么？它们都是<strong>TouchTarget</strong>类型，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///ViewGroup::TouchTarget</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TouchTarget</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前消费事件的View</span></span><br><span class="line">    <span class="keyword">public</span> View child;</span><br><span class="line">    <span class="comment">//它的下一个结点</span></span><br><span class="line">    <span class="keyword">public</span> TouchTarget next;</span><br><span class="line">    <span class="comment">//通过二进制位记录按在child上的手指数量，有多少个1就表示有多少根手指</span></span><br><span class="line">    <span class="comment">//例如pointerIdBits = 001表示有一根手指，pointerIdBits = 011表示有两根手指，</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> pointerIdBits;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它是一个链表结构，其中child表示本次需要消费事件的View，next表示下一个结点，pointerIdBits表示按在child上的手指数量，<strong>mFirstTouchTarget</strong>就是这个链表的表头，链表由很多的<strong>target</strong>串联起来，<strong>newTouchTarget</strong>就是代表最新插入的target，为什么mFirstTouchTarget是一个链表？我的猜测是由于<strong>多点触控</strong>的存在，例如我5个手指可以同时触摸到列表的5个子View，如果5个子View都是要消费这个DOWN事件的话，那么就要用链表把它们记录起来，当下一个事件到来时，5个子View都能分发到事件，所以后面遇到target的字眼，时刻记住它是一个链表结构。</p>
<blockquote>
<p>多点触控在事件分发中又是另外一个知识点，在多点触控中:<br>1、如果多个手指依此按在同一个View中，那么这个View会先收到第一个手指的ACTION_DOWN事件，接着会收到其他手指的ACTION_POINTER_DOWN事件;<br>2、如果多个手指依此按在不同的View中，那么每个View都会收到相应手指的ACTION_DOWN事件；<br>在Android中，通过idBitsToAssign、mFirstTouchTarget 和 mFirstTouchTarget中的pointerIdBits配合实现多点触控的事件分发，有兴趣的可以自行了解<a href="https://www.wanandroid.com/wenda/show/11287" target="_blank" rel="noopener">“事件分发只有一次 ACTION_DOWN，一次 ACTION_UP”严谨吗？</a>。</p>
</blockquote>
<p>好了，现在已经找到了可以消费事件的子View，并通过addTouchTarget方法为这个子View关联了一个target插入了mFirstTouchTarget，并且mFirstTouchTarget在链表插入时也被移动到链表表头了，不为null了，接着就一个break跳出for循环，直接来到dispatchTouchEvent()方法的注释4，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4、根据mFirstTouchTarget是否为null做出不同行为</span></span><br><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//有两种情况mFirstTouchTarget不为空，表示找到合适的子View为target：</span></span><br><span class="line">    <span class="comment">//1、本次事件是ACTION_DOWN，遍历完ViewGroup所有的子View后找到了合适的子View为target；</span></span><br><span class="line">    <span class="comment">//2、本次事件是除了ACTION_DOWN以外的其他事件，但是在ACTION_DOWN时已经找到了合适的子View为target，所以接下来就直接把事件分发给target的child处理就行</span></span><br><span class="line">    TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">    TouchTarget target = mFirstTouchTarget;</span><br><span class="line">    <span class="comment">//mFirstTouchTarget是一个单链表结构，下面是链表的遍历</span></span><br><span class="line">    <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">        <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;<span class="comment">//情况1的处理</span></span><br><span class="line">            <span class="comment">//因为在找到target时已经调用过dispatchTransformedTouchEvent()了，表示该target的View已经消费了该事件，handle直接等于true</span></span><br><span class="line">            handled = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//情况2的处理</span></span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">        predecessor = target;</span><br><span class="line">        <span class="comment">//继续分发给下一个target</span></span><br><span class="line">        target = next;</span><br><span class="line">    &#125;<span class="comment">//end...while (target != null) </span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//end...if (mFirstTouchTarget == null)</span></span><br></pre></td></tr></table></figure>

<p>mFirstTouchTarget不为空，就来到else分支，else分支中是一个链表的遍历，遍历所有的target，找到在上面的for循环消费了DOWN事件的子View对应的target，对应情况1的if分支，在上面的for循环中找到子View后，这个子View已经消费了DOWN事件，alreadyDispatchedToNewTouchTarget已经赋值为true，所以handle直接等于true。</p>
<p>到这里在DOWN事件下ViewGroup不拦截的情况下分析完毕。上面是假设找到了子View并且子View消费了事件，这样当下一次事件到来时mFirstTouchTarget不为空，就直接把这个事件给子View；但是如果上面是找到子View而这个子View不消费这个DOWN事件，即子View的dispatchTouchEvent()方法返回false，那么dispatchTransformedTouchEvent()返回false，就导致无法为mFirstTouchTarget赋值，mFirstTouchTarget为空，当下一次事件序列到来时，ViewGroup会直接处理，而不再转发给子View。这里得出一个结论：<strong>子View如果不消费ACTION_DOWN事件，那么同一事件序列的其他事件都不会再交给它来处理，而是交给它的父ViewGroup处理；子View一旦消费ACTION_DOWN事件，那么同一事件序列的其他事件都会交给它处理</strong>。</p>
<p>所以如果此时子View没有消费ACTION_DOWN事件，或者我重写了ViewGroup的onInterceptTouchEvent()并返回了true，那么ViewGroup就会开始拦截事件，接下来看在DOWN事件下ViewGroup拦截的情况，即<strong>intercepted = true</strong>。</p>
<h4 id="2-2、intercepted-true"><a href="#2-2、intercepted-true" class="headerlink" title="2.2、intercepted = true"></a>2.2、intercepted = true</h4><p>如果ViewGroup拦截DOWN事件，那么<strong>intercepted = true</strong>，就不会进入dispatchTouchEvent()方法的注释3的if语句，这样在DOWN事件下ViewGroup就不会遍历它的子View，也就无法调用dispatchTransformedTouchEvent()找到要消费事件的子View，同理无法调用addTouchTarget()方法为mFirstTouchTarget赋值，就会导致在DOWN事件下mFirstTouchTarget为空，这样就直接来到了dispatchTouchEvent()方法的注释4的if语句，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//检查本次事件是否是ACTION_CANCEL</span></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>) || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"><span class="comment">//...   </span></span><br><span class="line"><span class="comment">//4、根据mFirstTouchTarget是否为null做出不同行为</span></span><br><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;<span class="comment">//这一般有三种情况导致mFirstTouchTarget为空：</span></span><br><span class="line">    <span class="comment">//1、ViewGroup没有子View；</span></span><br><span class="line">    <span class="comment">//2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false；</span></span><br><span class="line">    <span class="comment">//3、ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true</span></span><br><span class="line">    <span class="comment">//在这三种情况下ViewGroup就会自己处理事件</span></span><br><span class="line">    <span class="comment">//注意第三个参数传入null，表示ViewGroup自己处理事件</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                                            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;         </span><br><span class="line">    <span class="comment">//...           </span></span><br><span class="line">&#125;<span class="comment">//end...if (mFirstTouchTarget == null)</span></span><br></pre></td></tr></table></figure>

<p>很明显这里是情况3，因为没有找到子View，dispatchTransformedTouchEvent()方法的第三个参数为空，而第二个参数为false，因为不是ACTION_CANCEL事件，我们参考上面的dispatchTransformedTouchEvent()方法分析，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="comment">//dispatchTransformedTouchEvent（）只需要关注两个参数：</span></span><br><span class="line"><span class="comment">//@params cancel 是否取消本次事件</span></span><br><span class="line"><span class="comment">//@params child 准备接收分发事件的子View</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel, View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//2、如果cancel为false，进入这个if分支</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;<span class="comment">//如果child为空</span></span><br><span class="line">        <span class="comment">//调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件</span></span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果child不为空</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件</span></span><br><span class="line">        handled = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面就会调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件，ViewGroup的父类是View，所以super.dispatchTouchEvent(event)里面的处理逻辑就是View的事件分发的处理逻辑，见前面分析的View的事件分发。</p>
<p>到这里在DOWN事件下ViewGroup拦截的情况分析完毕。这里得出一个结论：<strong>ViewGroup如果在onInterceptTouchEvent()方法的ACTION_DOWN事件中返回true，那么整个事件序列都会交给ViewGroup处理，不再交给子View</strong>。</p>
<p>我们回到dispatchTouchEvent()方法，还有一点要注意的是在ACTION_DOWN下不管拦截还是不拦截都会进入dispatchTouchEvent()方法中注释1的if语句，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//1、如果本次事件是ACTION_DOWN</span></span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    <span class="comment">//置空mFirstTouchTarget，mFirstTouchTarget是TouchTarget类型，是一个单链表结构</span></span><br><span class="line">    cancelAndClearTouchTargets(ev);</span><br><span class="line">    <span class="comment">//清除mGroupFlags中的FLAG_DISALLOW_INTERCEPT标志位，这个标志等同于下面的disallowIntercept</span></span><br><span class="line">    resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个if语句的作用就是防止前一次事件序列对本次事件序列造成影响，所以它会向先调用 cancelAndClearTouchTargets(ev)清空mFirstTouchTarget，然后调用resetTouchState()清除FLAG_DISALLOW_INTERCEPT标志位，因为ACTION_DOWN事件是一个新的事件序列的开始，所以dispatchTouchEvent()方法首先要做的就是判断是不是迎来了一个新的事件序列，所以要判断该事件是否是ACTION_DOWN 事件，如果是 ACTION_DOWN 事件，作为一个事件序列的开头，应当要消除前面的事件序列可能留下的影响。关于FLAG_DISALLOW_INTERCEPT标志位后面会讲。</p>
<p>到这里ViewGroup处理ACTION_DOWN事件的流程分析完毕，下面我们来看除了ACTION_DOWN以外的事件的处理流程。</p>
<h3 id="3、ViewGroup处理除了ACTION-DOWN以外的事件的流程"><a href="#3、ViewGroup处理除了ACTION-DOWN以外的事件的流程" class="headerlink" title="3、ViewGroup处理除了ACTION_DOWN以外的事件的流程"></a>3、ViewGroup处理除了ACTION_DOWN以外的事件的流程</h3><p>ACTION_DOWN事件的处理流程又可以分为两个流程即：<strong>mFirstTouchTarget != null与mFirstTouchTarget == null</strong>。你会发现intercepted这个标记位似乎已经没有多大作用， 它如果是true，它根本不会进入dispatchTouchEvent()方法的注释3，就算是false进入了dispatchTouchEvent()方法的注释3，它也不会满足注释3.1的条件。所以我们就直接来到注释4。</p>
<img src="/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/view5.png" class="" title="view5">

<h4 id="3-1、mFirstTouchTarget-null"><a href="#3-1、mFirstTouchTarget-null" class="headerlink" title="3.1、mFirstTouchTarget == null"></a>3.1、mFirstTouchTarget == null</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检查本次事件是否是ACTION_CANCEL</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>) || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"><span class="comment">//...   </span></span><br><span class="line"><span class="comment">//4、根据mFirstTouchTarget是否为null做出不同行为</span></span><br><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;<span class="comment">//这一般有三种情况导致mFirstTouchTarget为空：</span></span><br><span class="line">    <span class="comment">//1、ViewGroup没有子View；</span></span><br><span class="line">    <span class="comment">//2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false；</span></span><br><span class="line">    <span class="comment">//3、ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true</span></span><br><span class="line">    <span class="comment">//在这三种情况下ViewGroup就会自己处理事件</span></span><br><span class="line">    <span class="comment">//注意第三个参数传入null，表示ViewGroup自己处理事件</span></span><br><span class="line">    handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                                            TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;         </span><br><span class="line">    <span class="comment">//...           </span></span><br><span class="line">&#125;<span class="comment">//end...if (mFirstTouchTarget == null)</span></span><br></pre></td></tr></table></figure>

<p>这里1、2、3情况都有可能发生，<strong>从ACTION_DOWN的处理流程我们知道为mFirstTouchTarget赋值的过程只会在处理ACTION_DOWN事件的时候出现</strong>，所以如果在处理ACTION_DOWN事件的时候ViewGroup没有子View，不会进入for循环，导致mFirstTouchTarget为空；如果ViewGroup有子View，进入了for循环，但是View不消费DOWN事件，即在dispatchTouchEvent()返回了false，导致无法调用addTouchTarget()方法为mFirstTouchTarget赋值，导致mFirstTouchTarget为空；ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true，不会进入注释3的if语句，导致mFirstTouchTarget为空；所以在处理ACTION_DOWN事件的时候没有找到mFirstTouchTarget，就会导致在除了ACTION_DOWN其他事件到来时mFirstTouchTarget == null，这里就直接让ViewGroup自己处理事件了。</p>
<h4 id="3-2、mFirstTouchTarget-null"><a href="#3-2、mFirstTouchTarget-null" class="headerlink" title="3.2、mFirstTouchTarget != null"></a>3.2、mFirstTouchTarget != null</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4、根据mFirstTouchTarget是否为null做出不同行为</span></span><br><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//有两种情况mFirstTouchTarget不为空，表示找到合适的子View为target：</span></span><br><span class="line">    <span class="comment">//1、本次事件是ACTION_DOWN，遍历完ViewGroup所有的子View后找到了合适的子View为target；</span></span><br><span class="line">    <span class="comment">//2、本次事件是除了ACTION_DOWN以外的其他事件，但是在ACTION_DOWN时已经找到了合适的子View为target，所以接下来就直接把事件分发给target的child处理就行</span></span><br><span class="line">    TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">    TouchTarget target = mFirstTouchTarget;</span><br><span class="line">    <span class="comment">//mFirstTouchTarget是一个单链表结构，下面是链表的遍历</span></span><br><span class="line">    <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">        <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;<span class="comment">//情况1的处理</span></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//情况2的处理</span></span><br><span class="line">            <span class="comment">//4.1、注意这个intercepted，如果为true，cancelChild就会为true，会导致子View收到一个ACTION_CANCEL, 表示子View的本次事件取消</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                || intercepted;</span><br><span class="line">            <span class="comment">//4.2、调用dispatchTransformedTouchEvent()方法把事件分发给target</span></span><br><span class="line">            <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                <span class="comment">//handle的是否为true取决于子View的dispatchTouchEvent()返回值</span></span><br><span class="line">                handled = <span class="keyword">true</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//4.3、如果需要取消本次事件，清空这个子View对应的target，并把这个tareget从链表中取消，导致该事件序列的后序事件该子View都无法再收到</span></span><br><span class="line">            <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mFirstTouchTarget = next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    predecessor.next = next;</span><br><span class="line">                &#125;</span><br><span class="line">                target.recycle();</span><br><span class="line">                target = next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        predecessor = target;</span><br><span class="line">        <span class="comment">//继续分发给下一个target</span></span><br><span class="line">        target = next;</span><br><span class="line">    &#125;</span><br><span class="line">    predecessor = target;</span><br><span class="line">    target = next;</span><br><span class="line">&#125;<span class="comment">//end...while (target != null) </span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//end...if (mFirstTouchTarget == null)</span></span><br></pre></td></tr></table></figure>

<p>mFirstTouchTarget != null，表示在处理ACTION_DOWN事件的时候已经找到mFirstTouchTarget，就会进入注释4的else分支，这里是情况2，就会进入情况2的处理的else分支，注释4.1的cancelChild这个值会决定子View是收到ACTION_CANCEL事件还是其他事件，而cancelChild的值取决于intercepted的值，所以如果ViewGroup在除了ACTION_DOWN以外的其他事件中的onInterceptTouchEvent(ev)方法返回了true，导致intercepted = true，从而cancelChild = true，而如果ViewGroup一直保持默认状态，intercepted = false，从而cancelChild = false，紧接着在注释4.2把cancelChild和target.child传进了dispatchTransformedTouchEvent()方法中。</p>
<p>我再贴一下dispatchTransformedTouchEvent()方法的代码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dispatchTransformedTouchEvent</span><span class="params">(MotionEvent event, <span class="keyword">boolean</span> cancel, View child, <span class="keyword">int</span> desiredPointerIdBits)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">boolean</span> handled;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldAction = event.getAction();</span><br><span class="line">    <span class="comment">//1、如果cancel为true，进入这个if分支</span></span><br><span class="line">    <span class="keyword">if</span> (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">        <span class="comment">//设置ACTION_CANCEL事件</span></span><br><span class="line">        event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">        <span class="comment">//分发ACTION_CANCEL事件</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handled = child.dispatchTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">        event.setAction(oldAction);</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...省略多点触控处理</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、如果cancel为false，进入这个if分支</span></span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件</span></span><br><span class="line">        handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">//调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件</span></span><br><span class="line">        handled = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到如果cancel为true，进入注释1这个if分支，里面会set一个ACTION_CANCEL事件，然后传递给target记录的子View；如果cancel为false，进入注释2这个else分支，调用child.dispatchTouchEvent(event)，表示让target记录的子View决定是否处理本次事件，前面已经讲过了。</p>
<p>好，现在我们走出dispatchTransformedTouchEvent()方法，来到注释4.3，如果cancelChild为true，就会调用TouchTarget的recycler()方法回收这个target，这样做的后果是什么呢？这样相当于清空了这个子View对应的target，并把这个tareget从链表中取消，导致该事件序列的后序事件该子View都无法再收到。</p>
<p>到这里ViewGroup处理除了ACTION_DOWN以外事件的流程分析完毕。</p>
<h3 id="4、子View如何禁止ViewGroup拦截事件"><a href="#4、子View如何禁止ViewGroup拦截事件" class="headerlink" title="4、子View如何禁止ViewGroup拦截事件"></a>4、子View如何禁止ViewGroup拦截事件</h3><p>前面的分析都是默认子View不禁止ViewGroup拦截事件，所以ViewGroup可以通过onInterceptTouchEvent()返回true从而拦截下子View的事件，但此时子View希望依然能够响应这些事件该怎么办呢？Android给我们提供了一个方法：requestDisallowInterceptTouchEvent(boolean) 用于设置是否允许拦截，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ViewGroup.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDisallowInterceptTouchEvent</span><span class="params">(<span class="keyword">boolean</span> disallowIntercept)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (disallowIntercept) &#123;</span><br><span class="line">        mGroupFlags |= FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pass it up to our parent</span></span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mParent.requestDisallowInterceptTouchEvent(disallowIntercept);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当子View调用getParent.requestDisallowInterceptTouchEvent(true)，mGroupFlags就会有FLAG_DISALLOW_INTERCEPT标识，当子View调用getParent.requestDisallowInterceptTouchEvent(false)，mGroupFlags就会清除FLAG_DISALLOW_INTERCEPT标识，那么FLAG_DISALLOW_INTERCEPT标识又是怎么控制ViewGroup的拦截的呢？如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!disallowIntercept) &#123;<span class="comment">//如果子View允许ViewGroup拦截事件</span></span><br><span class="line">    <span class="comment">//调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent(ev)决定</span></span><br><span class="line">    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//如果子View禁止ViewGroup拦截事件</span></span><br><span class="line">    intercepted = <span class="keyword">false</span>;<span class="comment">//intercepted值为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子View通过调用getParent.requestDisallowInterceptTouchEvent(true)，来禁止ViewGroup拦截除了ACTION_DOWN以外的其他事件，这样当下一个事件到来时就会交给这个子View，</p>
<p>为什么是除了ACTION_DOWN以外的其他事件？因为ACTION_DOWN事件是事件序列的开始，ACTION_DOWN事件会先经过ViewGroup的onInterceptTouchEvent()方法，从<strong>ACTION_DOWN事件的处理流程 - intercepted = true</strong>我们知道，如果ViewGroup一开始在onInterceptTouchEvent()的ACTION_DOWN返回true，它就不会进入dispatchTouchEvent()方法的注释3的if语句，这样在DOWN事件下就无法找到mFirstTouchTarget，这样当同一个事件序列的其他事件到来时，mFirstTouchTarget == null，这样ViewGroup只能把事件交给自己处理，无法传递给子View，也就无法调用子View的dispatchTouchEvent()方法，这样子View在dispatchTouchEvent()方法中调用getParent.requestDisallowInterceptTouchEvent(true)就没有意义了。</p>
<h3 id="5、小结"><a href="#5、小结" class="headerlink" title="5、小结"></a>5、小结</h3><p>从ViewGroup的事件分发中得出几个结论：</p>
<p>1、ViewGroup如果在onInterceptTouchEvent()方法的ACTION_DOWN事件中返回true，那么整个事件序列都会交给ViewGroup处理，不再交给子View，从而导致无法调用子View的dispatchTouchEvent()方法，导致子View调用getParent.requestDisallowInterceptTouchEvent(true)失效。</p>
<p>2、ViewGroup如果在onInterceptTouchEvent()方法中一旦拦截除了ACTION_DOWN的事件，那么子View将会收到一个ACTION_CANCEL事件，并且接下来的事件都是交给ViewGroup处理。</p>
<p>3、1、2点的含义都是ViewGroup决定拦截事件，那么一旦ViewGroup决定拦截事件，那么接下来的事件都是交给ViewGroup处理，并且ViewGroup的onInterceptTouchEvent()方法在这个事件序列内不会再调用，这说明ViewGroup的onInterceptTouchEvent()方法不是每次都调用,只有ViewGroup的dispatchTouchEvent()才能保证每次调用。</p>
<p>3、在ViewGroup中ACTION_DOWN 事件负责寻找 target，即寻找能够消费ACTION_DOWN事件的子View，如果找到，那么接下来同一事件序列内的所有事件都会交给这个子View处理，不再交给ViewGroup；如果没有找到，有两种情况：1、ViewGroup没有子View，2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false，那么接下来同一事件序列下的所有事件都是ViewGroup自己处理。</p>
<p>4、子View如果不消费ACTION_DOWN事件，那么同一事件序列的其他事件都不会再交给它来处理，而是交给它的父ViewGroup处理；子View一旦消费ACTION_DOWN事件，如果ViewGroup不拦截，那么同一事件序列的其他事件都会交给子View处理。</p>
<p>5、当调用super.dispatchTouchEvent(event)就代表ViewGroup开始自己处理事件，里面会执行ViewGroup的onTouchEvent(), 逻辑和View的事件分发一样。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>当点击事件到达ViewGroup时，它的dispatchTouchEvent()方法就会被调用，如果这个ViewGroup的onInterceptTouchEvent()方法返回true，就表示它要拦截当前事件，接下来这个事件序列内的事件都会交给它处理，即super.dispatchTouchEvent()方法得到调用；如果这个ViewGroup的onInterceptTouchEvent()方法返回false，就表示它不拦截当前事件，这时当前事件就会传递给它的子View，接着子View的dispatchTouchEvent()方法就会被调用，如果子View是一个View，那么它的处理流程就像前面介绍的View的事件分发一样，如果子View是一个ViewGroup，那么它的处理流程就又是ViewGroup的事件分发，如此递归，<strong>从上到下</strong>，直到整颗View树都收到事件，接下来递归返回，<strong>从下到上</strong>，每一层的返回值都决定是否消费本次事件，如果消费，返回true，它的上一层就无法处理这个事件，如果不消费，返回false，它的上一层又继续传给上一层，直到根视图。</p>
<p>View的事件分发小结和ViewGroup的事件分发小结都可以在源码中找到证明，可以自行验证一下，本文通过源码 + 流程图 说明了整个View的事件分发体制，在看的过程最好要结合上下文来看，始终记住这是在同一个事件序列内，跟着流程图的每一个分支在源码中走一遍，那样你就会有更深刻的理解。</p>
<p>参考资料：</p>
<p><a href="https://blog.csdn.net/qq_43660664/article/details/84026785" target="_blank" rel="noopener">Android事件分发完全解析之事件从何而来</a></p>
<p><a href="https://blog.csdn.net/u010707039/article/details/85211658#commentBox" target="_blank" rel="noopener">通过流程图来分析Android事件分发</a></p>
<p><a href="https://www.jianshu.com/p/f05d6b05ba17" target="_blank" rel="noopener">十分钟了解Android触摸事件原理（InputManagerService）</a></p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最終更新：<time datetime="2023-01-07T10:44:48.810Z" itemprop="dateUpdated">2023-01-07 18:44:48</time>
</span><br>


        
        谢谢大家的阅读！
        
    </div>
    
    <footer>
        <a href="http://yoursite.com">
            <img src="/img/avatar.jpg" alt="rain9155">
            rain9155
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/view/" rel="tag">view</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/&title=《View的事件分发机制》 — jianyu的博客&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/&title=《View的事件分发机制》 — jianyu的博客&source=前言前几天写过一篇文章View的工作原理，讲述的View工作的三大流程，其实与View的工作流程同样重要还有View的事件分发机制，平时我们经常通过set..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《View的事件分发机制》 — jianyu的博客&url=http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/08/06/%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AE%9E%E8%B7%B5-%E4%BB%BF%E5%BE%AE%E4%BF%A1%E7%9A%84%E6%BB%91%E5%8A%A8%E6%8C%89%E9%92%AE/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">自定义View实践-仿微信的滑动按钮</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/07/22/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">View的工作原理</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢打赏!
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>このブログの内容物は<a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.ja" target="_blank">クリエイティブ・コモンズ 表示 - 非営利 - 継承 4.0 国際ライセンスの下に提供されています</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>rain9155 &copy; 2018 - 2023</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/&title=《View的事件分发机制》 — jianyu的博客&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/&title=《View的事件分发机制》 — jianyu的博客&source=前言前几天写过一篇文章View的工作原理，讲述的View工作的三大流程，其实与View的工作流程同样重要还有View的事件分发机制，平时我们经常通过set..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《View的事件分发机制》 — jianyu的博客&url=http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2019/07/29/View%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADK0lEQVR42u3aS47jMAwFwL7/pXuAWc0iTh5JZRAz5VWQj6ySG2DrUT8/8fX79/r39fN3ktGuruffvPr05x0XNjY29k3YySSukMlEr8Y5tcTP53a5NNjY2Njr2JPbv2OEhPf89QsjNjY29leye//VJyVtsgnBxsbGxq6Wn2Qb0Ctyyb2uvo+NjY2NnZeZ/NNJ9J83AN6epWFjY2N/PLvX6P3M12/vb2NjY2N/GHseA1VbudVtQ17eCgpsbGzsReznsU6+MUjw1QZDbz6Fx4CNjY29iJ0PUY1ykiXoRVe9h/ciUcPGxsa+ITuP0Sfxfa8lkN+3vBDY2NjYi9h5OcnjnvydXhO3OnK0A8PGxsa+LTuBNdeyeLxmEhjly/egbmNjY2MvYieR0DuauKcCrLwtjY2Njb2PfSq4n7SNqweDJu1hbGxs7E3svEgkv8phvdA/P45TuC82Njb2zdnz4L4a+uQl89TzfDA+NjY29jp2/o/+PGya7AV+D13Y2NjYu9nz+Cb5NFnECbtcwLCxsbFvzu4dyjnVKpiUxnzMwg+wsbGxb8XOY/e8LJ3dNuQhV3ULhI2Njb2J3Yv7q4cpk3d67eH88WBjY2NvZeeFIdl+VL95aiOU/wobGxt7K3vSKki2Iu84jtkrq9jY2Nj72PkBnaQwVNuu1eZx8jAKMRM2Njb2zdnVFcoXIklvJs3dXlDV/MPAxsbG/nh2MtzkNvmGZLIVye+OjY2NvYk9aQNM4p78eFAeclUt2NjY2DvYvWgm/34yxXnrt1wCsbGxsdex84LRC/fPLkF1abCxsbF3s09NqBro5G3d6gapoMDGxsZewa6WqPzY5aRB24ur8kYyNjY29j523prNuw3/5/hmtZRiY2Njb2VPStTkGM2k0VtdJmxsbOyt7PxKClivOFUP6OSLmJdPbGxs7Luze1FRDpgs3KmW84Plw8bGxl7HrrZse59Wx5k0nsv9bWxsbOwvYOfHaPLQqto8qM7hcgRsbGzsL2b3ov/e1HuHe6LMDBsbG3sde15geoUkb9xWG8wvlgMbGxt7Ebt3kDEvKr0DN9VJHyts2NjY2Hdi/wGdDumtI+Kd6gAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>








<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '去哪里了?';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎光临!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
