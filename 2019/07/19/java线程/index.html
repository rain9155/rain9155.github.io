<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>java学习总结之线程 | jianyu的博客 | 每天进步一点点</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#009688">
    
    
    <meta name="keywords" content="线程">
    <meta name="description" content="前言在java中，线程非常重要，我们要分清楚进程和线程的区别：进程是操作系统中资源分配的基本单位，进程是指一个内存中运行的应用程序，每个进程都拥有自己的一块独立的内存空间，进程之间的资源不共享；而线程是CPU调度的最小单元，一个进程可以有多个线程，线程之间的堆空间是共享的，但栈空间是独立的，java程序的进程至少包含主线程和后台线程(垃圾回收线程)。了解这些知识后，来看下文有关线程的知识。">
<meta property="og:type" content="article">
<meta property="og:title" content="java学习总结之线程">
<meta property="og:url" content="http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="jianyu的博客">
<meta property="og:description" content="前言在java中，线程非常重要，我们要分清楚进程和线程的区别：进程是操作系统中资源分配的基本单位，进程是指一个内存中运行的应用程序，每个进程都拥有自己的一块独立的内存空间，进程之间的资源不共享；而线程是CPU调度的最小单元，一个进程可以有多个线程，线程之间的堆空间是共享的，但栈空间是独立的，java程序的进程至少包含主线程和后台线程(垃圾回收线程)。了解这些知识后，来看下文有关线程的知识。">
<meta property="og:image" content="http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/thread1.png">
<meta property="og:image" content="http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/thread2.png">
<meta property="article:published_time" content="2019-07-19T04:25:50.000Z">
<meta property="article:modified_time" content="2023-01-07T10:44:48.887Z">
<meta property="article:author" content="rain9155">
<meta property="article:tag" content="线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/thread1.png">
    
        <link rel="alternate" type="application/atom+xml" title="jianyu的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">rain9155</h5>
          <a href="mailto:jianyu9155@gmail.com" title="jianyu9155@gmail.com" class="mail">jianyu9155@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/rain9155" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://juejin.im/user/5b437173e51d45191d79c27a/posts" target="_blank" >
                <i class="icon icon-lg icon-gg"></i>
                Juejin
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://blog.csdn.net/Rain_9155" target="_blank" >
                <i class="icon icon-lg icon-eye"></i>
                CSDN
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.jianshu.com/u/93cb7ffd83e9" target="_blank" >
                <i class="icon icon-lg icon-book"></i>
                Jianshu
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/links"  >
                <i class="icon icon-lg icon-link"></i>
                Links
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">java学习总结之线程</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="搜尋">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">java学习总结之线程</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-07-19T04:25:50.000Z" itemprop="datePublished" class="page-time">
  2019-07-19
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/java/">java</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#一、并发和并行"><span class="post-toc-text">一、并发和并行</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#二、线程的创建与启动"><span class="post-toc-text">二、线程的创建与启动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#方式1：继承Thread类"><span class="post-toc-text">方式1：继承Thread类</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#方式2：实现Runnable接口"><span class="post-toc-text">方式2：实现Runnable接口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1：定义一个类实现Runnable接口"><span class="post-toc-text">2.1：定义一个类实现Runnable接口</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2、使用匿名内部类"><span class="post-toc-text">2.2、使用匿名内部类</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#方式3：实现Callable接口"><span class="post-toc-text">方式3：实现Callable接口</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#继承与实现的区别"><span class="post-toc-text">继承与实现的区别</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#三、线程的中断与终止"><span class="post-toc-text">三、线程的中断与终止</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、interrupt-、isInterrupted-、interrupted-的作用"><span class="post-toc-text">1、interrupt()、isInterrupted()、interrupted()的作用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2、终止线程的运行"><span class="post-toc-text">2、终止线程的运行</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-1、利用中断标志位"><span class="post-toc-text">2.1、利用中断标志位</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-2、利用一个boolean变量"><span class="post-toc-text">2.2、利用一个boolean变量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-3、响应InterruptedException"><span class="post-toc-text">2.3、响应InterruptedException</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#四、线程的生命周期"><span class="post-toc-text">四、线程的生命周期</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、线程的6种状态"><span class="post-toc-text">1、线程的6种状态</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-1、NEW-新建状态"><span class="post-toc-text">1.1、NEW(新建状态)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-2、RUNNABLE-可运行状态"><span class="post-toc-text">1.2、RUNNABLE(可运行状态)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-3、BLOCKED-阻塞状态"><span class="post-toc-text">1.3、BLOCKED(阻塞状态)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-4、WAITING-等待状态"><span class="post-toc-text">1.4、WAITING(等待状态)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-5、TIMED-WAITING-计时等待状态"><span class="post-toc-text">1.5、TIMED WAITING(计时等待状态)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-6、TREMINATED-终止状态"><span class="post-toc-text">1. 6、TREMINATED(终止状态)</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2、线程的状态转换图"><span class="post-toc-text">2、线程的状态转换图</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#六、线程之间的通信"><span class="post-toc-text">六、线程之间的通信</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、wait-notify-notifyAll-机制"><span class="post-toc-text">1、wait() &#x2F; notify()  notifyAll() 机制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2、await-signal-signalAll-机制"><span class="post-toc-text">2、await()  &#x2F; signal() signalAll()机制</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3、死锁"><span class="post-toc-text">3、死锁</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4、-Thread类中过时的方法"><span class="post-toc-text">4、 Thread类中过时的方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#七、线程的控制操作"><span class="post-toc-text">七、线程的控制操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#1、线程休眠"><span class="post-toc-text">1、线程休眠</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#2、联合线程"><span class="post-toc-text">2、联合线程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#3、后台线程"><span class="post-toc-text">3、后台线程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#4、线程优先级"><span class="post-toc-text">4、线程优先级</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#5、线程礼让"><span class="post-toc-text">5、线程礼让</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#6、线程组"><span class="post-toc-text">6、线程组</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结语"><span class="post-toc-text">结语</span></a></li></ol>
        </nav>
    </aside>


<article id="post-java线程"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">java学习总结之线程</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-07-19 12:25:50" datetime="2019-07-19T04:25:50.000Z"  itemprop="datePublished">2019-07-19</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/java/">java</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在java中，线程非常重要，我们要分清楚进程和线程的区别：进程是操作系统中<strong>资源分配</strong>的基本单位，进程是指一个内存中运行的应用程序，每个进程都拥有自己的一块独立的内存空间，进程之间的资源不共享；而线程是<strong>CPU调度</strong>的最小单元，一个进程可以有多个线程，线程之间的堆空间是共享的，但栈空间是独立的，java程序的进程至少包含主线程和后台线程(垃圾回收线程)。了解这些知识后，来看下文有关线程的知识。</p>
<a id="more"></a>

<h2 id="一、并发和并行"><a href="#一、并发和并行" class="headerlink" title="一、并发和并行"></a>一、并发和并行</h2><p>我们先来看一下概念：</p>
<ul>
<li>并行：指两个或多个事件在<strong>同一时刻点</strong>发生</li>
<li>并发：指两个或多个事件在<strong>同一时间段内发生</strong></li>
</ul>
<p>对于单核CPU的计算机来说，它是不能并行的处理多个任务，它的每一时刻只能有一个程序执行时间片（时间片是指CPU分配给各个程序的运行时间），故在微观上这些程序只是<strong>分时交替的运行</strong>，所以在宏观看来在一段时间内有多个程序在同时运行，看起来像是并行运行。</p>
<p>对于多核CPU的计算机来说，它就可以并行的处理多个任务，可以做到多个程序在同一时刻同时运行。</p>
<p>同理对线程也一样，但系统只有一个CPU时，线程会以某种顺序执行，我们把这种情况称为线程调度，所以从宏观角度上看线程是并行运行的，但是从微观角度来看，却是串行运行，即一个线程一个线程的运行。</p>
<blockquote>
<p>一般来说，JVM的进程和线程都是与操作系统的进程和线程<strong>一 一对应</strong>的，这样做的好处是可以使操作系统来调度进程和线程，进程和线程调度是操作系统的核心模块，它的实现是非常复杂的，特别是考虑到多核的情况，因此，就完全没有必要在JVM中再提供一个进程和线程调度机制。</p>
</blockquote>
<h2 id="二、线程的创建与启动"><a href="#二、线程的创建与启动" class="headerlink" title="二、线程的创建与启动"></a>二、线程的创建与启动</h2><p>有3种方式使用线程。</p>
<h3 id="方式1：继承Thread类"><a href="#方式1：继承Thread类" class="headerlink" title="方式1：继承Thread类"></a>方式1：继承Thread类</h3><p>定义一个类继承java.lang.Thread类，重写Thread类中的run方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">     thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方式2：实现Runnable接口"><a href="#方式2：实现Runnable接口" class="headerlink" title="方式2：实现Runnable接口"></a>方式2：实现Runnable接口</h3><h4 id="2-1：定义一个类实现Runnable接口"><a href="#2-1：定义一个类实现Runnable接口" class="headerlink" title="2.1：定义一个类实现Runnable接口"></a>2.1：定义一个类实现Runnable接口</h4><p>实现 Runnable只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2、使用匿名内部类"><a href="#2-2、使用匿名内部类" class="headerlink" title="2.2、使用匿名内部类"></a>2.2、使用匿名内部类</h4><p>这种方式只适用于这个线程只使用一次的情况，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方式3：实现Callable接口"><a href="#方式3：实现Callable接口" class="headerlink" title="方式3：实现Callable接口"></a>方式3：实现Callable接口</h3><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装，所以在创建Thread时，要把FutureTask 传进去，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承与实现的区别"><a href="#继承与实现的区别" class="headerlink" title="继承与实现的区别"></a>继承与实现的区别</h3><p>1、继承方式：</p>
<p>（1）java中类是单继承的，如果继承了Thread，该类就不能有其他父类了，但是可以实现多个接口</p>
<p>（2）从操作上分析，继承方式更简单，获取线程名字也简单</p>
<p>2、实现方式：</p>
<p>（1）java中类可以实现多接口，此时该类还可以继承其他类，并且还可以实现其他接口</p>
<p>（2）从操作上分析，实现方式稍复杂，获取线程名字也比较复杂，得通过Thread.currentThread来获取当前线程得引用</p>
<p>综上所述，实现接口会更好一些。</p>
<h2 id="三、线程的中断与终止"><a href="#三、线程的中断与终止" class="headerlink" title="三、线程的中断与终止"></a>三、线程的中断与终止</h2><h3 id="1、interrupt-、isInterrupted-、interrupted-的作用"><a href="#1、interrupt-、isInterrupted-、interrupted-的作用" class="headerlink" title="1、interrupt()、isInterrupted()、interrupted()的作用"></a>1、interrupt()、isInterrupted()、interrupted()的作用</h3><p>中断就是线程的一个标识位，它表示一个运行中的线程是否被其他线程调用了中断操作，其他线程可以通过调用线程的interrupt()方法对其进行中断操作，线程可以通过调用isInterrupted()方法判断是否被中断，线程也可以通过调用Thread的interrupted()静态方法对当前线程的中断标识位进行复位。</p>
<p>大家不要认为调用了线程的interrupt()方法，该线程就会停止，它只是做了一个标志位，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个死循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"InterruptThread正在执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    InterruptThread interruptThread = <span class="keyword">new</span> InterruptThread();</span><br><span class="line">    interruptThread.start();</span><br><span class="line">    interruptThread.interrupt();<span class="comment">//调用线程的interrupt()</span></span><br><span class="line">    System.out.println(<span class="string">"interruptThread是否被中断，interrupt  = "</span> + interruptThread.isInterrupted());<span class="comment">//此时isInterrupted()方法返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">interruptThread是否被中断，interrupt  = <span class="keyword">true</span></span><br><span class="line">InterruptThread正在执行</span><br><span class="line">InterruptThread正在执行</span><br><span class="line">InterruptThread正在执行</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>可以看到当你调用了线程的interrupt()方法后，此时调用isInterrupted()方法会返回true，但是该线程还是会继续执行下去。所以怎么样才能终止一个线程的运行呢？</p>
<h3 id="2、终止线程的运行"><a href="#2、终止线程的运行" class="headerlink" title="2、终止线程的运行"></a>2、终止线程的运行</h3><p>一个线程正常执行完run方法之后会自动结束，如果在运行过程中发生异常也会提前结束；所以利用这两种情况，我们还可以通过以下三种种方式安全的终止运行中的线程：</p>
<h4 id="2-1、利用中断标志位"><a href="#2-1、利用中断标志位" class="headerlink" title="2.1、利用中断标志位"></a>2.1、利用中断标志位</h4><p>前面讲到的中断操作就可以用来取消线程任务，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted())&#123;<span class="comment">//利用中断标记位</span></span><br><span class="line">            System.out.println(<span class="string">"InterruptThread正在执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当不需要运行InterruptThread线程时，通过调用InterruptThread.interrupt()使得isInterrupted()返回true，就可以让线程退出循环，正常执行完毕之后自动结束。</p>
<h4 id="2-2、利用一个boolean变量"><a href="#2-2、利用一个boolean变量" class="headerlink" title="2.2、利用一个boolean变量"></a>2.2、利用一个boolean变量</h4><p>利用一个boolean变量和上述方法同理，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isCancel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!isCancel)&#123;<span class="comment">//利用boolean变量</span></span><br><span class="line">            System.out.println(<span class="string">"InterruptThread正在执行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isCancel = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当不需要运行InterruptThread线程时，通过调用InterruptThread.cancel()使isCancel等于true，就可以让线程退出循环，正常执行完毕之后自动结束，这里要注意boolean变量要用volatile修饰保证内存的可见性。</p>
<h4 id="2-3、响应InterruptedException"><a href="#2-3、响应InterruptedException" class="headerlink" title="2.3、响应InterruptedException"></a>2.3、响应InterruptedException</h4><p>通过调用一个线程的 interrupt() 来中断该线程时，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程，例如当你调用Thread.sleep()方法时，通常会让你捕获一个InterruptedException异常，如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);<span class="comment">//Thread.sleep会抛出InterruptedException</span></span><br><span class="line">                System.out.println(<span class="string">"InterruptThread正在执行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当不需要运行InterruptThread线程时，通过调用InterruptThread.interrupt()使得 Thread.sleep() 抛出InterruptedException，就可以让线程退出循环，提前结束。在抛出InterruptedException异常之前，JVM会把中断标识位复位，此时调用线程的isInterrupted()方法将会返回false。</p>
<h2 id="四、线程的生命周期"><a href="#四、线程的生命周期" class="headerlink" title="四、线程的生命周期"></a>四、线程的生命周期</h2><h3 id="1、线程的6种状态"><a href="#1、线程的6种状态" class="headerlink" title="1、线程的6种状态"></a>1、线程的6种状态</h3><p>线程也是有生命周期，也就是存在不同的状态，状态之间相互转换，线程可以处于以下的状态之一：</p>
<h4 id="1-1、NEW-新建状态"><a href="#1-1、NEW-新建状态" class="headerlink" title="1.1、NEW(新建状态)"></a>1.1、NEW(新建状态)</h4><p>使用new创建一个线程对象，但还没有调用线程的start方法，<strong>Thread t = new Thread()</strong>，此时属于新建状态。</p>
<h4 id="1-2、RUNNABLE-可运行状态"><a href="#1-2、RUNNABLE-可运行状态" class="headerlink" title="1.2、RUNNABLE(可运行状态)"></a>1.2、RUNNABLE(可运行状态)</h4><p>但在新建状态下线程调用了start方法，<strong>t.start()</strong>，此时进入了可运行状态。可运行状态又分为两种状态：</p>
<ul>
<li>ready(就绪状态)：线程对象调用stat方法后，等待JVM的调度，此时线程并没有运行。</li>
<li>running(运行状态)：线程对象获得JVM调度，此时线程开始运行，如果存在多个CPU，那么允许多个线程并行运行。</li>
</ul>
<p>线程的start方法只能调用一次，否则报错（IllegalThreadStateException）。</p>
<h4 id="1-3、BLOCKED-阻塞状态"><a href="#1-3、BLOCKED-阻塞状态" class="headerlink" title="1.3、BLOCKED(阻塞状态)"></a>1.3、BLOCKED(阻塞状态)</h4><p>正在运行的线程因为某些原因放弃CPU，暂时停止运行，就会进入阻塞状态，此时JVM不会给该线程分配CPU，直到线程重新进入就绪状态，才有机会转到运行状态，阻塞状态只能先进入就绪状态，不能跳过就绪状态直接进入运行状态。线程进入阻塞状态常见的情况有：</p>
<ul>
<li>1、当A线程处于运行状态时，试图获取同步锁，却被B线程获取，此时JVM把当前A线程放到对象的锁池(同步队列)中，A线程进入阻塞状态，等待获取对象的同步锁。</li>
<li>2、当线程处于运行状态时，发出了IO请求，此时进入阻塞状态。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 如果是使用Synchronize关键字，那么尝试获取锁的线程会进入BLOCKED状态；如果是使用java.util.concurrent 类库中的Lock，那么尝试获取锁的线程则会进入WAITING或TIMED WAITING状态，因为java.util.concurrent 类库中的Lock是使用LockSupport来进行同步的。</span><br></pre></td></tr></table></figure>

<h4 id="1-4、WAITING-等待状态"><a href="#1-4、WAITING-等待状态" class="headerlink" title="1.4、WAITING(等待状态)"></a>1.4、WAITING(等待状态)</h4><p>正在运行的线程调用了无参数的wait方法，此时JVM把该线程放入对象的等待池（等待队列）中，此时线程进入等待状态，等待状态的线程只能被其他线程唤醒，否则不会被分配 CPU 时间片。下面是让线程进入等待状态的方法：</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>无Timeout参数的Object.wait()</td>
<td>Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>无Timeout参数的Thread.join() 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h4 id="1-5、TIMED-WAITING-计时等待状态"><a href="#1-5、TIMED-WAITING-计时等待状态" class="headerlink" title="1.5、TIMED WAITING(计时等待状态)"></a>1.5、TIMED WAITING(计时等待状态)</h4><p>正在运行的线程调用了有参数的wait方法，此时JVM把该线程放入对象的等待池中，此时线程进入计时等待状态，计时等待状态的线程被其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。下面是让线程进入等待状态的方法：</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>调用Thread.sleep(int timeout) 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>有Timeout 参数的 Object.wait() 方法</td>
<td>时间结束 / Object.notify() / Object.notifyAll()</td>
</tr>
<tr>
<td>有Timeout 参数的 Thread.join() 方法</td>
<td>时间结束 / 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td>LockSupport.parkUntil() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps：阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</span><br></pre></td></tr></table></figure>

<h4 id="1-6、TREMINATED-终止状态"><a href="#1-6、TREMINATED-终止状态" class="headerlink" title="1. 6、TREMINATED(终止状态)"></a>1. 6、TREMINATED(终止状态)</h4><p>又称死亡状态，表示线程的终止。线程进入终止状态的情况有：</p>
<ul>
<li>1、正常执行完run方法，线程正常退出。</li>
<li>2、遇到异常而退出</li>
</ul>
<p>线程一旦终止了，就不能再次启动，否则报错（IllegalThreadStateException）</p>
<h3 id="2、线程的状态转换图"><a href="#2、线程的状态转换图" class="headerlink" title="2、线程的状态转换图"></a>2、线程的状态转换图</h3><img src="/2019/07/19/java%E7%BA%BF%E7%A8%8B/thread1.png" class="" title="thread1">

<h2 id="六、线程之间的通信"><a href="#六、线程之间的通信" class="headerlink" title="六、线程之间的通信"></a>六、线程之间的通信</h2><p>如果一个线程从头到尾的执行完一个任务，不需要和其他线程打交道的话，那么就不会存在安全性问题了，由于java内存模式的存在，如下：</p>
<img src="/2019/07/19/java%E7%BA%BF%E7%A8%8B/thread2.png" class="" title="thread2">

<p>每一个java线程都有自己的工作内存，线程之间要想协作完成一个任务，就必须通过主内存来通信，所以这里就涉及到对共享资源的竞争，在主内存中的东西都是线程之间共享，所以这里就必须通过一些手段来让线程之间完成正常通信。主要有以下两种方法：</p>
<h3 id="1、wait-notify-notifyAll-机制"><a href="#1、wait-notify-notifyAll-机制" class="headerlink" title="1、wait() / notify()  notifyAll() 机制"></a>1、wait() / notify()  notifyAll() 机制</h3><p>它们都是Object类中的方法，它们的主要作用如下：</p>
<ul>
<li>wait()：执行该方法的线程对象释放同步锁（这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁），然后JVM把该线程存放在等待池中，等待其他线程唤醒该线程</li>
<li>notify()：执行该方法的线程唤醒在等待池中等待的任意一个线程，把线程转到锁池中等待</li>
<li>notifyAll()：执行该方法的线程唤醒在等待池中等待的所有线程，把线程转到锁池中等待</li>
</ul>
<p>注意：上述方法只能在同步方法或者同步代码中使用，否则会报IllegalMonitorStateException异常，还有上述方法只能被同步监听锁对象来调用，不能使用其他对象调用，否则会报IllegalMonitorStateException异常。</p>
<p>假设A线程和B线程共同操作一个X对象，A、B线程可以通过X对象的wait方法和notify方法进行通信，流程如下：</p>
<p>1、当A线程执行X对象的同步方法时，A线程持有X对象的锁，则B线程没有执行同步方法的机会，B线程在X对象的锁池中等待。</p>
<p>2、A线程在同步方法中执行X.wait()时，A线程释放X对象的锁，进入X对象的等待池中。</p>
<p>3、在X对象的锁池中等待获取锁的B线程在这时获取X对象的锁，执行X对象的另一个同步方法。</p>
<p>4、B线程在同步方法中执行X.notify()或notifyAll()时，JVM把A线程从X对象的等待池中移到X对象的锁池中，等待获取锁。</p>
<p>5、B线程执行完同步方法，释放锁，A线程获取锁，从上次停下来的地方继续执行同步方法。</p>
<p>下面以一个ATM机存钱取钱的例子说明，ATM机要在银行把钱存进去后，其他人才能取钱，如果没钱取，只能先回家等待，等银行通知你有钱取了，再来取，如果有钱取，就直接取钱。</p>
<p>ATM机，存钱和取钱方法都是同步方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ATM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEmpty = <span class="keyword">true</span>;<span class="comment">//标志ATM是否有钱的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往ATM机中存钱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//ATM中有钱，等待被人把钱取走</span></span><br><span class="line">            <span class="keyword">while</span> (!isEmpty)&#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ATM中没钱了，开始存钱</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"发现ATM机没钱了，存钱中..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">this</span>.money = money;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"存钱完毕，存了"</span> + money + <span class="string">"元"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存钱完毕，把标志置为false</span></span><br><span class="line">            isEmpty = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ATM中有钱了，通知别人取钱</span></span><br><span class="line">            <span class="keyword">this</span>.notify();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从ATM机中取钱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//ATM中没钱取，等待通知</span></span><br><span class="line">                <span class="keyword">while</span> (isEmpty)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"ATM机没钱，等待中..."</span>);</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//ATM中有钱了，开始取钱</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"收到通知，取钱中..."</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span>+ <span class="string">"取出完毕，取出了"</span> + <span class="keyword">this</span>.money + <span class="string">"钱"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//取钱完毕，把标志置为true</span></span><br><span class="line">                isEmpty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//ATM没钱了，通知银行存钱</span></span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>银行， 需要传入同一个ATM示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blank</span> <span class="keyword">implements</span>  <span class="title">Runnable</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ATM mAtm;<span class="comment">//共享资源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Blank</span><span class="params">(ATM atm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mAtm = atm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//银行来存钱</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">            mAtm.push(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小明， 需要传入同一个ATM示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ATM mAtm;<span class="comment">//共享资源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(ATM atm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mAtm = atm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这个人来取钱</span></span><br><span class="line">        mAtm.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端操作，我特地让小明提前来取钱，此时ATM机中是没钱的，小明要等待：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建一个ATM机</span></span><br><span class="line">       ATM atm = <span class="keyword">new</span> ATM();</span><br><span class="line">       <span class="comment">//小明来取钱</span></span><br><span class="line">       Thread tPerson = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Person(atm), <span class="string">"XiaoMing"</span>);</span><br><span class="line">       tPerson.start();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//银行来存钱</span></span><br><span class="line">       Thread tBlank = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Blank(atm), <span class="string">"Blank"</span>);</span><br><span class="line">       tBlank.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">XiaoMing:ATM机没钱，等待中...</span><br><span class="line">Blank:发现ATM机没钱了，存钱中...</span><br><span class="line">Blank:存钱完毕，存了<span class="number">100</span>元</span><br><span class="line">XiaoMing:收到通知，取钱中...</span><br><span class="line">XiaoMing:取出完毕，取出了<span class="number">100</span>钱</span><br><span class="line">Blank:发现ATM机没钱了，存钱中...</span><br><span class="line">Blank:存钱完毕，存了<span class="number">100</span>元</span><br></pre></td></tr></table></figure>

<p>可以看到，小明总是在收到ATM的通知后才来取钱，如果通过这个存钱取钱的例子还不了解wait/notify机制的话，可以看看这个<a href="https://mp.weixin.qq.com/s/OriB-ouTDuCzquoFmjv9Lg" target="_blank" rel="noopener">修厕所的例子</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: wait() 和 sleep() 的区别是什么，首先wait()是Object的方法，而sleep()是Thread的静态方法，其次调用wait()会释放同步锁，而sleep()不会，最后一点不同的是调用&#96;wait&#96;方法需要先获得锁，而调用&#96;sleep&#96;方法是不需要的。</span><br></pre></td></tr></table></figure>

<h3 id="2、await-signal-signalAll-机制"><a href="#2、await-signal-signalAll-机制" class="headerlink" title="2、await()  / signal() signalAll()机制"></a>2、await()  / signal() signalAll()机制</h3><p>从java5开始，可以使用Lock机制取代synchronized代码块和synchronized方法，使用java.util.concurrent 类库中提供的Condition 接口的await / signal() signalAll()方法取代Object的wait() / notify()  notifyAll() 方法。</p>
<p>下面使用Lock机制和Condition 提供的方法改写上面的那个例子，如下：</p>
<p>ATM2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ATM2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> money;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEmpty = <span class="keyword">true</span>;<span class="comment">//标志ATM是否有钱的状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock mLock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//新建一个lock</span></span><br><span class="line">    <span class="keyword">private</span> Condition mCondition = mLock.newCondition();<span class="comment">//通过lock的newCondition方法获得一个Condition对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 往ATM机中存钱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> money)</span></span>&#123;</span><br><span class="line">        mLock.lock();<span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//ATM中有钱，等待被人把钱取走</span></span><br><span class="line">            <span class="keyword">while</span> (!isEmpty)&#123;</span><br><span class="line">                mCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ATM中没钱了，开始存钱</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"发现ATM机没钱了，存钱中..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">this</span>.money = money;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"存钱完毕，存了"</span> + money + <span class="string">"元"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//存钱完毕，把标志置为false</span></span><br><span class="line">            isEmpty = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ATM中有钱了，通知别人取钱</span></span><br><span class="line">            mCondition.signal();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            mLock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从ATM机中取钱</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mLock.lock();<span class="comment">//获取锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ATM中没钱取，等待通知</span></span><br><span class="line">            <span class="keyword">while</span> (isEmpty)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"ATM机没钱，等待中..."</span>);</span><br><span class="line">                 mCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ATM中有钱了，开始取钱</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + <span class="string">"收到通知，取钱中..."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span>+ <span class="string">"取出完毕，取出了"</span> + <span class="keyword">this</span>.money + <span class="string">"钱"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取钱完毕，把标志置为true</span></span><br><span class="line">            isEmpty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ATM没钱了，通知银行存钱</span></span><br><span class="line">            mCondition.signal();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            mLock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到ATM2改写ATM后，把方法的synchronized去掉，因为Lock机制没有同步锁的概念，然后获取lock锁，在finally里释放lock锁，还把原本Object.wait()用Condition.await()代替，原本Object.notify()用Condition.signal()代替。</p>
<p>客户端操作只是把ATM换成ATM2，输出结果和上面的一样，就不在累述。</p>
<h3 id="3、死锁"><a href="#3、死锁" class="headerlink" title="3、死锁"></a>3、死锁</h3><p>多线程通信的时候很容易造成死锁，死锁一旦发生，只能通过外力解决。</p>
<p><strong>死锁是什么？</strong></p>
<p>当A线程等待获取由B线程持有的锁，而B线程正在等待获取由A线程持有的锁，发生死锁现象，JVM既不检测也不会避免这种情况，所以程序员必须保证不导致死锁。</p>
<blockquote>
<p>官方定义：如果一组进程中的每一个进程都在等待仅由该进程组中的其他进程才能引发的事件，那么该组进程就是死锁。</p>
</blockquote>
<p><strong>产生死锁的原因？</strong></p>
<p>多个线程对<strong>不可抢占性资源</strong>或<strong>可消耗性资源</strong>的进行争夺时，可能会产生死锁。</p>
<p><strong>产生死锁的必要条件？</strong></p>
<p>同时满足以下4个条件，就会产生死锁：</p>
<p>1、 互斥条件：线程对分配到的资源进行排他性使用；</p>
<p>2、 请求和保持条件：线程已经保持了至少一个资源，又提出了新的资源请求;</p>
<p>3、 不可抢占条件: 线程已获得的资源在未使用完之前不能被抢占；</p>
<p>4、 循环等待条件：发生死锁时，一定存在一个线程-资源的循环链。</p>
<p><strong>如何预防死锁？</strong></p>
<p>在程序运行之前，可以通过以下3点来预防死锁：</p>
<p>1、破坏必要条件中的一个或几个就行；</p>
<p>2、当多个线程都要访问共享资源A、B、C时，保证每一个线程都按照相同的顺序去访问去访问他们，比如先访问A，接着访问B，最后访问C；</p>
<p>3、不要使用Thread类中过时的方法，因为容易导致死锁，所以被废弃，例如A线程获得对象锁，正在执行一个同步方法，如果B线程调用A线程的suspend()，此时A线程暂停运行，放弃CPU，但是不会放弃锁，所以B就永远不会得到A持有的锁。</p>
<blockquote>
<p>在操作系统中，还可以在程序运行时，通过<strong>银行家算法</strong>来避免死锁。</p>
</blockquote>
<p><strong>解决死锁的办法？</strong></p>
<p>1、从一个或多个线程中，抢占足够数量的资源分配给死锁线程，解决死锁状态；</p>
<p>2、终止或撤销系统中一个或多个线程，直到打破死锁状态。</p>
<blockquote>
<p>上面对死锁讨论的所有情况，同样适用于进程，线程就是””轻量级进程””。</p>
</blockquote>
<h3 id="4、-Thread类中过时的方法"><a href="#4、-Thread类中过时的方法" class="headerlink" title="4、 Thread类中过时的方法"></a>4、 Thread类中过时的方法</h3><p>由于线程安全问题，被弃用，如下：</p>
<ul>
<li>void suspend()：暂停当前线程。</li>
<li>void resume()：恢复当前线程。</li>
<li>void stop()：结束当前线程</li>
</ul>
<p>suspend()方法在调用之后不会释放已经占有的资源(锁)，然后进入睡眠状态，这样很容易导致死锁； stop()方法直接终止线程，不会保证线程资源的正常释放，导致程序处于不确定状态。对于suspend()和 resume()可以用上面提到的等待/通知机制代替，而 stop()方法可以用上面提到的终止线程运行的3种方式代替。</p>
<h2 id="七、线程的控制操作"><a href="#七、线程的控制操作" class="headerlink" title="七、线程的控制操作"></a>七、线程的控制操作</h2><p>下面来看一些可以控制线程的操作。</p>
<h3 id="1、线程休眠"><a href="#1、线程休眠" class="headerlink" title="1、线程休眠"></a>1、线程休眠</h3><p>让执行的线程暂停等待一段时间，进入计时等待状态，使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用sleep()后，当前线程放弃CPU，在指定的时间段内，sleep所在的线程不会获得执行的机会，在此状态下该线程不会释放同步锁。</p>
<h3 id="2、联合线程"><a href="#2、联合线程" class="headerlink" title="2、联合线程"></a>2、联合线程</h3><p>在线程中调用另一个线程的 join() 方法，会将当前线程置于阻塞状态，等待另一个线程完成后才继续执行，原理就是等待/通知机制，使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"JoinThread执行完毕！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        JoinThread joinThread = <span class="keyword">new</span> JoinThread();</span><br><span class="line">        joinThread.start();</span><br><span class="line">        System.out.println(<span class="string">"主线程等待..."</span>);</span><br><span class="line">        joinThread.join();<span class="comment">//主线程等join线程执行完毕后才继续执行</span></span><br><span class="line">        System.out.println(<span class="string">"主线程执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">主线程等待...</span><br><span class="line">JoinThread执行完毕！</span><br><span class="line">主线程执行完毕</span><br></pre></td></tr></table></figure>

<p>对于以上代码，主线程会等join线程执行完毕后才继续执行，因此最后的结果能保证join线程的输出先于主线程的输出。</p>
<h3 id="3、后台线程"><a href="#3、后台线程" class="headerlink" title="3、后台线程"></a>3、后台线程</h3><p>顾名思义，在后台运行的线程，其目的是为其他线程提供服务，也称“守护线程”，JVM的垃圾回收线程就是典型的后台线程，通过<strong>t.setDaemon(true)</strong>把一个线程设置为后台线程，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeamonThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//主线程不是后台线程，是前台线程</span></span><br><span class="line">        DeamonThread deamonThread = <span class="keyword">new</span> DeamonThread();</span><br><span class="line">        deamonThread.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置子线程为后台线程</span></span><br><span class="line">        deamonThread.start();</span><br><span class="line">        <span class="comment">//通过deamonThread.isDaemon()判断是否是后台线程</span></span><br><span class="line">        System.out.println(deamonThread.isDaemon());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">输出结果：<span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<p>后台线程有以下几个特点：</p>
<p>1、若所有的前台线程死亡，后台线程自动死亡，若前台线程没有结束，后台线程是不会结束的。</p>
<p>2、前台线程创建的线程默认是前台线程，可以通过setDaemon(true)设置为后台线程，在后台线程创建的新线程，新线程是后台线程。</p>
<p>注意：t.setDaemon(true)方法必须在start方法前调用，否则会报IllegalMonitorStateException异常</p>
<h3 id="4、线程优先级"><a href="#4、线程优先级" class="headerlink" title="4、线程优先级"></a>4、线程优先级</h3><p>当线程的时间片用完时就会发生线程调度，而线程优先级就是决定线程需要多或少分配一些CPU时间片的线程属性，在java中，通过一个成员变量priority来控制优先级，在线程构建时可以通过setPriority(int)方法来修改线程的优先级，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    PriorityThread priorityThread = <span class="keyword">new</span> PriorityThread();</span><br><span class="line">    priorityThread.setPriority(Thread.MAX_PRIORITY);<span class="comment">//10</span></span><br><span class="line">    priorityThread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先级范围从1到10，默认是5，优先级高的线程分配的时间片数量要多于优先级低的线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps: 在不同的JVM以及操作系统上，线程优先级规划会有差异，有些操作系统会忽略对线程优先级的设定，所以线程优先级不能作为程序正确性的依赖保证，因为操作系统可以完全不用理会线程优先级的设定</span><br></pre></td></tr></table></figure>

<h3 id="5、线程礼让"><a href="#5、线程礼让" class="headerlink" title="5、线程礼让"></a>5、线程礼让</h3><p>对静态方法 Thread.yield() 的调用，声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"已经完成重要部分，可以让其他线程获取CPU时间片"</span>);</span><br><span class="line">        Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。也就是说，就算你执行了这个方法，该线程还是有可能继续运行下去。</p>
<h3 id="6、线程组"><a href="#6、线程组" class="headerlink" title="6、线程组"></a>6、线程组</h3><p>java.lang.ThreadGroup类表示线程组，可以对一组线程进行集中管理，当用户在创建线程对象时，可以通过构造器指定其所属的线程组：Thread(ThreadGroup group, String name)。</p>
<p>如果A线程创建B线程，如果没有设置B线程的分组，那么B线程加入到A线程的线程组，一旦线程加入某个线程组，该线程就一直存在于该线程组中直到线程死亡，不能在中途修改线程的分组。</p>
<p>当java程序运行时，JVM会创建名为main的线程组，在默认情况下，所以的线程都属于该线程组。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文到这里就结束了，在平时开发中我们一般都只会使用线程，但却很少去了解线程的生命周期、通信机制等，但我们不要忽略掉这些知识点，它们都是<strong>面试常客</strong>，也是非常的重要，在java中，一般不推荐你直接<strong>new</strong>一个线程使用，如果你需要创建的线程数量非常多的话，这时就需要使用<a href="https://blog.csdn.net/Rain_9155/article/details/90757694" target="_blank" rel="noopener"><strong>线程池</strong></a>来帮助你管理线程的创建，在线程的内部中，还有一个用于存储数据的<strong>Map集合</strong>，java提供了一个<a href="https://blog.csdn.net/Rain_9155/article/details/86768467" target="_blank" rel="noopener"><strong>ThreadLocal</strong></a>类来操作这些集合，ThreadLocal在多线程环境下可以很好的保证了这些数据只能为本线程使用，从而避免了并发问题。</p>
<p>以上就是我对线程的总结，希望对大家有所帮助。</p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最後更新時間：<time datetime="2023-01-07T10:44:48.887Z" itemprop="dateUpdated">2023-01-07 18:44:48</time>
</span><br>


        
        谢谢大家的阅读！
        
    </div>
    
    <footer>
        <a href="http://yoursite.com">
            <img src="/img/avatar.jpg" alt="rain9155">
            rain9155
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag">线程</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/&title=《java学习总结之线程》 — jianyu的博客&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/&title=《java学习总结之线程》 — jianyu的博客&source=前言在java中，线程非常重要，我们要分清楚进程和线程的区别：进程是操作系统中资源分配的基本单位，进程是指一个内存中运行的应用程序，每个进程都拥有自己的一..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《java学习总结之线程》 — jianyu的博客&url=http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/07/19/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">java学习总结之线程池</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/07/19/java%E5%9F%BA%E7%A1%80/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">java学习总结之基础</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢打赏!
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>本部落格係採用<a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/deed.zh_TW" target="_blank">創用 CC 姓名標示 4.0 國際 授權條款授權</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>rain9155 &copy; 2018 - 2023</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/&title=《java学习总结之线程》 — jianyu的博客&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/&title=《java学习总结之线程》 — jianyu的博客&source=前言在java中，线程非常重要，我们要分清楚进程和线程的区别：进程是操作系统中资源分配的基本单位，进程是指一个内存中运行的应用程序，每个进程都拥有自己的一..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《java学习总结之线程》 — jianyu的博客&url=http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2019/07/19/java%E7%BA%BF%E7%A8%8B/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACL0lEQVR42u3aUa6DMAwFUfa/afpbiULn2rQSzuSreiUkp0+yEtvbhsd+GMdvr59/f+b4/HHW9oshQ4aMxzL2y9HZFt9ouu6HFWXIkLEA42xJstGzJ9MAzdeVIUOGDPK6Wtglhz8ZMmTIuJdBZqXvkSFDhozOJZYn1ziMHy5vu4vLkCHjgQyeJvv/55/UN2TIkPEoxh6ONAhez03D6+mKMmTIGM2opcnSa2oniAdpOxkyZAxldA5qaQiurYWurDJkyBjN6LRNpImw9NtaUUGGDBmzGbyFqx/l0hwaWVGGDBlTGbVGh1pOnl+MyZH09BIrQ4aMcQw+4d7oTto14hSeDBkyhjLSK2KtVFlL3vGLtAwZMlZgpM0Qta2nV9mgjUOGDBmjGWlTRZrE50dAXgYIarMyZMgYwUi3W0u9dQ5/6NgqQ4aMBRid1opOSZKsjq7ZMmTIGM0IUlo4IJKyZa1pA3WLyJAhYxkG/0w2VwvfcaJNhgwZoxlp+KsVEjrNZMUuEhkyZAxikKtpuiHyQ6SFhC+7kiFDxgIMvnA/ScdbMXjqTYYMGSsweNjtFwxqJ9Yvs2TIkDGUsYeDvDrtRKsFWfR/kCFDxghGrVWCv64TWPsFCRkyZExi8Ktm+qvU2shqP5kMGTJWYKSBr9MwwfcQPClDhgwZYIu83MgbMopdITJkyFie0Wnk4myekpMhQ8Y6jHRbtbnpe3giT4YMGbMZ6bmrdpRMU2m1v8iQIWMc4wW8KgPxZjH01wAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>








<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '去哪里了?';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎光临!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
