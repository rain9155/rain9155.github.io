<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>揭秘kotlin协程的实现原理 | jianyu的博客 | 每天进步一点点</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#009688">
    
    
    <meta name="keywords" content="协程">
    <meta name="description" content="前言 上一篇文章：揭秘kotlin协程中的CoroutineContext  上一篇文章中介绍了kotlin协程的CoroutineContext的主要组成以及它的结构，kotlin协程的CoroutineContext它是一个K-V数据结构，保存了跟协程相关联的运行上下文例如协程的线程调度策略、异常处理逻辑、日志记录、运行标识、名字等，本篇文章是作为上一篇文章的补充，在使用kotlin协程一年多">
<meta property="og:type" content="article">
<meta property="og:title" content="揭秘kotlin协程的实现原理">
<meta property="og:url" content="http://yoursite.com/2022/05/26/%E6%8F%AD%E7%A7%98kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="jianyu的博客">
<meta property="og:description" content="前言 上一篇文章：揭秘kotlin协程中的CoroutineContext  上一篇文章中介绍了kotlin协程的CoroutineContext的主要组成以及它的结构，kotlin协程的CoroutineContext它是一个K-V数据结构，保存了跟协程相关联的运行上下文例如协程的线程调度策略、异常处理逻辑、日志记录、运行标识、名字等，本篇文章是作为上一篇文章的补充，在使用kotlin协程一年多">
<meta property="og:image" content="http://yoursite.com/2022/05/26/%E6%8F%AD%E7%A7%98kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/coroutines1.png">
<meta property="article:published_time" content="2022-05-25T18:56:26.000Z">
<meta property="article:modified_time" content="2023-01-07T10:44:49.155Z">
<meta property="article:author" content="rain9155">
<meta property="article:tag" content="协程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2022/05/26/%E6%8F%AD%E7%A7%98kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/coroutines1.png">
    
        <link rel="alternate" type="application/atom+xml" title="jianyu的博客" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">rain9155</h5>
          <a href="mailto:jianyu9155@gmail.com" title="jianyu9155@gmail.com" class="mail">jianyu9155@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/rain9155" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://juejin.im/user/5b437173e51d45191d79c27a/posts" target="_blank" >
                <i class="icon icon-lg icon-gg"></i>
                Juejin
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://blog.csdn.net/Rain_9155" target="_blank" >
                <i class="icon icon-lg icon-eye"></i>
                CSDN
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.jianshu.com/u/93cb7ffd83e9" target="_blank" >
                <i class="icon icon-lg icon-book"></i>
                Jianshu
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/links"  >
                <i class="icon icon-lg icon-link"></i>
                Links
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">揭秘kotlin协程的实现原理</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="検索">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">揭秘kotlin协程的实现原理</h1>
        <h5 class="subtitle">
            
                <time datetime="2022-05-25T18:56:26.000Z" itemprop="datePublished" class="page-time">
  2022-05-26
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/kotlin/">kotlin</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Continuation和CPS"><span class="post-toc-text">Continuation和CPS</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#suspend方法的实现"><span class="post-toc-text">suspend方法的实现</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#intrinsics方法"><span class="post-toc-text">intrinsics方法</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Continuation的恢复"><span class="post-toc-text">Continuation的恢复</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#自己实现Coroutine"><span class="post-toc-text">自己实现Coroutine</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结语"><span class="post-toc-text">结语</span></a></li></ol>
        </nav>
    </aside>


<article id="post-揭秘kotlin协程的实现原理"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">揭秘kotlin协程的实现原理</h1>
        <div class="post-meta">
            <time class="post-time" title="2022-05-26 02:56:26" datetime="2022-05-25T18:56:26.000Z"  itemprop="datePublished">2022-05-26</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/kotlin/">kotlin</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>上一篇文章：<a href="https://juejin.cn/post/6926695962354122765#heading-0" target="_blank" rel="noopener">揭秘kotlin协程中的CoroutineContext</a></li>
</ul>
<p>上一篇文章中介绍了kotlin协程的CoroutineContext的主要组成以及它的结构，kotlin协程的CoroutineContext它是一个K-V数据结构，保存了跟协程相关联的运行上下文例如协程的线程调度策略、异常处理逻辑、日志记录、运行标识、名字等，本篇文章是作为上一篇文章的补充，在使用kotlin协程一年多之后，对kotlin协程的实现有了新的认识，本文会深入介绍kotlin协程的实现原理，例如Continuation和CPS，suspend方法的含义以及背后的原理，协程是如何被创建、启动、调度，同时使用kotlin-stdlib提供的intrinsics原语实现一个简化版的协程，从而帮助我们更好地理解kotlin协程的整个设计思想，kotlin协程的源码被放在了两个库中，一部分是在kotlin标准库<a href="https://github.com/JetBrains/kotlin/tree/1.4.0/libraries/stdlib/src/kotlin/coroutines" target="_blank" rel="noopener">kotlin-stdlib</a>中，一部分是在kotlin协程官方实现库<a href="https://github.com/Kotlin/kotlinx.coroutines/tree/native-mt-1.4.20/kotlinx-coroutines-core" target="_blank" rel="noopener">kotlinx-coroutines</a>中，其中kotlinx-coroutines是基于kotlin-stdlib的，kotlin-stdlib库提供了实现协程所需的基本原语。</p>
<blockquote>
<p>本文涉及到的源码都是基于kotlin1.4版本</p>
</blockquote>
<h2 id="Continuation和CPS"><a href="#Continuation和CPS" class="headerlink" title="Continuation和CPS"></a>Continuation和CPS</h2><p>在讲解协程的原理之前，我们先来了解一下Continuation和CPS，理解了这两个术语，那么后面对于协程的理解就非常容易了：</p>
<p><strong>Continuation</strong></p>
<p><a href="https://en.wikipedia.org/wiki/Continuation" target="_blank" rel="noopener">Continuation</a>延续在计算机中表示<strong>程序剩余的部分</strong>，它保存了程序从某一点开始的执行状态，并能够在稍后的时间让程序回到这一点恢复执行，所以它是一种能够保存程序执行状态的数据结构，像break、continue这类控制流操作符一样可以暴露给用户使用，用户通过操作Continuation来控制程序的执行顺序，Continuation的概念在上个世纪五、六十年代就被提出来，首次实现Continuation的编程语言是上个世纪70年代的<a href="https://en.wikipedia.org/wiki/Scheme_(programming_language)" target="_blank" rel="noopener">Scheme</a>语言，在Scheme语言中它引入了<strong>call/cc</strong>关键字 - <a href="https://en.wikipedia.org/wiki/Call-with-current-continuation" target="_blank" rel="noopener">call-with-current-continuation</a>，通过call/cc关键字我们可以捕获程序当前剩余的执行状态保存到Continuation中，并在之后适当的时候执行Continuation以恢复到捕获Continuation时所在的上下文继续执行，由于我不熟悉Schema语言，这里我用kotlin来模拟这个关键字，<strong>假设</strong>kotlin有call/cc关键字，它是这样使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//pause</span></span><br><span class="line">    <span class="keyword">val</span> result = call/cc &#123; continuation -&gt;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        continuation(<span class="string">"world"</span>)</span><br><span class="line">        <span class="comment">//ignore</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"world!"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//resume</span></span><br><span class="line">    println(<span class="string">"hello <span class="variable">$result</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行输出：</span></span><br><span class="line"><span class="comment">//hello world</span></span><br></pre></td></tr></table></figure>

<p>call/cc接收一个带有一个参数的函数，这个参数就是current-continuation表示程序剩余的部分，当程序运行到call/cc时，它会暂停程序后续的执行并捕获程序当前剩余的部分作为参数传进call/cc接收的函数中，然后执行这个函数，然后在适当的时候我们可以调用continuation，continuation接收一个参数作为call/cc的返回值，一旦我们调用continuation后，函数后面的部分就不会继续执行而是返回到call/cc调用处继续执行，而如果我们不调用continuation，那么函数就会正常执行完毕返回，这时call/cc的返回值就是函数的返回值，由于我们这里调用了continuation，所以这里程序恢复后输出了”hello world”，这就是使用call/cc应用Continuation的一个简单例子，通过Continuation我们还可以实现更为复杂的场景例如<a href="https://en.wikipedia.org/wiki/Exception_handling" target="_blank" rel="noopener">异常处理</a>，这里继续通过call/cc实现一个异常处理try catch能力：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tryCatch(&#123;</span><br><span class="line">         <span class="comment">//do something,</span></span><br><span class="line">         throwException(IllegalAccessException(<span class="string">"something error"</span>))</span><br><span class="line">    &#125;, &#123; e: Exception -&gt;</span><br><span class="line">        <span class="comment">//continue</span></span><br><span class="line">        println(<span class="string">"catch <span class="variable">$e</span>"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  	println(<span class="string">"finish"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> continuationStack = Stack&lt;Continuation&gt;()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">tryCatch</span><span class="params">(tryBlock: () -&gt; <span class="type">Unit</span>, catchBlock: (<span class="type">e</span>: <span class="type">Exception</span>) -&gt; <span class="type">Unit</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> result = call/cc &#123; continuation -&gt;</span><br><span class="line">        funStack.add(continuation)</span><br><span class="line">        <span class="keyword">return</span> tryBlock()</span><br><span class="line">    &#125;</span><br><span class="line">    funStack.pop()</span><br><span class="line">    <span class="keyword">if</span>(result <span class="keyword">is</span> Exception) &#123;</span><br><span class="line">        catchBlock(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">throwException</span><span class="params">(e: <span class="type">Exception</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(continuationStack.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> continuation = continuationStack.peek()</span><br><span class="line">        continuation(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行输出：</span></span><br><span class="line"><span class="comment">//catch IllegalAccessException: something error</span></span><br><span class="line"><span class="comment">//finish</span></span><br></pre></td></tr></table></figure>

<p>tryCatch方法接收两个函数：一个是正常代码执行主体tryBlock，一个是异常处理执行主体catchBlock，每次在执行tryBlock前都会把当前捕获的延续Continuation压入栈中，然后每次调用throwException方法抛出异常时都会弹出最近的Continuation传入异常恢复外部执行，如果tryBlock正常返回即没有调用throwException方法，这时call/cc的返回值是一个Unit类型，如果tryBlock出现异常即调用了throwException方法抛出异常，那么这时call/cc的返回值是一个Exception类型，这时就调用catchBlock处理异常，这样就通过Continuation实现了一个简单的try catch能力，这里我们也可以看到Continuation的作用，可以让我们灵活的控制程序的执行，除了异常处理，Continuation也可以被运用来实现<a href="https://en.wikipedia.org/wiki/Coroutine#Mutual_recursion" target="_blank" rel="noopener">协程</a>、<a href="https://en.wikipedia.org/wiki/Generator_(computer_programming)" target="_blank" rel="noopener">生成器</a>等，后面我们就会看到kotlin协程的实现原理。</p>
<p><strong>CPS</strong></p>
<p>介绍完Continuation，继续来了解一下<a href="https://en.wikipedia.org/wiki/Continuation-passing_style" target="_blank" rel="noopener">CPS</a>即Continuation-passing Style延续传递风格，它是Continuation在<a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener">函数式编程</a>中的应用，像一些支持函数式编程的编程语言例如scheme、kotlin、js、py、C#等都可以把它们的函数转化为CPS风格，CPS风格的函数有以下特点：</p>
<p>1、函数没有return语句；</p>
<p>2、函数都有一个额外的Continuation参数；</p>
<p>3、函数内对于Continuation的传递调用都是<a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank" rel="noopener">尾调用</a>。</p>
<p>先看一个普通的函数的调用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> result = add(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    println(<span class="string">"<span class="variable">$result</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面定义了一个add方法，调用它返回两个参数相加的结果，接下把它翻译成CPS函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">1</span>) &#123; result -&gt;  </span><br><span class="line">        println(<span class="string">"<span class="variable">$result</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, continuation: (<span class="type">result</span>: <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    continuation(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到CPS风格的add方法与普通的add方法多了一个continuation参数，用来表示外部的控制流，当方法需要返回时，就调用传进来的continuation代替return语句，当调用传进来的continuation后，外部代码的逻辑就继续执行。</p>
<p>下面再看一个嵌套的函数调用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> result = squareAdd(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    println(<span class="string">"<span class="variable">$result</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">squareAdd</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> add(square(a), square(b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">square</span><span class="params">(c: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c * c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面定义了一个squareAdd方法，调用它返回两个平方的相加结果，把它翻译成CPS函数：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    squareAdd(<span class="number">1</span>, <span class="number">1</span>) &#123; result -&gt;  </span><br><span class="line">        println(<span class="string">"<span class="variable">$result</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">squareAdd</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>,  continuation: (<span class="type">result</span>: <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    square(a) &#123; aSquareResult -&gt;</span><br><span class="line">        square(b) &#123; bSquareResult -&gt;</span><br><span class="line">            add(aSquareResult, bSquareResult) &#123; abAddResult -&gt;</span><br><span class="line">                continuation(abAddResult)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">add</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>, continuation: (<span class="type">result</span>: <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    continuation(a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">square</span><span class="params">(c: <span class="type">Int</span>, continuation: (<span class="type">result</span>: <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    continuation(c * c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到CPS风格的squareAdd方法里面不断的嵌套调用其他方法，并且调用其他方法传递Continuation时都是尾调用，尾调用就是在函数的末尾调用了另外一个函数而没有做其他操作，相应地，如果在函数的末尾调用地是函数本身，那么这就叫做尾递归，每个CPS风格的方法就是这样不断地在尾部调用其他方法并把自己当前的延续Continuation传递给调用的方法，这就是<strong>Continuation-passing延续传递</strong>名字的由来，从本质讲，CPS方法就是一个回调函数，Continuation相当于一个回调，每个CPS方法只能通过Continuation回调来恢复程序的后续逻辑执行，随着代码的复杂度提升，方法的调用数变多，CPS方法的嵌套深度也会越来越深，代码的可读性也会越来越差，出现回调地狱callback-hell现象，同时如果编译器不支持尾调用优化，那么CPS方法很容易就出现栈溢出错误。</p>
<blockquote>
<p>如果编译器支持，尾调用和尾递归都可以进行优化，尾调用由于不需要依赖调用方，所以调用方函数的栈帧可以直接被尾调用函数的栈帧代替，如果所有函数都是都是尾调用，那么调用方就可以直接goto到最深处调用的函数，减少调用栈帧从而避免了栈溢出，同时减少了栈帧的内存消耗，这就是尾调用优化，而尾递归除了可以应用尾调用优化外，它还有自己特属的优化方法，由于尾递归的特殊性，我们可以把一个尾递归函数展开为一个循环调用，这样也减少了调用栈帧和内存消耗，这就是尾递归优化，kotlin中可以通过<strong>tailrec</strong>修饰符让编译器对一个尾递归函数进行优化，不管是尾调用优化和还是尾递归优化，它们都改变了原本函数的调用栈帧，所以会让debug变得困难，这也是为什么支持尾调用和尾递归优化的编译器不默认打开这个选项的原因。</p>
</blockquote>
<p>那么CPS存在的意义是什么？其实CPS方法主要是作为高级语言的一种中间表示IR，把高级语言的方法逻辑编译成CPS风格，可以大大地减少编译器的实现复杂度，当程序被编译成CPS时，方法会被划分成不可再分割的最小粒度例如基本的运算、基本的方法调用等，例如 1 + 2 + 3 * 4 的计算翻译成CPS风格：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   calculate &#123;</span><br><span class="line">       println(it)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate</span><span class="params">(continuation: (<span class="type">result</span>: <span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    &#123; cont1: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span> -&gt;</span><br><span class="line">        cont1(<span class="number">3</span> * <span class="number">4</span>)</span><br><span class="line">    &#125;(&#123; mul: <span class="built_in">Int</span> -&gt;</span><br><span class="line">        &#123; cont2: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span> -&gt;</span><br><span class="line">            cont2(<span class="number">2</span> + mul)</span><br><span class="line">        &#125;(&#123; add: <span class="built_in">Int</span> -&gt;</span><br><span class="line">            &#123; cont3: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Unit</span> -&gt;</span><br><span class="line">                cont3(<span class="number">1</span> + add)</span><br><span class="line">            &#125;(&#123; result: <span class="built_in">Int</span> -&gt;</span><br><span class="line">                continuation(result)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到每一条基本的计算语句(+、*)都会被包含在一个函数中，每个函数只负责基本的运算，然后原函数剩余的部分被包装在Continuation中，这对于用户来说可能比较难以阅读，但对于编译器来说这会让程序的语法分析更加简单，同时CPS所有的控制流例如if else、try catch等都会通过Continuation显式表示出来，这时编译器可以直接进行控制流分析，同时在CPS的基础上还可以进行尾调用优化等手段，如果对CPS这些编译优化感兴趣的可以阅读下面链接：</p>
<p><a href="https://www.gnu.org/software/guile/manual/html_node/Compiling-CPS.html" target="_blank" rel="noopener">Compiling CPS</a></p>
<p><a href="https://www.reddit.com/r/haskell/comments/d5tutb/what_optimizations_cps_transformations_enables/" target="_blank" rel="noopener">What optimizations CPS transformations enables / disables</a></p>
<p>CPS除了应用在编译器中，还可以应用在异步编程中，异步编程就是我们以不阻塞当前线程的方式来获取一个耗时操作的执行结果，例如网络请求、IO读取等，在Android中一般通过callback实现异步编程，但是通过callback进行异步编程是很困难，因为程序的逻辑被分散到各个callback，程序的连续性被打破，同时当每个callback相互依赖时就会出现callback-hell，让代码可读性降低，我们还需要额外去维护每一个callback，前面讲过CPS方法本质上是一个callback方法，所以通过CPS方法也可以处理异步编程的场景，由于CPS方法遵循一定的规则，所有编程语言就很容易替我们完成CPS转换和Continuation管理，不用我们编写复杂的CPS代码，例如js、c#中的async/await、kotlin中的suspend关键字等，这些都是语法糖，通过这些关键字修饰的一些方法都会有CPS转换的过程，可以让我们像编写同步代码那样编写异步代码，可以在一定的范围内保持程序的连续性，例如下面login和fetchData都是异步方法，fetchData方法依赖login方法，displayUI方法依赖fetchData方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js</span></span><br><span class="line">async function display() &#123;</span><br><span class="line">  <span class="keyword">var</span> user = await login(); <span class="comment">//async方法</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">data</span> = await fetchData(user); <span class="comment">//async方法</span></span><br><span class="line">  displayUI(<span class="keyword">data</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c#</span></span><br><span class="line">async void display() &#123;</span><br><span class="line">  <span class="keyword">var</span> user = await login(); <span class="comment">//async方法</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">data</span> = await fetchData(user); <span class="comment">//async方法</span></span><br><span class="line">  displayUI(<span class="keyword">data</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//kotlin</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">display</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> user = login() <span class="comment">//suspend方法</span></span><br><span class="line">   <span class="keyword">val</span> userData = fetchData(user) <span class="comment">//suspend方法</span></span><br><span class="line">   displayUI(userData)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即使login和fetchData方法是异步的，但是上面的整个运行过程都是线性的，每一个方法都会等前一个方法返回后再继续执行，这就是Continuation和CPS在异步编程中的应用，对方法进行CPS转换时，首先要进行call/cc处理即捕获当前延续Continuation，然后还要处理不同Continuation之间的流转，实现暂停和恢复，每个编程语言对于这些实现是不一样，主流的有<strong>生成器</strong>和<strong>状态机</strong>两种实现方式，js中通过<a href="https://dev.to/yelouafi/algebraic-effects-in-javascript-part-1---continuations-and-control-transfer-3g88" target="_blank" rel="noopener">生成器</a>实现，而c#和kotlin则是通过<a href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank" rel="noopener">状态机</a>的方式实现，得益于编程语言的良好封装，我们通过这些语法糖编写异步代码时不用再去维护每一个callback，不用再考虑这些复杂的处理。</p>
<h2 id="suspend方法的实现"><a href="#suspend方法的实现" class="headerlink" title="suspend方法的实现"></a>suspend方法的实现</h2><p>通过前面的介绍，相信大家已经猜到kotlin suspend方法的实现原理，suspend就是一个语法糖，当我们用suspend修饰命名方法或者匿名、lambda方法时，kotlin编译器会替我们把suspend方法进行CPS转换，转化后的方法会多一个额外的名为completion的Continuation类型参数，原本的返回值类型会移动到Continuation的类型参数中，并且把返回值用Any类型表示，例如命名方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span>: String</span><br></pre></td></tr></table></figure>

<p>转化为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(completion: <span class="type">Continuation</span>&lt;<span class="type">String</span>&gt;)</span></span>: Any?</span><br></pre></td></tr></table></figure>

<p>再例如lambda方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> () -&gt; String</span><br></pre></td></tr></table></figure>

<p>转化为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(completion: Continuation&lt;String&gt;) -&gt; Any?</span><br></pre></td></tr></table></figure>

<p>其实kotlin中的每个lambda方法都会对应一个<a href="https://github.com/JetBrains/kotlin/blob/1.4.0/libraries/stdlib/jvm/runtime/kotlin/jvm/functions/Functions.kt" target="_blank" rel="noopener">Function</a>类型, 如果lambda方法没有参数就对应Function0类型，如果lambda方法有一个参数就对应Function1类型，以此类推，每个Function类都有一个invoke方法，invoke方法的参数就对应lambda方法的参数，invoke方法的返回值就对应lambda方法的返回值，调用Function类实例的invoke方法就相当于调用对应的lambda方法，所以上面CPS转化后的lambda方法在kotlin中实际表示为：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XXX就是lambda方法对应类的名称，会根据所在类、所在方法用$符号拼接而成</span></span><br><span class="line"><span class="comment">//这里是简化版，实际情况还会实现一个SuspendLambda抽象类，SuspendLambda继承自ContinuationImpl，后面会讲到</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXX</span> : <span class="type">Function1</span>&lt;<span class="type">Continuation&lt;String</span>&gt;, <span class="type">Any?&gt; &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(completion: <span class="type">Continuation</span>&lt;<span class="type">String</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>suspend方法CPS后的方法都返回值用一个Any类型表示，它是<strong>T | COROUTINE_SUSPENDED</strong>的组合类型，T表示suspend方法同步执行返回时的类型，例如这里返回为String类型，当suspend方法不需要挂起时，suspend方法就正常返回对应的值或者抛出异常，COROUTINE_SUSPENDED表示suspend方法需要挂起时返回的一个枚举类型，当suspend方法需要挂起时，suspend方法就返回COROUTINE_SUSPENDED表示这个suspend方法被挂起，最终真正执行挂起动作返回COROUTINE_SUSPENDED的地方是kotlin intrinsics提供的<strong>suspendCoroutineUninterceptedOrReturn</strong>方法，这个方法可以捕获传递过来的Continuation，然后决定是否挂起，kotlin协程库提供的一些封装好的挂起方法如withContext、delay、await等最终都是调用这个方法捕获Continuation和执行挂起动作，我们编写suspend方法时也可以直接使用这个方法，实现我们自己的挂起逻辑，后面在intrinsics中会介绍这个方法。</p>
<p>当一个suspend方法被挂起，说明这个suspend方法不能马上同步返回对应的结果，而是在稍后准备好时再通过调用Continuation的<strong>resumeWith</strong>方法从挂起点恢复返回结果，Continuation在kotlin中是一个接口：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T为suspend方法的返回值类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Continuation</span>&lt;<span class="type">in T</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//当前延续的上下文</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> context: CoroutineContext</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当需要从挂起点恢复时调用这个方法，result可以表示正常恢复还是异常恢复</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>挂起点suspend point就是调用suspend方法的地方，当我们在suspend方法中调用suspend方法时，每一个suspend方法的调用处就是一个挂起点，整个suspend方法被挂起点分割成多个部分，每一个部分都对应一个Continuation，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">display</span><span class="params">()</span></span> &#123;     </span><br><span class="line">    <span class="keyword">val</span> user = login() <span class="comment">//suspend方法，挂起点1     </span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span> = fetchData(user) <span class="comment">//suspend方法，挂起点2   </span></span><br><span class="line">    displayUI(<span class="keyword">data</span>) <span class="comment">//普通方法                         </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">  	delay(<span class="number">200</span>) <span class="comment">//suspend方法，延迟200ms后返回</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="string">"user"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">(user: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"<span class="variable">$user</span> data"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">displayUI</span><span class="params">(<span class="keyword">data</span>: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"displayUI: <span class="variable">$data</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据挂起点划分，上面display方法有三个延续Continuation：</p>
<p>1、初始Continuation，整个display方法就是一个Continuation；</p>
<p>2、子Continuation1，挂起点1到display方法结尾；</p>
<p>3、子Continuation2，挂起点2到display方法结尾。</p>
<p>类似地，login方法有两个延续，kotlin并不会像传统的CPS处理那样为每一个Continuation创建对应的实例，kotlin只会为整个suspend方法创建一个初始Continuation实例，然后在这个Continuation实例内部通过<strong>状态机</strong>进行流转，每个挂起点对应状态机中的一个状态，通过状态机就可以复用一个Continuation实例就能达到在多个挂起点之间进行挂起和恢复的效果，减少了Continuation实例的创建数量，下面是display方法的对应实现，是经过简化后的版本：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">display</span><span class="params">(completion: <span class="type">Continuation</span>&lt;<span class="type">Unit</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//display方法的状态机，继承自ContinuationImpl</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DisplayStateMachine</span></span>(</span><br><span class="line">        <span class="comment">//completion是调用display方法时传递进来的，当display执行完毕时，通过completion恢复外部执行</span></span><br><span class="line">        completion: Continuation&lt;<span class="built_in">Unit</span>&gt;</span><br><span class="line">    ) : ContinuationImpl(completion) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存每个挂起点恢复后的结果</span></span><br><span class="line">        <span class="keyword">var</span> result: Result&lt;Any?&gt; = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前display方法的状态</span></span><br><span class="line">        <span class="keyword">var</span> label: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当invokeSuspend被调用时，再次调用display方法，这时result会是前一个状态的结果，而label也已处于将要执行的状态</span></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeSuspend</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any? &#123;</span><br><span class="line">            <span class="keyword">this</span>.result = result</span><br><span class="line">            <span class="keyword">return</span> display(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是第一次调用display方法，就创建状态机实例，如果不是第一次调用，继续执行状态</span></span><br><span class="line">    <span class="keyword">val</span> continuation = completion <span class="keyword">as</span>? DisplayStateMachine ?: DisplayStateMachine(completion)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//COROUTINE_SUSPENDED标记，用于判断是否挂起</span></span><br><span class="line">    <span class="keyword">val</span> val0 = COROUTINE_SUSPENDED</span><br><span class="line"></span><br><span class="line">    <span class="keyword">when</span>(continuation.label) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">//错误检查</span></span><br><span class="line">            continuation.result?.getOrThrow()</span><br><span class="line">            <span class="comment">//下次display方法被调用时, 它应当直接去到状态1</span></span><br><span class="line">            continuation.label = <span class="number">1</span></span><br><span class="line">            <span class="comment">//调用login方法，传入continuation</span></span><br><span class="line">            <span class="keyword">val</span> val1 = login(continuation)</span><br><span class="line">            <span class="comment">//判断是否挂起</span></span><br><span class="line">            <span class="keyword">if</span>(val1 == val0) &#123;</span><br><span class="line">                <span class="comment">//如果挂起，直接return，后面通过传进login方法的continuation恢复当前状态机执行</span></span><br><span class="line">                <span class="keyword">return</span> val0</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有挂起，继续执行，下面流程跟label1类似</span></span><br><span class="line">            <span class="keyword">val</span> user = val1 <span class="keyword">as</span> String</span><br><span class="line">            continuation.label = <span class="number">2</span></span><br><span class="line">            <span class="keyword">val</span> val2 = fetchData(user, continuation)</span><br><span class="line">            <span class="keyword">if</span>(val2 == val0) &#123;</span><br><span class="line">                <span class="keyword">return</span> val0</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">data</span> = val2 <span class="keyword">as</span> String</span><br><span class="line">            continuation.label = -<span class="number">1</span></span><br><span class="line">            displayUI(<span class="keyword">data</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Unit</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">1</span> -&gt; &#123;</span><br><span class="line">            <span class="comment">//错误检查, 并获取前一个状态的结果</span></span><br><span class="line">            <span class="keyword">val</span> user = continuation.result?.getOrThrow() <span class="keyword">as</span> String</span><br><span class="line">          	<span class="comment">//下次display方法被调用时, 它应当直接去到状态2</span></span><br><span class="line">            continuation.label = <span class="number">2</span></span><br><span class="line">            <span class="comment">//调用fetchData方法，传入continuation</span></span><br><span class="line">            <span class="keyword">val</span> val2 = fetchData(user, continuation)</span><br><span class="line">            <span class="comment">//判断是否挂起</span></span><br><span class="line">            <span class="keyword">if</span>(val2 == val0) &#123;</span><br><span class="line">                <span class="comment">//如果挂起，直接return，后面通过传进fetchData方法的continuation恢复当前状态机执行</span></span><br><span class="line">                <span class="keyword">return</span> val0</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有挂起，继续执行，下面流程跟label2类似</span></span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">data</span> = val2 <span class="keyword">as</span> String</span><br><span class="line">            continuation.label = -<span class="number">1</span></span><br><span class="line">            displayUI(<span class="keyword">data</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Unit</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">2</span> -&gt; &#123;</span><br><span class="line">          	<span class="comment">//错误检查, 并获取前一个状态的结果</span></span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">data</span> = continuation.result?.getOrThrow() <span class="keyword">as</span> String</span><br><span class="line">            <span class="comment">//display方法执行完毕，把label置为非法状态</span></span><br><span class="line">            continuation.label = -<span class="number">1</span></span><br><span class="line">            displayUI(<span class="keyword">data</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Unit</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalStateException(<span class="string">"call to 'resume' before 'invoke' with coroutine"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">login</span><span class="params">(completion: <span class="type">Continuation</span>&lt;<span class="type">String</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="comment">//login方法的状态机, 跟display方法的类似</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LoginStateMachine</span></span>(</span><br><span class="line">        <span class="comment">//completion是调用login方法时传递进来的，当login执行完毕时，通过completion恢复外部执行</span></span><br><span class="line">        completion: Continuation&lt;<span class="built_in">Unit</span>&gt;</span><br><span class="line">    ) : ContinuationImpl(completion) &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">var</span> result: Result&lt;Any?&gt; = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> label: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeSuspend</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any? &#123;</span><br><span class="line">            <span class="keyword">this</span>.result = result</span><br><span class="line">            <span class="keyword">return</span> login(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> continuation = completion <span class="keyword">as</span>? LoginStateMachine ?: LoginStateMachine(completion)</span><br><span class="line">    <span class="keyword">val</span> val0 = COROUTINE_SUSPENDED</span><br><span class="line">    <span class="keyword">when</span>(continuation.label) &#123;</span><br><span class="line">        <span class="number">0</span> -&gt; &#123;</span><br><span class="line">            continuation.result?.getOrThrow()</span><br><span class="line">            continuation.label = <span class="number">1</span></span><br><span class="line">            <span class="keyword">val</span> val1 = delay(continuation)</span><br><span class="line">            <span class="keyword">if</span>(val1 == val0) &#123;</span><br><span class="line">                <span class="keyword">return</span> val0</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"user"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">1</span> -&gt; &#123;</span><br><span class="line">            continuation.result?.getOrThrow()</span><br><span class="line">            continuation.label = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"user"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalStateException(<span class="string">"call to 'resume' before 'invoke' with coroutine"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">(user: <span class="type">String</span>, completion: <span class="type">Continuation</span>&lt;<span class="type">String</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"<span class="variable">$user</span> data"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">displayUI</span><span class="params">(<span class="keyword">data</span>: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"displayUI: <span class="variable">$data</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到display和login方法都创建了对应的状态机，每个延续都对应状态机的一个状态，每个状态机都继承自<strong>ContinuationImpl</strong>，ContinuationImpl的父类是<strong>BaseContinuationImpl</strong>，它实现了<strong>Continuation</strong>的resumeWith方法并且含有一个invokeSuspend抽象方法，所以每个状态机都会实现这个invokeSuspend方法，并且每个状态机都会持有一个外部的完成延续Continuation，用来在当前状态机运行结束时恢复外部的Continuation，关于Continuation的恢复后面会讲。</p>
<p>当suspend方法第一次被调用时就会创建一个状态机，这时状态机是初始状态，对应执行初始延续的逻辑，每执行完一个状态，都会把状态机的状态提前置为下一个状态，当要执行下一个状态时，只需要再次调用suspend方法就行，而这个再次调用就由<strong>invokeSuspend</strong>方法来完成，invokeSuspend方法中会调用suspend方法进行<strong>状态流转</strong>，而invokeSuspend方法会被<strong>resumeWith方</strong>法调用，而Continuation的resumeWith方法什么时候调用，就是由我们自己决定的，因为最终suspend方法的状态机Continuation会被传递到kotlin intrinsics提供的<strong>suspendCoroutineUninterceptedOrReturn</strong>方法中，在这个方法中我们可以捕获到这个Continuation，并决定什么时候调用这个Continuation到resumeWith方法。</p>
<p>上面的display和login方法都是命名suspend方法，对于suspend lambda方法，kotlin编译器也会对它进行CPS转换并且创建状态机，不同的是suspend lambda方法的状态机是继承自<strong>SuspendLambda</strong>类，而SuspendLambda是ContinuationImpl的子类，例如我们通过launch方法传递<strong>block块</strong>启动协程：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   GlobalScope.launch &#123;<span class="comment">//suspend lambda方法</span></span><br><span class="line">      	<span class="keyword">val</span> user = login() <span class="comment">//suspend方法，挂起点1     </span></span><br><span class="line">    		<span class="keyword">val</span> <span class="keyword">data</span> = fetchData(user) <span class="comment">//suspend方法，挂起点2   </span></span><br><span class="line">    		displayUI(<span class="keyword">data</span>) <span class="comment">//普通方法    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: Job &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个block块就是一个suspend lambda方法，所以kotlin编译器会为这个suspend lambda方法创建一个实现了Function接口、继承自SuspendLambda的类，并且这个类同时也实现了状态机，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    GlobalScope.launch(EmptyCoroutineContext, CoroutineStart.DEFAULT, SuspendLambdaStateMachine(<span class="literal">null</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuspendLambdaStateMachine</span></span>(completion: Continuation&lt;<span class="built_in">Unit</span>&gt;) : SuspendLambda(<span class="number">2</span>, completion), Function2&lt;CoroutineScope, Continuation&lt;<span class="built_in">Unit</span>&gt;, Any?&gt; &#123;</span><br><span class="line"></span><br><span class="line">   	<span class="comment">//保存每个挂起点恢复后的结果</span></span><br><span class="line">    <span class="keyword">var</span> result: Result&lt;Any?&gt; = <span class="literal">null</span></span><br><span class="line">  	<span class="comment">//当前lambda方法的状态</span></span><br><span class="line">  	<span class="keyword">var</span> label: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//invoke方法被调用相当于lambda方法被执行，在里面它会创建状态机，并执行状态机的invokeSuspend方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(p1: <span class="type">CoroutineScope</span>, completion: <span class="type">Continuation</span>&lt;<span class="type">Unit</span>&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">return</span> (create(completion) <span class="keyword">as</span> SuspendLambdaStateMachine).invokeSuspend(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用create方法可以传入一个完成延续创建suspend lambda方法的状态机</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">create</span><span class="params">(completion: <span class="type">Continuation</span>&lt;*&gt;)</span></span>: Continuation&lt;<span class="built_in">Unit</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> SuspendLambdaStateMachine(completion)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">//调用invokeSuspend方法进行状态流转，这时result会是前一个状态的结果，而label也已处于将要执行的状态</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeSuspend</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any? &#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result</span><br><span class="line">        <span class="keyword">when</span>(label) &#123;</span><br><span class="line">            <span class="comment">//...跟前面display方法类似, 这个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>suspend lambda方法的状态机会比suspend命名方法多实现一个<strong>create</strong>方法，这个create方法也来自于父类BaseContinuationImpl中，这个create方法的目的就是创建一个suspend lambda方法的状态机实例并传入它的完成延续，这个方法最终会被kotlin intrinsice方法的<strong>createCoroutineUnintercepted</strong>方法调用。</p>
<p>通过前面介绍的suspend命名方法和suspend lambda方法实现可以看出，kotlin编译器为每个suspend方法做了以下几件事：</p>
<ul>
<li><p>1、为含有挂起点、且挂起点不是尾调用的suspend方法创建一个私有的状态机；</p>
</li>
<li><p>2、状态机中通过变量保存了suspend方法将要执行的状态和上一个状态的结果，每一次执行状态前，为了防止挂起函数运行失败都会进行状态检查，并且调用挂起函数前，状态机的状态都会提前置为下一个状态；</p>
</li>
<li><p>3、调用其他挂起函数时，都会把当前状态机实例作为Continuation传递过去，而被调用的挂起函数满足1条件时也会被创建一个状态机，当被调用挂起函数的状态机运行结束时，可以利用传递过去的Continuation恢复当前状态机执行。</p>
</li>
</ul>
<p>从第1点可以看出，kotlin编译器并不总是为suspend方法创建状态机，例如fetchData方法，虽然它是suspend方法，但是它里面没有调用其他的suspend方法，并不需要处理状态，所以kotlin编译器不会为它创建状态机，还有一种情况kotlin编译器也不会创建状态机，就是如果suspend方法中只有一个suspend方法调用并且这个suspend方法调用是尾调用，那么kotlin编译器不会为它创建状态机，只会简单地把suspend方法的Continuation实例继续传递给尾调用的suspend方法，因为在尾调用中，调用方不需要保存状态，所以总结起来就是kotlin编译器只会为<strong>含有非尾部suspend方法调用</strong>的suspend方法创建状态机，这是kotlin编译器的一个优化，避免创建多余的状态机实例。</p>
<blockquote>
<p>kotlin官方对于suspend方法还提出了另外一个优化，就是只有当首次挂起时才进行状态机的创建，即状态机懒创建，因为在首次挂起前，suspend方法很有可能因为其他原因提前退出了，这时提前创建的状态机就是多余的。</p>
</blockquote>
<p>从第2点可以看出，suspend方法的挂起和恢复是通过状态机的状态切换来实现的，每个状态对应suspend方法的每个延续，状态机保存了每个延续恢复后的结果，从第3点可以看出，suspend方法的状态机实例会作为Continuation在suspend方法之间传递，而最终这个状态机实例Continuation会传到<strong>suspendCoroutineUninterceptedOrReturn</strong>方法中暴露给我们使用，在这个方法里我们可以控制这个Continuation例如包装它在恢复前作出一些我们的自定义行为，并决定什么时候进行恢复，当我们决定恢复时，就调用resumeWith方法就行。</p>
<h2 id="intrinsics方法"><a href="#intrinsics方法" class="headerlink" title="intrinsics方法"></a>intrinsics方法</h2><p>kotlin intrinsics方法是用来实现协程的基本原语，前面已经讲过协程的实现原理是Continuation，Continuation的最主要的好处就是可以暴露给用户用于控制程序的执行，而kotlin intrinsics作用就是可以让我们调用它提供的基本方法获取Continuation，kotlin intrinsics在<a href="https://github.com/JetBrains/kotlin/blob/1.4.0/libraries/stdlib/jvm/src/kotlin/coroutines/intrinsics/IntrinsicsJvm.kt" target="_blank" rel="noopener">kotlin-stdlib</a>和<a href="https://github.com/Kotlin/kotlinx.coroutines/tree/native-mt-1.4.20/kotlinx-coroutines-core/common/src/intrinsics" target="_blank" rel="noopener">kotlinx-coroutines</a>都有相应的intrinsics包，而kotlinx-coroutines的intrinsics包是基于kotlin-stdlib的intrinsics包的安全实现，增加了一些try catch、启动时可取消、拦截的能力，kotlin-stdlib的intrinsics包是不推荐给用户使用的，因为使用它必须要注意一些问题，所以kotlin在IDE中隐藏了kotlin-stdlib的intrinsics包的智能提示，我们无法自动导入这个包只能手动导入，并且里面的方法在引用时也没有提示，只能手动编写，这里我主要讲kotlin-stdlib的intrinsics包的方法，因为它才是最基本的实现，如果平时开发使用，还是推荐使用kotlinx-coroutines的intrinsics包。</p>
<p>首先我们要手动导入kotlin-stdlib的intrinsics包：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.coroutines.intrinsics.*</span><br></pre></td></tr></table></figure>

<p>intrinsics包主要有两部分，一部分是基于suspend lambda方法创建Continuation，一部分是捕获suspend方法的Continuation，先看Continuation的创建：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).createCoroutineUnintercepted(completion: Continuation&lt;T&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">actual</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> R.()</span></span> -&gt; T).createCoroutineUnintercepted(receiver: R, completion: Continuation&lt;T&gt;): Continuation&lt;<span class="built_in">Unit</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>createCoroutineUnintercepted</strong>方法用来创建一个返回值为T类型的初始Continuation实例，创建Continuation实例需要传入一个完成延续，当需要执行这个Continuation时，就调用它的resumeWith方法，当这个Continuation执行完毕时，完成延续completion的resumeWith方法就会回调，suspend lambda方法是普通方法和suspend方法之间的<strong>桥梁</strong>，因为suspend方法只能在suspend方法中调用，所以为了调用suspend方法，我们只能在普通方法声明一个suspend lambda类型的参数，然后在调用普通方法时传入suspend lambda方法块，并在传入suspend lambda方法块中调用其他suspend方法，例如kotlin协程通过launch方法启动时，都是要传一个<strong>block</strong>块，这个block块就是一个suspend lambda方法，我们传进去的block最终会被调用它的createCoroutineUnintercepted方法创建初始协程的初始Continuation实例，以CoroutineStart.DEFAULT启动模式为例，调用链如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CoroutineScope.launch(context, start, block)</span><br><span class="line">-&gt; AbstractCoroutine.start(start, coroutine, block)</span><br><span class="line">-&gt; CoroutineStart.invoke(block, receiver, completion)</span><br><span class="line">-&gt; block.startCoroutineCancellable(receiver, completion)</span><br><span class="line">-&gt; createCoroutineUnintercepted(receiver, completion).intercepted().resumeCancellable(Result.success(<span class="built_in">Unit</span>))</span><br></pre></td></tr></table></figure>

<p>而前面讲过suspend lambda方法会被CPS成一个状态机实现，这个状态机继承自BaseContinuationImpl并且实现了<strong>create</strong>方法，而createCoroutineUnintercepted方法会调用这个create方法创建状态机实例作为协程的初始Continuation。</p>
<p>从上面launch的调用链可以看到调用了createCoroutineUnintercepted方法后会马上调用<strong>intercepted</strong>方法，intercepted方法是Continuation的扩展方法，它也属于intrinsics方法，方法签名如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Continuation<span class="type">&lt;T&gt;</span>.<span class="title">intercepted</span><span class="params">()</span></span>: Continuation&lt;T&gt;</span><br></pre></td></tr></table></figure>

<p>这个方法的作用是在Continuation的上下文CoroutineContext中查找拦截器ContinuationInterceptor，并返回拦截器对Continuation的拦截延续，它包装了原始的Continuation，在Continuation恢复前做出一些其他操作，目前在协程实现中intercepted方法返回的是一个<strong>DispatchedContinuation</strong>，它的作用是在Continuation恢复前把它分发到对应上下文的Dispatcher中恢复，这样原始的Continuation就会被切换到对应的Dispatcher中执行，由于拦截在协程的执行过程会经常用到，所以kotlin就建议在调用createCoroutineUnintercepted方法创建了初始Continuation后和调用suspendCoroutineUninterceptedOrReturn方法捕获Continuation后马上调用它的intercepted方法，因为intercepted方法中会返回的拦截延续进行缓存，这样后续调用intercepted方法时就能马上返回。</p>
<p>前面多次讲到了<strong>suspendCoroutineUninterceptedOrReturn</strong>方法，它也属于intrinsics方法，suspendCoroutineUninterceptedOrReturn方法的作用是捕获suspend连续传递过来的Continuation，方法签名如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">suspendCoroutineUninterceptedOrReturn</span><span class="params">(<span class="keyword">crossinline</span> block: (<span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Any</span>?)</span></span>: T</span><br></pre></td></tr></table></figure>

<p>suspendCoroutineUninterceptedOrReturn方法的返回值类型即为Continuation的结果类型，在block块中我们可以拿到Continuation实例，注意到block块的返回值为<strong>Any</strong>类型，还记得前面讲suspend方法CPS后的返回值也为Any类型，这个Any类型就是<strong>T | COROUTINE_SUSPENDED</strong>的组合类型，如果block块中返回了COROUTINE_SUSPENDED，则表示suspend方法需要挂起并且不会立即返回结果，在这种情况下，要在将来的某个时刻调用Continuation的resumeWith来恢复suspend方法的执行，如果block块中返回了T类型的值或者抛出了异常，这表示执行没有被挂起，suspend方法可以直接同步返回结果，suspendCoroutineUninterceptedOrReturn方法是一个非常实用且常用的intrinsics方法，通过它我们可以对普通回调方法进行包装，把它与suspend方法进行结合，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  GlobalScope.launch &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> <span class="keyword">data</span> = fetchData()</span><br><span class="line">            println(<span class="keyword">data</span>)</span><br><span class="line">        &#125;<span class="keyword">catch</span> (e: NullPointerException) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">()</span></span>: String = suspendCoroutineUninterceptedOrReturn &#123; continuation -&gt;</span><br><span class="line">    fetchDataAsync &#123;</span><br><span class="line">      	<span class="comment">//恢复</span></span><br><span class="line">        <span class="keyword">if</span>(it.isNullOrEmpty()) &#123;</span><br><span class="line">            continuation.resumeWithException(NullPointerException())</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            continuation.resume(it)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//挂起                                                                </span></span><br><span class="line">    COROUTINE_SUSPENDED</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fetchDataAsync</span><span class="params">(callback: (<span class="type">String</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    Executors.newCachedThreadPool().execute &#123;</span><br><span class="line">        callback.invoke(<span class="string">"result"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到suspendCoroutineUninterceptedOrReturn方法可以把回调方法结果在suspend方法中以同步的形式返回，除了这种应用，我还可以对捕获到的Continuation进行包装，像DispatchedContinuation那样在Continuation恢复前后自定义我们自己的逻辑，像协程提供的delay、await、withContext等方法都是利用suspendCoroutineUninterceptedOrReturn方法实现它们的逻辑，例如delay方法可以让捕获的Continuation延迟指定时间后恢复，await方法可以让捕获的Continuation等到协程完成得到结果后才恢复，但是我们在日常开发中一般不会直接使用suspendCoroutineUninterceptedOrReturn方法，因为使用不当会让线程出现<strong>栈溢出</strong>错误，suspendCoroutineUninterceptedOrReturn方法已经在注释中明确提示：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note that it is not recommended to call either Continuation.resume nor Continuation.resumeWithException   	* functions synchronously in the same stackframe where suspension function is run. Use suspendCoroutine as a 	* safer way to obtain current continuation instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>不推荐在运行suspend方法的同一堆栈帧中同步调用Continuation的resumeWith方法，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">()</span></span>: String = suspendCoroutineUninterceptedOrReturn &#123; continuation -&gt;</span><br><span class="line">   <span class="comment">//错误做法，不推荐在当前线程栈帧调用Continuation的resumeWith方法                                                    		continuation.resume("result")</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为如果我们直接在当前线程上同步调用resumeWith方法，就相当于<strong>递归调用</strong>上一个suspend方法，这样当当前线程长时间运行时，就会很容易出现栈溢出错误，注释提到推荐使用<strong>suspendCoroutine</strong>方法代替suspendCoroutineUninterceptedOrReturn方法获取当前Continuation，该方法定义在kotlin.coroutines中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">suspendCoroutine</span><span class="params">(<span class="keyword">crossinline</span> block: (<span class="type">Continuation</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123; c: Continuation&lt;T&gt; -&gt;</span><br><span class="line">        <span class="keyword">val</span> safe = SafeContinuation(c.intercepted())</span><br><span class="line">        block(safe)</span><br><span class="line">        safe.getOrThrow()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过suspendCoroutine获取到的Continuation是一个<strong>SafeContinuation</strong>，它是对suspendCoroutineUninterceptedOrReturn捕获的Continuation又一层包装，它可以让我们同步地、安全地调用Continuation的resumeWith方法，而不用考虑任何限制，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">()</span></span>: String = suspendCoroutine &#123; continuation -&gt;</span><br><span class="line">   <span class="comment">//没问题，SafeContinuation可以同步调用</span></span><br><span class="line">   continuation.resume(<span class="string">"result"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SafeContinuation的原理就是它重写了resumeWith方法，在同步调用的情况下，不调用真正的Continuation的resumeWith方法，而是先保存结果，然后把保存的结果在调用getOrThrow方法时直接return给调用方法，这样就避免了同步调用Continuation的resumeWith方法出现的问题，同时SafeContinuation还替我们封装好了返回COROUTINE_SUSPENDED的逻辑，我们使用suspendCoroutine需要挂起时不用再显式地返回COROUTINE_SUSPENDED，除了suspendCoroutine方法，我们还可以使用<strong>suspendCancellableCoroutine</strong>方法代替，它定义在kotlinx.coroutines中：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">suspendCancellableCoroutine</span><span class="params">( <span class="keyword">crossinline</span> block: (<span class="type">CancellableContinuation</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Unit</span>)</span></span>: T = suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt;</span><br><span class="line">      <span class="keyword">val</span> cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE)</span><br><span class="line">      cancellable.initCancellability()</span><br><span class="line">      block(cancellable)</span><br><span class="line">      cancellable.getResult()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>通过suspendCancellableCoroutine获取到的Continuation是一个<strong>CancellableContinuation</strong>，它也是对suspendCoroutineUninterceptedOrReturn捕获的Continuation又一层包装，它除了可以让我们同步地、安全地调用Continuation的resumeWith方法外，还可以取消Continuation同时响应协程的取消，例如：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">fetchData</span><span class="params">()</span></span>: String = suspendCancellableCoroutine&#123; continuation -&gt;</span><br><span class="line">    <span class="keyword">val</span> fileIs = FileInputStream(File(<span class="string">"test"</span>))</span><br><span class="line">    continuation.invokeOnCancellation &#123;</span><br><span class="line">        <span class="comment">//Continuation被取消时执行一些资源释放工</span></span><br><span class="line">        fileIs.close()</span><br><span class="line">    &#125;                                                             </span><br><span class="line">    <span class="comment">//...do something</span></span><br><span class="line">    <span class="comment">//没问题，CancellableContinuation可以同步调用</span></span><br><span class="line">    continuation.resume(<span class="string">"result"</span>)                                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kotlin intrinsics方法中还有一个<strong>startCoroutineUninterceptedOrReturn</strong>方法，当你调用它之后，他会创建一个Continuation并立即执行它，直到遇到第一个挂起点，而createCoroutineUnintercepted方法创建的Continuation需要你显式调用resumeWith方法才会执行，它的方法签名如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="params">(<span class="keyword">suspend</span> ()</span></span> -&gt; T).startCoroutineUninterceptedOrReturn(completion: Continuation&lt;T&gt;): Any?</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R, T&gt;</span> <span class="params">(<span class="keyword">suspend</span> R.()</span></span> -&gt; T).startCoroutineUninterceptedOrReturn(receiver: R, completion: Continuation&lt;T&gt;): Any?</span><br></pre></td></tr></table></figure>

<p>这个返回的调用同样需要传入一个Continuation作为该方法创建的Continuation的完成延续，当该方法创建的Continuation执行完毕后，完成延续completion的resumeWith方法就会被调用，与createCoroutineUnintercepted方法不同的是它的返回值是一个Any类型，这个Any类型的含义和前面讲的suspendCoroutineUninterceptedOrReturn方法中block块的返回值含义一样，这个方法的主要是和suspendCoroutineUninterceptedOrReturn方法结合使用，在相同的上下文中使用不同的suspend lambda块创建执行新的Continuation，并在新的Continuation结束后恢复suspendCoroutineUninterceptedOrReturn方法捕获的Continuation，例如withContext方法就使用到了suspendCoroutineUninterceptedOrReturn方法，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">withContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">CoroutineScope</span>.() -&gt; <span class="type">T</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: T &#123;</span><br><span class="line">    <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn <span class="symbol">sc@</span> &#123; uCont -&gt;</span><br><span class="line">        <span class="keyword">val</span> oldContext = uCont.context</span><br><span class="line">        <span class="keyword">val</span> newContext = oldContext + context</span><br><span class="line">        newContext.checkCompletion()</span><br><span class="line">        <span class="comment">// FAST PATH #1 -- newContext等于oldContext，不需要执行上下文切换</span></span><br><span class="line">        <span class="keyword">if</span> (newContext === oldContext) &#123;</span><br><span class="line">            <span class="keyword">val</span> coroutine = ScopeCoroutine(newContext, uCont)</span><br><span class="line">            <span class="comment">//最终调用block.startCoroutineUninterceptedOrReturn方法</span></span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// FAST PATH #2 -- newContext的Dispatcher等于oldContext的oldContext，不需要切换Dispatcher</span></span><br><span class="line">        <span class="keyword">if</span> (newContext[ContinuationInterceptor] == oldContext[ContinuationInterceptor]) &#123;</span><br><span class="line">            <span class="keyword">val</span> coroutine = UndispatchedCoroutine(newContext, uCont)</span><br><span class="line">            withCoroutineContext(newContext, <span class="literal">null</span>) &#123;</span><br><span class="line">              	<span class="comment">//最终调用block.startCoroutineUninterceptedOrReturn方法</span></span><br><span class="line">                <span class="keyword">return</span><span class="symbol">@sc</span> coroutine.startUndispatchedOrReturn(coroutine, block)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// SLOW PATH -- newContext不等于oldContext</span></span><br><span class="line">        <span class="keyword">val</span> coroutine = DispatchedCoroutine(newContext, uCont)</span><br><span class="line">        coroutine.initParentJob()</span><br><span class="line">        <span class="comment">//最终调用block.createCoroutineUnintercepted方法</span></span><br><span class="line">        block.startCoroutineCancellable(coroutine, coroutine)</span><br><span class="line">        coroutine.getResult()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>withContext方法的作用是把block块运行在新的上下文中，并返回block块的运行结果，同时返回时会切换到原来的上下文中，withContext方法在不需要进行Dispatcher切换的情况中会直接使用block.startCoroutineUninterceptedOrReturn方法，这样会减少无谓的intercepted方法调用。</p>
<p>createCoroutineUnintercepted、startCoroutineUninterceptedOrReturn、suspendCoroutineUninterceptedOrReturn三个方法就是kotlin intrinsice中最常用到的方法，用来创建、启动和捕获Continuation，kotlin协程的本质就是启动、调度和管理Continuation，所以说intrinsics方法是kotlin协程实现的基石。</p>
<h2 id="Continuation的恢复"><a href="#Continuation的恢复" class="headerlink" title="Continuation的恢复"></a>Continuation的恢复</h2><p>从前面可以看到，当我们需要从挂起点恢复被挂起的Continuation或者首次执行这个Continuation时，就要调用<a href="https://github.com/JetBrains/kotlin/blob/1.4.0/libraries/stdlib/src/kotlin/coroutines/Continuation.kt" target="_blank" rel="noopener">Continuation</a>接口的resumeWith方法，resumeWith方法方法根据Continuation的子类不同有不同的实现，在kotlin协程中，Continuation主要有<strong>BaseContinuationImpl</strong>、<strong>DispatchedContinuation</strong>、<strong>SafeContinuation</strong>、<strong>CancellableContinuation</strong>、<strong>AbstractCoroutine</strong>这几种实现，下面主要讲一下DispatchedContinuation、BaseContinuationImpl和AbstractCoroutine的resumeWith方法实现，它们之间的关系如下：</p>
<img src="/2022/05/26/%E6%8F%AD%E7%A7%98kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/coroutines1.png" class="" title="coroutine">

<p><strong>DispatchedContinuation</strong></p>
<p>DispatchedContinuation就是把Continuation分发到对应上下文的Dispatcher中执行，当我们需要拦截Continuation时，就调用它的intercepted方法获取它的DispatchedContinuation，当一个Continuation被拦截后，后续它执行都在对应的Dispatcher中，DispatchedContinuation当resumeWith方法实现如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatchedContinuation</span>&lt;<span class="type">in T</span>&gt;</span>(</span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> dispatcher: CoroutineDispatcher,<span class="comment">//被拦截Continuation的Dispatcher</span></span><br><span class="line">    <span class="meta">@JvmField</span> <span class="keyword">val</span> continuation: Continuation&lt;T&gt;<span class="comment">//被拦截的Continuation</span></span><br><span class="line">) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; <span class="keyword">by</span> continuation &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> context = continuation.context</span><br><span class="line">        <span class="keyword">val</span> state = result.toState()</span><br><span class="line">        <span class="keyword">if</span> (dispatcher.isDispatchNeeded(context)) &#123;<span class="comment">//IO、DEFAULT、MAIN走这里逻辑</span></span><br><span class="line">            _state = state</span><br><span class="line">            resumeMode = MODE_ATOMIC</span><br><span class="line">            <span class="comment">//调用dispatch方法后，DispatchedTask的run方法会执行</span></span><br><span class="line">            dispatcher.dispatch(context, <span class="keyword">this</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//Unconfined走这里的逻辑</span></span><br><span class="line">            executeUnconfined(state, MODE_ATOMIC) &#123;</span><br><span class="line">                withCoroutineContext(<span class="keyword">this</span>.context, countOrElement) &#123;</span><br><span class="line">                   <span class="comment">//调用Continuation的resumeWith方法</span></span><br><span class="line">                    continuation.resumeWith(result)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatchedTask</span>&lt;<span class="type">in T</span>&gt;</span>(<span class="meta">@JvmField</span> <span class="keyword">public</span> <span class="keyword">var</span> resumeMode: <span class="built_in">Int</span>) : SchedulerTask() &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> taskContext = <span class="keyword">this</span>.taskContext</span><br><span class="line">    <span class="keyword">var</span> fatalException: Throwable? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> delegate = delegate <span class="keyword">as</span> DispatchedContinuation&lt;T&gt;</span><br><span class="line">      <span class="keyword">val</span> continuation = delegate.continuation</span><br><span class="line">      <span class="keyword">val</span> context = continuation.context</span><br><span class="line">      <span class="keyword">val</span> state = takeState()</span><br><span class="line">      withCoroutineContext(context, delegate.countOrElement) &#123;</span><br><span class="line">        <span class="keyword">val</span> exception = getExceptionalResult(state)</span><br><span class="line">        <span class="keyword">val</span> job = <span class="keyword">if</span> (exception == <span class="literal">null</span> &amp;&amp; resumeMode.isCancellableMode) context[Job] <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span> (job != <span class="literal">null</span> &amp;&amp; !job.isActive) &#123;</span><br><span class="line">          <span class="keyword">val</span> cause = job.getCancellationException()</span><br><span class="line">          cancelCompletedResult(state, cause)</span><br><span class="line">          continuation.resumeWithStackTrace(cause)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//调用Continuation的resumeWith方法</span></span><br><span class="line">          <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">            continuation.resumeWithException(exception)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            continuation.resume(getSuccessfulResult(state))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">      fatalException = e</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> result = runCatching &#123; taskContext.afterTask() &#125;</span><br><span class="line">      handleFatalException(fatalException, result.exceptionOrNull())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到如果Dispatcher是Unconfined，那么就会在当前线程调用Continuation的resumeWith方法，如果Dispatcher是IO、DEFAULT、MAIN，就调用它们的dispatch方法提交DispatchedTask任务等待调度执行，而DispatchedContinuation同时又继承自DispatchedTask，所以它是一个DispatchedTask，等IO、DEFAULT、MAIN的Dispatcher调度时，run方法就会执行，这时就调用Continuation的resumeWith方法，这样Continuation就被分发到对应上下文的线程中恢复。</p>
<p><strong>BaseContinuationImpl</strong></p>
<p><a href="https://github.com/JetBrains/kotlin/blob/1.4.0/libraries/stdlib/jvm/src/kotlin/coroutines/jvm/internal/ContinuationImpl.kt" target="_blank" rel="noopener">BaseContinuationImpl</a>是所有suspend方法状态机的共同父类，例如子类ContinuationImpl就表示suspend命名方法，子类SuspendLambda就表示suspend lambda方法，除了这些普通的suspend方法外，kotlin中还有一种受限suspend方法，它是一种带有限制的suspend方法作用域，在这种带限制的suspend方法中只能调用<strong>@RestrictsSuspension</strong>注解的类中定义的suspend方法，例如<a href="https://kotlinlang.org/docs/sequences.html" target="_blank" rel="noopener">sequence</a>方法的block块就是一个带有限制的suspend lambda方法：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sequence&lt;<span class="built_in">Int</span>&gt; &#123;</span><br><span class="line">      <span class="comment">//display() 报错，不允许调用其他suspend方法</span></span><br><span class="line">      yield(<span class="number">1</span>) <span class="comment">//只能调用被@RestrictsSuspension注解的SequenceScope类中定义的yield方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">sequence</span><span class="params">(<span class="meta">@BuilderInference</span> block: <span class="type">suspend</span> <span class="type">SequenceScope</span>&lt;<span class="type">T</span>&gt;.() -&gt; <span class="type">Unit</span>)</span></span>: Sequence&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestrictsSuspension</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SequenceScope</span>&lt;<span class="type">in T</span>&gt; <span class="keyword">internal</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">yield</span><span class="params">(value: <span class="type">T</span>)</span></span></span><br><span class="line">  </span><br><span class="line"> 	 <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>受限的suspend方法用RestrictedContinuationImpl表示，受限的suspend lambda方法用RestrictedSuspendLambda表，当我们调用BaseContinuationImpl的resumeWith方法时，就是在执行当前suspend方法的状态机，并且在状态机运行结束时恢复外部Continuation，我们可以看一下BaseContinuationImpl的resumeWith方法的实现：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseContinuationImpl</span></span>(</span><br><span class="line">    <span class="comment">//每个BaseContinuationImpl实例都会引用一个完成Continuation，用来在当前状态机流转结束时恢复这个Continuation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">val</span> completion: Continuation&lt;Any?&gt;?</span><br><span class="line">) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//resumeWith方法中通过循环由里到外恢复Continuation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> current = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">var</span> param = result</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            probeCoroutineResumed(current)</span><br><span class="line">            with(current) &#123;</span><br><span class="line">                <span class="keyword">val</span> completion = completion!!</span><br><span class="line">                <span class="keyword">val</span> outcome: Result&lt;Any?&gt; =</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//通过调用invokeSuspend方法执行当前suspend方法主体，进行状态流转</span></span><br><span class="line">                        <span class="keyword">val</span> outcome = invokeSuspend(param)</span><br><span class="line">                        <span class="keyword">if</span> (outcome === COROUTINE_SUSPENDED) <span class="keyword">return</span></span><br><span class="line">                        Result.success(outcome)</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (exception: Throwable) &#123;</span><br><span class="line">                        Result.failure(exception)</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">//当invokeSuspend方法没有返回COROUTINE_SUSPENDED，就表示当前状态机流转结束，即当前suspend方法执行完毕</span></span><br><span class="line">                releaseIntercepted() </span><br><span class="line">              	<span class="comment">//然后在这里判断是否还有suspend方法需要恢复</span></span><br><span class="line">                <span class="keyword">if</span> (completion <span class="keyword">is</span> BaseContinuationImpl) &#123; <span class="comment">//completion是suspend方法，继续恢复</span></span><br><span class="line">                    current = completion</span><br><span class="line">                    param = outcome</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//completion不是suspend方法，调用resumeWith方法恢复</span></span><br><span class="line">                    completion.resumeWith(outcome)</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个suspend方法状态机都要实现这个接口，用来调用suspend方法主体</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeSuspend</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">Any</span>?&gt;)</span></span>: Any?</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个BaseContinuationImpl实例就代表一个suspend方法状态机，当suspend方法状态机执行结束时，BaseContinuationImpl就会恢复引用的完成Continuation，如果完成Continuation是suspend方法，就调用它状态机的invokeSuspend方法，当遇到完成Continuation不是suspend方法时，就调用它的resumeWith方法执行对应的逻辑。</p>
<p><strong>AbstractCoroutine</strong></p>
<p><a href="https://github.com/Kotlin/kotlinx.coroutines/blob/native-mt-1.4.20/kotlinx-coroutines-core/common/src/AbstractCoroutine.kt" target="_blank" rel="noopener">AbstractCoroutine</a>是kotlin协程的基类，AbstractCoroutine在kotlin协程实现中会作为<strong>最后一个恢复的Continaution</strong>，所以当所有suspend方法都执行完毕后，AbstractCoroutine的resumeWith方法就会被调用，这时它就可以进行协程的生命周期流转，例如判断子协程是否完成，如果子协程都完成了，那么就能置为完成状态，否则就置为完成中状态等待所有子协程完成，如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCoroutine</span>&lt;<span class="type">in T</span>&gt;</span>(<span class="keyword">protected</span> <span class="keyword">val</span> parentContext: CoroutineContext, active: <span class="built_in">Boolean</span> = <span class="literal">true</span>) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope &#123;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">      <span class="comment">//进行协程生命周期流转</span></span><br><span class="line">      <span class="keyword">val</span> state = makeCompletingOnce(result.toState())</span><br><span class="line">      <span class="keyword">if</span> (state === COMPLETING_WAITING_CHILDREN) <span class="keyword">return</span></span><br><span class="line">      afterResume(state)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自己实现Coroutine"><a href="#自己实现Coroutine" class="headerlink" title="自己实现Coroutine"></a>自己实现Coroutine</h2><p>当我们通过launch方法传入block块启动一个协程，本质是通过这个block块创建了一个Continuation，当我们在block块中调用其他suspend方法，并且suspend方法中再调用其他suspend方法，Continuation就会在这些suspend方法之间传递，最终我们可以捕获到连续传递的Continuation，当我们通过Continuation恢复时，本质是上一个suspend方法的递归调用进行状态流转，而kotlin协程只是在这些Continuation的基础上添加了生命周期管理、父子关系、异常处理、线程切换等逻辑。</p>
<p>通过intrinsics方法，我们自己也可以实现一个协程，这里我通过intrinsics方法仿照kotlin协程写了个简化版的协程，它这样使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> simpleScope = SimpleCoroutineScope(Dispatchers.Default)</span><br><span class="line">    <span class="keyword">val</span> simpleJob = simpleScope.launch(CoroutineName(<span class="string">"main"</span>), CoroutineStart.DEFAULT) &#123;</span><br><span class="line">        <span class="keyword">val</span> user = login()</span><br><span class="line">        <span class="keyword">val</span> userData = fetchData(user)</span><br><span class="line">        displayUI(userData)</span><br><span class="line">    &#125;</span><br><span class="line">    simpleJob.invokeOnCompletion(<span class="keyword">object</span> : SimpleJob.CompletionHandler &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(cause: <span class="type">Throwable</span>?)</span></span> &#123;</span><br><span class="line">            println(<span class="string">"invokeOnCompletion: cause = <span class="variable">$cause</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">  	<span class="comment">//进程保活</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> SimpleCoroutineScope.<span class="title">login</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> async(CoroutineName(<span class="string">"login"</span>)) &#123;</span><br><span class="line">        delay(<span class="number">200</span>)</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@async</span> <span class="string">"user"</span></span><br><span class="line">    &#125;.await()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> SimpleCoroutineScope.<span class="title">fetchData</span><span class="params">(user: <span class="type">String</span>)</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> async(CoroutineName(<span class="string">"fetch"</span>)) &#123;</span><br><span class="line">        delay(<span class="number">200</span>)</span><br><span class="line">        <span class="keyword">return</span><span class="symbol">@async</span> <span class="string">"<span class="variable">$user</span> data"</span></span><br><span class="line">    &#125;.await()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">displayUI</span><span class="params">(<span class="keyword">data</span>: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"displayUI: <span class="variable">$data</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行输出：</span></span><br><span class="line"><span class="comment">//displayUI: user data</span></span><br><span class="line"><span class="comment">//invokeOnCompletion: cause = null</span></span><br></pre></td></tr></table></figure>

<p>invokeOnCompletion方法回调会在协程完成后被调用，如果协程正常完成那么，cause为null，如果协程异常完成，那么cause为对应的异常，上面协程正常完成，所有实现代码如下：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.coroutines.*</span><br><span class="line"><span class="keyword">import</span> kotlin.coroutines.intrinsics.*</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CopyOnWriteArraySet</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简化版的[CoroutineScope]，提供协程运行作用域，它与[CoroutineScope]的区别是没有[CoroutineScope.cancel]、[CoroutineScope.ensureActive]等这些扩展方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">SimpleCoroutineScope</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> coroutineContext: CoroutineContext</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [SimpleCoroutineScope]的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCoroutineScopeImpl</span></span>(<span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext) : SimpleCoroutineScope</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造[SimpleCoroutineScope]实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">SimpleCoroutineScope</span><span class="params">(context: <span class="type">CoroutineContext</span>)</span></span> = SimpleCoroutineScopeImpl(<span class="keyword">if</span>(context[SimpleJob] != <span class="literal">null</span>) context <span class="keyword">else</span> context + SimpleJob())</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简化版的[Job]，用于管理协程的生命周期，它与[Job]的区别是它没有取消操作、异常传播、异常处理等功能，只有简单的状态流转：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      start/await</span></span><br><span class="line"><span class="comment"> * NEW -------------&gt; ACTIVE (isActive = true)</span></span><br><span class="line"><span class="comment"> *   \                /</span></span><br><span class="line"><span class="comment"> *    \  fail/finish /</span></span><br><span class="line"><span class="comment"> *     \            /</span></span><br><span class="line"><span class="comment"> *       COMPLETING</span></span><br><span class="line"><span class="comment"> *           |</span></span><br><span class="line"><span class="comment"> *           | wait children</span></span><br><span class="line"><span class="comment"> *           v</span></span><br><span class="line"><span class="comment"> *       COMPLETE (isComplete = true)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">SimpleJob</span> : <span class="type">CoroutineContext.Element &#123;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> Key : CoroutineContext.Key&lt;SimpleJob&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协程是否已启动</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isActive</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协程是否已完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">isComplete</span><span class="params">()</span></span>: <span class="built_in">Boolean</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动协程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待协程的结果返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">await</span><span class="params">()</span></span>: T</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册协程完成回调[completionHandler]，返回的[DisposableHandle]可以用来反注册回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnCompletion</span><span class="params">(completionHandler: <span class="type">CompletionHandler</span>, invokeImmediately: <span class="type">Boolean</span> = <span class="literal">true</span>)</span></span>: DisposableHandle</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立起与[childJob]子协程的父子关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">attachChild</span><span class="params">(childJob: <span class="type">SimpleJob</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协程完成通知回调</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">CompletionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * cause == null -&gt; 成功结束</span></span><br><span class="line"><span class="comment">         * cause == other -&gt; 异常结束</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(cause: <span class="type">Throwable</span>?)</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反注册句柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">DisposableHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 调用[dispose]方法反注册</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">dispose</span><span class="params">()</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [SimpleJob]的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleJobImpl</span></span>(active: <span class="built_in">Boolean</span>) : SimpleJob &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        NEW, ACTIVE, COMPLETING, COMPLETED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> key: CoroutineContext.Key&lt;*&gt; <span class="keyword">get</span>() = SimpleJob</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> state = <span class="keyword">if</span>(active) State.ACTIVE <span class="keyword">else</span> State.NEW</span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> result: Any? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> children = CopyOnWriteArraySet&lt;SimpleJob&gt;()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> completionHandlers = CopyOnWriteArraySet&lt;SimpleJob.CompletionHandler&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isActive</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state == State.ACTIVE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">isComplete</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state == State.COMPLETED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(state == State.NEW) &#123;</span><br><span class="line">            state = State.ACTIVE</span><br><span class="line">            onStart()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">await</span><span class="params">()</span></span>: T &#123;</span><br><span class="line">        <span class="keyword">if</span>(state == State.COMPLETED) &#123;</span><br><span class="line">            <span class="keyword">if</span>(result <span class="keyword">is</span> Throwable) &#123;</span><br><span class="line">                <span class="keyword">throw</span> result <span class="keyword">as</span> Throwable</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> result <span class="keyword">as</span> T</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(state == State.NEW) &#123;</span><br><span class="line">            start()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> suspendCoroutineUninterceptedOrReturn &#123;</span><br><span class="line">            invokeOnCompletion(<span class="keyword">object</span> : SimpleJob.CompletionHandler &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(cause: <span class="type">Throwable</span>?)</span></span> &#123;</span><br><span class="line">                     <span class="keyword">if</span>(cause != <span class="literal">null</span>) &#123;</span><br><span class="line">                         it.resumeWithException(cause)</span><br><span class="line">                     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                         it.resume(result <span class="keyword">as</span> T)</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            COROUTINE_SUSPENDED</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invokeOnCompletion</span><span class="params">(completionHandler: <span class="type">SimpleJob</span>.<span class="type">CompletionHandler</span>, invokeImmediately: <span class="type">Boolean</span>)</span></span>: SimpleJob.DisposableHandle &#123;</span><br><span class="line">        <span class="keyword">if</span>(invokeImmediately &amp;&amp; state == State.COMPLETED) &#123;</span><br><span class="line">            completionHandler.invoke(result <span class="keyword">as</span>? Throwable)</span><br><span class="line">        &#125;</span><br><span class="line">        completionHandlers.add(completionHandler)</span><br><span class="line">        <span class="keyword">return</span> CompletionHandlerDisposeHandle(completionHandler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">attachChild</span><span class="params">(childJob: <span class="type">SimpleJob</span>)</span></span> &#123;</span><br><span class="line">        children.add(childJob)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">initParentJob</span><span class="params">(parentJob: <span class="type">SimpleJob</span>?)</span></span> &#123;</span><br><span class="line">        parentJob?.start()</span><br><span class="line">        parentJob?.attachChild(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">fun</span> <span class="title">tryMakeCompleted</span><span class="params">(value: <span class="type">Any</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        result = value ?: result</span><br><span class="line">        <span class="keyword">val</span> complete = children.find &#123; !it.isComplete() &#125; == <span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span>(complete) &#123;</span><br><span class="line">            <span class="keyword">if</span>(state == State.COMPLETED) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            state = State.COMPLETED</span><br><span class="line">            <span class="keyword">val</span> cause = <span class="keyword">if</span>(result <span class="keyword">is</span> Throwable) &#123; result <span class="keyword">as</span> Throwable &#125; <span class="keyword">else</span> &#123; <span class="literal">null</span> &#125;</span><br><span class="line">            notifyCompleteHandlers(cause)</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">// 等待所有child完成</span></span><br><span class="line">            <span class="keyword">if</span>(state == State.COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            state = State.COMPLETING</span><br><span class="line">            children.forEach &#123;</span><br><span class="line">                it.invokeOnCompletion(<span class="keyword">object</span> : SimpleJob.CompletionHandler &#123;</span><br><span class="line">                    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(cause: <span class="type">Throwable</span>?)</span></span> &#123;</span><br><span class="line">                        tryMakeCompleted(cause)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, invokeImmediately = <span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> complete</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">notifyCompleteHandlers</span><span class="params">(cause: <span class="type">Throwable</span>?)</span></span> &#123;</span><br><span class="line">        completionHandlers.forEach &#123;</span><br><span class="line">            it.invoke(cause)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协程调用start/await方法从[State.NEW]转移到[State.ACTIVE]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用[dispose]方法解除注册的[completionHandler]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletionHandlerDisposeHandle</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> completionHandler: SimpleJob.CompletionHandler) : SimpleJob.DisposableHandle &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">dispose</span><span class="params">()</span></span> &#123;</span><br><span class="line">            completionHandlers.remove(completionHandler)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造[SimpleJob]实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">SimpleJob</span><span class="params">()</span></span> = SimpleJobImpl(active = <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简化版的协程，调用start方法启动协程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parentContext 协程的父Context，用于建立父子关系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> active 为true时让协程处于active状态，否则处于new状态，处于new状态需要调用start/await方法才会启动协程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCoroutine</span>&lt;<span class="type">T</span>&gt;</span>(<span class="keyword">private</span> <span class="keyword">val</span> parentContext: CoroutineContext, active: <span class="built_in">Boolean</span> = <span class="literal">true</span>) : SimpleJobImpl(active), SimpleCoroutineScope, Continuation&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> context: CoroutineContext = parentContext + <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> coroutineContext: CoroutineContext <span class="keyword">get</span>() = context</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协程完成通知，这里处理结果，进行生命周期状态流转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">resumeWith</span><span class="params">(result: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;)</span></span> &#123;</span><br><span class="line">        println(<span class="string">"resumeWith: result = <span class="variable">$result</span>, coroutineName = <span class="subst">$&#123;coroutineContext[CoroutineName]&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">if</span>(result.isSuccess) &#123;<span class="comment">//成功恢复</span></span><br><span class="line">            tryMakeCompleted(result.getOrNull())</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//错误恢复</span></span><br><span class="line">            tryMakeCompleted(result.exceptionOrNull())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * for [CoroutineStart.LAZY]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> lazyContinuation: Continuation&lt;<span class="built_in">Unit</span>&gt;? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * for [CoroutineStart.LAZY]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">        lazyContinuation?.intercepted()?.resumeWith(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立协程的父子关系，使用[kotlin.coroutines.intrinsics]原语为[block]块创建协程的初始化[Continuation], 并根据[start]模式启动它</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">(start: <span class="type">CoroutineStart</span>, block: <span class="type">suspend</span> <span class="type">SimpleCoroutineScope</span>.() -&gt; <span class="type">T</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(coroutineContext[CoroutineExceptionHandler] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> IllegalAccessException(<span class="string">"unsupport CoroutineExceptionHandler"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        initParentJob(parentContext[SimpleJob])</span><br><span class="line">        <span class="keyword">when</span>(start) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 立即启动协程，并把启动的协程运行在指定的Dispatcher上</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            CoroutineStart.DEFAULT -&gt; &#123;</span><br><span class="line">                block.createCoroutineUnintercepted(<span class="keyword">this</span>, <span class="keyword">this</span>).intercepted().resumeWith(Result.success(<span class="built_in">Unit</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 在当前线程立即启动协程, 但恢复时会把协程运行在指定的Dispatcher上，效果和指定[Dispatchers.Unconfined]类似</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            CoroutineStart.UNDISPATCHED -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> result = <span class="keyword">try</span> &#123;</span><br><span class="line">                    block.startCoroutineUninterceptedOrReturn(<span class="keyword">this</span>, <span class="keyword">this</span>)</span><br><span class="line">                &#125;<span class="keyword">catch</span> (e: Throwable) &#123;</span><br><span class="line">                    e</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(result <span class="keyword">is</span> Throwable) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.resumeWithException(result)</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result !== COROUTINE_SUSPENDED) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.resume(result <span class="keyword">as</span> T)</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//COROUTINE_SUSPENDED, do noting</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 不立即启动协程，当调用start/await方法时才启动协程，并把启动的协程运行在指定的Dispatcher上</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            CoroutineStart.LAZY -&gt; &#123;</span><br><span class="line">                lazyContinuation = block.createCoroutineUnintercepted(<span class="keyword">this</span>, <span class="keyword">this</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">throw</span> IllegalAccessException(<span class="string">"unsupport <span class="variable">$start</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动协程，没有结果返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> SimpleCoroutineScope.<span class="title">launch</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">SimpleCoroutineScope</span>.() -&gt; <span class="type">Unit</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: SimpleJob &#123;</span><br><span class="line">    <span class="keyword">val</span> newContext = coroutineContext + context</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span>(start == CoroutineStart.LAZY) &#123;</span><br><span class="line">        SimpleCoroutine&lt;<span class="built_in">Unit</span>&gt;(newContext, active = <span class="literal">false</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        SimpleCoroutine&lt;<span class="built_in">Unit</span>&gt;(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutine.start(start, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动协程，可以调用返回的SimpleJob的await方法等待结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> SimpleCoroutineScope.<span class="title">async</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    context: <span class="type">CoroutineContext</span> = EmptyCoroutineContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    start: <span class="type">CoroutineStart</span> = CoroutineStart.DEFAULT,</span></span></span><br><span class="line"><span class="function"><span class="params">    block: <span class="type">suspend</span> <span class="type">SimpleCoroutineScope</span>.() -&gt; <span class="type">T</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: SimpleJob &#123;</span><br><span class="line">    <span class="keyword">val</span> newContext = coroutineContext + context</span><br><span class="line">    <span class="keyword">val</span> coroutine = <span class="keyword">if</span>(start == CoroutineStart.LAZY) &#123;</span><br><span class="line">        SimpleCoroutine&lt;T&gt;(newContext, active = <span class="literal">false</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        SimpleCoroutine&lt;T&gt;(newContext, active = <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    coroutine.start(start, block)</span><br><span class="line">    <span class="keyword">return</span> coroutine</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我自定义了SimpleCoroutineScope、SimpleJob、SimpleCoroutine分别对应kotlin协程的CoroutineScope、Job、AbstractCoroutine角色，实现了协程的launch、async方法，支持DEFAULT、LAZY、UNDISPATCHED三种启动模式，在kotlin协程中CoroutineScope是用来控制协程的作用域，Job是用来管理协程的生命周期和父子关系，而AbstractCoroutine实现了Continuation同时继承自Job，它的作用在前面也讲过，就是当所有suspend方法都执行完毕后，AbstractCoroutine的resumeWith方法就会被调用，这时它就可以进行协程的生命周期流转，DEFAULT模式表示立即启动，所以它调用了createCoroutineUnintercepted方法创建初始Continuation后马上调用resumeWith方法执行它，LAZY模式表示延迟启动，所以它通过createCoroutineUnintercepted方法创建的初始Continuation的resumeWith方法会等到调用start方法时才调用，而UNDISPATCHED模式表示在当前线程立即启动，所以它通过startCoroutineUninterceptedOrReturn方法创建并执行Continuation，希望大家通过这个简化版的协程理解kotlin协程中角色的作用。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文介绍了kotlin协程的实现思想，Continuation、CPS和suspend方法的实现，不只是kotlin协程，其他语言的协程的实现思想也是类似的，同时还介绍了kotlin提供的intrinsics方法，它是用于给用户操纵这些Continuation，最后通过intrinsics方法实现了一个简化版的kotlin协程，所以kotlin协程也没有那么神秘，它只是Continuation的应用，它只是在这些Continuation的基础上添加了生命周期管理、父子关系、异常处理、线程切换等逻辑。</p>
<p>以上就是本文的所有内容，希望大家有所收获！</p>
<p>参考文档：</p>
<p><a href="https://blog.csdn.net/pzhang_9_25/article/details/7832072" target="_blank" rel="noopener">Continuation-passing Style介绍及应用</a></p>
<p><a href="https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md#implementation-details" target="_blank" rel="noopener">KEEP-Kotlin Coroutines</a></p>
<p><a href="https://medium.com/androiddevelopers/the-suspend-modifier-under-the-hood-b7ce46af624f" target="_blank" rel="noopener">The suspend modifier</a></p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最終更新：<time datetime="2023-01-07T10:44:49.155Z" itemprop="dateUpdated">2023-01-07 18:44:49</time>
</span><br>


        
        谢谢大家的阅读！
        
    </div>
    
    <footer>
        <a href="http://yoursite.com">
            <img src="/img/avatar.jpg" alt="rain9155">
            rain9155
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%8F%E7%A8%8B/" rel="tag">协程</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2022/05/26/%E6%8F%AD%E7%A7%98kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/&title=《揭秘kotlin协程的实现原理》 — jianyu的博客&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2022/05/26/%E6%8F%AD%E7%A7%98kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/&title=《揭秘kotlin协程的实现原理》 — jianyu的博客&source=记录我学习的点点滴滴" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2022/05/26/%E6%8F%AD%E7%A7%98kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《揭秘kotlin协程的实现原理》 — jianyu的博客&url=http://yoursite.com/2022/05/26/%E6%8F%AD%E7%A7%98kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2022/05/26/%E6%8F%AD%E7%A7%98kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2021/09/23/%E4%BC%98%E9%9B%85%E5%9C%B0%E5%A4%84%E7%90%86%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E8%AF%B7%E6%B1%82/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">优雅地处理运行时权限请求</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢打赏!
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>このブログの内容物は<a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.ja" target="_blank">クリエイティブ・コモンズ 表示 - 非営利 - 継承 4.0 国際ライセンスの下に提供されています</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>rain9155 &copy; 2018 - 2023</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://yoursite.com/2022/05/26/%E6%8F%AD%E7%A7%98kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/&title=《揭秘kotlin协程的实现原理》 — jianyu的博客&pic=http://yoursite.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://yoursite.com/2022/05/26/%E6%8F%AD%E7%A7%98kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/&title=《揭秘kotlin协程的实现原理》 — jianyu的博客&source=记录我学习的点点滴滴" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/2022/05/26/%E6%8F%AD%E7%A7%98kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《揭秘kotlin协程的实现原理》 — jianyu的博客&url=http://yoursite.com/2022/05/26/%E6%8F%AD%E7%A7%98kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/&via=http://yoursite.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://yoursite.com/2022/05/26/%E6%8F%AD%E7%A7%98kotlin%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQ4AAAEOCAAAAABd2qZ5AAAD6ElEQVR42u3ay05CQRAFQP7/pzFxZaIXz+kekMS6KyI4zNQsmn7cbvFz/3yuXn99rv7+9d3vn/m+8uM9XL2br7Z6cODAgQNHcNTHB9h8TbtmTvz4wpLr+eEsOHDgwIHjEMc+uF5tJXk3uYw8DOdBFwcOHDhw/C1Hsq023UoCZ7J+Enpx4MCBA8e7cbRf0x5yny7iwIEDB4734WiTqFkilxcB29Ru80kcOHDgwHGWYz/Q8P6vXzrfgQMHDhz/mOM+ek6lTLPBhbYRVZwLBw4cOHCsOfKlk69sA/OmZbVPPusj4cCBAweOYA/tWEBy1M2Bk+C6STV/WRkHDhw4cBziaFtBm+GDdouzCxsOVeDAgQMHjqMcbXhrU748MWuvbX/Nl7VSHDhw4MAx4kiKaG0RsKXcf9fmwYEDBw4cpzjyEJUneMlY9n6ku+XL21Q4cODAgWPDsR9924wa5O2ipILXpnNRFw4HDhw4cIw42sLcZoxglobNUsG6oIkDBw4cOI5ytJvL//dscJ2lnThw4MCB4zUceeqVB9FTo9L5OvuiIQ4cOHDgOMvxjFRt04JqxxpmLatj2S0OHDhw4IiX3pTz2lRw0+5qE8vL9XHgwIEDx5qjTb3yls8GNA+c+VhDAYcDBw4cONYc7bbypGg2eL153TbVcODAgQPHWY7ZWNumCJinUvkhh6lantHiwIEDB46jHLOhgf36eZCe/VC4nd0uDhw4cODY5HZHm0D5fk41w6K94cCBAweO0d6SINSmTHla2F5Gm0bWPwhw4MCBA8dRjrw8lyRpCWJ+pPZbhleIAwcOHDjWHElAnbV22oDXlhfbwJxcAw4cOHDg2HO0Sc6sdTRrRG1aX+233PJ7w4EDBw4cZZ6Sv9uG532Y3LTEIiwcOHDgwLHmONXymSHmCVu+wmZgAgcOHDhw7DlmIwizNG/2jc9IAi/Xx4EDBw4cRzlmoWs2xNCS5Ung6jM4cODAgeMoRxto23C7SQvbAmK7Bxw4cODA8QyOBKIdYrgvnrZo2IbqKIXDgQMHDhwjjraBdOoYyX/ljbH2qi4DLQ4cOHDgWHC029q0pvIkbTMGMStoRvMdOHDgwIEj4NikVWeHG4oS3qJN9csF4MCBAweONceswTMrzD1eZ7Z++1/7HwE4cODAgSPhSIJrvnR7gDYYtz8C8s/gwIEDB46zHPug2Dai8qDeDlvkxcFhbRIHDhw4cDyBI99iPtyQjz60LbF8nzhw4MCB45UcbbhNUql8rK0NnElB8HK+AwcOHDhwrDmS4uA+SbuPnjag5vT1FnHgwIEDRxezDg80nCoRbtKzGRwOHDhw4BhxfADNj/ZJUewgJgAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>








<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '去哪里了?';
            clearTimeout(titleTime);
        } else {
            document.title = '欢迎光临!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
