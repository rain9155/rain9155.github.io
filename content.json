[{"title":"揭秘kotlin协程的实现原理","date":"2022-05-25T18:56:26.000Z","path":"2022/05/26/揭秘kotlin协程的实现原理/","text":"前言 上一篇文章：揭秘kotlin协程中的CoroutineContext 上一篇文章中介绍了kotlin协程的CoroutineContext的主要组成以及它的结构，kotlin协程的CoroutineContext它是一个K-V数据结构，保存了跟协程相关联的运行上下文例如协程的线程调度策略、异常处理逻辑、日志记录、运行标识、名字等，本篇文章是作为上一篇文章的补充，在使用kotlin协程一年多之后，对kotlin协程的实现有了新的认识，本文会深入介绍kotlin协程的实现原理，例如Continuation和CPS，suspend方法的含义以及背后的原理，协程是如何被创建、启动、调度，同时使用kotlin-stdlib提供的intrinsics原语实现一个简化版的协程，从而帮助我们更好地理解kotlin协程的整个设计思想，kotlin协程的源码被放在了两个库中，一部分是在kotlin标准库kotlin-stdlib中，一部分是在kotlin协程官方实现库kotlinx-coroutines中，其中kotlinx-coroutines是基于kotlin-stdlib的，kotlin-stdlib库提供了实现协程所需的基本原语。 本文涉及到的源码都是基于kotlin1.4版本 Continuation和CPS在讲解协程的原理之前，我们先来了解一下Continuation和CPS，理解了这两个术语，那么后面对于协程的理解就非常容易了： Continuation Continuation延续在计算机中表示程序剩余的部分，它保存了程序从某一点开始的执行状态，并能够在稍后的时间让程序回到这一点恢复执行，所以它是一种能够保存程序执行状态的数据结构，像break、continue这类控制流操作符一样可以暴露给用户使用，用户通过操作Continuation来控制程序的执行顺序，Continuation的概念在上个世纪五、六十年代就被提出来，首次实现Continuation的编程语言是上个世纪70年代的Scheme语言，在Scheme语言中它引入了call/cc关键字 - call-with-current-continuation，通过call/cc关键字我们可以捕获程序当前剩余的执行状态保存到Continuation中，并在之后适当的时候执行Continuation以恢复到捕获Continuation时所在的上下文继续执行，由于我不熟悉Schema语言，这里我用kotlin来模拟这个关键字，假设kotlin有call/cc关键字，它是这样使用： 1234567891011121314fun main()&#123; //pause val result = call/cc &#123; continuation -&gt; //do something continuation(\"world\") //ignore return \"world!\" &#125; //resume println(\"hello $result\")&#125;//运行输出：//hello world call/cc接收一个带有一个参数的函数，这个参数就是current-continuation表示程序剩余的部分，当程序运行到call/cc时，它会暂停程序后续的执行并捕获程序当前剩余的部分作为参数传进call/cc接收的函数中，然后执行这个函数，然后在适当的时候我们可以调用continuation，continuation接收一个参数作为call/cc的返回值，一旦我们调用continuation后，函数后面的部分就不会继续执行而是返回到call/cc调用处继续执行，而如果我们不调用continuation，那么函数就会正常执行完毕返回，这时call/cc的返回值就是函数的返回值，由于我们这里调用了continuation，所以这里程序恢复后输出了”hello world”，这就是使用call/cc应用Continuation的一个简单例子，通过Continuation我们还可以实现更为复杂的场景例如异常处理，这里继续通过call/cc实现一个异常处理try catch能力： 12345678910111213141516171819202122232425262728293031323334fun main()&#123; tryCatch(&#123; //do something, throwException(IllegalAccessException(\"something error\")) &#125;, &#123; e: Exception -&gt; //continue println(\"catch $e\") &#125;) println(\"finish\")&#125;val continuationStack = Stack&lt;Continuation&gt;()fun tryCatch(tryBlock: () -&gt; Unit, catchBlock: (e: Exception) -&gt; Unit)&#123; val result = call/cc &#123; continuation -&gt; funStack.add(continuation) return tryBlock() &#125; funStack.pop() if(result is Exception) &#123; catchBlock(result) &#125;&#125;fun throwException(e: Exception) &#123; if(continuationStack.size &gt; 0) &#123; val continuation = continuationStack.peek() continuation(e) &#125;&#125;//运行输出：//catch IllegalAccessException: something error//finish tryCatch方法接收两个函数：一个是正常代码执行主体tryBlock，一个是异常处理执行主体catchBlock，每次在执行tryBlock前都会把当前捕获的延续Continuation压入栈中，然后每次调用throwException方法抛出异常时都会弹出最近的Continuation传入异常恢复外部执行，如果tryBlock正常返回即没有调用throwException方法，这时call/cc的返回值是一个Unit类型，如果tryBlock出现异常即调用了throwException方法抛出异常，那么这时call/cc的返回值是一个Exception类型，这时就调用catchBlock处理异常，这样就通过Continuation实现了一个简单的try catch能力，这里我们也可以看到Continuation的作用，可以让我们灵活的控制程序的执行，除了异常处理，Continuation也可以被运用来实现协程、生成器等，后面我们就会看到kotlin协程的实现原理。 CPS 介绍完Continuation，继续来了解一下CPS即Continuation-passing Style延续传递风格，它是Continuation在函数式编程中的应用，像一些支持函数式编程的编程语言例如scheme、kotlin、js、py、C#等都可以把它们的函数转化为CPS风格，CPS风格的函数有以下特点： 1、函数没有return语句； 2、函数都有一个额外的Continuation参数； 3、函数内对于Continuation的传递调用都是尾调用。 先看一个普通的函数的调用： 12345678fun main()&#123; val result = add(1, 1) println(\"$result\")&#125;fun add(a: Int, b: Int): Int &#123; return a + b&#125; 上面定义了一个add方法，调用它返回两个参数相加的结果，接下把它翻译成CPS函数： 123456789fun main()&#123; add(1, 1) &#123; result -&gt; println(\"$result\") &#125;&#125;fun add(a: Int, b: Int, continuation: (result: Int) -&gt; Unit) &#123; continuation(a + b)&#125; 可以看到CPS风格的add方法与普通的add方法多了一个continuation参数，用来表示外部的控制流，当方法需要返回时，就调用传进来的continuation代替return语句，当调用传进来的continuation后，外部代码的逻辑就继续执行。 下面再看一个嵌套的函数调用： 12345678910111213141516fun main()&#123; val result = squareAdd(1, 1) println(\"$result\")&#125;fun squareAdd(a: Int, b: Int): Int &#123; return add(square(a), square(b))&#125;fun add(a: Int, b: Int): Int &#123; return a + b&#125;fun square(c: Int): Int &#123; return c * c&#125; 上面定义了一个squareAdd方法，调用它返回两个平方的相加结果，把它翻译成CPS函数： 1234567891011121314151617181920212223fun main()&#123; squareAdd(1, 1) &#123; result -&gt; println(\"$result\") &#125;&#125;fun squareAdd(a: Int, b: Int, continuation: (result: Int) -&gt; Unit) &#123; square(a) &#123; aSquareResult -&gt; square(b) &#123; bSquareResult -&gt; add(aSquareResult, bSquareResult) &#123; abAddResult -&gt; continuation(abAddResult) &#125; &#125; &#125;&#125;fun add(a: Int, b: Int, continuation: (result: Int) -&gt; Unit) &#123; continuation(a + b)&#125;fun square(c: Int, continuation: (result: Int) -&gt; Unit) &#123; continuation(c * c)&#125; 可以看到CPS风格的squareAdd方法里面不断的嵌套调用其他方法，并且调用其他方法传递Continuation时都是尾调用，尾调用就是在函数的末尾调用了另外一个函数而没有做其他操作，相应地，如果在函数的末尾调用地是函数本身，那么这就叫做尾递归，每个CPS风格的方法就是这样不断地在尾部调用其他方法并把自己当前的延续Continuation传递给调用的方法，这就是Continuation-passing延续传递名字的由来，从本质讲，CPS方法就是一个回调函数，Continuation相当于一个回调，每个CPS方法只能通过Continuation回调来恢复程序的后续逻辑执行，随着代码的复杂度提升，方法的调用数变多，CPS方法的嵌套深度也会越来越深，代码的可读性也会越来越差，出现回调地狱callback-hell现象，同时如果编译器不支持尾调用优化，那么CPS方法很容易就出现栈溢出错误。 如果编译器支持，尾调用和尾递归都可以进行优化，尾调用由于不需要依赖调用方，所以调用方函数的栈帧可以直接被尾调用函数的栈帧代替，如果所有函数都是都是尾调用，那么调用方就可以直接goto到最深处调用的函数，减少调用栈帧从而避免了栈溢出，同时减少了栈帧的内存消耗，这就是尾调用优化，而尾递归除了可以应用尾调用优化外，它还有自己特属的优化方法，由于尾递归的特殊性，我们可以把一个尾递归函数展开为一个循环调用，这样也减少了调用栈帧和内存消耗，这就是尾递归优化，kotlin中可以通过tailrec修饰符让编译器对一个尾递归函数进行优化，不管是尾调用优化和还是尾递归优化，它们都改变了原本函数的调用栈帧，所以会让debug变得困难，这也是为什么支持尾调用和尾递归优化的编译器不默认打开这个选项的原因。 那么CPS存在的意义是什么？其实CPS方法主要是作为高级语言的一种中间表示IR，把高级语言的方法逻辑编译成CPS风格，可以大大地减少编译器的实现复杂度，当程序被编译成CPS时，方法会被划分成不可再分割的最小粒度例如基本的运算、基本的方法调用等，例如 1 + 2 + 3 * 4 的计算翻译成CPS风格： 123456789101112131415161718192021fun main()&#123; calculate &#123; println(it) &#125;&#125;fun calculate(continuation: (result: Int) -&gt; Unit) &#123; &#123; cont1: (Int) -&gt; Unit -&gt; cont1(3 * 4) &#125;(&#123; mul: Int -&gt; &#123; cont2: (Int) -&gt; Unit -&gt; cont2(2 + mul) &#125;(&#123; add: Int -&gt; &#123; cont3: (Int) -&gt; Unit -&gt; cont3(1 + add) &#125;(&#123; result: Int -&gt; continuation(result) &#125;) &#125;) &#125;)&#125; 可以看到每一条基本的计算语句(+、*)都会被包含在一个函数中，每个函数只负责基本的运算，然后原函数剩余的部分被包装在Continuation中，这对于用户来说可能比较难以阅读，但对于编译器来说这会让程序的语法分析更加简单，同时CPS所有的控制流例如if else、try catch等都会通过Continuation显式表示出来，这时编译器可以直接进行控制流分析，同时在CPS的基础上还可以进行尾调用优化等手段，如果对CPS这些编译优化感兴趣的可以阅读下面链接： Compiling CPS What optimizations CPS transformations enables / disables CPS除了应用在编译器中，还可以应用在异步编程中，异步编程就是我们以不阻塞当前线程的方式来获取一个耗时操作的执行结果，例如网络请求、IO读取等，在Android中一般通过callback实现异步编程，但是通过callback进行异步编程是很困难，因为程序的逻辑被分散到各个callback，程序的连续性被打破，同时当每个callback相互依赖时就会出现callback-hell，让代码可读性降低，我们还需要额外去维护每一个callback，前面讲过CPS方法本质上是一个callback方法，所以通过CPS方法也可以处理异步编程的场景，由于CPS方法遵循一定的规则，所有编程语言就很容易替我们完成CPS转换和Continuation管理，不用我们编写复杂的CPS代码，例如js、c#中的async/await、kotlin中的suspend关键字等，这些都是语法糖，通过这些关键字修饰的一些方法都会有CPS转换的过程，可以让我们像编写同步代码那样编写异步代码，可以在一定的范围内保持程序的连续性，例如下面login和fetchData都是异步方法，fetchData方法依赖login方法，displayUI方法依赖fetchData方法： 123456789101112131415161718192021//jsasync function display() &#123; var user = await login(); //async方法 var data = await fetchData(user); //async方法 displayUI(data);&#125;//c#async void display() &#123; var user = await login(); //async方法 var data = await fetchData(user); //async方法 displayUI(data);&#125;//kotlinsuspend fun display() &#123; val user = login() //suspend方法 val userData = fetchData(user) //suspend方法 displayUI(userData)&#125; 即使login和fetchData方法是异步的，但是上面的整个运行过程都是线性的，每一个方法都会等前一个方法返回后再继续执行，这就是Continuation和CPS在异步编程中的应用，对方法进行CPS转换时，首先要进行call/cc处理即捕获当前延续Continuation，然后还要处理不同Continuation之间的流转，实现暂停和恢复，每个编程语言对于这些实现是不一样，主流的有生成器和状态机两种实现方式，js中通过生成器实现，而c#和kotlin则是通过状态机的方式实现，得益于编程语言的良好封装，我们通过这些语法糖编写异步代码时不用再去维护每一个callback，不用再考虑这些复杂的处理。 suspend方法的实现通过前面的介绍，相信大家已经猜到kotlin suspend方法的实现原理，suspend就是一个语法糖，当我们用suspend修饰命名方法或者匿名、lambda方法时，kotlin编译器会替我们把suspend方法进行CPS转换，转化后的方法会多一个额外的名为completion的Continuation类型参数，原本的返回值类型会移动到Continuation的类型参数中，并且把返回值用Any类型表示，例如命名方法： 1suspend fun login(): String 转化为： 1fun login(completion: Continuation&lt;String&gt;): Any? 再例如lambda方法： 1suspend () -&gt; String 转化为： 1(completion: Continuation&lt;String&gt;) -&gt; Any? 其实kotlin中的每个lambda方法都会对应一个Function类型, 如果lambda方法没有参数就对应Function0类型，如果lambda方法有一个参数就对应Function1类型，以此类推，每个Function类都有一个invoke方法，invoke方法的参数就对应lambda方法的参数，invoke方法的返回值就对应lambda方法的返回值，调用Function类实例的invoke方法就相当于调用对应的lambda方法，所以上面CPS转化后的lambda方法在kotlin中实际表示为： 12345678//XXX就是lambda方法对应类的名称，会根据所在类、所在方法用$符号拼接而成//这里是简化版，实际情况还会实现一个SuspendLambda抽象类，SuspendLambda继承自ContinuationImpl，后面会讲到class XXX : Function1&lt;Continuation&lt;String&gt;, Any?&gt; &#123; override fun invoke(completion: Continuation&lt;String&gt;): Any? &#123; //... &#125;&#125; suspend方法CPS后的方法都返回值用一个Any类型表示，它是T | COROUTINE_SUSPENDED的组合类型，T表示suspend方法同步执行返回时的类型，例如这里返回为String类型，当suspend方法不需要挂起时，suspend方法就正常返回对应的值或者抛出异常，COROUTINE_SUSPENDED表示suspend方法需要挂起时返回的一个枚举类型，当suspend方法需要挂起时，suspend方法就返回COROUTINE_SUSPENDED表示这个suspend方法被挂起，最终真正执行挂起动作返回COROUTINE_SUSPENDED的地方是kotlin intrinsics提供的suspendCoroutineUninterceptedOrReturn方法，这个方法可以捕获传递过来的Continuation，然后决定是否挂起，kotlin协程库提供的一些封装好的挂起方法如withContext、delay、await等最终都是调用这个方法捕获Continuation和执行挂起动作，我们编写suspend方法时也可以直接使用这个方法，实现我们自己的挂起逻辑，后面在intrinsics中会介绍这个方法。 当一个suspend方法被挂起，说明这个suspend方法不能马上同步返回对应的结果，而是在稍后准备好时再通过调用Continuation的resumeWith方法从挂起点恢复返回结果，Continuation在kotlin中是一个接口： 123456789//T为suspend方法的返回值类型public interface Continuation&lt;in T&gt; &#123; //当前延续的上下文 public val context: CoroutineContext //当需要从挂起点恢复时调用这个方法，result可以表示正常恢复还是异常恢复 public fun resumeWith(result: Result&lt;T&gt;)&#125; 挂起点suspend point就是调用suspend方法的地方，当我们在suspend方法中调用suspend方法时，每一个suspend方法的调用处就是一个挂起点，整个suspend方法被挂起点分割成多个部分，每一个部分都对应一个Continuation，例如： 123456789101112131415161718suspend fun display() &#123; val user = login() //suspend方法，挂起点1 val data = fetchData(user) //suspend方法，挂起点2 displayUI(data) //普通方法 &#125;suspend fun login(): String &#123; delay(200) //suspend方法，延迟200ms后返回 return \"user\"&#125;suspend fun fetchData(user: String): String &#123; return \"$user data\"&#125;fun displayUI(data: String) &#123; println(\"displayUI: $data\")&#125; 根据挂起点划分，上面display方法有三个延续Continuation： 1、初始Continuation，整个display方法就是一个Continuation； 2、子Continuation1，挂起点1到display方法结尾； 3、子Continuation2，挂起点2到display方法结尾。 类似地，login方法有两个延续，kotlin并不会像传统的CPS处理那样为每一个Continuation创建对应的实例，kotlin只会为整个suspend方法创建一个初始Continuation实例，然后在这个Continuation实例内部通过状态机进行流转，每个挂起点对应状态机中的一个状态，通过状态机就可以复用一个Continuation实例就能达到在多个挂起点之间进行挂起和恢复的效果，减少了Continuation实例的创建数量，下面是display方法的对应实现，是经过简化后的版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129fun display(completion: Continuation&lt;Unit&gt;): Any? &#123; //display方法的状态机，继承自ContinuationImpl class DisplayStateMachine( //completion是调用display方法时传递进来的，当display执行完毕时，通过completion恢复外部执行 completion: Continuation&lt;Unit&gt; ) : ContinuationImpl(completion) &#123; //保存每个挂起点恢复后的结果 var result: Result&lt;Any?&gt; = null //当前display方法的状态 var label: Int = 0 //当invokeSuspend被调用时，再次调用display方法，这时result会是前一个状态的结果，而label也已处于将要执行的状态 override fun invokeSuspend(result: Result&lt;Any?&gt;): Any? &#123; this.result = result return display(this) &#125; &#125; //如果是第一次调用display方法，就创建状态机实例，如果不是第一次调用，继续执行状态 val continuation = completion as? DisplayStateMachine ?: DisplayStateMachine(completion) //COROUTINE_SUSPENDED标记，用于判断是否挂起 val val0 = COROUTINE_SUSPENDED when(continuation.label) &#123; 0 -&gt; &#123; //错误检查 continuation.result?.getOrThrow() //下次display方法被调用时, 它应当直接去到状态1 continuation.label = 1 //调用login方法，传入continuation val val1 = login(continuation) //判断是否挂起 if(val1 == val0) &#123; //如果挂起，直接return，后面通过传进login方法的continuation恢复当前状态机执行 return val0 &#125; //如果没有挂起，继续执行，下面流程跟label1类似 val user = val1 as String continuation.label = 2 val val2 = fetchData(user, continuation) if(val2 == val0) &#123; return val0 &#125; val data = val2 as String continuation.label = -1 displayUI(data) return Unit &#125; 1 -&gt; &#123; //错误检查, 并获取前一个状态的结果 val user = continuation.result?.getOrThrow() as String //下次display方法被调用时, 它应当直接去到状态2 continuation.label = 2 //调用fetchData方法，传入continuation val val2 = fetchData(user, continuation) //判断是否挂起 if(val2 == val0) &#123; //如果挂起，直接return，后面通过传进fetchData方法的continuation恢复当前状态机执行 return val0 &#125; //如果没有挂起，继续执行，下面流程跟label2类似 val data = val2 as String continuation.label = -1 displayUI(data) return Unit &#125; 2 -&gt; &#123; //错误检查, 并获取前一个状态的结果 val data = continuation.result?.getOrThrow() as String //display方法执行完毕，把label置为非法状态 continuation.label = -1 displayUI(data) return Unit &#125; else -&gt; &#123; throw IllegalStateException(\"call to 'resume' before 'invoke' with coroutine\") &#125; &#125;&#125;fun login(completion: Continuation&lt;String&gt;): Any? &#123; //login方法的状态机, 跟display方法的类似 class LoginStateMachine( //completion是调用login方法时传递进来的，当login执行完毕时，通过completion恢复外部执行 completion: Continuation&lt;Unit&gt; ) : ContinuationImpl(completion) &#123; var result: Result&lt;Any?&gt; = null var label: Int = 0 override fun invokeSuspend(result: Result&lt;Any?&gt;): Any? &#123; this.result = result return login(this) &#125; &#125; val continuation = completion as? LoginStateMachine ?: LoginStateMachine(completion) val val0 = COROUTINE_SUSPENDED when(continuation.label) &#123; 0 -&gt; &#123; continuation.result?.getOrThrow() continuation.label = 1 val val1 = delay(continuation) if(val1 == val0) &#123; return val0 &#125; return \"user\" &#125; 1 -&gt; &#123; continuation.result?.getOrThrow() continuation.label = -1 return \"user\" &#125; else -&gt; &#123; throw IllegalStateException(\"call to 'resume' before 'invoke' with coroutine\") &#125; &#125;&#125;fun fetchData(user: String, completion: Continuation&lt;String&gt;): Any? &#123; return \"$user data\"&#125;fun displayUI(data: String) &#123; println(\"displayUI: $data\")&#125; 可以看到display和login方法都创建了对应的状态机，每个延续都对应状态机的一个状态，每个状态机都继承自ContinuationImpl，ContinuationImpl的父类是BaseContinuationImpl，它实现了Continuation的resumeWith方法并且含有一个invokeSuspend抽象方法，所以每个状态机都会实现这个invokeSuspend方法，并且每个状态机都会持有一个外部的完成延续Continuation，用来在当前状态机运行结束时恢复外部的Continuation，关于Continuation的恢复后面会讲。 当suspend方法第一次被调用时就会创建一个状态机，这时状态机是初始状态，对应执行初始延续的逻辑，每执行完一个状态，都会把状态机的状态提前置为下一个状态，当要执行下一个状态时，只需要再次调用suspend方法就行，而这个再次调用就由invokeSuspend方法来完成，invokeSuspend方法中会调用suspend方法进行状态流转，而invokeSuspend方法会被resumeWith方法调用，而Continuation的resumeWith方法什么时候调用，就是由我们自己决定的，因为最终suspend方法的状态机Continuation会被传递到kotlin intrinsics提供的suspendCoroutineUninterceptedOrReturn方法中，在这个方法中我们可以捕获到这个Continuation，并决定什么时候调用这个Continuation到resumeWith方法。 上面的display和login方法都是命名suspend方法，对于suspend lambda方法，kotlin编译器也会对它进行CPS转换并且创建状态机，不同的是suspend lambda方法的状态机是继承自SuspendLambda类，而SuspendLambda是ContinuationImpl的子类，例如我们通过launch方法传递block块启动协程： 123456789101112131415fun main() &#123; GlobalScope.launch &#123;//suspend lambda方法 val user = login() //suspend方法，挂起点1 val data = fetchData(user) //suspend方法，挂起点2 displayUI(data) //普通方法 &#125;&#125;public fun CoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope.() -&gt; Unit): Job &#123; //...&#125; 这个block块就是一个suspend lambda方法，所以kotlin编译器会为这个suspend lambda方法创建一个实现了Function接口、继承自SuspendLambda的类，并且这个类同时也实现了状态机，如下： 1234567891011121314151617181920212223242526272829fun main()&#123; GlobalScope.launch(EmptyCoroutineContext, CoroutineStart.DEFAULT, SuspendLambdaStateMachine(null))&#125;class SuspendLambdaStateMachine(completion: Continuation&lt;Unit&gt;) : SuspendLambda(2, completion), Function2&lt;CoroutineScope, Continuation&lt;Unit&gt;, Any?&gt; &#123; //保存每个挂起点恢复后的结果 var result: Result&lt;Any?&gt; = null //当前lambda方法的状态 var label: Int = 0 //invoke方法被调用相当于lambda方法被执行，在里面它会创建状态机，并执行状态机的invokeSuspend方法 override fun invoke(p1: CoroutineScope, completion: Continuation&lt;Unit&gt;): Any? &#123; return (create(completion) as SuspendLambdaStateMachine).invokeSuspend(Result.success(Unit)) &#125; //调用create方法可以传入一个完成延续创建suspend lambda方法的状态机 override fun create(completion: Continuation&lt;*&gt;): Continuation&lt;Unit&gt; &#123; return SuspendLambdaStateMachine(completion) &#125; //调用invokeSuspend方法进行状态流转，这时result会是前一个状态的结果，而label也已处于将要执行的状态 override fun invokeSuspend(result: Result&lt;Any?&gt;): Any? &#123; this.result = result when(label) &#123; //...跟前面display方法类似, 这个 &#125; &#125;&#125; suspend lambda方法的状态机会比suspend命名方法多实现一个create方法，这个create方法也来自于父类BaseContinuationImpl中，这个create方法的目的就是创建一个suspend lambda方法的状态机实例并传入它的完成延续，这个方法最终会被kotlin intrinsice方法的createCoroutineUnintercepted方法调用。 通过前面介绍的suspend命名方法和suspend lambda方法实现可以看出，kotlin编译器为每个suspend方法做了以下几件事： 1、为含有挂起点、且挂起点不是尾调用的suspend方法创建一个私有的状态机； 2、状态机中通过变量保存了suspend方法将要执行的状态和上一个状态的结果，每一次执行状态前，为了防止挂起函数运行失败都会进行状态检查，并且调用挂起函数前，状态机的状态都会提前置为下一个状态； 3、调用其他挂起函数时，都会把当前状态机实例作为Continuation传递过去，而被调用的挂起函数满足1条件时也会被创建一个状态机，当被调用挂起函数的状态机运行结束时，可以利用传递过去的Continuation恢复当前状态机执行。 从第1点可以看出，kotlin编译器并不总是为suspend方法创建状态机，例如fetchData方法，虽然它是suspend方法，但是它里面没有调用其他的suspend方法，并不需要处理状态，所以kotlin编译器不会为它创建状态机，还有一种情况kotlin编译器也不会创建状态机，就是如果suspend方法中只有一个suspend方法调用并且这个suspend方法调用是尾调用，那么kotlin编译器不会为它创建状态机，只会简单地把suspend方法的Continuation实例继续传递给尾调用的suspend方法，因为在尾调用中，调用方不需要保存状态，所以总结起来就是kotlin编译器只会为含有非尾部suspend方法调用的suspend方法创建状态机，这是kotlin编译器的一个优化，避免创建多余的状态机实例。 kotlin官方对于suspend方法还提出了另外一个优化，就是只有当首次挂起时才进行状态机的创建，即状态机懒创建，因为在首次挂起前，suspend方法很有可能因为其他原因提前退出了，这时提前创建的状态机就是多余的。 从第2点可以看出，suspend方法的挂起和恢复是通过状态机的状态切换来实现的，每个状态对应suspend方法的每个延续，状态机保存了每个延续恢复后的结果，从第3点可以看出，suspend方法的状态机实例会作为Continuation在suspend方法之间传递，而最终这个状态机实例Continuation会传到suspendCoroutineUninterceptedOrReturn方法中暴露给我们使用，在这个方法里我们可以控制这个Continuation例如包装它在恢复前作出一些我们的自定义行为，并决定什么时候进行恢复，当我们决定恢复时，就调用resumeWith方法就行。 intrinsics方法kotlin intrinsics方法是用来实现协程的基本原语，前面已经讲过协程的实现原理是Continuation，Continuation的最主要的好处就是可以暴露给用户用于控制程序的执行，而kotlin intrinsics作用就是可以让我们调用它提供的基本方法获取Continuation，kotlin intrinsics在kotlin-stdlib和kotlinx-coroutines都有相应的intrinsics包，而kotlinx-coroutines的intrinsics包是基于kotlin-stdlib的intrinsics包的安全实现，增加了一些try catch、启动时可取消、拦截的能力，kotlin-stdlib的intrinsics包是不推荐给用户使用的，因为使用它必须要注意一些问题，所以kotlin在IDE中隐藏了kotlin-stdlib的intrinsics包的智能提示，我们无法自动导入这个包只能手动导入，并且里面的方法在引用时也没有提示，只能手动编写，这里我主要讲kotlin-stdlib的intrinsics包的方法，因为它才是最基本的实现，如果平时开发使用，还是推荐使用kotlinx-coroutines的intrinsics包。 首先我们要手动导入kotlin-stdlib的intrinsics包： 1import kotlin.coroutines.intrinsics.* intrinsics包主要有两部分，一部分是基于suspend lambda方法创建Continuation，一部分是捕获suspend方法的Continuation，先看Continuation的创建： 123public actual fun &lt;T&gt; (suspend () -&gt; T).createCoroutineUnintercepted(completion: Continuation&lt;T&gt;)public actual fun &lt;R, T&gt; (suspend R.() -&gt; T).createCoroutineUnintercepted(receiver: R, completion: Continuation&lt;T&gt;): Continuation&lt;Unit&gt; createCoroutineUnintercepted方法用来创建一个返回值为T类型的初始Continuation实例，创建Continuation实例需要传入一个完成延续，当需要执行这个Continuation时，就调用它的resumeWith方法，当这个Continuation执行完毕时，完成延续completion的resumeWith方法就会回调，suspend lambda方法是普通方法和suspend方法之间的桥梁，因为suspend方法只能在suspend方法中调用，所以为了调用suspend方法，我们只能在普通方法声明一个suspend lambda类型的参数，然后在调用普通方法时传入suspend lambda方法块，并在传入suspend lambda方法块中调用其他suspend方法，例如kotlin协程通过launch方法启动时，都是要传一个block块，这个block块就是一个suspend lambda方法，我们传进去的block最终会被调用它的createCoroutineUnintercepted方法创建初始协程的初始Continuation实例，以CoroutineStart.DEFAULT启动模式为例，调用链如下： 12345CoroutineScope.launch(context, start, block)-&gt; AbstractCoroutine.start(start, coroutine, block)-&gt; CoroutineStart.invoke(block, receiver, completion)-&gt; block.startCoroutineCancellable(receiver, completion)-&gt; createCoroutineUnintercepted(receiver, completion).intercepted().resumeCancellable(Result.success(Unit)) 而前面讲过suspend lambda方法会被CPS成一个状态机实现，这个状态机继承自BaseContinuationImpl并且实现了create方法，而createCoroutineUnintercepted方法会调用这个create方法创建状态机实例作为协程的初始Continuation。 从上面launch的调用链可以看到调用了createCoroutineUnintercepted方法后会马上调用intercepted方法，intercepted方法是Continuation的扩展方法，它也属于intrinsics方法，方法签名如下： 1fun Continuation&lt;T&gt;.intercepted(): Continuation&lt;T&gt; 这个方法的作用是在Continuation的上下文CoroutineContext中查找拦截器ContinuationInterceptor，并返回拦截器对Continuation的拦截延续，它包装了原始的Continuation，在Continuation恢复前做出一些其他操作，目前在协程实现中intercepted方法返回的是一个DispatchedContinuation，它的作用是在Continuation恢复前把它分发到对应上下文的Dispatcher中恢复，这样原始的Continuation就会被切换到对应的Dispatcher中执行，由于拦截在协程的执行过程会经常用到，所以kotlin就建议在调用createCoroutineUnintercepted方法创建了初始Continuation后和调用suspendCoroutineUninterceptedOrReturn方法捕获Continuation后马上调用它的intercepted方法，因为intercepted方法中会返回的拦截延续进行缓存，这样后续调用intercepted方法时就能马上返回。 前面多次讲到了suspendCoroutineUninterceptedOrReturn方法，它也属于intrinsics方法，suspendCoroutineUninterceptedOrReturn方法的作用是捕获suspend连续传递过来的Continuation，方法签名如下： 1public suspend inline fun &lt;T&gt; suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation&lt;T&gt;) -&gt; Any?): T suspendCoroutineUninterceptedOrReturn方法的返回值类型即为Continuation的结果类型，在block块中我们可以拿到Continuation实例，注意到block块的返回值为Any类型，还记得前面讲suspend方法CPS后的返回值也为Any类型，这个Any类型就是T | COROUTINE_SUSPENDED的组合类型，如果block块中返回了COROUTINE_SUSPENDED，则表示suspend方法需要挂起并且不会立即返回结果，在这种情况下，要在将来的某个时刻调用Continuation的resumeWith来恢复suspend方法的执行，如果block块中返回了T类型的值或者抛出了异常，这表示执行没有被挂起，suspend方法可以直接同步返回结果，suspendCoroutineUninterceptedOrReturn方法是一个非常实用且常用的intrinsics方法，通过它我们可以对普通回调方法进行包装，把它与suspend方法进行结合，如下： 1234567891011121314151617181920212223242526272829fun main() &#123; GlobalScope.launch &#123; try &#123; val data = fetchData() println(data) &#125;catch (e: NullPointerException) &#123; e.printStackTrace() &#125; &#125;&#125;suspend fun fetchData(): String = suspendCoroutineUninterceptedOrReturn &#123; continuation -&gt; fetchDataAsync &#123; //恢复 if(it.isNullOrEmpty()) &#123; continuation.resumeWithException(NullPointerException()) &#125;else &#123; continuation.resume(it) &#125; &#125; //挂起 COROUTINE_SUSPENDED&#125;fun fetchDataAsync(callback: (String) -&gt; Unit) &#123; Executors.newCachedThreadPool().execute &#123; callback.invoke(\"result\") &#125;&#125; 可以看到suspendCoroutineUninterceptedOrReturn方法可以把回调方法结果在suspend方法中以同步的形式返回，除了这种应用，我还可以对捕获到的Continuation进行包装，像DispatchedContinuation那样在Continuation恢复前后自定义我们自己的逻辑，像协程提供的delay、await、withContext等方法都是利用suspendCoroutineUninterceptedOrReturn方法实现它们的逻辑，例如delay方法可以让捕获的Continuation延迟指定时间后恢复，await方法可以让捕获的Continuation等到协程完成得到结果后才恢复，但是我们在日常开发中一般不会直接使用suspendCoroutineUninterceptedOrReturn方法，因为使用不当会让线程出现栈溢出错误，suspendCoroutineUninterceptedOrReturn方法已经在注释中明确提示： 123/** * Note that it is not recommended to call either Continuation.resume nor Continuation.resumeWithException * functions synchronously in the same stackframe where suspension function is run. Use suspendCoroutine as a * safer way to obtain current continuation instance. */ 不推荐在运行suspend方法的同一堆栈帧中同步调用Continuation的resumeWith方法，例如： 123suspend fun fetchData(): String = suspendCoroutineUninterceptedOrReturn &#123; continuation -&gt; //错误做法，不推荐在当前线程栈帧调用Continuation的resumeWith方法 continuation.resume(\"result\")&#125; 因为如果我们直接在当前线程上同步调用resumeWith方法，就相当于递归调用上一个suspend方法，这样当当前线程长时间运行时，就会很容易出现栈溢出错误，注释提到推荐使用suspendCoroutine方法代替suspendCoroutineUninterceptedOrReturn方法获取当前Continuation，该方法定义在kotlin.coroutines中： 1234567public suspend inline fun &lt;T&gt; suspendCoroutine(crossinline block: (Continuation&lt;T&gt;) -&gt; Unit): T &#123; return suspendCoroutineUninterceptedOrReturn &#123; c: Continuation&lt;T&gt; -&gt; val safe = SafeContinuation(c.intercepted()) block(safe) safe.getOrThrow() &#125;&#125; 通过suspendCoroutine获取到的Continuation是一个SafeContinuation，它是对suspendCoroutineUninterceptedOrReturn捕获的Continuation又一层包装，它可以让我们同步地、安全地调用Continuation的resumeWith方法，而不用考虑任何限制，如下： 1234suspend fun fetchData(): String = suspendCoroutine &#123; continuation -&gt; //没问题，SafeContinuation可以同步调用 continuation.resume(\"result\")&#125; SafeContinuation的原理就是它重写了resumeWith方法，在同步调用的情况下，不调用真正的Continuation的resumeWith方法，而是先保存结果，然后把保存的结果在调用getOrThrow方法时直接return给调用方法，这样就避免了同步调用Continuation的resumeWith方法出现的问题，同时SafeContinuation还替我们封装好了返回COROUTINE_SUSPENDED的逻辑，我们使用suspendCoroutine需要挂起时不用再显式地返回COROUTINE_SUSPENDED，除了suspendCoroutine方法，我们还可以使用suspendCancellableCoroutine方法代替，它定义在kotlinx.coroutines中： 123456public suspend inline fun &lt;T&gt; suspendCancellableCoroutine( crossinline block: (CancellableContinuation&lt;T&gt;) -&gt; Unit): T = suspendCoroutineUninterceptedOrReturn &#123; uCont -&gt; val cancellable = CancellableContinuationImpl(uCont.intercepted(), resumeMode = MODE_CANCELLABLE) cancellable.initCancellability() block(cancellable) cancellable.getResult() &#125; 通过suspendCancellableCoroutine获取到的Continuation是一个CancellableContinuation，它也是对suspendCoroutineUninterceptedOrReturn捕获的Continuation又一层包装，它除了可以让我们同步地、安全地调用Continuation的resumeWith方法外，还可以取消Continuation同时响应协程的取消，例如： 12345678910suspend fun fetchData(): String = suspendCancellableCoroutine&#123; continuation -&gt; val fileIs = FileInputStream(File(\"test\")) continuation.invokeOnCancellation &#123; //Continuation被取消时执行一些资源释放工 fileIs.close() &#125; //...do something //没问题，CancellableContinuation可以同步调用 continuation.resume(\"result\") &#125; kotlin intrinsics方法中还有一个startCoroutineUninterceptedOrReturn方法，当你调用它之后，他会创建一个Continuation并立即执行它，直到遇到第一个挂起点，而createCoroutineUnintercepted方法创建的Continuation需要你显式调用resumeWith方法才会执行，它的方法签名如下： 123public inline fun &lt;T&gt; (suspend () -&gt; T).startCoroutineUninterceptedOrReturn(completion: Continuation&lt;T&gt;): Any?public inline fun &lt;R, T&gt; (suspend R.() -&gt; T).startCoroutineUninterceptedOrReturn(receiver: R, completion: Continuation&lt;T&gt;): Any? 这个返回的调用同样需要传入一个Continuation作为该方法创建的Continuation的完成延续，当该方法创建的Continuation执行完毕后，完成延续completion的resumeWith方法就会被调用，与createCoroutineUnintercepted方法不同的是它的返回值是一个Any类型，这个Any类型的含义和前面讲的suspendCoroutineUninterceptedOrReturn方法中block块的返回值含义一样，这个方法的主要是和suspendCoroutineUninterceptedOrReturn方法结合使用，在相同的上下文中使用不同的suspend lambda块创建执行新的Continuation，并在新的Continuation结束后恢复suspendCoroutineUninterceptedOrReturn方法捕获的Continuation，例如withContext方法就使用到了suspendCoroutineUninterceptedOrReturn方法，如下： 123456789101112131415161718192021222324252627282930public suspend fun &lt;T&gt; withContext( context: CoroutineContext, block: suspend CoroutineScope.() -&gt; T): T &#123; return suspendCoroutineUninterceptedOrReturn sc@ &#123; uCont -&gt; val oldContext = uCont.context val newContext = oldContext + context newContext.checkCompletion() // FAST PATH #1 -- newContext等于oldContext，不需要执行上下文切换 if (newContext === oldContext) &#123; val coroutine = ScopeCoroutine(newContext, uCont) //最终调用block.startCoroutineUninterceptedOrReturn方法 return@sc coroutine.startUndispatchedOrReturn(coroutine, block) &#125; // FAST PATH #2 -- newContext的Dispatcher等于oldContext的oldContext，不需要切换Dispatcher if (newContext[ContinuationInterceptor] == oldContext[ContinuationInterceptor]) &#123; val coroutine = UndispatchedCoroutine(newContext, uCont) withCoroutineContext(newContext, null) &#123; //最终调用block.startCoroutineUninterceptedOrReturn方法 return@sc coroutine.startUndispatchedOrReturn(coroutine, block) &#125; &#125; // SLOW PATH -- newContext不等于oldContext val coroutine = DispatchedCoroutine(newContext, uCont) coroutine.initParentJob() //最终调用block.createCoroutineUnintercepted方法 block.startCoroutineCancellable(coroutine, coroutine) coroutine.getResult() &#125;&#125; withContext方法的作用是把block块运行在新的上下文中，并返回block块的运行结果，同时返回时会切换到原来的上下文中，withContext方法在不需要进行Dispatcher切换的情况中会直接使用block.startCoroutineUninterceptedOrReturn方法，这样会减少无谓的intercepted方法调用。 createCoroutineUnintercepted、startCoroutineUninterceptedOrReturn、suspendCoroutineUninterceptedOrReturn三个方法就是kotlin intrinsice中最常用到的方法，用来创建、启动和捕获Continuation，kotlin协程的本质就是启动、调度和管理Continuation，所以说intrinsics方法是kotlin协程实现的基石。 Continuation的恢复从前面可以看到，当我们需要从挂起点恢复被挂起的Continuation或者首次执行这个Continuation时，就要调用Continuation接口的resumeWith方法，resumeWith方法方法根据Continuation的子类不同有不同的实现，在kotlin协程中，Continuation主要有BaseContinuationImpl、DispatchedContinuation、SafeContinuation、CancellableContinuation、AbstractCoroutine这几种实现，下面主要讲一下DispatchedContinuation、BaseContinuationImpl和AbstractCoroutine的resumeWith方法实现，它们之间的关系如下： DispatchedContinuation DispatchedContinuation就是把Continuation分发到对应上下文的Dispatcher中执行，当我们需要拦截Continuation时，就调用它的intercepted方法获取它的DispatchedContinuation，当一个Continuation被拦截后，后续它执行都在对应的Dispatcher中，DispatchedContinuation当resumeWith方法实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162internal class DispatchedContinuation&lt;in T&gt;( @JvmField val dispatcher: CoroutineDispatcher,//被拦截Continuation的Dispatcher @JvmField val continuation: Continuation&lt;T&gt;//被拦截的Continuation) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation &#123; //... override fun resumeWith(result: Result&lt;T&gt;) &#123; val context = continuation.context val state = result.toState() if (dispatcher.isDispatchNeeded(context)) &#123;//IO、DEFAULT、MAIN走这里逻辑 _state = state resumeMode = MODE_ATOMIC //调用dispatch方法后，DispatchedTask的run方法会执行 dispatcher.dispatch(context, this) &#125; else &#123;//Unconfined走这里的逻辑 executeUnconfined(state, MODE_ATOMIC) &#123; withCoroutineContext(this.context, countOrElement) &#123; //调用Continuation的resumeWith方法 continuation.resumeWith(result) &#125; &#125; &#125; &#125;&#125;internal abstract class DispatchedTask&lt;in T&gt;(@JvmField public var resumeMode: Int) : SchedulerTask() &#123; //... public final override fun run() &#123; val taskContext = this.taskContext var fatalException: Throwable? = null try &#123; val delegate = delegate as DispatchedContinuation&lt;T&gt; val continuation = delegate.continuation val context = continuation.context val state = takeState() withCoroutineContext(context, delegate.countOrElement) &#123; val exception = getExceptionalResult(state) val job = if (exception == null &amp;&amp; resumeMode.isCancellableMode) context[Job] else null if (job != null &amp;&amp; !job.isActive) &#123; val cause = job.getCancellationException() cancelCompletedResult(state, cause) continuation.resumeWithStackTrace(cause) &#125; else &#123; //调用Continuation的resumeWith方法 if (exception != null) &#123; continuation.resumeWithException(exception) &#125; else &#123; continuation.resume(getSuccessfulResult(state)) &#125; &#125; &#125; &#125; catch (e: Throwable) &#123; fatalException = e &#125; finally &#123; val result = runCatching &#123; taskContext.afterTask() &#125; handleFatalException(fatalException, result.exceptionOrNull()) &#125; &#125;&#125; 可以看到如果Dispatcher是Unconfined，那么就会在当前线程调用Continuation的resumeWith方法，如果Dispatcher是IO、DEFAULT、MAIN，就调用它们的dispatch方法提交DispatchedTask任务等待调度执行，而DispatchedContinuation同时又继承自DispatchedTask，所以它是一个DispatchedTask，等IO、DEFAULT、MAIN的Dispatcher调度时，run方法就会执行，这时就调用Continuation的resumeWith方法，这样Continuation就被分发到对应上下文的线程中恢复。 BaseContinuationImpl BaseContinuationImpl是所有suspend方法状态机的共同父类，例如子类ContinuationImpl就表示suspend命名方法，子类SuspendLambda就表示suspend lambda方法，除了这些普通的suspend方法外，kotlin中还有一种受限suspend方法，它是一种带有限制的suspend方法作用域，在这种带限制的suspend方法中只能调用@RestrictsSuspension注解的类中定义的suspend方法，例如sequence方法的block块就是一个带有限制的suspend lambda方法： 123456789101112131415161718fun main() &#123; sequence&lt;Int&gt; &#123; //display() 报错，不允许调用其他suspend方法 yield(1) //只能调用被@RestrictsSuspension注解的SequenceScope类中定义的yield方法 &#125;&#125;public fun &lt;T&gt; sequence(@BuilderInference block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit): Sequence&lt;T&gt; &#123; //...&#125;@RestrictsSuspensionpublic abstract class SequenceScope&lt;in T&gt; internal constructor() &#123; public abstract suspend fun yield(value: T) //...&#125; 受限的suspend方法用RestrictedContinuationImpl表示，受限的suspend lambda方法用RestrictedSuspendLambda表，当我们调用BaseContinuationImpl的resumeWith方法时，就是在执行当前suspend方法的状态机，并且在状态机运行结束时恢复外部Continuation，我们可以看一下BaseContinuationImpl的resumeWith方法的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041internal abstract class BaseContinuationImpl( //每个BaseContinuationImpl实例都会引用一个完成Continuation，用来在当前状态机流转结束时恢复这个Continuation public val completion: Continuation&lt;Any?&gt;?) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123; //resumeWith方法中通过循环由里到外恢复Continuation public final override fun resumeWith(result: Result&lt;Any?&gt;) &#123; var current = this var param = result while (true) &#123; probeCoroutineResumed(current) with(current) &#123; val completion = completion!! val outcome: Result&lt;Any?&gt; = try &#123; //通过调用invokeSuspend方法执行当前suspend方法主体，进行状态流转 val outcome = invokeSuspend(param) if (outcome === COROUTINE_SUSPENDED) return Result.success(outcome) &#125; catch (exception: Throwable) &#123; Result.failure(exception) &#125; //当invokeSuspend方法没有返回COROUTINE_SUSPENDED，就表示当前状态机流转结束，即当前suspend方法执行完毕 releaseIntercepted() //然后在这里判断是否还有suspend方法需要恢复 if (completion is BaseContinuationImpl) &#123; //completion是suspend方法，继续恢复 current = completion param = outcome &#125; else &#123; //completion不是suspend方法，调用resumeWith方法恢复 completion.resumeWith(outcome) return &#125; &#125; &#125; &#125; //每个suspend方法状态机都要实现这个接口，用来调用suspend方法主体 protected abstract fun invokeSuspend(result: Result&lt;Any?&gt;): Any? //...&#125; 每个BaseContinuationImpl实例就代表一个suspend方法状态机，当suspend方法状态机执行结束时，BaseContinuationImpl就会恢复引用的完成Continuation，如果完成Continuation是suspend方法，就调用它状态机的invokeSuspend方法，当遇到完成Continuation不是suspend方法时，就调用它的resumeWith方法执行对应的逻辑。 AbstractCoroutine AbstractCoroutine是kotlin协程的基类，AbstractCoroutine在kotlin协程实现中会作为最后一个恢复的Continaution，所以当所有suspend方法都执行完毕后，AbstractCoroutine的resumeWith方法就会被调用，这时它就可以进行协程的生命周期流转，例如判断子协程是否完成，如果子协程都完成了，那么就能置为完成状态，否则就置为完成中状态等待所有子协程完成，如下： 1234567891011public abstract class AbstractCoroutine&lt;in T&gt;(protected val parentContext: CoroutineContext, active: Boolean = true) : JobSupport(active), Job, Continuation&lt;T&gt;, CoroutineScope &#123; //... public final override fun resumeWith(result: Result&lt;T&gt;) &#123; //进行协程生命周期流转 val state = makeCompletingOnce(result.toState()) if (state === COMPLETING_WAITING_CHILDREN) return afterResume(state) &#125;&#125; 自己实现Coroutine当我们通过launch方法传入block块启动一个协程，本质是通过这个block块创建了一个Continuation，当我们在block块中调用其他suspend方法，并且suspend方法中再调用其他suspend方法，Continuation就会在这些suspend方法之间传递，最终我们可以捕获到连续传递的Continuation，当我们通过Continuation恢复时，本质是上一个suspend方法的递归调用进行状态流转，而kotlin协程只是在这些Continuation的基础上添加了生命周期管理、父子关系、异常处理、线程切换等逻辑。 通过intrinsics方法，我们自己也可以实现一个协程，这里我通过intrinsics方法仿照kotlin协程写了个简化版的协程，它这样使用： 1234567891011121314151617181920212223242526272829303132333435363738fun main() &#123; val simpleScope = SimpleCoroutineScope(Dispatchers.Default) val simpleJob = simpleScope.launch(CoroutineName(\"main\"), CoroutineStart.DEFAULT) &#123; val user = login() val userData = fetchData(user) displayUI(userData) &#125; simpleJob.invokeOnCompletion(object : SimpleJob.CompletionHandler &#123; override fun invoke(cause: Throwable?) &#123; println(\"invokeOnCompletion: cause = $cause\") &#125; &#125;) //进程保活 Thread.sleep(1000)&#125;private suspend fun SimpleCoroutineScope.login(): String &#123; return async(CoroutineName(\"login\")) &#123; delay(200) return@async \"user\" &#125;.await()&#125;private suspend fun SimpleCoroutineScope.fetchData(user: String): String &#123; return async(CoroutineName(\"fetch\")) &#123; delay(200) return@async \"$user data\" &#125;.await()&#125;private fun displayUI(data: String) &#123; println(\"displayUI: $data\")&#125;//运行输出：//displayUI: user data//invokeOnCompletion: cause = null invokeOnCompletion方法回调会在协程完成后被调用，如果协程正常完成那么，cause为null，如果协程异常完成，那么cause为对应的异常，上面协程正常完成，所有实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338import kotlinx.coroutines.*import kotlin.coroutines.*import kotlin.coroutines.intrinsics.*import java.util.concurrent.CopyOnWriteArraySet/** * 简化版的[CoroutineScope]，提供协程运行作用域，它与[CoroutineScope]的区别是没有[CoroutineScope.cancel]、[CoroutineScope.ensureActive]等这些扩展方法 */private interface SimpleCoroutineScope &#123; val coroutineContext: CoroutineContext&#125;/** * [SimpleCoroutineScope]的实现 */private class SimpleCoroutineScopeImpl(override val coroutineContext: CoroutineContext) : SimpleCoroutineScope/** * 构造[SimpleCoroutineScope]实例 */private fun SimpleCoroutineScope(context: CoroutineContext) = SimpleCoroutineScopeImpl(if(context[SimpleJob] != null) context else context + SimpleJob())/** * 简化版的[Job]，用于管理协程的生命周期，它与[Job]的区别是它没有取消操作、异常传播、异常处理等功能，只有简单的状态流转： * * start/await * NEW -------------&gt; ACTIVE (isActive = true) * \\ / * \\ fail/finish / * \\ / * COMPLETING * | * | wait children * v * COMPLETE (isComplete = true) */private interface SimpleJob : CoroutineContext.Element &#123; companion object Key : CoroutineContext.Key&lt;SimpleJob&gt; /** * 协程是否已启动 */ fun isActive(): Boolean /** * 协程是否已完成 */ fun isComplete(): Boolean /** * 启动协程 */ fun start() /** * 等待协程的结果返回 */ suspend fun &lt;T&gt; await(): T /** * 注册协程完成回调[completionHandler]，返回的[DisposableHandle]可以用来反注册回调 */ fun invokeOnCompletion(completionHandler: CompletionHandler, invokeImmediately: Boolean = true): DisposableHandle /** * 建立起与[childJob]子协程的父子关系 */ fun attachChild(childJob: SimpleJob) /** * 协程完成通知回调 */ interface CompletionHandler &#123; /** * cause == null -&gt; 成功结束 * cause == other -&gt; 异常结束 */ fun invoke(cause: Throwable?) &#125; /** * 反注册句柄 */ interface DisposableHandle &#123; /** * 调用[dispose]方法反注册 */ fun dispose() &#125;&#125;/** * [SimpleJob]的实现 */private open class SimpleJobImpl(active: Boolean) : SimpleJob &#123; enum class State &#123; NEW, ACTIVE, COMPLETING, COMPLETED &#125; override val key: CoroutineContext.Key&lt;*&gt; get() = SimpleJob @Volatile private var state = if(active) State.ACTIVE else State.NEW @Volatile private var result: Any? = null private val children = CopyOnWriteArraySet&lt;SimpleJob&gt;() private val completionHandlers = CopyOnWriteArraySet&lt;SimpleJob.CompletionHandler&gt;() override fun isActive(): Boolean &#123; return state == State.ACTIVE &#125; override fun isComplete(): Boolean &#123; return state == State.COMPLETED &#125; override fun start() &#123; if(state == State.NEW) &#123; state = State.ACTIVE onStart() &#125; &#125; override suspend fun &lt;T&gt; await(): T &#123; if(state == State.COMPLETED) &#123; if(result is Throwable) &#123; throw result as Throwable &#125;else &#123; return result as T &#125; &#125; if(state == State.NEW) &#123; start() &#125; return suspendCoroutineUninterceptedOrReturn &#123; invokeOnCompletion(object : SimpleJob.CompletionHandler &#123; override fun invoke(cause: Throwable?) &#123; if(cause != null) &#123; it.resumeWithException(cause) &#125;else &#123; it.resume(result as T) &#125; &#125; &#125;) COROUTINE_SUSPENDED &#125; &#125; override fun invokeOnCompletion(completionHandler: SimpleJob.CompletionHandler, invokeImmediately: Boolean): SimpleJob.DisposableHandle &#123; if(invokeImmediately &amp;&amp; state == State.COMPLETED) &#123; completionHandler.invoke(result as? Throwable) &#125; completionHandlers.add(completionHandler) return CompletionHandlerDisposeHandle(completionHandler) &#125; override fun attachChild(childJob: SimpleJob) &#123; children.add(childJob) &#125; protected fun initParentJob(parentJob: SimpleJob?) &#123; parentJob?.start() parentJob?.attachChild(this) &#125; protected fun tryMakeCompleted(value: Any?): Boolean &#123; result = value ?: result val complete = children.find &#123; !it.isComplete() &#125; == null if(complete) &#123; if(state == State.COMPLETED) &#123; return true &#125; state = State.COMPLETED val cause = if(result is Throwable) &#123; result as Throwable &#125; else &#123; null &#125; notifyCompleteHandlers(cause) &#125;else &#123;// 等待所有child完成 if(state == State.COMPLETING) &#123; return false &#125; state = State.COMPLETING children.forEach &#123; it.invokeOnCompletion(object : SimpleJob.CompletionHandler &#123; override fun invoke(cause: Throwable?) &#123; tryMakeCompleted(cause) &#125; &#125;, invokeImmediately = true) &#125; &#125; return complete &#125; private fun notifyCompleteHandlers(cause: Throwable?) &#123; completionHandlers.forEach &#123; it.invoke(cause) &#125; &#125; /** * 协程调用start/await方法从[State.NEW]转移到[State.ACTIVE] */ protected open fun onStart() &#123;&#125; /** * 调用[dispose]方法解除注册的[completionHandler] */ inner class CompletionHandlerDisposeHandle(private val completionHandler: SimpleJob.CompletionHandler) : SimpleJob.DisposableHandle &#123; override fun dispose() &#123; completionHandlers.remove(completionHandler) &#125; &#125;&#125;/** * 构造[SimpleJob]实例 */private fun SimpleJob() = SimpleJobImpl(active = true)/** * 简化版的协程，调用start方法启动协程 * @param parentContext 协程的父Context，用于建立父子关系 * @param active 为true时让协程处于active状态，否则处于new状态，处于new状态需要调用start/await方法才会启动协程 */private open class SimpleCoroutine&lt;T&gt;(private val parentContext: CoroutineContext, active: Boolean = true) : SimpleJobImpl(active), SimpleCoroutineScope, Continuation&lt;T&gt; &#123; override val context: CoroutineContext = parentContext + this override val coroutineContext: CoroutineContext get() = context /** * 协程完成通知，这里处理结果，进行生命周期状态流转 */ override fun resumeWith(result: Result&lt;T&gt;) &#123; println(\"resumeWith: result = $result, coroutineName = $&#123;coroutineContext[CoroutineName]&#125;\") if(result.isSuccess) &#123;//成功恢复 tryMakeCompleted(result.getOrNull()) &#125;else &#123;//错误恢复 tryMakeCompleted(result.exceptionOrNull()) &#125; &#125; /** * for [CoroutineStart.LAZY] */ private var lazyContinuation: Continuation&lt;Unit&gt;? = null /** * for [CoroutineStart.LAZY] */ override fun onStart() &#123; lazyContinuation?.intercepted()?.resumeWith(Result.success(Unit)) &#125; /** * 建立协程的父子关系，使用[kotlin.coroutines.intrinsics]原语为[block]块创建协程的初始化[Continuation], 并根据[start]模式启动它 */ fun start(start: CoroutineStart, block: suspend SimpleCoroutineScope.() -&gt; T) &#123; if(coroutineContext[CoroutineExceptionHandler] != null) &#123; throw IllegalAccessException(\"unsupport CoroutineExceptionHandler\") &#125; initParentJob(parentContext[SimpleJob]) when(start) &#123; /** * 立即启动协程，并把启动的协程运行在指定的Dispatcher上 */ CoroutineStart.DEFAULT -&gt; &#123; block.createCoroutineUnintercepted(this, this).intercepted().resumeWith(Result.success(Unit)) &#125; /** * 在当前线程立即启动协程, 但恢复时会把协程运行在指定的Dispatcher上，效果和指定[Dispatchers.Unconfined]类似 */ CoroutineStart.UNDISPATCHED -&gt; &#123; val result = try &#123; block.startCoroutineUninterceptedOrReturn(this, this) &#125;catch (e: Throwable) &#123; e &#125; if(result is Throwable) &#123; this.resumeWithException(result) &#125;else if(result !== COROUTINE_SUSPENDED) &#123; this.resume(result as T) &#125;else &#123; //COROUTINE_SUSPENDED, do noting &#125; &#125; /** * 不立即启动协程，当调用start/await方法时才启动协程，并把启动的协程运行在指定的Dispatcher上 */ CoroutineStart.LAZY -&gt; &#123; lazyContinuation = block.createCoroutineUnintercepted(this, this) &#125; else -&gt; &#123; throw IllegalAccessException(\"unsupport $start\") &#125; &#125; &#125;&#125;/** * 启动协程，没有结果返回 */private fun SimpleCoroutineScope.launch( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend SimpleCoroutineScope.() -&gt; Unit): SimpleJob &#123; val newContext = coroutineContext + context val coroutine = if(start == CoroutineStart.LAZY) &#123; SimpleCoroutine&lt;Unit&gt;(newContext, active = false) &#125;else &#123; SimpleCoroutine&lt;Unit&gt;(newContext, active = true) &#125; coroutine.start(start, block) return coroutine&#125;/** * 启动协程，可以调用返回的SimpleJob的await方法等待结果 */private fun &lt;T&gt; SimpleCoroutineScope.async( context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend SimpleCoroutineScope.() -&gt; T): SimpleJob &#123; val newContext = coroutineContext + context val coroutine = if(start == CoroutineStart.LAZY) &#123; SimpleCoroutine&lt;T&gt;(newContext, active = false) &#125;else &#123; SimpleCoroutine&lt;T&gt;(newContext, active = true) &#125; coroutine.start(start, block) return coroutine&#125; 在这里我自定义了SimpleCoroutineScope、SimpleJob、SimpleCoroutine分别对应kotlin协程的CoroutineScope、Job、AbstractCoroutine角色，实现了协程的launch、async方法，支持DEFAULT、LAZY、UNDISPATCHED三种启动模式，在kotlin协程中CoroutineScope是用来控制协程的作用域，Job是用来管理协程的生命周期和父子关系，而AbstractCoroutine实现了Continuation同时继承自Job，它的作用在前面也讲过，就是当所有suspend方法都执行完毕后，AbstractCoroutine的resumeWith方法就会被调用，这时它就可以进行协程的生命周期流转，DEFAULT模式表示立即启动，所以它调用了createCoroutineUnintercepted方法创建初始Continuation后马上调用resumeWith方法执行它，LAZY模式表示延迟启动，所以它通过createCoroutineUnintercepted方法创建的初始Continuation的resumeWith方法会等到调用start方法时才调用，而UNDISPATCHED模式表示在当前线程立即启动，所以它通过startCoroutineUninterceptedOrReturn方法创建并执行Continuation，希望大家通过这个简化版的协程理解kotlin协程中角色的作用。 结语本文介绍了kotlin协程的实现思想，Continuation、CPS和suspend方法的实现，不只是kotlin协程，其他语言的协程的实现思想也是类似的，同时还介绍了kotlin提供的intrinsics方法，它是用于给用户操纵这些Continuation，最后通过intrinsics方法实现了一个简化版的kotlin协程，所以kotlin协程也没有那么神秘，它只是Continuation的应用，它只是在这些Continuation的基础上添加了生命周期管理、父子关系、异常处理、线程切换等逻辑。 以上就是本文的所有内容，希望大家有所收获！ 参考文档： Continuation-passing Style介绍及应用 KEEP-Kotlin Coroutines The suspend modifier","tags":[{"name":"协程","slug":"协程","permalink":"http://yoursite.com/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"优雅地处理运行时权限请求","date":"2021-09-22T17:22:43.000Z","path":"2021/09/23/优雅地处理运行时权限请求/","text":"前言从android 6.0(API 级别 23)开始，android引入了运行时权限，用户开始在应用运行时向其授予权限，而不是在应用安装时向其授予权限，如果应用的某项功能需要使用到受运行时权限保护的资源(例如相机、位置、麦克风等)，但在运行该功能前没有动态地申请相应的权限，那么在调用该功能时就会抛出SecurityException异常， android 6.0已经推出了很多年了，相信大家对于运行时权限的申请过程已经非常的熟悉，但是android的运行时权限的申请过程一直都是非常的繁琐的，主要有两步： 1、在需要申请权限的地方检查该权限是否被同意，如果同意了就直接执行，如果不同意就动态申请权限； 2、重写Activity或Fragment的onRequestPermissionsResult方法，在里面根据grantResults数组判断权限是否被同意，如果同意就直接执行，如果不同意就要进行相应的提示，如果用户勾选了“don’t ask again”，还要引导用户去“Settings”界面打开权限，这时还要重写onActivityResult判断权限是否被同意. 就是这简单的两步，却夹杂了大量的if else语句，不但不优雅，而且每次都要写重复的样板代码，可能android的开发者也意识到了这一点，在最新androidx中引入了activity result api，通过activity result api你可以不需要自己管理requestCode，只需要提供需要请求的权限和处理结果的回调就行，让权限请求简单了一点，但是如果在权限请求的过程中，用户点击拒绝或者拒绝并不再询问，那么我们还是需要自己处理这些情况，但是这些处理流程都是一样的，完全可以封装起来，所以我就把以前的一个使用无界面fragment代理权限申请的库重构了一下，让权限的请求流程更加简单，本文会先复习一下权限的分类，然后再介绍PermissionHelper申请权限时的设计，最后记录一下从android 6.0后随着系统的迭代跟权限申请相关的重要行为变更。 PermissionHelper 权限的分类android中所有的预定义权限(不包括厂商自定义的)都可以在Manifest.permission这个静态类中找到定义，android把权限分为四类：普通权限、签名权限、危险权限和特殊权限，每一种类型的权限都分配一个对应的Protection Level，分别为：normal、signature、dangerous和appop，下面简单介绍一下这四种类型的权限 1、普通权限普通权限也叫正常权限，Protection Level为normal，它不需要动态申请，你只需要在AndroidManifest.xml中静态地声明，然后系统在应用安装时就会自动的授予该应用相应的权限，当应用获得授权时，它就可以访问应用沙盒外受该普通权限保护地数据或操作，这些数据或操作不会泄漏或篡改用户的隐私，对用户或其他应用几乎没有风险。 2、签名权限这类权限我们用得比较少，它只对拥有相同签名的应用开放，Protection Level为signature，它也不需要动态申请，例如应用A在AndroidManifest.xml中自定义了一个permission且在权限标签中加入android:protectionLevel=”signature”，表示应用A声明了一个签名权限，那么应用B想要访问应用A受该权限保护的数据时，必须要在AndroidManifest.xml中声明该权限，同时要用与应用A相同的签名打包，这样系统在应用B安装时才会自动地授予应用B该权限，应用B在获得授权后就可以访问该权限控制的数据，其他应用即使知道这个权限，也在AndroidManifest.xml中声明了该权限，但由于应用签名不同，安装时系统不会授予它该权限，这样其他应用就无法访问受该权限保护的数据。 还有一些签名权限不会供第三方应用程序使用，只会供系统预装应用使用，这种签名权限的Protection Level为signature和privileged。 3、危险权限危险权限也叫运行时权限，Protection Level为dangerous，跟普通权限相反，一旦应用获取了该类权限，用户的隐私数据就会面临被泄露或篡改的风险，所以如果你想使用该权限保护的数据或操作，就必须在AndroidManifest.xml中静态地声明需要用到的危险权限，并在访问这些数据或操作前动态的申请权限，系统就会弹出一个权限请求弹窗征求用户的同意，除非用户同意该权限，否则你不能使用该权限保护的数据或操作。 所有的危险权限都有对应的权限组，android预定义了11个权限组(根据android 11总结)，这11个权限组中包含了30个危险权限和几个普通权限，当我们动态的申请某个危险权限时，都是按权限组申请的，当用户一旦同意授权该危险权限，那么该权限所对应的权限组中的其他在AndroidManifest.xml中注册的权限也会同时被授权，android预定义的11个权限组包含的危险权限如下： Permission Group Dangerous Permissions CALENDAR (日历) READ_CALENDAR WRITE_CALENDAR CALL_LOG (通话记录，Added in android 29) READ_CALL_LOG WRITE_CALL_LOG PROCESS_OUTGOING_CALLS CAMERA (相机) CAMERA CONTACTS (通讯录) READ_CONTACTS WRITE_CONTACTS GET_ACCOUNTS LOCATION (位置信息) ACCESS_COARSE_LOCATION ACCESS_FINE_LOCATION ACCESS_BACKGROUND_LOCATION (Added in android 10) MICROPHONE (麦克风) RECORD_AUDIO PHONE (电话) READ_PHONE_NUMBERS READ_PHONE_STATE CALL_PHONE ANSWER_PHONE_CALLS ADD_VOICEMAIL USE_SIP ACCEPT_HANDOVER (Added in android 9) SENSORS (身体传感器) BODY_SENSORS SMS (短信) READ_SMS RECEIVE_WAP_PUSH RECEIVE_SMS RECEIVE_MMS SEND_SMS STORAGE (存储空间) READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE ACCESS_MEDIA_LOCATION (Added in android 10) ACTIVITY_RECOGNITION (身体活动，Added in android 10) ACTIVITY_RECOGNITION (Added in android 10) 4、特殊权限特殊权限用于保护一些特定的应用程序操作，Protection Level为appop，使用前也需要在AndroidManifest.xml中静态地声明，也需要动态的申请，但是它不同于危险权限的申请，危险权限的申请会弹出一个对话框询问你是否同意，而特殊权限的申请需要跳转到指定的设置界面，让你手动点击toggle按钮确认是否同意，截止到android 11，我了解到的常用的5个特殊权限为： SYSTEM_ALERT_WINDOW：允许应用在其他应用的顶部绘制悬浮窗，当你创建的悬浮窗是TYPE_APPLICATION_OVERLAY类型时需要申请这个权限； WRITE_SETTINGS：允许应用修改系统设置，当你需要修改系统参数Settings.System时需要申请该权限，例如修改系统屏幕亮度等； REQUEST_INSTALL_PACKAGES： 允许应用安装未知来源应用，android 8.0以后当你在应用中安装第三方应用时需要申请这个权限，否则不会跳转到安装界面； PACKAGE_USAGE_STATS：允许应用收集其他应用的使用信息，当你使用UsageStatsManager相关Api获取其他应用的信息时需要申请这个权限； MANAGE_EXTERNAL_STORAGE(Added in android 11)：允许应用访问作用域存储(scoped storage)中的外部存储，android 11以后强制新安装的应用使用作用域存储，但是对于文件管理器这一类的应用它们需要管理整个SD卡上的文件，所以针对这些特殊应用可以申请这个权限来获得对整个SD卡的读写权限，当应用授予这个权限后，它就可以访问文件的真实路径，注意这个权限是很危险的，声明这个权限上架应用时可能需要进行审核. 除了特殊权限，LOCATION权限组中的位置权限也有点特殊，需要注意一下，位置信息的获取不仅依赖位置权限的动态申请还依赖系统定位开关，如果你没有打开定位开关就申请了位置权限，那么就算用户同意授权位置权限，应用通过Location相关Api也无法获取到位置信息，所以申请位置权限前，最好先通过LocationManager#isProviderEnabled方法判断是否打开定位开关后再进行位置权限的申请，如果没有打开定位开关需要先跳转到设置界面打开定位开关，伪代码如下： 1234567891011val locationManager = this.getSystemService(Context.LOCATION_SERVICE) as LocationManagerif (locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER) or locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER)) &#123; //请求位置权限&#125; else &#123; //跳转到开启定位的地方 Toast.makeText(this, \"检测到未开启定位服务,请开启\", Toast.LENGTH_SHORT).show() val intent = Intent().apply &#123; action = Settings.ACTION_LOCATION_SOURCE_SETTINGS &#125; startActivityForResult(intent, REQUEST_CODE_LOCATION_PROVIDER)&#125; 当然，上面危险权限和特殊权限的判断与申请，PermissionHelper都已经替你做好了封装，你只需要像平常一样在AndroidManifest.xml中静态地声明权限，然后在代码中动态地申请就行，下面我把危险权限和特殊权限都统称为动态权限，因为它们都是需要动态申请的。 动态权限申请设计动态权限的申请依据不同的android版本和应用targetSdkVersion有着不同的行为，主要有两种处理，如下： android版本 &lt;= 5.1 或者 应用的targetSdkVersion &lt;= 22：当用户同意安装应用时，系统会要求用户授权应用声明的所有权限，包括动态权限，如果用户不同意授权，只能拒绝安装应用，如果用户同意全部授权，他们撤销权限的唯一方式就是卸载应用； android版本 &gt;= 6.0 且 应用的targetSdkVersion &gt;= 23：当用户同意安装应用时，系统不再强制用户必须授权动态权限，系统只会授权应用除动态权限之外的普通权限，而动态权限需要应用使用到相关功能时才动态申请，当申请动态权限时，用户可以选择授权或拒绝每项权限，即使用户同意授权权限，用户也可以随时进入应用的“Settings”中调整应用的动态权限授权，所以你每次使用到该权限的功能时，都要动态申请，因为用户有可能在“Settings”界面中把它再次关闭掉. 在android版本 &lt;= 5.1 或者 应用的targetSdkVersion &lt;= 22时，系统使用的是AppOps来进行权限管理，这是android在4.4推出的一套应用程序操作权限管理，AppOps所管理的是所有可能涉及用户隐私和安全的操作，例如access notification、keep weak lock、display toast 等等，而运行时权限管理是android 6.0才出现，是基于AppOps的实现，进一步做了动态请求封装和明确的规范，同时当targetSdkVersion &lt;= 22的应用运行在 &gt;= 6.0的android系统上时，动态权限可以在“Settings”界面中关闭，应用运行过程中使用到相关功能时就会由于没有权限而出现崩溃，这时只能使用AppOps的 checkOp方法来检测对应的权限是否已经授权，没有权限就跳转到“Settings”界面，考虑到目前android 6.0已经推出了很久，应用商店也不允许targetSdkVersion &lt; 23的应用上架，所以为了减少框架的复杂度，动态权限申请设计就没有考虑兼容AppOps的权限管理操作，所以当你使用PermissionHelper时应用的targetSdkVersion要 &gt;= 23。 PermissionHelper支持危险权限和特殊权限的申请，只需要一行代码就可以发起权限请求，具有生命周期感应能力，只在界面可见时才发起请求和回调结果，同时当系统配置更改例如屏幕旋转后能够恢复之前权限申请流程，不会中断权限申请流程，灵活性高，可以设置请求前、拒绝后回调，在回调发生时暂停权限申请流程，然后根据用户意愿再决定是否继续权限申请流程，整个申请过程如图： PermissionHelper可以通过设置回调在权限申请开始前和权限被拒绝后把要请求的权限和被拒绝的权限回调出去，在回调中你可以通过弹窗向用户解释要申请的权限对应用的必要性，引导用户继续授权或再次授权，PermissionHelper不定制弹窗UI，弹窗的UI由开发者自定义，开发者只需要在用户同意或拒绝后调用回调中的Process实例的相应方法就能让被暂停的权限申请流程恢复，然后在最终的结果回调中处理结果就行，整个过程都是链式的，关于向用户解释权限申请原因的弹窗，弹窗内容建议包含下面的3点： 1、包含需要授权的权限列表的描述； 2、包含确认按钮，用户可以点击确认按钮再次授权或跳转到”Settings“； 3、包含取消按钮，用户可以点击取消按钮放弃授权. 如果用户不授权这个权限，就会导致应用无法继续运行下去，可以考虑取消第3步的取消按钮，即无法取消这个弹窗，一定要用户再次授权或跳转到”Settings“去授权。 PermissionHelper整个框架的设计参考了okhttp的拦截器模式，通过责任链模式的形式把危险权限申请、特殊权限申请、申请前处理和申请后处理划分为一个个节点，然后通过Chain串联起各个节点，每个节点只负责对应的内容，如下： 12345678910val originalRequest = Request() val interceptors = listOf( StartRequestNode(), RequestLocationNode(), RequestNormalNode(), RequestSpecialNode(), PostRequestNode(), FinishRequestNode())DefaultChain(originalRequest, interceptors).process(originalRequest) 通过这样的形式PermissionHelper就可以很灵活的控制权限申请流程，对于生命周期感应能力的实现PermissionHelper使用了Lifecycle+LiveData组件，这两个都是官方支持的用于实现需要响应生命周期感应的操作，可以编写更轻量级和更易于维护的代码，避免界面销毁后的内存泄漏，对于系统配置更改后的数据恢复则使用到了ViewModel组件，这是官方支持的用于保存需要在配置更改后恢复的数据，例如一些UI相关的数据，通过这三件套 + 责任链模式实现了一个简单易用的权限申请框架，更多详细使用和实现细节可以查看代码仓库。 权限申请相关变更自android 6.0推出动态权限申请之后，有一些申请行为也随着系统的迭代发生变化，目的都是更好的保护用户的隐私权，使得权限申请对用户感知： android 8.0以后并且应用的targetSdkVersion &gt;= 28时，应用申请某个危险权限授权，用户同意后，系统不再错误地把该危险权限对应的权限组中的其他在AndroidManifest.xml中注册的权限一并授予给应用，系统只会授予应用明确请求的权限，然而，一旦用户应用同意授权某个危险权限，则后续对该危险权限的权限组中的其他权限请求都会被自动批准，而不会提示用户，例如某个应用在AndroidManifest.xml中注册READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限，应用申请READ_EXTERNAL_STORAGE权限并且用户同意，在android 8.0之前，系统在用户同意后还会一并授予WRITE_EXTERNAL_STORAGE权限，因为它和READ_EXTERNAL_STORAGE权限是同一个权限组并且也在AndroidManifest.xml中注册，但在android 8.0之后并且应用的targetSdkVersion &gt;= 28，系统在用户同意后只会授予READ_EXTERNAL_STORAGE权限，但是如果后来应用又申请WRITE_EXTERNAL_STORAGE权限，系统会立即授予该权限，而不会提示用户，换句话说，如果只申请了外部存储空间读取权限，在低版本下（android &lt; 8.0）对外部存储空间使用写入操作是没有问题的，但是在高版本（android &gt;= 8.0 &amp;&amp; targetSdkVersion &gt;= 28）下是会出现问题的，解决方案是将两个读和写的权限一起申请。 android 9.0增加了CALL_LOG（通话记录）权限组，并把READ_CALL_LOG、WRITE_CALL_LOG]、PROCESS_OUTGOING_CALLS权限从PHONE（电话）权限组移动到了CALL_LOG权限组，CALL_LOG权限组使得用户能够更好地控制需要访问电话通话记录敏感信息的应用程序，例如读取通话记录和识别电话号码。 android 10引入了很多隐私变更，新增了ACTIVITY_RECOGNITION（身体活动）权限和权限组，允许应用检测用户的步数或分类用户的身体活动如步行、骑自行车等；同时android 10引入了作用域存储，当应用启用作用域存储时，WRITE_EXTERNAL_STORAGE权限会失效，应用对WRITE_EXTERNAL_STORAGE权限的申请不会对应用的存储访问权限产生任何影响，并且WRITE_EXTERNAL_STORAGE会在未来被废弃，因为作用域存储的目的就是不让应用随意的修改应用沙盒外的外部存储；同时新增了ACCESS_BACKGROUND_LOCATION权限，归属于LOCATION权限组，用于后台运行的应用访问用户定位时申请，与ACCESS_FINE_LOCATION和ACCESS_COARSE_LOCATION这些前台定位权限区分开，当你的应用targetSdkVersion &gt;= 29并且运行在android 10以上时，应用在后台访问定位时需要动态的申请后台定位权限，当你把后台定位权限和前台定位权限一起申请时，弹窗授权框会有2个允许选项：始终允许和仅在应用使用过程中允许，点击始终允许表示同时授权后台定位权限和前台定位权限，点击仅在应用使用过程中允许表示仅授权前台定位权限，然后下次再次申请时只会单独申请后台定位权限，并且也会有2个允许选项，并且要点击始终允许才会让后台定位权限申请通过，当你的应用targetSdkVersion &lt; 29运行在android 10以上时，应用在申请前台定位权限时系统会把后台定位权限一并授予给应用；android 10还新增了ACCESS_MEDIA_LOCATION权限，归属于STORAGE (存储空间) 权限组，android 10以后，因为隐私问题，默认不再提供图片的地理位置信息，要获取该信息需要向用户申请ACCESS_MEDIA_LOCATION权限，并使用MediaStore.setRequireOriginal()接口更新文件Uri。 android 11也引入了很多隐私变更，android 11强制新安装的应用(targetSdkVersion &gt;= 30)启用作用域存储，新增MANAGE_EXTERNAL_STORAGE用于代替WRITE_EXTERNAL_STORAGE权限，提供给手机管家、文件管理器这类需要管理整个SD卡上的文件的应用申请；android 11中当用户开启“安装未知来源应用”权限后返回应用，应用会被杀死重启，该行为与强制分区存储有关；从android 11后，如果应用对某个权限连续点击多次拒绝，那么下一次请求该权限时系统会直接拒绝连授权弹窗都不会弹出，该行为等同于android 11之前勾选了don‘t ask again；android 11后还新增了一次性权限（One-time permissions）和权限自动重置功能（Permissions auto-reset），这些变更只要你正确的进行运行时权限请求就不需要做额外适配；同时android 11后当targetSdkVersion &lt; 30的应用把后台定位权限和前台定位权限一起申请时，弹窗授权框的允许选项中不再会显示始终允许选项，只有本次允许和仅在应用使用过程中允许，也就说点击允许时只会授予你前台定位权限不再默认授予你后台定位权限，而android 11后targetSdkVersion &gt;= 30的应用的ACCESS_BACKGROUND_LOCATION权限需要独立申请，不能与前台权限一起申请，如果与前台权限一起申请，系统会直接拒绝连授权弹窗都不会弹出，系统推荐增量请求权限，这样对用户更友好，同时用户必须先同意前台权限后才能进入后台定位权限的申请。 可以看到从android 10引入ACCESS_BACKGROUND_LOCATION权限以来，后台定位权限的申请一直都非常特殊，它在android 10可以和前台定位权限一起申请，而在android 11又不可以一起申请还有先后申请顺序，针对这种特殊情况，申请后台定位权限时要做到： 1、先请求前台定位权限，再请求后台定位权限； 2、单独请求后台定位权限，不要与其他权限一同请求. 上面这些PermissionHelper都已经做好了处理，申请时只需要把后台定位权限和前台定位权限一起传进去就行。 结语本文主要让让大家对权限的申请流程有进一步的认识，然后可以通过对动态权限的封装，将检测动态权限，请求动态权限，权限设置跳转，监听权限设置结果等处理和业务功能隔离开来，业务以后可以非常快速的接入动态权限支持，提高开发效率。 以上就是本文的全部内容！ 参考资料： Request app permissions 安卓系统权限，你真的了解吗？ Android 6.0 运行权限解析","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"快速发布组件到mavenCentral","date":"2021-07-03T05:55:40.000Z","path":"2021/07/03/快速发布组件到mavencentral/","text":"前言在很久之前写过一篇发布开源库到jcenter的文章，但不幸的是几个月前Jfrog发布了终止Bintray服务的声明，声明的大概意思是说2021年3月31号之后Jcenter仓库将不再接收用户的组件提交，同时将Jcenter设为只读代码仓库，无限期地提供现有组件供用户下载，也就是说目前Jcenter仓库的状态是你无法再提交组件的更新，但你可以继续下载你以前托管的组件版本，所以现在你要做的就是把你的组件的新版本发布到其他仓库，例如Jitpack和MavenCentral，我曾经写过一篇快速发布开源库到jitpack的文章，本篇文章的内容是教你如何发布组件到MavenCentral仓库，同时写了一个发布脚本简化发布过程，使用这个脚本之前先看一下本篇文章的前期准备内容。 脚本地址：MavenPublishScript 前期准备在讲解之前，有必要介绍一下Sonatype 、OSSRH、MavenCentral之间的关系，Sonatype是一间公司，它运营着MavenCentral仓库，我们想要发布组件到MavenCentral，必须要通过Sonatype的OSSRH，OSSRH即OSS Repository Hosting，对象存储仓库托管，Sonatype使用Nexus Repository Manager为组件提供存储库托管服务，我们发布组件时要先发布到Sonatype OSSRH上，然后才能同步到MavenCentral仓库，就好像我们之前使用Jcenter时，要先发布到Jfrog Bintray上，然后才能同步到Jcenter仓库。 1、注册Sonatype账号首先你需要注册一个Sonatype Jira账号，Sonatype使用Jira管理你的groupId申请过程，注册地址如下： Sonatype Jira - Sign up 点开注册地址后，如图： 按要求填入你的邮箱地址、姓名、用户名、密码即可，其中用户名最好不要有中文，记住你的用户名和密码，会在后面用到。 2、申请groupId我们平时使用托管在远程仓库的组件时都是通过它的GAV坐标来定位的，GAV即groupId、artifactId、version，其中groupId你可以理解为你自己在Sonatype OSSRH创建的仓库，groupId就是你仓库的名称，申请groupId就是在Sonatype OSSRH申请创建属于你的仓库，我们后面发布组件时要先发布到Sonatype OSSRH上名为groupId的仓库，然后才能同步到MavenCentral仓库。 还有申请的groupId并不是顺便填的，按照Sonatype的要求，groupId必须要是一个域名的反写，所以你要拥有一个域名，当你申请groupId时，Sonatype会用某种方式让你证明你是这个域名的所有者。 如果你拥有某个域名，例如example.com域名，你可以使用任何以com.example开头的groupId，例如com.example.test1、com.example.test2等，如果你没有自己的域名也没关系，Sonatype支持代码托管平台的Pages网站域名，例如Github，你可以在你的Github账号上开启你的Pages服务，这样你就拥有了一个与Github账号关联的个人域名，格式为{username}.github.io，例如我的Github Pages网站就是rain9155.github.io，很多人都是利用这种托管在三方平台的网站搭建自己的博客网站，除了Github，Sonatype还支持GitLab、Gitee等，下面表格列出这些常用的代码托管平台Pages服务开启的官方教程地址，和开启后对应的域名和相应的groupId： 代码托管平台 Pages服务开启教程地址 域名 groupId Github https://pages.github.com/ {username}.github.io io.github.{username} Gitee https://gitee.com/help/articles/4136 {username}.gitee.io io.gitee.{username} GitLab https://about.gitlab.com/stages-devops-lifecycle/pages/ {username}.gitlab.io io.gitlab.{username} 下面就以我的Github Pages网站域名rain9155.github.io为例，申请名为io.github.rain9155的groupId，首先打开Sonatype Jira网站, 地址如下： Sonatype Jira - Dashboard 首次进入需要你登陆，输入你刚才注册的Sonatype Jira用户名和密码登陆，然后就进入Sonatype Jira网站首页，然后点击导航栏的Create按钮，此时会弹出一个弹窗，会让你填一些申请groupId时需要的信息，其中Project选择Community Support - Open Source Project Repository Hosting (OSSRH)，Issue Type选择New Project，Summary填一个标题，Group Id就填你要申请的groupId，Project URL随便填一个你的组件仓库地址，SCM url也是随便填一个你的组件仓库版本控制地址，如下： 最后点击create按钮，它会创建一个issue，issue名称格式为OSSRH-{taskId}，如我这里为OSSRH-69596，你可以在All Projects面板中看到它，然后接下来就是等待Sonatype Jira的邮件通知，邮件会发送到你注册账号时填写的邮箱，它的第一封邮件会叫你在你的Github中创建一个名为OSSRH-{taskId}的空仓库，从而证明你是groupId对应域名的拥有者，当你创建之后，你需要到OSSRH-{taskId}下的comment面板中回复，当你回复后，它又会再发一封邮件给你，告诉你groupId已经申请完毕，此时你可以发布组件到Sonatype OSSRH中，如何发布请看后面的内容，当你发布后，你需要在Sonatype OSSRH中把你的组件同步到MavenCentral后才可以通过GAV引用它，如何同步请看后面的内容，当你同步后，你需要再次到OSSRH-{taskId}下的comment面板中回复，然后Sonatype OSSRH才会为你激活组件同步到MavenCentral的程序，整个交流过程可以参考我OSSRH-69596中的comment面板，如下： 回复的内容是什么不重要，只要你回复了就行，上述就是申请groupId和激活MavenCentral同步的整个流程，只需要在第一次发布组件时进行一次就行，以后发布组件时不需要再进行上面的过程，直接使用该groupId就行。 3、生成gpg签名信息Sonatype要求发布到MavenCentral仓库的组件中的每个文件都需要通过gpg签名，gpg是一个命令行工具，提供了对数据的签名和加密能力，支持主流的签名和加密算法，并提供了密钥管理系统，要使用gpg签名，我们必须先在电脑上安装gpg，然后使用gpg生成签名需要的密钥对。 我们首先来安装gpg，对于mac电脑，直接通过Homebrew安装就行，在命令行执行： 1$ brew install gpg 对于window电脑，我们可以下载gpg的执行文件安装，下载地址如下： gpg download 安装完成后，在命令行输入gpg --version 输出gpg的版本信息表示安装完成，如下： 123456789101112131415$ gpg --versiongpg (GnuPG) 2.2.27libgcrypt 1.8.7Copyright (C) 2021 g10 Code GmbHLicense GNU GPL-3.0-or-later &lt;https://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Home: C:/Users/HY/AppData/Roaming/gnupgSupported algorithms:Pubkey: RSA, ELG, DSA, ECDH, ECDSA, EDDSACipher: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH, CAMELLIA128, CAMELLIA192, CAMELLIA256Hash: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224Compression: Uncompressed, ZIP, ZLIB, BZIP2 然后在命令行输入gpg --full-generate-key 进行密钥对生成，这个命令会让你一步步选择生成密钥对需要的信息，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ gpg --full-generate-keygpg (GnuPG) 2.2.27; Copyright (C) 2021 g10 Code GmbHThis is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Please select what kind of key you want: (1) RSA and RSA (default) (2) DSA and Elgamal (3) DSA (sign only) (4) RSA (sign only) (14) Existing key from cardYour selection? 4RSA keys may be between 1024 and 4096 bits long.What keysize do you want? (3072)Requested keysize is 3072 bitsPlease specify how long the key should be valid. 0 = key does not expire &lt;n&gt; = key expires in n days &lt;n&gt;w = key expires in n weeks &lt;n&gt;m = key expires in n months &lt;n&gt;y = key expires in n yearsKey is valid for? (0)Key does not expire at allIs this correct? (y/N) yGnuPG needs to construct a user ID to identify your key.Real name: rain9155Email address: jianyu9155@gmail.comComment:You selected this USER-ID: \"rain9155 &lt;jianyu9155@gmail.com&gt;\"Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? oWe need to generate a lot of random bytes. It is a good idea to performsome other action (type on the keyboard, move the mouse, utilize thedisks) during the prime generation; this gives the random numbergenerator a better chance to gain enough entropy.gpg: key DF7B4B4D1A32FB02 marked as ultimately trustedgpg: revocation certificate stored as 'C:/Users/HY/AppData/Roaming/gnupg/openpgp-revocs.d\\9E02D0E104E3D3517B5B0E54DF7B4B4D1A32FB02.rev'public and secret key created and signed.Note that this key cannot be used for encryption. You may want to usethe command \"--edit-key\" to generate a subkey for this purpose.pub rsa3072 2021-07-06 [SC] 9E02D0E104E3D3517B5B0E54DF7B4B4D1A32FB02uid rain9155 &lt;jianyu9155@gmail.com&gt; 首先它会让你选择算法，我这里选择了RSA，仅用于签名，然后会让你输入密钥长度，默认是3072bits，然后会让你选择密钥的过期时间，我这里选择了永久有效，建议大家也选择永久有效，然后确认信息后会让你输入姓名、邮箱、注释来作为密钥的唯一标识，这里我生成的标识为”rain9155 &lt;jianyu9155@gmail.com&gt;“，最后确认后会弹出一个弹窗让你输入一个密码来保护你的私钥，记住你输入的密码后面会用到，点击确认后看到public and secret key created and signed这句话说明密钥对生成完毕，我们可以通过gpg --list-keys列出生成的公钥信息，通过gpg --list-secret-keys列出生成的私钥信息，但其实列出的信息是类似的，我们以gpg --list-keys为例，如下： 123456789$ gpg --list-keysgpg: checking the trustdbgpg: marginals needed: 3 completes needed: 1 trust model: pgpgpg: depth: 0 valid: 2 signed: 0 trust: 0-, 0q, 0n, 0m, 0f, 2uC:/Users/HY/AppData/Roaming/gnupg/pubring.kbx---------------------------------------------pub rsa3072 2021-07-06 [SC] 9E02D0E104E3D3517B5B0E54DF7B4B4D1A32FB02uid [ultimate] rain9155 &lt;jianyu9155@gmail.com&gt; 列出的信息首先有公钥的文件位置，这里为C:/Users/HY/AppData/Roaming/gnupg/pubring.kbx，接着是pub rsa3072 2021-07-06 [SC]，表示使用RSA算法，公钥长度为3072bits，创建日期为2021-07-06，接着是长长的一串id值9E02D0E104E3D3517B5B0E54DF7B4B4D1A32FB02，它表示公钥的id，我们使用时只需要用到它的后八位就行，所以我们后面使用这个公钥时只需要使用1A32FB02就行，最后是公钥的唯一标识uid，根据我们前面输入的姓名、邮箱、注释生成。 我们签名只需要用到私钥，而公钥需要上传到公钥服务器，这样我们用私钥签名的文件上传到MavenCenral后，它才能使用公钥验证这个文件，这里我选择了keyserver.ubuntu.com这个公钥服务器，上传公钥的命令格式为gpg --keyserver 公钥服务器地址 --send-keys 公钥id，如下我把刚刚生成的公钥1A32FB02上传到公钥服务器： 12$ gpg --keyserver keyserver.ubuntu.com --send-keys 1A32FB02gpg: sending key DF7B4B4D1A32FB02 to hkp://keyserver.ubuntu.com 没有错误提示就表示上传成功，我们还可以使用gpg --keyserver 公钥服务器地址 --recv-keys 公钥id从公钥服务器导入公钥到本地从而验证公钥是否上传成功，如下： 1234$ gpg --keyserver keyserver.ubuntu.com --recv-keys 1A32FB02gpg: key DF7B4B4D1A32FB02: \"rain9155 &lt;jianyu9155@gmail.com&gt;\" not changedgpg: Total number processed: 1gpg: unchanged: 1 可以看到导入成功，表示公钥已经成功上传到公钥服务器。 还有最后一步，把私钥导出到一个文件中，这样我们发布组件时才能通过引用这个文件，从而使用私钥进行签名，命令格式为gpg -o 导出的文件路径 --export-secret-key 私钥id，执行导出私钥命令会弹出一个弹窗让你输入私钥密码，输入正确后才能成功导出，如下把私钥导出到名为1A32FB02.gpg的文件中，私钥id和公钥id是一样的： 1$ gpg -o D:/File/keystore/1A32FB02.gpg --export-secret-key 1A32FB02 现在已经成功把私钥导出D:/File/keystore/1A32FB02.gpg中，记住你导出的私钥文件路径，后面会用到。 发布到OSSRH现在万事俱备，可以发布组件了，发布组件使用maven-publish插件，我们主要发布的内容有组件的aar或jar文件、sources文件、javadoc文件，pom文件，还有这些文件的签名文件，以.asc为后缀，签名要使用signing插件，为了简化发布过程，我已经把发布过程编写成了一个gradle脚本 - MavenPublishScript，使用时只需要apply进来，然后填写发布的基本信息，执行发布任务就可以自动生成发布所需的所有文件并发布到OSSRH中，下面简单介绍如何使用这个gradle脚本。 首先在你的组件的build.gradle中apply该脚本： 1apply from: 'https://raw.githubusercontent.com/rain9155/MavenPublishScript/main/script/publication.gradle' 接下来准备好你在前面注册的Sonatype账号、申请好的groupId、生成好的gpg私钥信息，然后在组件的gradle.properties(没有则创建)中添加组件信息，其中GAV坐标是必填信息，其他是可选信息： 123456789101112131415161718192021### GAV坐标publish.groupId=io.github.rain9155publish.artifactId=mavenpublishscriptpublish.version=1.0.0### 下面都是可选信息# 基本描述publish.description=发布组件到Maven仓库的gradle脚本，支持aar和jar发布publish.url=https://github.com/rain9155/MavenPublishScript# 开发者信息publish.developerName=rain9155publish.developerEmail=jianyu9155@gmail.com# license信息publish.licenseName=The Apache License, Version 2.0publish.licenseUrl=http://www.apache.org/licenses/LICENSE-2.0.txt# scm信息，格式参考http://maven.apache.org/scm/scm-url-format.htmlpublish.scmUrl=https://github.com/rain9155/MavenPublishScript/tree/masterpublish.scmConnection=scm:git:git://github.com/rain9155/MavenPublishScript.gitpublish.scmDeveloperConnection=scm:git:ssh://github.com:rain9155/MavenPublishScript.git# 如果发布的是android组件，当为false时不根据flavor动态生成组件的artifactId，如果你不想组件的artifactId拼接flavorName，可以设置为false，默认为truepublish.artifactId.isAppendFavorName=false 然后在项目根目录的local.properties(没有则创建)中添加gpg签名信息和ossrh账号信息，记得要把local.properties从你的版本控制中移除，避免泄漏你的签名信息和账号信息： 12345678# gpg签名信息signing.keyId=你的密钥id，例如1A32FB02signing.password=你的私钥密码signing.secretKeyRingFile=你的私钥文件路径，例如D:/File/keystore/1A32FB02.gpg# ossrh账号信息ossrh.username=你的ossrh账号名，即Sonatype账号用户名ossrh.password=你的ossrh账号密码，即Sonatype账号密码 最后在命令行执行gradle任务发布组件，如果你发布的是android组件(aar)，执行的任务的名称格式为publish{flavorName}AndroidlibPublicationToMavenRepository或publish{flavorName}AndroidlibPublicationToMavenLocal，其中flavorName为android组件的flavor的名称，首字母大写，没有则不填flavorName，如果你发布的是java组件(jar)，执行的任务名称为publishJavalibPublicationToMavenRepository或publishJavalibPublicationToMavenLocal： 1234567891011121314151617181920212223242526//发布android组件到maven本地仓库gradle publishAndroidlibPublicationToMavenLocal//发布android组件到maven远程release或snapshot仓库gradle publishAndroidlibPublicationToMavenRepository//假设android组件含有flavorName为china，发布china版本的android组件到maven本地仓库gradle publishChinaAndroidlibPublicationToMavenLocal//假设android组件含有flavorName为oversea，发布oversea版本的android组件到maven远程release或snapshot仓库gradle publishOverseaAndroidlibPublicationToMavenRepository//发布java组件到maven本地仓库gradle publishJavalibPublicationToMavenLocal//发布java组件到maven远程release或snapshot仓库gradle publishJavalibPublicationToMavenRepository//发布所有android组件和java组件到maven本地仓库gradle publishToMavenLocal//发布所有android组件和java组件到maven远程release或snapshot仓库gradle publishAllPublicationsToMavenRepository//发布所有android组件和java组件到maven本地仓库和maven远程release或snapshot仓库gradle publish 上述发布任务根据组件发布的是android组件(aar)还是java组件(jar)来执行，同时发布android组件时支持flavor发布，publishXXToMavenRepository任务表示发布到远程仓库OSSRH中，publishXXToMavenLocal任务表示发布到maven本地仓库，maven本地仓库路径为{用户目录}/.m2/repository/，也可以在AS左侧的gradle面板中查看这些任务，如下： 选中合适的任务双击执行就行，如果你执行的是publishXXToMavenRepository任务，任务执行成功后你就可以到OSSRH查看你发布上去的组件，首次进入需要登陆，输入你的Sonatype用户名和密码登陆，然后点击左下侧的Staging Repository就可以看到你发布到OSSRH的组件，如下： 在Staging Repository的面板中可以浏览你发布的组件，选中它，然后点击下面的content面板就可以查看组件发布的详细文件。 同步到MavenCentral组件发布到OSSRH后，还不能通过GAV引用它，还要同步到MavenCentral后才能通过GAV引用它，首先要在OSSRH上Close组件，让它从open状态变为close状态，如下： 当你点击Close按钮后，会弹出一个弹窗叫你确认，确认后Close按钮会变灰，此时下方的Activity面板会显示close过程中进行的规则校验，例如校验你发布的文件是否有签名、是否含有javadoc文件、是否含有sources文件，pom文件是否合格等，当所有校验通过后你才可以同步组件到MavenCentral，当校验通过后你会收到Sonatype发送的邮件，此时你可以点击上方的Release按钮同步组件到MavenCentral，如下： 当你点击Release按钮后，会弹出一个弹窗叫你确认，确认后Release按钮会变灰，如果你是第一次发布组件，在申请groupId时我讲过，你还要到OSSRH-{taskid}的comment面板下回复它一次OSSRH才会为你激活同步程序，激活同步程序后大概十几分钟你的组件就会被同步到MavenCentral，这时你就可以在MavenCentral网站搜索到你的组件，并可以在gradle或maven等构建工具中通过GAV引用它，激活同步程序后，你下次Release组件时就会自动同步到MavenCentral而无需再做其他操作。 结语发布到MavenCentral的步骤相比于发布到Jitpack要复杂的多，Jitpack只需要一个代码托管仓库账号，而MavenCentral需要准备Sonatype账号、个人域名、签名信息，但是MavenCentral比Jitpack成熟得多，它目前是最大的java组件和其他开源组件的托管仓库，也是很多构建系统如Maven的默认存储仓库，如何选择就看个人爱好了。 以上就是本文的所有内容！ 参考资料： JCenter service update The Central Repository Documentation Use the Maven Publish plugin","tags":[{"name":"mavenCentral","slug":"mavenCentral","permalink":"http://yoursite.com/tags/mavenCentral/"},{"name":"gradle","slug":"gradle","permalink":"http://yoursite.com/tags/gradle/"}]},{"title":"揭秘kotlin协程中的CoroutineContext","date":"2021-01-21T02:52:18.000Z","path":"2021/01/21/揭秘kotlin协程中的CoroutineContext/","text":"前言从kotlin1.1开始，协程就被添加到kotlin中作为实验性功能，直到kotlin1.3，协程在kotlin中的api已经基本稳定下来了，现在kotlin已经发布到了1.4，为协程添加了更多的功能并进一步完善了它，所以我们现在在kotlin代码中可以放心的引入kotlin协程并使用它，其实协程并不是kotlin独有的功能，它是一个广泛的概念，协作式多任务的实现，除了kotlin外，很多语言如Go、Python等都通过自己的方式实现了协程，本文阅读前希望你已经知道如何使用kotlin协程，如果不熟悉可以阅读一下官方文档： kotlin coroutines guide 其实入门协程我还是非常推荐通过官方文档来进行学习，因为官方文档的例子是很全面的，跟着它的例子敲一遍代码，你也基本掌握了协程的使用，kotlin协程的源码被放在了两个库中，一部分是在kotlin标准库kotlin-stdlib中，一部分是在kotlin协程实现库kotlinx-coroutines中，其中kotlinx-coroutines是基于kotlin-stdlib的，kotlin-stdlib库提供了实现协程所需的基本原语，而本文讲解的CoroutineContext的主要实现就是在kotlin-stdlib中。 本文涉及到的源码都是基于kotlin1.4版本 Coroutine的简单理解提到协程，很对人会把它和线程进行比较，就像提到线程，很多人会把它和进程进行比较，线程和进程分别是操作系统中的CPU调度单位和资源划分单位，它们在操作系统中有专门的数据结构代表，而协程在操作系统中没有专门的数据结构代表，所以协程并不是由操作系统创建和调度，它而是由程序自己创建和调度，由于不需要操作系统调度，所以协程比线程更加的轻量，切换协程比切换线程的开销更小，即它的上下文切换比线程更快，因为操作系统切换线程时一般都会涉及到用户态内核态的转换，这是一个开销相对较大的操作。 协程的实现依赖于线程，它不能脱离线程而存在，因为线程才是CPU调度的基本单位，协程通过程序的调度可以执行在一个或多个线程之中，所以协程需要运行于线程之中，由于协程是由程序自己调度的，所以程序就需要实现调度逻辑，不同语言的调度的实现不一样，在kotlin中，通过Dispatcher来调度协程，而Dispatcher它通常是一个线程池的实现或者基于特定平台(例如Android)主线程的实现，通过调度让协程运行于一个或多个线程之中，这些协程可以在同一线程的不同时刻被执行，也可以在不同线程上的不同时刻被执行。 协程可以说是编程语言的能力， 是上层的能力，它并不需要操作系统和硬件的支持， 是编程语言为了让开发者更容易写出协作式任务的代码，而封装的一种任务调度能力，所以协程通常是包含一段特定逻辑的代码块，多个协程之间就组合成一段具有特定逻辑的代码流程，这些编程语言为了让开发者更方便的使用协程，它通常会提供一些关键字， 而这些关键字会通过编译器自动生成了一些支持型代码，例如kotlin中的suspend关键字，对于suspend修饰的方法，编译器会方法生成一些额外的代码。 上面就是我对协程的简单理解，总的来说：协程需要线程的承载运行，协程需要程序自己完成调度，协程让你更容易写出协作式任务。 Coroutine的简单使用12345678fun main()&#123; val scope = CoroutineScope(CoroutineName(\"Coroutine-Name\") + Dispatchers.IO) val job = scope.launch(start = CoroutineStart.DEFAULT)&#123; println(\"hello world\") &#125; //进程保活1s，只有进程存活的前提下，协程才能会启动和执行 Thread.sleep(1000)&#125; 上面首先构造了一个CoroutineScope，它是协程的作用域，用于控制协程的生命周期，构造CoroutineScope需要一个CoroutineContext，它是协程的上下文，用于提供协程启动和运行时需要的信息，这是我们后面需要重点介绍的，最后通过CoroutineScope的launch方法启动协程并输出hello world，其中启动协程时可以通过CoroutineStart指定协程的启动模式，它是一个枚举值，默认是立即启动，也通过指定CoroutineStart.LAZY变为延迟启动，延迟启动需要你主动调用返回的Job对象的start方法后协程才会启动，如果我们想取消掉这个协程的执行就可以调用CoroutineScope的cancel方法，或者调用launch方法返回的Job对象的cancel方法，其实CoroutineScope的cancel方法内部也是调用返回的Job对象的cancel方法来结束这个协程。 上面就是启动一个协程的简单步骤，需要用到CoroutineScope、CoroutineContext、CoroutineStart。 通过自定义CoroutineScope，可以在应用程序的某一个层次开启或者控制协程的生命周期，例如Android，在ViewModel和Lifecycle类的生命周期里提供了CoroutineScope，分别是ViewModelScope和LifecycleScope，通过这两个CoroutineScope启动的所有协程可以在对应类的生命周期结束时自动被取消从而避免内存泄漏。 CoroutineContext的元素构造CoroutineScope使用到的CoroutineContext是一个特殊的集合，这个集合它既有Map的特点，也有Set的特点，集合的每一个元素都是Element，每个Element都有一个Key与之对应，对于相同Key的Element是不可以重复存在的，Element之间可以通过 + 号组合起来，后面我会详细介绍CoroutineContext这个特殊集合的结构，接下来我先简单讲解一下组成CoroutineContext的各个Element的作用，CoroutineContext主要由以下4个Element组成： Job：协程的唯一标识，用来控制协程的生命周期(new、active、completing、completed、cancelling、cancelled)； CoroutineDispatcher：指定协程运行的线程(IO、Default、Main、Unconfined); CoroutineName: 指定协程的名称，默认为coroutine; CoroutineExceptionHandler: 指定协程的异常处理器，用来处理未捕获的异常. 它们之间的关系如下： 下面分别介绍一下4个Element各自的作用： 1、Job123456789101112131415161718192021222324public interface Job : CoroutineContext.Element &#123; public companion object Key : CoroutineContext.Key&lt;Job&gt; &#123; init &#123; CoroutineExceptionHandler &#125; &#125; public val isActive: Boolean public val isCompleted: Boolean public val isCancelled: Boolean public fun start(): Boolean public fun cancel(cause: CancellationException? = null) public suspend fun join() public val children: Sequence&lt;Job&gt; //...&#125; 通过CoroutineScope的扩展方法launch启动一个协程后，它会新建返回一个Job对象，它是协程的唯一标识，这个Job对象包含了这个协程任务的一系列状态，如下： 当一个协程创建后它就处于新建(New)状态，当调用Job的start/join方法后协程就处于活跃(Active)状态，这是运行状态，协程运行出错或者调用Job的cancel方法都会将当前协程置为取消中(Cancelling)状态, 处于取消中状态的协程会等所有子协程都完成后才进入取消 (Cancelled)状态，当协程执行完成后或者调用CompletableJob(CompletableJob是Job的一个子接口)的complete方法都会让当前协程进入完成中(Completing)状态， 处于完成中状态的协程会等所有子协程都完成后才进入完成(Completed)状态。 虽然协程有New、Cancelling、Completing状态，但是外部是无法感知这三个状态的，Job只提供了isActive、isCancelled、isCompleted属性来供外部判断协程是否处于Active、Cancelled、Completed状态，当协程处于Active状态时，isActive为true，isCancelled和isCompleted为false，当协程处于Cancelled状态时，isCancelled和isCompleted为true，isActive为false，当协程处于Completed状态时，isCompleted为true，isActive和isCancelled为false。 协程中有两种类型的Job，如果我们平时启动协程时没有特意地通过CoroutineContext指定一个Job，那么使用launch/async方法启动协程时返回的Job它会产生异常传播，我们知道协程有一个父子的概念，例如启动一个协程1，在协程中继续启动协程2、协程3，那么协程1就是协程2、协程3的父协程，协程2、协程3就是协程1的子协程，每个协程都会有一个对应的Job，协程之间的父子关系是通过Job对象维持的，像一颗树一样： 所以异常传播就是这个Job因为除了CancellationException以外的异常而失败时，那么父Job就会感知到并抛出异常，在抛出异常之前，父Job会取消所有子Job的运行，这也是结构化编程的一个特点，如果要抑制这种异常传播的行为，那么可以用到另外一种类型的Job - SupervisorJob，SupervisorJob它不是一个类，它是一个构造方法： 1public fun SupervisorJob(parent: Job? = null) : CompletableJob = SupervisorJobImpl(parent) SupervisorJob方法会返回CompletableJob的一个supervisor实现，CompletableJob是Job的一个子接口，它比Job接口多了一个complete方法，这意味着它可以调用complete方法让协程任务进入完成状态，supervisor实现的意思是这个Job它不会产生异常传播，每个Job可以单独被管理，当SupervisorJob因为除了CancellationException以外的异常而失败时，并不会影响到父Job和其他子Job，下面是SupervisorJob的一个使用例子： 1234567891011fun main()&#123; val parentJob = GlobalScope.launch &#123; //childJob是一个SupervisorJob val childJob = launch(SupervisorJob())&#123; throw NullPointerException() &#125; childJob.join() println(\"parent complete\") &#125; Thread.sleep(1000)&#125; childJob抛出异常并不会影响parentJob的运行，parentJob会继续运行并输出parent complete。 2、CoroutineDispatcher12345678910111213public abstract class CoroutineDispatcher : AbstractCoroutineContextElement(ContinuationInterceptor), ContinuationInterceptor &#123; public companion object Key : AbstractCoroutineContextKey&lt;ContinuationInterceptor, CoroutineDispatcher&gt;( ContinuationInterceptor, &#123; it as? CoroutineDispatcher &#125; ) public open fun isDispatchNeeded(context: CoroutineContext): Boolean = true public abstract fun dispatch(context: CoroutineContext, block: Runnable) //...&#125; CoroutineDispatcher可以指定协程的运行线程，CoroutineDispatcher里面有一个dispatch方法，这个dispatch方法用于把协程任务分派到特定线程运行，kotlin已经内置了CoroutineDispatcher的4个实现，可以通过Dispatchers的Default、IO、Main、Unconfined字段分别返回使用，如下： 12345678910111213public actual object Dispatchers &#123; @JvmStatic public actual val Default: CoroutineDispatcher = createDefaultDispatcher() @JvmStatic public val IO: CoroutineDispatcher = DefaultScheduler.IO @JvmStatic public actual val Unconfined: CoroutineDispatcher = kotlinx.coroutines.Unconfined @JvmStatic public actual val Main: MainCoroutineDispatcher get() = MainDispatcherLoader.dispatcher&#125; 2.1、Default、IODispatchers.Default和Dispatchers.IO内部都是线程池实现，它们的含义是把协程运行在共享的线程池中，我们先看Dispatchers.Default的实现，看createDefaultDispatcher方法： 1internal actual fun createDefaultDispatcher(): CoroutineDispatcher = if (useCoroutinesScheduler) DefaultScheduler else CommonPool DefaultScheduler和CommonPool都是CoroutineDispatcher的子类，不同的是DefaultScheduler内部依赖的是kotlin自己实现的线程池逻辑，而CommonPool内部依赖的是java类库中的Executor，默认情况下useCoroutinesScheduler为true，所以createDefaultDispatcher方法返回的是DefaultScheduler实例，我们看一下这个DefaultScheduler： 12345678910internal object DefaultScheduler : ExperimentalCoroutineDispatcher() &#123; val IO: CoroutineDispatcher = LimitingDispatcher( this,//DefaultScheduler实例被传进了LimitingDispatcher中 systemProp(IO_PARALLELISM_PROPERTY_NAME, 64.coerceAtLeast(AVAILABLE_PROCESSORS)), \"Dispatchers.IO\", TASK_PROBABLY_BLOCKING ) //...&#125; DefaultScheduler中的IO字段就是Dispatchers.IO，它是LimitingDispatcher实例，所以Dispatchers.IO的实现是LimitingDispatcher，同时我们要注意到DefaultScheduler是用object字段修饰，这说明它是一个单例，并且DefaultScheduler实例被传进了LimitingDispatcher的构造方法中，所以LimitingDispatcher就会持有DefaultScheduler实例，而DefaultScheduler它的主要实现都在它的父类ExperimentalCoroutineDispatcher中： 12345678910111213141516171819202122232425262728293031323334353637@InternalCoroutinesApipublic open class ExperimentalCoroutineDispatcher( private val corePoolSize: Int, private val maxPoolSize: Int, private val idleWorkerKeepAliveNs: Long, private val schedulerName: String = \"CoroutineScheduler\") : ExecutorCoroutineDispatcher() &#123; public constructor( corePoolSize: Int = CORE_POOL_SIZE, maxPoolSize: Int = MAX_POOL_SIZE, schedulerName: String = DEFAULT_SCHEDULER_NAME ) : this(corePoolSize, maxPoolSize, IDLE_WORKER_KEEP_ALIVE_NS, schedulerName) private var coroutineScheduler = createScheduler() //返回CoroutineScheduler实例 private fun createScheduler() = CoroutineScheduler(corePoolSize, maxPoolSize, idleWorkerKeepAliveNs, schedulerName) override fun dispatch(context: CoroutineContext, block: Runnable): Unit = try &#123; //dispatch方法委托给了CoroutineScheduler的dispatch方法 coroutineScheduler.dispatch(block) &#125; catch (e: RejectedExecutionException) &#123; //... &#125; internal fun dispatchWithContext(block: Runnable, context: TaskContext, tailDispatch: Boolean) &#123; try &#123; //dispatchWithContext方法委托给了CoroutineScheduler的dispatch方法 coroutineScheduler.dispatch(block, context, tailDispatch) &#125; catch (e: RejectedExecutionException) &#123; //... &#125; &#125; //...&#125; 我们再看Dispatchers.IO对应的LimitingDispatcher实现： 1234567891011121314151617181920212223242526272829303132333435private class LimitingDispatcher( private val dispatcher: ExperimentalCoroutineDispatcher,//外部传进的DefaultScheduler实例 private val parallelism: Int, private val name: String?, override val taskMode: Int) : ExecutorCoroutineDispatcher(), TaskContext, Executor &#123; private val queue = ConcurrentLinkedQueue&lt;Runnable&gt;() private val inFlightTasks = atomic(0) override fun dispatch(context: CoroutineContext, block: Runnable) = dispatch(block, false) private fun dispatch(block: Runnable, tailDispatch: Boolean) &#123; var taskToSchedule = block while (true) &#123; val inFlight = inFlightTasks.incrementAndGet() if (inFlight &lt;= parallelism) &#123; //LimitingDispatcher的dispatch方法委托给了DefaultScheduler的dispatchWithContext方法 dispatcher.dispatchWithContext(taskToSchedule, this, tailDispatch) return &#125; queue.add(taskToSchedule) if (inFlightTasks.decrementAndGet() &gt;= parallelism) &#123; return &#125; taskToSchedule = queue.poll() ?: return &#125; &#125; //...&#125; 从上面分析得知，Dispatchers.Default的实现是DefaultScheduler，Dispatchers.IO的实现是LimitingDispatcher，而LimitingDispatcher持有DefaultScheduler实例，把dispatch操作委托给DefaultScheduler，DefaultScheduler内部持有CoroutineScheduler实例，把dispatch操作委托给CoroutineScheduler，而DefaultScheduler又是一个单例，所以Dispatchers.Default和Dispatchers.IO它们共用同一个CoroutineScheduler实例，它们之间的关系如下： CoroutineScheduler就是kotlin自己实现的共享线程池，是Dispatchers.Default和Dispatchers.IO内部的共同实现，Dispatchers.Default和Dispatchers.IO共享CoroutineScheduler中的线程，DefaultScheduler和LimitingDispatcher的主要作用是对CoroutineScheduler进行线程数、任务数等配置，CoroutineScheduler使用工作窃取算法(Work Stealing)重新实现了一套线程池的任务调度逻辑，它的性能、扩展性对协程的任务调度更友好，具体的逻辑可以查看这个类的dispatch方法： 123456789101112131415161718192021internal class CoroutineScheduler( @JvmField val corePoolSize: Int, @JvmField val maxPoolSize: Int, @JvmField val idleWorkerKeepAliveNs: Long = IDLE_WORKER_KEEP_ALIVE_NS, @JvmField val schedulerName: String = DEFAULT_SCHEDULER_NAME) : Executor, Closeable &#123; override fun execute(command: Runnable) = dispatch(command) fun dispatch(block: Runnable, taskContext: TaskContext = NonBlockingContext, tailDispatch: Boolean = false) &#123; val task = createTask(block, taskContext) //... if (task.mode == TASK_NON_BLOCKING) &#123; //... &#125; else &#123; //... &#125; &#125; //...&#125; 所以这个线程池既可以运行两种类型的任务：CPU密集型任务和IO密集型任务，用一个mode来区别，当你为协程指定Dispatchers.Default时，Dispatcher会把协程的任务指定为CPU密集型任务，对应mode为TASK_NON_BLOCKING，当你为协程指定Dispatchers.IO时，Dispatcher会把协程的任务指定为IO密集型任务，对应mode为TASK_PROBABLY_BLOCKING，所以这时CoroutineScheduler就可以根据task mode作出不同的线程创建、调度、唤醒策略，当启动协程时没有指定Dispatcher，默认会使用Dispatchers.Default。 当运行CPU密集型任务时，CoroutineScheduler最多有corePoolSize个线程被创建，corePoolSize它的取值为max(2, CPU核心数)，即它会尽量的等于CPU核心数，当运行IO密集型任务时，它可以创建比corePoolSize更多的线程来运行IO型任务，但不能大于maxPoolSize，maxPoolSize会取一个很大的值，默认为max(corePoolSize, min(CPU核心数 * 128, 2^21 - 2))，即大于corePoolSize，小于2^21 - 2，而2^21 - 2是一个很大的数约为2M，但是CoroutineScheduler是不可能创建这么多线程的，所以就需要外部限制提交的任务数，而Dispatchers.IO构造时就通过LimitingDispatcher默认限制了最大线程并发数parallelism为max(64, CPU核心数)，即Dispatchers.IO最多只能提交parallelism个任务到CoroutineScheduler中执行，剩余的任务被放进一个队列中等待。 CPU密集型任务：CPU密集型任务的特点是执行任务时CPU会处于忙碌状态，任务会消耗大量的CPU资源，例如计算复杂的算术、视频解码等，如果此时线程数太多，超过了CPU核心数，那么这些超出来的线程是得不到CPU的执行的，只会浪费内存资源，因为线程本身也有栈等空间，同时线程过多，频繁的线程切换带来的消耗也会影响线程池的性能，所以对于CPU密集型任务，线程池并发线程数等于CPU核心数才能让CPU的执行效率最大化； IO密集型任务：IO密集型任务的特点是执行任务时CPU会处于闲置状态，任务不会消耗大量的CPU资源，例如网络请求、IO操作等，线程执行IO密集型任务时大多数处于阻塞状态，处于阻塞状态的线程是不占用CPU的执行时间，这时CPU就处于闲置状态，为了让CPU忙起来，执行IO密集型任务时理应让线程的创建数量更多一点，理想情况下线程数应该等于提交的任务数，对于这些多创建出来的线程，当它们闲置时，线程池一般会有一个超时回收策略，所以大部分情况下并不会占用大量的内存资源，但也会有极端情况，所以对于IO密集型任务，线程池并发线程数应尽可能地多才能提高CPU的吞吐量，这个尽可能地多的程度并不是无限大，而是根据业务情况设定，但肯定要大于CPU核心数。 2.2、UnconfinedDispatchers.Unconfined的含义是不给协程指定运行的线程，在第一次被挂起(suspend)之前，由启动协程的线程执行它，但被挂起后, 会由恢复协程的线程继续执行, 如果一个协程会被挂起多次, 那么每次被恢复后, 都有可能被不同线程继续执行，看下面的一个例子： 1234567891011121314151617181920212223242526272829fun main()&#123; GlobalScope.launch(Dispatchers.Unconfined)&#123; println(Thread.currentThread().name) //挂起 withContext(Dispatchers.IO)&#123; println(Thread.currentThread().name) &#125; //恢复 println(Thread.currentThread().name) //挂起 withContext(Dispatchers.Default)&#123; println(Thread.currentThread().name) &#125; //恢复 println(Thread.currentThread().name) &#125; //进程保活 Thread.sleep(1000)&#125;运行输出：mainDefaultDispatcher-worker-1DefaultDispatcher-worker-1DefaultDispatcher-worker-3DefaultDispatcher-worker-3 协程启动时指定了Dispatchers.Unconfined，所以第一次执行时是由启动协程的线程执行，上面在主线程中启动了协程，所以第一次输出主线程main，withContext方法是一个suspend方法，它可以挂起当前协程，并把指定的代码块运行到给定的上下文中，直到代码块运行完成并返回结果，第一个代码块通过withContext方法把它运行在Dispatchers.IO中，所以第二次输出了线程池中的某一个线程DefaultDispatcher-worker-1，第一个代码块执行完毕后，协程在DefaultDispatcher-worker-1线程中恢复，所以协程恢复后执行在DefaultDispatcher-worker-1线程中，所以第三次继续输出DefaultDispatcher-worker-1，第二个代码块同理。 那么Dispatchers.Unconfined是怎么做到的呢，我们看下Unconfined对应的CoroutineDispatcher实现 - kotlinx.coroutines.Unconfined： 1234567891011121314151617internal object Unconfined : CoroutineDispatcher() &#123; override fun isDispatchNeeded(context: CoroutineContext): Boolean = false override fun dispatch(context: CoroutineContext, block: Runnable) &#123; // It can only be called by the \"yield\" function. See also code of \"yield\" function. val yieldContext = context[YieldContext] if (yieldContext != null) &#123; // report to \"yield\" that it is an unconfined dispatcher and don't call \"block.run()\" yieldContext.dispatcherWasUnconfined = true return &#125; throw UnsupportedOperationException(\"Dispatchers.Unconfined.dispatch function can only be used by the yield function. \" + \"If you wrap Unconfined dispatcher in your code, make sure you properly delegate \" + \"isDispatchNeeded and dispatch calls.\") &#125;&#125; Unconfined他重写了CoroutineDispatcher的isDispatchNeeded方法和dispatch方法，isDispatchNeeded方法返回了false，表示不需要dispatch，而默认CoroutineDispatcher的isDispatchNeeded方法是返回true的，Dispatchers.Default和Dispatchers.IO都没有重写这个方法，Unconfined的dispatch方法没有任何任务调度的逻辑，只是写明了只有当调用yield方法时，Unconfined的dispatch方法才会被调用，yield方法是一个suspend方法，当在协程中调用这个方法时表示当前协程让出自己所在的线程给其他协程运行，所以正常情况下是不会调用Unconfined的dispatch方法的。 在kotlin中每个协程都有一个Continuation实例与之对应，当协程恢复时会调用Continuation的resumeWith方法，它的实现在DispatchedContinuation中，如下： 1234567891011121314151617181920212223242526internal class DispatchedContinuation&lt;in T&gt;( @JvmField val dispatcher: CoroutineDispatcher,//协程的的CoroutineDispatcher实例 @JvmField val continuation: Continuation&lt;T&gt;//代表协程的Continuation实例) : DispatchedTask&lt;T&gt;(MODE_UNINITIALIZED), CoroutineStackFrame, Continuation&lt;T&gt; by continuation &#123; //... override fun resumeWith(result: Result&lt;T&gt;) &#123; val context = continuation.context val state = result.toState() if (dispatcher.isDispatchNeeded(context)) &#123; _state = state resumeMode = MODE_ATOMIC dispatcher.dispatch(context, this) &#125; else &#123;//Unconfined走这里的逻辑 //调用executeUnconfined方法 executeUnconfined(state, MODE_ATOMIC) &#123; //withCoroutineContext方法的作用是查找context中的ThreadContextElement元素，然后调用ThreadContextElement的相应方法更新当前线程的上下文 withCoroutineContext(this.context, countOrElement) &#123; //调用Continuation的resumeWith方法 continuation.resumeWith(result) &#125; &#125; &#125; &#125;&#125; 我们注意到by关键字，这是kotlin中的委托实现，DispatchedContinuation通过类委托加强了Continuation的resumeWith方法，即在调用Continuation的resumeWith方法之前增加了一些自己的逻辑，我们可以看到DispatchedContinuation的resumeWith方法中会根据CoroutineDispatcher的isDispatchNeeded方法返回值做出不同处理，当isDispatchNeeded方法返回true时，会调用协程的CoroutineDispatcher的dispatch方法，而当isDispatchNeeded方法返回false时，不会调用CoroutineDispatcher的dispatch方法而是调用executeUnconfined方法，上面讲到Unconfined的isDispatchNeeded方法返回了false，我们看executeUnconfined方法： 123456789101112131415161718192021222324252627282930313233343536373839404142private inline fun DispatchedContinuation&lt;*&gt;.executeUnconfined( contState: Any?, mode: Int, doYield: Boolean = false, block: () -&gt; Unit): Boolean &#123; assert &#123; mode != MODE_UNINITIALIZED &#125; //从ThreadLocal中取出EventLoop val eventLoop = ThreadLocalEventLoop.eventLoop if (doYield &amp;&amp; eventLoop.isUnconfinedQueueEmpty) return false //判断是否在执行Unconfined任务 return if (eventLoop.isUnconfinedLoopActive) &#123; _state = contState resumeMode = mode //调用EventLoop的dispatchUnconfined方法把Unconfined任务放进EventLoop中 eventLoop.dispatchUnconfined(this) true &#125; else &#123; //执行Unconfined任务 runUnconfinedEventLoop(eventLoop, block = block) false &#125;&#125;internal inline fun DispatchedTask&lt;*&gt;.runUnconfinedEventLoop( eventLoop: EventLoop, block: () -&gt; Unit) &#123; eventLoop.incrementUseCount(unconfined = true) try &#123; //先执行block代码块，block()就是executeUnconfined方法传进的代码块, block()里面会调用Continuation的resumeWith方法 block() while (true) &#123; //再调用EventLoop的processUnconfinedEvent方法执行EventLoop中的Unconfined任务，直到EventLoop中的所有Unconfined任务执行完才跳出循环 if (!eventLoop.processUnconfinedEvent()) break &#125; &#125; catch (e: Throwable) &#123; //... &#125; finally &#123; eventLoop.decrementUseCount(unconfined = true) &#125;&#125; 可以看到对于Unconfined任务，是在当前线程马上执行或者通过当前线程的EventLoop来执行的，EventLoop是存放在ThreadLocal中的，所以EventLoop它是跟当前线程相关联的，而EventLoop也是CoroutineDispatcher的一个子类： 123456789101112131415161718internal abstract class EventLoop : CoroutineDispatcher() &#123; //... private var unconfinedQueue: ArrayQueue&lt;DispatchedTask&lt;*&gt;&gt;? = null public fun dispatchUnconfined(task: DispatchedTask&lt;*&gt;) &#123; val queue = unconfinedQueue ?: ArrayQueue&lt;DispatchedTask&lt;*&gt;&gt;().also &#123; unconfinedQueue = it &#125; queue.addLast(task) &#125; public fun processUnconfinedEvent(): Boolean &#123; val queue = unconfinedQueue ?: return false val task = queue.removeFirstOrNull() ?: return false task.run() return true &#125;&#125; EventLoop中有一个双端队列用于存放Unconfined任务，Unconfined任务是指指定了Dispatchers.Unconfined的协程任务，EventLoop的dispatchUnconfined方法用于把Unconfined任务放进队列的尾部，processUnconfinedEvent方法用于从队列的头部移出Unconfined任务执行，所以executeUnconfined方法里面的策略就是：在当前线程立即执行Unconfined任务，如果当前线程已经在执行Unconfined任务，就暂时把它放进跟当前线程关联的EventLoop中，等待执行，同时Unconfined任务里面会调用Continuation的resumeWith方法恢复协程运行，这也是为什么指定了Dispatchers.Unconfined后协程恢复能够被恢复协程的线程执行的原因。 2.3、MainDispatchers.Main的含义是把协程运行在平台相关的只能操作UI对象的Main线程，所以它根据不同的平台有不同的实现，kotlin它支持下面三种平台： kotlin/js：kotlin/js是kotlin对JavaScript的支持，提供了转换kotlin代码，kotlin标准库的能力，npm包管理能力，在kotlin/js上Dispatchers.Main等效于Dispatchers.Default； kotlin/native：kotlin/native是一种将kotlin代码编译为无需虚拟机就可运行的原生二进制文件的技术, 它的主要目的是允许对不需要或不可能使用虚拟机的平台进行编译，例如嵌入式设备或iOS，在kotlin/native上Dispatchers.Main等效于Dispatchers.Default； kotlin/JVM：kotlin/JVM就是需要虚拟机才能编译的平台，例如Android就是属于kotlin/JVM，对于kotlin/JVM我们需要引入对应的dispatcher，例如Android就需要引入kotlinx-coroutines-android库，它里面有Android对应的Dispatchers.Main实现，其实就是把任务通过Handler运行在Android的主线程. 我们再看Dispatchers.Main的实现 - MainDispatcherLoader.dispatcher: 123456789internal object MainDispatcherLoader &#123; @JvmField val dispatcher: MainCoroutineDispatcher = loadMainDispatcher() private fun loadMainDispatcher(): MainCoroutineDispatcher &#123; //...主要是通过反射加载实现了MainCoroutineDispatcher的类 &#125;&#125; 所以Dispatchers.Main的CoroutineDispatcher实现是MainCoroutineDispatcher，MainCoroutineDispatcher的具体实现就因平台的不同而不同了，如果你直接使用Dispatchers.Main而没有引入对应的库就会引发IllegalStateException异常。 3、CoroutineName12345678public data class CoroutineName( val name: String) : AbstractCoroutineContextElement(CoroutineName) &#123; public companion object Key : CoroutineContext.Key&lt;CoroutineName&gt; override fun toString(): String = \"CoroutineName($name)\"&#125; CoroutineName就是协程的名字，它的结构很简单, 我们平时开发一般是不会去指定一个CoroutineName的，因为CoroutineName只在kotlin的debug模式下才会被用的, 它在debug模式下被用于设置协程运行线程的名字： 12345678910111213141516171819202122internal data class CoroutineId( val id: Long) : ThreadContextElement&lt;String&gt;, AbstractCoroutineContextElement(CoroutineId) &#123; override fun updateThreadContext(context: CoroutineContext): String &#123; val coroutineName = context[CoroutineName]?.name ?: \"coroutine\" val currentThread = Thread.currentThread() val oldName = currentThread.name var lastIndex = oldName.lastIndexOf(DEBUG_THREAD_NAME_SEPARATOR) if (lastIndex &lt; 0) lastIndex = oldName.length currentThread.name = buildString(lastIndex + coroutineName.length + 10) &#123; append(oldName.substring(0, lastIndex)) append(DEBUG_THREAD_NAME_SEPARATOR) append(coroutineName) append('#') append(id) &#125; return oldName &#125; //...&#125; 我们可以通过设置key为kotlinx.coroutines.debug的SystemProp的值为on打开协程的debug模式，这样我们指定的CoroutineName就会出现运行协程的线程的名字上。 4、CoroutineExceptionHandler123456public interface CoroutineExceptionHandler : CoroutineContext.Element &#123; public companion object Key : CoroutineContext.Key&lt;CoroutineExceptionHandler&gt; public fun handleException(context: CoroutineContext, exception: Throwable)&#125; CoroutineExceptionHandler就是协程的异常处理器，用来处理协程运行中未捕获的异常，如果我们没有指定它，那么协程中未捕获的异常默认会流转到Thread的uncaughtExceptionHandler中，我们可以在启动协程时通过CoroutineContext指定我们自定义的异常处理器，我们可以通过CoroutineExceptionHandler方法创建一个CoroutineExceptionHandler，它会返回一个CoroutineExceptionHandler的默认实现，默认实现的handleException方法中调用了我们传进的handler方法： 12345public inline fun CoroutineExceptionHandler(crossinline handler: (CoroutineContext, Throwable) -&gt; Unit): CoroutineExceptionHandler = object : AbstractCoroutineContextElement(CoroutineExceptionHandler), CoroutineExceptionHandler &#123; override fun handleException(context: CoroutineContext, exception: Throwable) = handler.invoke(context, exception) &#125; CoroutineExceptionHandler只对launch方法启动的根协程有效，而对async启动的根协程无效，因为async启动的根协程默认会捕获所有未捕获异常并把它放在Deferred中，等到用户调用Deferred的await方法才抛出，如下： 1234567891011121314151617181920212223fun main()&#123; //自定义CoroutineExceptionHandler val handler = CoroutineExceptionHandler&#123; coroutineContext, throwable -&gt; println(\"my coroutineExceptionHandler catch exception, msg = $&#123;throwable.message&#125;\") &#125; //handler有效 val job = GlobalScope.launch(handler)&#123; throw IndexOutOfBoundsException(\"exception thrown from launch\") &#125; job.start() //handler无效 val deferred = GlobalScope.async(handler)&#123; throw NullPointerException(\"exception thrown from async\") &#125; deferred.start() Thread.sleep(1000)&#125;输出：my coroutineExceptionHandler catch exception, msg = exception thrown from launch 其中只有launch启动的根协程抛出的异常才被CoroutineExceptionHandler处理，而对于async启动的根协程抛出的异常CoroutineExceptionHandler无效，需要我们调用Deferred的await方法时try catch。 还有子协程抛出的未捕获异常会委托父协程的CoroutineExceptionHandler处理，子协程设置的CoroutineExceptionHandler永远不会生效(SupervisorJob 除外)，如下： 123456789101112131415161718192021222324fun main()&#123; //根协程的Handler val parentHandler = CoroutineExceptionHandler&#123;coroutineContext, throwable -&gt; println(\"parent coroutineExceptionHandler catch exception, msg = $&#123;throwable.message&#125;\") &#125; //启动根协程 val parentJob = GlobalScope.launch(parentHandler)&#123; //子协程的Handler val childHandler = CoroutineExceptionHandler&#123;coroutineContext, throwable -&gt; println(\"child coroutineExceptionHandler catch exception, msg = $&#123;throwable.message&#125;\") &#125; //启动子协程 val childJob = launch(childHandler)&#123; throw IndexOutOfBoundsException(\"exception thrown from child launch\") &#125; childJob.start() &#125; parentJob.start() Thread.sleep(1000)&#125;输出：parent coroutineExceptionHandler catch exception, msg = exception thrown from child launch 可以看到子协程设置CoroutineExceptionHandler没有输出，只有根协程的CoroutineExceptionHandler输出了，但是也有例外，如果子协程是SupervisorJob，那么它设置的CoroutineExceptionHandler是生效的，前面也说过SupervisorJob不会产生异常传播。 当父协程的子协程同时抛出多个异常时，CoroutineExceptionHandler只会捕获第一个协程抛出的异常，后续协程抛出的异常被保存在第一个异常的suppressed数组中，如下： 123456789101112131415161718192021222324252627fun main()&#123; val handler = CoroutineExceptionHandler&#123;coroutineContext, throwable -&gt; println(\"my coroutineExceptionHandler catch exception, msg = $&#123;throwable.message&#125;, suppressed = $&#123;throwable.suppressed.contentToString()&#125;\") &#125; val parentJob = GlobalScope.launch(handler)&#123; launch &#123; try &#123; delay(200) &#125;finally &#123; //第二个抛出的异常 throw IndexOutOfBoundsException(\"exception thrown from first child launch\") &#125; &#125;.start() launch &#123; delay(100) //第一个抛出的异常 throw NullPointerException(\"exception thrown from second child launch\") &#125;.start() &#125; parentJob.start() Thread.sleep(1000)&#125;输出：my coroutineExceptionHandler catch exception, msg = exception thrown from second child launch, suppressed = [java.lang.IndexOutOfBoundsException: exception thrown from first child launch] 可以看到CoroutineExceptionHandler只处理了第一个子协程抛出的异常，后续异常都放在了第一个抛出异常的suppressed数组中。 还有取消协程时会抛出一个CancellationException，它会被所有CoroutineExceptionHandler省略，但可以try catch它，同时当子协程抛出CancellationException时，并不会终止当前父协程的运行： 123456789101112131415161718192021222324252627282930fun main()&#123; val handler = CoroutineExceptionHandler&#123;coroutineContext, throwable -&gt; println(\"my coroutineExceptionHandler catch exception, msg = $&#123;throwable.message&#125;\") &#125; val parentJob = GlobalScope.launch(handler)&#123; val childJob = launch &#123; try &#123; delay(Long.MAX_VALUE) &#125;catch (e: CancellationException)&#123; println(\"catch cancellationException thrown from child launch\") println(\"rethrow cancellationException\") throw CancellationException() &#125;finally &#123; println(\"child was canceled\") &#125; &#125; //取消子协程 childJob.cancelAndJoin() println(\"parent is still running\") &#125; parentJob.start() Thread.sleep(1000)&#125;输出：catch cancellationException thrown from child launchrethrow cancellationExceptionchild was canceledparent is still running 可以看到当抛出CancellationException时，我们可以try catch住它，同时当我们再次抛出它时，协程的CoroutineExceptionHandler并没有处理它，同时父协程不受影响，继续运行。 以上就是我们平时开发常用到的CoroutineContext元素，除了这四个元素，还有一些在特定场景下会使用到的元素，例如NonCancellable、ThreadContextElement等，其中NonCancellable可以把协程运行在不可取消的上下文中，ThreadContextElement可以让协程恢复/挂起前修改当前线程的上下文信息，例如修改线程的名字为当前运行协程的名字，前面讲的CoroutineName通过CoroutineId这个ThreadContextElement就是这么干的，除了这些内置的元素，我们还可以自定义CoroutineContext元素以满足我们的开发，后面会讲到如何自定义CoroutineContext的元素。 CoroutineContext的结构我们再次看一下CoroutineContext的全家福： 上面讲解了组成CoroutineContext的Element，每一个Element都继承自CoroutineContext，而每一个Element都可以通过 + 号来组合，也可以通过类似map的 [key] 来取值，这和CoroutineContext的运算符重载逻辑和它的结构实现CombinedContext有关，我们先来看一下CoroutineContext类： 1234567891011121314151617181920212223242526public interface CoroutineContext &#123; //操作符[]重载，可以通过CoroutineContext[Key]这种形式来获取与Key关联的Element public operator fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E? //它是一个聚集函数，提供了从left到right遍历CoroutineContext中每一个Element的能力，并对每一个Element做operation操作 public fun &lt;R&gt; fold(initial: R, operation: (R, Element) -&gt; R): R //操作符+重载，可以CoroutineContext + CoroutineContext这种形式把两个CoroutineContext合并成一个 public operator fun plus(context: CoroutineContext): CoroutineContext //返回一个新的CoroutineContext，这个CoroutineContext删除了Key对应的Element public fun minusKey(key: Key&lt;*&gt;): CoroutineContext //Key定义，空实现，仅仅做一个标识 public interface Key&lt;E : Element&gt; //Element定义，每个Element都是一个CoroutineContext public interface Element : CoroutineContext &#123; //每个Element都有一个Key实例 public val key: Key&lt;*&gt; //... &#125;&#125; 除了plus方法，CoroutineContext中的其他三个方法都被CombinedContext、Element、EmptyCoroutineContext重写，CombinedContext就是CoroutineContext集合结构的实现，它里面是一个递归定义，Element就是CombinedContext中的元素，而EmptyCoroutineContext就表示一个空的CoroutineContext，它里面是空实现。 1、CombinedContext我们先看CombinedContext类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//CombinedContext只包含left和element两个成员：left可能为CombinedContext或Element实例，而element就是Element实例internal class CombinedContext( private val left: CoroutineContext, private val element: Element) : CoroutineContext, Serializable &#123; //CombinedContext的get操作的逻辑是： //1、先看element是否是匹配，如果匹配，那么element就是需要找的元素，返回element，否则说明要找的元素在left中，继续从left开始找，根据left是CombinedContext还是Element转到2或3 //2、如果left又是一个CombinedContext，那么重复1 //3、如果left是Element，那么调用它的get方法返回 override fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E? &#123; var cur = this while (true) &#123; //1 cur.element[key]?.let &#123; return it &#125; val next = cur.left if (next is CombinedContext) &#123;//2 cur = next &#125; else &#123;//3 return next[key] &#125; &#125; &#125; //CombinedContext的fold操作的逻辑是：先对left做fold操作，把left做完fold操作的的返回结果和element做operation操作 public override fun &lt;R&gt; fold(initial: R, operation: (R, Element) -&gt; R): R = operation(left.fold(initial, operation), element) //CombinedContext的minusKey操作的逻辑是： //1、先看element是否是匹配，如果匹配，那么element就是需要删除的元素，返回left，否则说明要删除的元素在left中，继续从left中删除对应的元素，根据left是否删除了要删除的元素转到2或3或4 //2、如果left中不存在要删除的元素，那么当前CombinedContext就不存在要删除的元素，直接返回当前CombinedContext实例就行 //3、如果left中存在要删除的元素，删除了这个元素后，left变为了空，那么直接返回当前CombinedContext的element就行 //4、如果left中存在要删除的元素，删除了这个元素后，left不为空，那么组合一个新的CombinedContext返回 public override fun minusKey(key: Key&lt;*&gt;): CoroutineContext &#123; //1 element[key]?.let &#123; return left &#125; val newLeft = left.minusKey(key) return when &#123; newLeft === left -&gt; this//2 newLeft === EmptyCoroutineContext -&gt; element//3 else -&gt; CombinedContext(newLeft, element)//4 &#125; &#125; //...&#125; 可以发现CombinedContext中的get、fold、minusKey操作都是递归形式的操作，递归的终点就是当这个left是一个Element，我们再看Element类： 12345678910111213141516public interface Element : CoroutineContext &#123; public val key: Key&lt;*&gt; //Element的get方法逻辑：如果key和自己的key匹配，那么自己就是要找的Element，返回自己，否则返回null public override operator fun &lt;E : Element&gt; get(key: Key&lt;E&gt;): E? = if (this.key == key) this as E else null //Element的fold方法逻辑：对传入的initial和自己做operation操作 public override fun &lt;R&gt; fold(initial: R, operation: (R, Element) -&gt; R): R = operation(initial, this) //Element的minusKey方法逻辑：如果key和自己的key匹配，那么自己就是要删除的Element，返回EmptyCoroutineContext(表示删除了自己)，否则说明自己不需要被删除，返回自己 public override fun minusKey(key: Key&lt;*&gt;): CoroutineContext = if (this.key == key) EmptyCoroutineContext else this&#125; 现在我们把CombinedContext和Element结合来看，那么CombinedContext的整体结构如下： 有点像是一个链表，left就是指向下一个结点的指针，有了这个图我们再从整体看当调用CombinedContext的get、fold、minusKey操作时的访问顺序：get、minusKey操作大体逻辑都是先访问当前element，不满足，再访问left的element，顺序都是从right到left，而fold的操作大体逻辑是先访问left，直到递归到最后的element，然后再从left到right的返回，从而访问了所有的element。 2、CoroutineContext的plus操作现在我们来看CoroutineContext唯一没有被重写的方法 - plus方法： 123456789101112131415161718public interface CoroutineContext &#123; //... public operator fun plus(context: CoroutineContext): CoroutineContext = if (context === EmptyCoroutineContext) this else context.fold(this) &#123; acc, element -&gt; val removed = acc.minusKey(element.key) if (removed === EmptyCoroutineContext) element else &#123; val interceptor = removed[ContinuationInterceptor] if (interceptor == null) CombinedContext(removed, element) else &#123; val left = removed.minusKey(ContinuationInterceptor) if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else CombinedContext(CombinedContext(left, element), interceptor) &#125; &#125; &#125;&#125; 这个方法看起来有点复杂，为了方便我们理解，我把它简化一下，我把对ContinuationInterceptor的处理去掉，如下： 123456789101112131415161718public interface CoroutineContext &#123; //... public operator fun plus(context: CoroutineContext): CoroutineContext = //如果要相加的CoroutineContext为空，那么不做任何处理，直接返回 if (context === EmptyCoroutineContext) this else //如果要相加的CoroutineContext不为空，那么对它进行fold操作 context.fold(this) &#123; acc, element -&gt; //我们可以把acc理解成+号左边的CoroutineContext，element理解成+号右边的CoroutineContext的某一个element //首先从左边CoroutineContext中删除右边的这个element val removed = acc.minusKey(element.key) //如果removed为空，说明左边CoroutineContext删除了和element相同的元素后为空，那么返回右边的element即可 if (removed === EmptyCoroutineContext) element else &#123; //如果removed不为空，说明左边CoroutineContext删除了和element相同的元素后还有其他元素，那么构造一个新的CombinedContext返回 return CombinedContext(removed, element) &#125; &#125;&#125; plus方法大部分情况最终下返回一个CombinedContext，即我们把两个CoroutineContext相加后，返回一个CombinedContext，在组合成CombinedContext时，+号右边的CoroutineContext中的元素会覆盖+号左边的CoroutineContext中的含有相同key的元素，如下： 1(Dispatchers.Main, \"name\") + (Dispatchers.IO) = (Dispatchers.IO, \"name\") 这个覆盖操作就在fold方法的参数operation代码块中完成，通过minusKey方法删除掉重复元素，前面讲过当调用CombinedContext的fold方法时，会从left到right到访问所有的element，即会从left到right的把每一个element传入operation方法中，作为operation方法的第二个参数，而operation方法第一个参数acc的初始值为fold方法传入的initial值，然后它会不断的更新，每次更新的值为上一次调用operation方法的返回值，所以当两个CoroutineContext相加时，puls方法可以理解为下面的伪代码： 12345val acc = 左边的CoroutineContext for(var element in 右边的CoroutineContext)&#123; acc = operation(acc, element)//operation操作中会让element覆盖掉acc中与element相同的元素 &#125; return acc//所以plus方法最终返回的CoroutineContext是不存在key相同的element的 所以puls方法最终返回的CoroutineContext是不存在key相同的element的，+号右边的CoroutineContext中的元素会覆盖+号左边的CoroutineContext中的含有相同key的元素，这像是Set的特性。 现在我们再看回简化前的plus方法，它里面有个对ContinuationInterceptor的处理，目的是让ContinuationInterceptor在每次相加后都能变成CoroutineContext中的最后一个元素， ContinuationInterceptor它也是继承自Element，通常叫做协程上下文拦截器，它的主要作用是在协程执行前拦截它，从而在协程执行前做出一些其他的操作，前面我们讲到CoroutineDispatcher它本身也继承自ContinuationInterceptor，ContinuationInterceptor有一个interceptContinuation方法用于返回拦截协程的行为，而这个行为就是前面我们所讲到Dispatchers.Unconfined时的DispatchedContinuation，DispatchedContinuation在恢复协程前根据协程的CoroutineDispatcher类型做出不同的协程分派行为，通过把ContinuationInterceptor放在最后面，协程在查找上下文的element时，总能最快找到拦截器，避免了递归查找，从而让拦截行为前置执行。 自定义CoroutineContext元素通过前面对CoroutineContext结构的介绍，我们知道CoroutineContext中的Element和Key是一一对应的，我们可以自定义Element和对应的Key把它们放进协程的CoroutineContext中，然后在适当的时候从CoroutineContext中根据Key取出我们自定义的Element并执行相应的逻辑，你可以把协程的CoroutineContext简单地类比为线程的ThreadLocal，CoroutineContext保存的是跟协程运行相关的上下文信息，而ThreadLocal保存的是跟线程相关的上下文信息，与线程的ThreadLocal不同的是协程的CoroutineContext的是不可变的而线程的ThreadLocal是可变的，所以我们每次对CoroutineContext的修改返回的都是一个新的CoroutineContext，自定义的Element推荐继承自AbstractCoroutineContextElement，例如应用中有些方法需要登陆后才能调用，所以我们可以自定义一个名为的User的Element： 1234class User(val name: String) : AbstractCoroutineContextElement(User) &#123; companion object Key : CoroutineContext.Key&lt;User&gt;&#125; 然后在启动协程时根据是否登陆把用户信息保存到CoroutineContext中： 1234567891011fun mian() &#123; //... val context = if(isLogin) &#123; User(\"rain9155\") + Dispatchers.Main &#125;else &#123; Dispatchers.Main &#125; GlobalScope.launch(context) &#123; //...调用其他方法 &#125;&#125; 然后在执行每个需要登陆态的方法前都检查一下当前协程的CoroutineContext中是否有登陆后的用户信息： 1234suspend fun performAction() &#123; val name = coroutineContext[User]?.name ?: throw IllegalAccessException(\"unauthorized\") //...根据登陆后的用户信息执行其他操作&#125; coroutineContext是kotlin.coroutines包中的一个字段，可以获取当前运行协程的上下文，在每个suspend方法中都可以访问这个字段，同时由于User的Key是一个伴生对象，所以我们可以直接通过User名使用Key实例。 结语本文主要介绍了kotlin协程的CoroutineContext的元素组成和结构，CoroutineContext它是一个K-V数据结构，保存了跟协程相关联的运行上下文例如协程的线程调度策略、异常处理逻辑、日志记录、运行标识、名字等，理解CoroutineContext对于理解协程使用有很大的帮助，因为协程的启动时就离不开CoroutineContext，同时如果你以后想要更深入的学习协程，例如协程的调度过程、Continuation概念、suspend关键字等，本篇文章也能给你一个抛砖引玉的效果。 以上就是本文的所有内容，希望大家有所收获！ 参考文章： 开始使用Kotlin协程 协程中的核心概念 协程中的异常处理","tags":[{"name":"协程","slug":"协程","permalink":"http://yoursite.com/tags/%E5%8D%8F%E7%A8%8B/"}]},{"title":"自定义Gradle插件检测函数耗时","date":"2020-09-29T08:35:11.000Z","path":"2020/09/29/自定义Gradle插件检测函数耗时/","text":"前言 上一篇文章：Gradle的快速入门学习 上一篇文章讲解了Gralde的入门知识，其中讲到了如何自定义Gralde插件，本文就通过Asm和Transfrom来自定义一个简单的Gradle插件，这个Gradle插件它可以统计方法的耗时，并当方法的耗时超过阀值时，通过Log打印在控制台上，然后我们通过Log可以定位到耗时方法的位置，帮助我们找出耗时方法，一个很简单的功能，原理也很简单，这其中需要使用到Asm知识和Transfrom知识，所以本文首先会介绍Asm和Transfrom相关知识点，最后再介绍如何使用Asm和Transform来实现这个Gradle插件，如果你对Asm和Transfrom已经很熟悉了，可以跳过这两节。 源码位置在文末 运行效果由于这个是本地插件，所以直接在app/build.gradle中apply就行，然后可以通过time扩展配置它(可选)： 123456apply plugin: com.example.plugin.TimeCostPlugin//函数耗时阀值为200ms，只对应用内的函数做插桩(排除第三方库)time&#123; threshold = 200 appPackage = 'com.example.plugindemo'&#125; 然后特意定义几个耗时函数： 123456789101112131415161718192021222324252627public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); try &#123; method1(); method2(); method3(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; private static void method1() throws InterruptedException &#123; Thread.sleep(500); &#125; public void method2() throws InterruptedException &#123; Thread.sleep(300); &#125; void method3() throws InterruptedException &#123; Thread.sleep(1000); &#125;&#125; 最后编译运行一下，就会在在控制台打印耗时函数的信息出来： 点击方法行号就可以直接定位到耗时函数处。 Asm官方地址：ASM 官方教程：ASM4-guide(英文版)、ASM4-guide(中文版) Asm是一个通用的Java字节码操作和分析框架, 它提供了一些简单易用的字节码操作方法，可以直接以二进制的形式修改现有类或动态生成类，简单地来说，Asm就是一个字节码操作框架，通过Asm，我们可以凭空生成一个类，或者修改现有的类，Asm相比其他的字节码操作框架如Javasist、AspectJ等的优点就是体积小、性能好、效率高，但它的缺点就是学习成本高，不过现在已经有IntelliJ插件ASM Bytecode Outline可以替我们自动的生成Asm代码，所以对于想要入门Asm的人来说，它还是很简单的，我们只需要简单的学习一下Asm的相关api的含义，在此之前希望你已经对JVM的基础知识：类型描述符、方法描述符、Class文件结构有一定的了解。 Asm中有两类api，一种是基于树模型的tree api，一种是基于访问者模式的visitor api，其中visitor api是Asm最核心和基本的api，所以对于入门者，我们需要知道visitor api的使用，在visitor api中有三个主要的类用于读取、访问和生成class字节码： ClassVisitor： 它是用于访问calss字节码，它里面有很多visitXX方法，每调用一个visitXX方法，就表示你在访问class文件的某个结构，如Method、Field、Annotation等，我们通常会扩展ClassVisitor，利用代理模式，把扩展的ClassVisitor的每一个visitXX方法的调用委托给另外一个ClassVisitor，在委托的前后我们可以添加自己的逻辑从而达到转换、修改这个类的class字节码的目的； ClassReader：它用于读取以字节数组形式给出的class字节码，它有一个accept方法，用于接收一个ClassVisitor实例，accept方法内部会调用ClassVisitor的visitXX方法来访问已读取的class文件； ClassWriter：它继承自ClassVisitor，可以以二进制形式生成class字节码，它有一个toByteArray方法，可以把已生成的二进制形式的class字节码转换成字节数组形式返回. ClassVisitor、ClassReader、ClassWriter这三个之间一般都是需要组合使用的，下面通过一些实际的例子快速掌握，首先我们需要在build.gradle中引入Asm，如下： 12345678dependencies &#123; //核心api，提供visitor api implementation 'org.ow2.asm:asm:7.0' //可选，提供了一些基于核心api的预定义类转换器 implementation 'org.ow2.asm:asm-commons:7.0' //可选，提供了一些基于核心api的工具类 implementation 'org.ow2.asm:asm-util:7.0'&#125; 1、读取、访问一个类读取类之前，首先介绍一下ClassVisitor中的visitXX方法，ClassVisitor的主要结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public abstract class ClassVisitor &#123; //ASM的版本, 版本数值定义在Opcodes接口中，最低为ASM4，目前最新为ASM7 protected final int api; //委托的ClassVisitor，可传空 protected ClassVisitor cv; public ClassVisitor(final int api) &#123; this(api, null); &#125; public ClassVisitor(final int api, final ClassVisitor cv) &#123; //... this.api = api; this.cv = cv; &#125; //表示开始访问这个类 public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; if (cv != null) &#123; cv.visit(version, access, name, signature, superName, interfaces); &#125; &#125; //表示访问这个类的源文件名(如果有的话) public void visitSource(String source, String debug) &#123; if (cv != null) &#123; cv.visitSource(source, debug); &#125; &#125; //表示访问这个类的外部类(如果有的话) public void visitOuterClass(String owner, String name, String desc) &#123; if (cv != null) &#123; cv.visitOuterClass(owner, name, desc); &#125; &#125; //表示访问这个类的注解(如果有的话) public AnnotationVisitor visitAnnotation(String desc, boolean visible) &#123; if (cv != null) &#123; return cv.visitAnnotation(desc, visible); &#125; return null; &#125; //表示访问这个类的内部类(如果有的话) public void visitInnerClass(String name, String outerName, String innerName, int access) &#123; if (cv != null) &#123; cv.visitInnerClass(name, outerName, innerName, access); &#125; &#125; //表示访问这个类的字段(如果有的话) public FieldVisitor visitField(int access, String name, String desc, String signature, Object value) &#123; if (cv != null) &#123; return cv.visitField(access, name, desc, signature, value); &#125; return null; &#125; //表示访问这个类的方法(如果有的话) public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123; if (cv != null) &#123; return cv.visitMethod(access, name, desc, signature, exceptions); &#125; return null; &#125; //表示结束对这个类的访问 public void visitEnd() &#123; if (cv != null) &#123; cv.visitEnd(); &#125; &#125; //...省略了一些其他visitXX方法&#125; 可以看到，ClassVisitor的所有visitXX方法都把逻辑委托给另外一个ClassVisitor的visitorXX方法，我们知道，当一个类被加载进JVM中时，它的class的大概结构如下： 所以把class文件结构和ClassVisitor中的方法做对比，可以发现，ClassVisitor中除了visitEnd方法，其他visitXX方法的访问都对应class文件的某个结构，如字段、方法、属性等，每个visitXX方法的参数都表示字段、方法、属性等的相关信息，例如：access表示修饰符、signature表示泛型、desc表示描述符、name表示名字或全权限定名，我们还注意到有些visitXX方法会返回一个XXVisitor类实例，这些XXVisitor类里面又会有类似的visitXX方法，这表示外部可以继续调用返回的XXVisitor实例的visitXX方法，从而继续访问相应结构中的子结构，这个后面再解释。 知道了ClassVisitor中方法的作用后，我们自定义一个类，使用ClassReader和ClassVisitor把这个类的信息读取、打印出来，首先自定义一个名为OuterClass的类，如下： 123456789101112131415@Deprecatedpublic class OuterClass&#123; private int mData = 1; public OuterClass(int data)&#123; this.mData = data; &#125; public int getData()&#123; return mData; &#125; class InnerClass&#123; &#125;&#125; OuterClass类有注解、字段、方法、内部类，然后再自定义一个名为PrintClassVisitor的类扩展自ClassVisitor，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class PrintClassVisitor extends ClassVisitor implements Opcodes &#123; public ClassPrinter() &#123; super(ASM7); &#125; @Override public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; System.out.println(name + \" extends \" + superName + \"&#123;\"); &#125; @Override public void visitSource(String source, String debug) &#123; System.out.println(\" source name = \" + source); &#125; @Override public void visitOuterClass(String owner, String name, String descriptor) &#123; System.out.println(\" outer class = \" + name); &#125; @Override public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) &#123; System.out.println(\" annotation = \" + descriptor); return null; &#125; @Override public void visitInnerClass(String name, String outerName, String innerName, int access) &#123; System.out.println(\" inner class = \" + name); &#125; @Override public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) &#123; System.out.println(\" field = \" + name); return null; &#125; @Override public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) &#123; System.out.println(\" method = \" + name); return null; &#125; @Override public void visitEnd() &#123; System.out.println(\"&#125;\"); &#125;&#125; 其中Opcodes接口中定义了很多常量，ASM7就是来自Opcodes，在每个visitXX方法把类的相关信息打印出来，最后使用ClassReader读取OuterClass的class字节码，在accept方法中传入ClassVisitor实例，完成对OuterClass的访问，如下： 123456789101112131415161718public static void main(String[] args) throws IOException &#123; //创建ClassVisitor实例 ClassPrinter printClassVisitor = new ClassPrinter(); //从构造传入OuterClass的全权限定名，ClassReader会读取OuterClass字节码为字节数组 ClassReader classReader = new ClassReader(OuterClass.class.getName()); //在ClassReader的accept传入ClassVisitor实例，开启访问，第二个参数表示访问模式，先不用管，传入0 classReader.accept(printClassVisitor, 0);&#125;运行输出：com/example/plugindemo/OuterClass extends java/lang/Object&#123; source name = OuterClass.java annotation = Ljava/lang/Deprecated; inner class = com/example/plugindemo/OuterClass$InnerClass field = mData method = &lt;init&gt; method = getData&#125; ClassReader的构造除了可以接受类的全限定名，还可以接受class文件的输入流，最终都是把class字节码读取到内存中，变成字节数组，ClassReader的accept方法会利用内存偏移量解析构造中读取到的class字节码的字节数组，把class字节码的结构信息从字节数组中解析出来，然后调用传入的ClassVisitor实例的visitorXX方法来访问解析出来的结构信息，而且从运行输出的结果可以看出，accept方法中对于ClassVisitor的visitorXX方法的调用会有一定的顺序，以visit方法开头，以visitEnd方法结束，中间穿插调用其他的visitXX方法，其大概顺序如下： 12345678visit [visitSource] [visitOuterClass] [visitAnnotation][visitInnerClass | visitField | visitMethod]visitEnd//其中[]表示可选，｜表示平级 2、生成一个类前面知道了ClassReader可以用来读取一个类，ClassVisitor可以用来访问一个类，而ClassWirter它可以凭空生成一个类，接下来我们来生成一个名为Person的接口，该接口结构如下： 1234public interface Person &#123; String NAME = \"rain9155\"; int getAge();&#125; 使用ClassWriter生成Person接口的代码如下： 12345678910111213141516171819202122import static org.objectweb.asm.Opcodes.*;public class Main &#123; public static void main(String[] args)&#123; //创建一个ClassWriter，构造传入修改类的行为模式，传0就行 ClassWriter classWriter = new ClassWriter(0); //生成类的头部 classWriter.visit(V1_7, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, \"com/example/plugindemo/Person\", null, \"java/lang/Object\", null); //生成文件名 classWriter.visitSource(\"Person.java\", null); //生成名为NAME，值为rain9155的字段 FieldVisitor fileVisitor = classWriter.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, \"NAME\", \"Ljava/lang/String;\", null, \"rain9155\"); fileVisitor.visitEnd(); //生成名为getAge，返回值为int的方法 MethodVisitor methodVisitor = classWriter.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, \"getAge\", \"()I\", null, null); methodVisitor.visitEnd(); //生成类完毕 classWriter.visitEnd(); //生成的类可以通过toByteArray方法以字节数组形式返回 byte[] bytes = classWriter.toByteArray(); &#125; ClassWirter继承自ClassVisitor，它扩展了ClassVisitor的visitorXX方法，使得它具有生成class字节码的能力，最终toByteArray方法返回的字节数组可以通过ClassLoader动态加载为一个Class对象，由于我这里生成的是一个接口，所以getAge方法没有方法体，所以visitMethod方法返回的MethodVisitor只是简单的调用了visitEnd就完成了getAge方法头的生成，如果需要生成getAge方法的内部逻辑，例如： 123int getAge()&#123; return 1;&#125; 那么在调用MethodVisitor的visitEnd方法之前，还需要调用MethodVisitor的其他visitXX方法来生成方法的内部逻辑，MethodVisitor的visitXX方法就是在模拟的JVM的字节码指令，例如入栈、出栈等，对于visitField方法返回的FieldVisitor和visitAnnotation方法返回的AnnotationVisitor的含义和MethodVisitor类似。 可以看到使用ClassWirter生成一个简单的接口的代码量就如此繁琐，如果这是一个类，并且类中的方法有方法体，代码会更加的复杂，所幸的是我们可以通过ASM Bytecode Outline插件来完成这繁琐的过程，首先你要在你的AS或IntelliJ IDE中安装这个插件，然后在你想要查看的Asm代码的类右键 -&gt; Show Bytecode outline，就会在侧边窗口中显示这个类的字节码(Bytecode)和Asm代码(ASMified)，点击ASMified栏目就会显示这个类的Asm码，例如下图就是Person接口的通过插件生成的Asm代码： 可以看到，使用ClassWriter来生成Person接口。 3、转换一个类ClassReader可以用来读取一个类，ClassVisitor可以用来访问一个类，ClassWirter可以生成一个类，所以当把它们三个组合在一起时，我们可以把class字节码通过ClassReader读取，把读取到的class字节码通过扩展的ClassVisitor转换，转换后，再通过ClassWirter重新生成这个类，就可以达到转换一个类的目的，下面我们把前面的OuterClass类的注解通过转换移除掉，首先自定义一个ClassVisitor，如下： 123456789101112public class RemoveAnnotationClassVisitor extends ClassVisitor implements Opcodes &#123; public RemoveAnnotationClassVisitor(ClassVisitor classVisitor) &#123; super(ASM7, classVisitor); &#125; @Override public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) &#123; //返回null return null; &#125;&#125; 这里我只重写了ClassVisitor的visitAnnotation方法，在visitAnnotation方法中返回null，这样调用者就无法使用返回的AnnotationVisitor生成类的注解，然后使用这个RemoveAnnotationClassVisitor，如下： 123456789101112public static void main(String[] args) throws IOException &#123; //读取OuterClass类的字节码到ClassReader ClassReader classReader = new ClassReader(OuterClass.class.getName()); //定义用于生成类的ClassWriter ClassWriter classWriter = new ClassWriter(0); //把ClassWriter传进RemoveAnnotationClassVisitor的构造中 RemoveAnnotationClassVisitor removeAnnotationClassVisitor = new RemoveAnnotationClassVisitor(classWriter); //在ClassReader的accept方法中传入RemoveAnnotationClassVisitor实例，开启访问 classReader.accept(removeAnnotationClassVisitor, 0); //最终使用ClassWriter的toByteArray方法返回转换后的OuterClass类的字节数组 byte[] bytes = classWriter.toByteArray();&#125; 上面这段代码只是把前面所讲的读取、访问、生成一个类的知识结合在一起，ClassVisitor的构造可以传进一个ClassVisitor，从而代理传进的ClassVisitor，而ClassWriter是继承自ClassVisitor的，所以RemoveAnnotationClassVisitor代理了ClassWriter，RemoveAnnotationClassVisitor把OuterClass转换完后就交给了ClassWriter，最终我们可以通过ClassWriter的toByteArray方法返回转换后的OuterClass类的字节数组。 上面是只有简单的一个ClassVisitor进行转换的代码，如果我们把它扩展，我们还可以定义RemoveMethodClassVisitor、AddFieldClassVisitor等多个具有不同功能的ClassVisitor，然后把所有的ClassVisitor串成一条转换链，把ClassReader想象成头，ClassWriter想象成尾，中间是一系列的ClassVisitor，ClassReader把读取到的class字节码经过一系列的ClassVisitor转换后到达ClassWriter，最终被ClassWriter生成新的class，这个过程如图： Asm的入门知识就讲解到这里，如果想要了解更多关于Asm的知识请查阅开头给出的官方教程，下面我们来学习Transform相关知识。 Transform官网：Transform Transform是android gradle api中的一部分，它可以在android项目的.class文件编译为.dex文件之前，得到所有的.class文件，然后我们可以在Transform中对所有的.class文件进行处理，所以Transform提供了一种可以让我们得到android项目的字节码的能力，如图红色标志的位置为Transform的作用点： 上图就是android打包流程的一部分，而android的打包流程是交给android gradle plugin完成的，所以如果我们想要自定义Transform，必须要注入到android gradle plugin中才能产生效果，而plugin的执行单元是Task，但Transform并不是Task，那么Transform是怎么被执行的呢？android gradle plugin会为每一个Transform创建对应的TransformTask，由相应的TransformTask执行相应的Transform。 接下来我们来介绍Transform，首先我们需要在build.gradle中引入Transform，如下： 1234dependencies &#123; //引用android gradle api, 里面包含transform api implementation 'com.android.tools.build:gradle:4.0.0'&#125; 因为transform api是android gradle api的一部分，所以我们引入android gradle api就行，自定义一个名为MyTransform的Transform，如下： 12345678910111213141516171819202122232425262728293031public class MyTransform extends Transform &#123; @Override public String getName() &#123; //用来生成TransformTask的名称 return \"MyTransform\"; &#125; @Override public Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123; //输入类型 return TransformManager.CONTENT_CLASS; &#125; @Override public Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123; //输入的作用域 return TransformManager.SCOPE_FULL_PROJECT; &#125; @Override public boolean isIncremental() &#123; //是否开启增量编译 return false; &#125; @Override public void transform(TransformInvocation transformInvocation)&#123; //在这里处理class文件 &#125;&#125; Transform是一个抽象类，所以它会强制要求我们实现几个方法，还要重写transform方法，下面分别讲解这几个方法的含义： 1、getName方法前面讲过android gradle plugin会为每一个Transform创建一个对应的TransformTask，而创建的TransformTask的名称一般的格式为transformXX1WithXX2ForXX3，其中XX1是inputType类型，XX2的值就是getName方法的返回值，而XX3的值就是当前构建环境的Build Variants，例如Debug、Release等，所以如果你自定义的的Transform名为MyTransform，Build Variants为Debug，inputType为Class文件，那么该Transform对应的Task名为transformClassesWithMyTransformForDebug。 2、getInputTypes和getScopes方法getInputTypes方法和getScopes方法都返回一个Set集合，其中集合的元素类型分别为ContentType接口和Scope枚举，在Transform中，ContentType表示Transform输入的类型，Scope表示Transform输入的作用域，Transform从ContentType和Scope这两个维度来过滤Transform的输入，某个输入只有同时满足了getInputTypes方法返回的ContentType集合和getScopes方法返回的Scope集合，才会被Transform消费。 在Transform中，主要有两种类型的输入，它们分别为CLASSES和RESOURCES，以实现了ContentType接口的枚举DefaultContentType表示，各枚举含义如下： DefaultContentType 含义 CLASSES 表示在jar或文件夹中的.class文件 RESOURCES 表示标准的java源文件 同理，在Transform中，输入的作用域也以枚举Scope表示，主要有PROJECT、SUB_PROJECTS、EXTERNAL_LIBRARIES、TESTED_CODE、PROVIDED_ONLY这五种作用域，各枚举含义如下： Scope 含义 PROJECT 只处理当前项目 SUB_PROJECTS 只处理当前项目的子项目 EXTERNAL_LIBRARIES 只处理当前项目的外部依赖库 TESTED_CODE 只处理当前项目构建环境的测试代码 PROVIDED_ONLY 只处理当前项目使用provided-only依赖的库 ContentType和Scope都可以分别进行组合，已Set集合的形式返回，在TransformManager类中定义了一些我们常用的组合，我们可以直接使用，如MyTransform的ContentType为CONTENT_CLASS， Scope为SCOPE_FULL_PROJECT，定义如下： 12345678public class TransformManager extends FilterableStreamCollection &#123; public static final Set&lt;ContentType&gt; CONTENT_CLASS = ImmutableSet.of(CLASSES); public static final Set&lt;ScopeType&gt; SCOPE_FULL_PROJECT = ImmutableSet.of(Scope.PROJECT, Scope.SUB_PROJECTS, Scope.EXTERNAL_LIBRARIES); //...还有其他很多组合&#125; 可以看到CONTENT_CLASS由CLASSES组成，SCOPE_FULL_PROJECT由PROJECT、SUB_PROJECTS、EXTERNAL_LIBRARIES组成，所以MyTransform只会处理来自当前项目(包括子项目)和外部依赖库的.class文件输入。 3、isIncremental方法isIncremental方法的返回值表示当前Transform是否支持增量编译，返回true表示支持，其实在Gradle中只有Task才有增量编译这一说，Transform最终会被TransformTask执行，所以Transform是依赖Task来实现增量编译的，Gradle Task通过检测它的输入与输出来实现增量编译：当检测到输入有文件changed时，Gradle判定本次编译为增量编译，Task内部根据changed文件做增量输出，即只对changed文件产生输出；当检测到输入与上一次输入没有发生任何changed时，Gradle判定本次编译UP-TO-DATA，可以跳过执行；当检测到输出被deleted时，Gradle判定本次编译为全量编译，会触发该Task的全量输出，即对所有输入文件产生输出。 当Transform被判定为增量编译后，在transform方法中就可以根据输入文件的Status来处理每个输入的文件产生增量输出，Status也是一个枚举，各枚举含义如下： Status 含义 NOTCHANGED 该文件自上次构建以来没有发生变化 ADDED 该文件为新增文件 CHANGED 该文件自上次构建以来发生变化(被修改) REMOVED 该文件已被删除 开启增量编译可以大大的提高Gradle的构建速度。 注意：如果你的isIncremental方法返回true，那么自定义的Transform的transform方法中必须提供对增量编译的支持，即根据Status来对输入的文件作出处理，否则增量编译是不生效的，这在后面的插件实现中可以看到如何提供对增量编译的支持。 4、transform方法transform方法就是Transform中处理输入的地方，TransformTask执行时就是执行Transform的transform方法，transform方法的参数是TransfromInvocation，它包含的当前Transform的输入和输出信息，可以使用TransfromInvocation的getInputs方法来获取Transform的输入，使用TransformInvocation的getOutputProvider方法来生成Transform的输出，还可以通过TransfromInvocation的isIncremental方法的返回值判断本次transform是否是增量编译。 TransfromInvocation的getInputs方法返回一个元素类型为TransformInput的集合，其中TransformInput可以获取两种类型的输入，如下： 1234567public interface TransformInput &#123; //getJarInputs方法返回JarInput集合 Collection&lt;JarInput&gt; getJarInputs(); //getDirectoryInputs方法返回DirectoryInput集合 Collection&lt;DirectoryInput&gt; getDirectoryInputs();&#125; 两种类型的输入又抽象为JarInput和DirectoryInput，JarInput代表输入为.Jar文件，DirectoryInput代表输入为文件夹类型，JarInput有一个getStatus方法来获取该jar文件的Status，而DirectoryInputgetChangedFiles方法来获取一个Map&lt;File, Status&gt;集合，所以可以遍历这个Map集合，然后根据File对应的Status来对File进行增量处理。 TransfromInvocation的getOutputProvider方法返回一个TransformOutputProvider，它可以用来创建Transform的输出位置，如下： 1234567891011public interface TransformOutputProvider &#123; //删除所有输出 void deleteAll() throws IOException; //根据参数给的name、ContentType、Scope、Format来创建输出位置 File getContentLocation( @NonNull String name, @NonNull Set&lt;QualifiedContent.ContentType&gt; types, @NonNull Set&lt;? super QualifiedContent.Scope&gt; scopes, @NonNull Format format);&#125; 调用getContentLocation方法就可以创建一个输出位置并返回该位置代表的File实例，如果存在就直接返回，通过getContentLocation方法创建的输出位置一般位于/app/build/intermediates/transforms/build variants/transform名称/目录下，其中build variants就是当前的构建环境如debug、release等，Transform名称就是getName方法的返回值，例如在debug构建下MyTransform的输出位置就是/app/build/intermediates/transforms/debug/MyTransform/目录下，该目录下都是Transform输出的jar文件或文件夹，名称是以0、1、2、…递增的命名形式命名，调用deleteAll方法就可以把getContentLocation方法创建的输出位置下的所有文件删除掉。 所以如果不支持增量编译的话，transform方法里面一般会这样写： 123456789101112131415161718192021222324252627282930313233343536public void transform(TransformInvocation transformInvocation) throws IOException &#123; //通过TransformInvocation的getInputs方法获取所有输入，是一个集合，TransformInput代表一个输入 Collection&lt;TransformInput&gt; transformInputs = transformInvocation.getInputs(); //通过TransformInvocation的getOutputProvider方法获取输出的提供者，通过TransformOutputProvider可以创建Transform的输出 TransformOutputProvider outputProvider = transformInvocation.getOutputProvider(); //遍历所有的输入，每一个输入里面包含jar和directory两种输入类型的文件集合 for(TransformInput transformInput : transformInputs)&#123; Collection&lt;JarInput&gt; jarInputs = transformInput.getJarInputs(); //遍历，处理jar文件 for(JarInput jarInput : jarInputs)&#123; File dest = outputProvider.getContentLocation( jarInput.getName(), jarInput.getContentTypes(), jarInput.getScopes(), Format.JAR ); //这里只是简单的把jar文件复制到输出位置 FileUtils.copyFile(jarInput.getFile(), dest); &#125; Collection&lt;DirectoryInput&gt; directoryInputs = transformInput.getDirectoryInputs(); //遍历，处理文件夹 for(DirectoryInput directoryInput : directoryInputs)&#123; File dest = outputProvider.getContentLocation( directoryInput.getName(), directoryInput.getContentTypes(), directoryInput.getScopes(), Format.DIRECTORY ); //这里只是简单的把文件夹中的所有文件递归地复制到输出位置 FileUtils.copyDirectory(directoryInput.getFile(), dest); &#125; &#125; &#125; 就是获取到输入，遍历输入中的所有JarInput和DirectoryInput，然后把相应的输入简单地重定向到输出位置中，在这过程中，我们还可以获取jar文件和文件夹中的class文件，对class文件进行修改后再进行重定向到输出，这就达到了在编译期间修改字节码的目的，这也是后面插件实现的核心。 每一个Transform的输出会作为下一个Transform的输入，这些Transform会被串行执行，如下： 现在对于Asm和Transform都有了一个大概的了解，就可以动手实现函数耗时检测插件。 插件实现检测函数耗时很简单，只需要在每个方法的开头和结尾增加耗时检测的代码逻辑即可，例如： 1234567891011121314151617181920protected void onCreate(Bundle savedInstanceState) &#123; long startTime = System.currentTimeMillis();//start super.onCreate(savedInstanceState); long endTime = System.currentTimeMillis();//end long costTime = endTime - startTime; if(costTime &gt; 100)&#123; StackTraceElement thisMethodStack = (new Exception()).getStackTrace()[0];//获得当前方法的StackTraceElement Log.e(\"TimeCost\", String.format( \"===&gt; %s.%s(%s:%s)方法耗时 %d ms\", thisMethodStack.getClassName(), //类的全限定名称 thisMethodStack.getMethodName(),//方法名 thisMethodStack.getFileName(), //类文件名称 thisMethodStack.getLineNumber(),//行号 costTime //方法耗时 ) ); &#125;&#125; 我们不可能手动的替应用内的每个方法的开头结尾加上上述代码，应用内的方法太多了，所以我们需要Gradle插件替我们完成这重复的过程，在项目编译的过程中，通过Transform拿到项目中每个类的字节码，然后使用Asm对每个类的的每个方法的开头结尾增加上述函数耗时检测的字节码，如果你不知道自定义一个Gradle插件的步骤，请移步上一篇文章，我把Gradle插件的实现代码放在buildSrc目录下，整个项目的目录结构如下： 有关Plugin和Transform实现的代码放在com.example.plugin下，有关Asm实现的代码放在com.example.asm下。 1、自定义Plugin自定义Plugin对应代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class TimeCostPlugin implements Plugin&lt;Project&gt; &#123; //当函数运行时间大于threshold阀值时判定为耗时函数，单位ms public static long sThreshold = 100L; //当package有值时，只打印package包内的耗时函数 public static String sPackage = \"\"; @Override public void apply(Project project) &#123; try &#123; //通过project实例注册一个名为time的扩展 Time time = project.getExtensions().create(\"time\", Time.class); //在project构建完成后获取time扩展中的赋值情况 project.afterEvaluate(project1 -&gt; &#123; if(time.getThreshold() &gt;= 0)&#123; sThreshold = time.getThreshold(); &#125; if(time.getAppPackage().length() &gt; 0)&#123; sPackage = time.getAppPackage(); &#125; &#125;); //通过project实例获取android gradle plugin中的名为android的扩展实例 AppExtension appExtension = (AppExtension) project.getExtensions().getByName(\"android\"); //调用android的扩展实例即appExtension的registerTransform方法往android gradle plugin中注册我们自定义的Transform appExtension.registerTransform(new TimeCostTransform()); &#125;catch (UnknownDomainObjectException e)&#123; e.printStackTrace(); &#125; &#125; /** * 扩展对应的bean类 */ static class Time&#123; private long mThreshold = -1; private String mPackage = \"\"; public Time()&#123;&#125; public long getThreshold() &#123; return mThreshold; &#125; public void setThreshold(long threshold) &#123; this.mThreshold = threshold; &#125; public String getAppPackage() &#123; return mPackage; &#125; public void setAppPackage(String p) &#123; this.mPackage = p; &#125; &#125;&#125; TimeCostPlugin做了两件事： 1、定义了一个名为time的扩展，扩展对应的bean类为Time类，通过这个扩展我们可以在build.gradle中配置我们的插件，在这里我定义了函数耗时阀值threshold和通过package过滤打印的函数，然后我们在app/build.gradle中就可以这样使用： 123456apply plugin: com.example.plugin.TimeCostPlugin//函数耗时阀值为200ms，只对应用内的函数做插桩(排除第三方库)time&#123; threshold = 200 filter = 'com.example.plugindemo'&#125; 扩展属性的赋值情况要在project构建完毕后才能获取，所以注册了project的afterEvaluate回调，在里面获取time扩展属性的赋值情况。 2、把我们自定义的Transform注入到android gradle plugin中去，android gradle plugin的名为android的扩展对应的bean类为AppExtension类，AppExtension中有一个元素类型为Transform的List集合，我们调用registerTransform方法就是把TimeCostTransform放入到这个集合中，这个Transform集合会在android gradle plugin中被使用，android gradle plugin也注册了project的afterEvaluate回调，在回调中它会为每个Transform生成TransformTask. 2、自定义Transform自定义Transform对应部分代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class TimeCostTransform extends Transform &#123; private static final String TAG = TimeCostTransform.class.getSimpleName();//类名 @Override public String getName() &#123; return TAG; &#125; @Override public Set&lt;QualifiedContent.ContentType&gt; getInputTypes() &#123; return TransformManager.CONTENT_CLASS; &#125; @Override public Set&lt;? super QualifiedContent.Scope&gt; getScopes() &#123; return TransformManager.SCOPE_FULL_PROJECT; &#125; @Override public boolean isIncremental() &#123; return true; &#125; @Override public void transform(TransformInvocation transformInvocation) throws IOException &#123; System.out.println(\"transform(), ---------------------------start------------------------------\"); Collection&lt;TransformInput&gt; transformInputs = transformInvocation.getInputs(); TransformOutputProvider outputProvider = transformInvocation.getOutputProvider(); //通过TransformInvocation的isIncremental方法判断本次Transform任务是否是增量，如果Transform的isIncremental方法返回false，TransformInvocation的isIncremental方法永远返回false boolean isIncremental = transformInvocation.isIncremental(); System.out.println(\"transform(), isIncremental = \" + isIncremental); //如果不是增量，就删除之前所有产生的输出，重头来过 if(!isIncremental)&#123; outputProvider.deleteAll(); &#125; //遍历所有的输入，每一个输入里面包含jar和directory两种输入类型的文件集合 for(TransformInput transformInput : transformInputs)&#123; Collection&lt;JarInput&gt; jarInputs = transformInput.getJarInputs(); //遍历所有的jar文件输入 for(JarInput jarInput : jarInputs)&#123; //判断本次Transform任务是否增量 if(isIncremental)&#123; //增量处理Jar文件 handleJarIncremental(jarInput, outputProvider); &#125;else &#123; //非增量处理Jar文件 handleJar(jarInput, outputProvider); &#125; &#125; Collection&lt;DirectoryInput&gt; directoryInputs = transformInput.getDirectoryInputs(); //遍历所有的directory文件输入 for(DirectoryInput directoryInput : directoryInputs)&#123; //判断本次Transform任务是否增量 if(isIncremental)&#123; //增量处理目录文件 handleDirectoryIncremental(directoryInput, outputProvider); &#125;else &#123; //非增量处理目录文件 handleDirectory(directoryInput, outputProvider); &#125; &#125; &#125; System.out.println(\"transform(), ---------------------------end------------------------------\"); &#125; //... &#125; 根据前面Transform的讲解，TimeCostTransform中每个方法的含义应该是比较好理解的了，其中最重要的就是transform方法，由于我在isIncremental方法返回了true表示TimeCostTransform支持增量编译，所以就需要在transform方法中需要根据是否是增量编译分别做出全量处理和增量处理，由于jar文件的处理和directory文件的处理雷同，下面就以jar文件的处理为例讲解，对于directory文件的处理可以查看文末源码链接： 1、handleJar方法，全量处理jar文件输入，产生新的输出： 1234567891011121314private void handleJar(JarInput jarInput, TransformOutputProvider outputProvider) throws IOException &#123; //获取输入的jar文件 File srcJar = jarInput.getFile(); //使用TransformOutputProvider的getContentLocation方法根据输入构造输出位置 File destJar = outputProvider.getContentLocation( jarInput.getName(), jarInput.getContentTypes(), jarInput.getScopes(), Format.JAR ); //遍历srcJar的所有内容, 在遍历的过程中把srcJar中的内容一条一条地复制到destJar //如果发现这个内容条目是class文件，就把它通过asm修改后再复制到destJar中 foreachJarWithTransform(srcJar, destJar);&#125; handleJar方法中确定输入输出然后调用foreachJarWithTransform方法，如下： 12345678910111213141516171819202122232425262728293031private void foreachJarWithTransform(File srcJar, File destJar) throws IOException &#123; try( JarFile srcJarFile = new JarFile(srcJar); JarOutputStream destJarFileOs = new JarOutputStream(new FileOutputStream(destJar)) )&#123; Enumeration&lt;JarEntry&gt; enumeration = srcJarFile.entries(); //遍历srcJar中的每一条条目 while (enumeration.hasMoreElements())&#123; JarEntry entry = enumeration.nextElement(); try( //获取每一条条目的输入流 InputStream entryIs = srcJarFile.getInputStream(entry) )&#123; destJarFileOs.putNextEntry(new JarEntry(entry.getName())); if(entry.getName().endsWith(\".class\"))&#123;//如果是class文件 //通过asm修改源class文件 ClassReader classReader = new ClassReader(entryIs); ClassWriter classWriter = new ClassWriter(0); TimeCostClassVisitor timeCostClassVisitor = new TimeCostClassVisitor(classWriter); classReader.accept(timeCostClassVisitor, ClassReader.EXPAND_FRAMES); //然后把修改后的class文件复制到destJar中 destJarFileOs.write(classWriter.toByteArray()); &#125;else &#123;//如果不是class文件 //原封不动地复制到destJar中 destJarFileOs.write(IOUtils.toByteArray(entryIs)); &#125; destJarFileOs.closeEntry(); &#125; &#125; &#125;&#125; 由于该输入是jar文件，而jar文件本质是一个zip文件，所以foreachJarWithTransform中就像在解压这个jar文件，然后遍历解压后的jar文件中的所有文件，通过后缀名判断该文件是否是.class文件，如果是.class文件就通过asm处理后输出，如果不是就是原封不动地复制到输出中去，逻辑还是很简单的，关于asm的处理在后面再讲。 2、handleJarIncremental方法, 增量处理jar文件输入, 可能产生新的输出： 12345678910111213141516171819private void handleJarIncremental(JarInput jarInput, TransformOutputProvider outputProvider) throws IOException &#123; //获取输入文件的状态 Status status = jarInput.getStatus(); //根据文件的Status做出不同的操作 switch (status)&#123; case ADDED: case CHANGED: handleJar(jarInput, outputProvider); break; case REMOVED: //删除所有输出 outputProvider.deleteAll(); break; case NOTCHANGED: //do nothing break; default: &#125;&#125; 理解了前面handleJar方法的全量处理，那么handleJarIncremental方法中的增量处理就很好理解了，其实就是根据输入的jar文件的Status来做出不同处理，对于ADDED和CHANGED都判定为changed文件，只对changed文件做处理，所以直接调用handleJar方法处理就行，对于REMOVED表示输入被删除了，那么就删除对应的输出，对于NOTCHANGED表示输入没有变化，不做处理，跳过。 3、asm处理class文件前面transform方法中当判定为某个文件为class文件后就使用asm处理class文件，如下： 123456789if(entry.getName().endsWith(\".class\"))&#123;//如果是class文件 //通过asm修改源class文件 ClassReader classReader = new ClassReader(entryIs); ClassWriter classWriter = new ClassWriter(0); TimeCostClassVisitor timeCostClassVisitor = new TimeCostClassVisitor(classWriter); classReader.accept(timeCostClassVisitor, ClassReader.EXPAND_FRAMES); //然后把修改后的class文件复制到destJar中 destJarFileOs.write(classWriter.toByteArray());&#125; 根据前面asm的讲解，这是使用asm转换一个类的步骤，首先使用ClassReader读取这个class文件，然后调用ClassReader的accept方法使用TimeCostClassVisitor开启对class文件的访问，最终通过ClassWriter的toByteArray方法获取转换后的class字节流，所以对class文件修改的逻辑都在TimeCostClassVisitor中，如下： 12345678910111213141516171819202122232425262728293031323334353637public class TimeCostClassVisitor extends ClassVisitor implements Opcodes &#123; private String mPackage;//包名 private String mCurClassName;//当前访问的类的全限定名 private boolean isExcludeOtherPackage;//是否排除不属于package的类 public TimeCostClassVisitor(ClassVisitor classVisitor) &#123; super(ASM7, classVisitor); mPackage = TimeCostPlugin.sPackage; if(mPackage.length() &gt; 0)&#123; mPackage = mPackage.replace(\".\", \"/\"); &#125; isExcludeOtherPackage = mPackage.length() &gt; 0; &#125; @Override public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) &#123; super.visit(version, access, name, signature, superName, interfaces); mCurClassName = name; &#125; @Override public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) &#123; MethodVisitor methodVisitor = super.visitMethod(access, name, descriptor, signature, exceptions); if(isExcludeOtherPackage)&#123; //如果该方法对应的类在package中就处理 if(mCurClassName.startsWith(mPackage) &amp;&amp; !\"&lt;init&gt;\".equals(name))&#123; return new TimeCostMethodVisitor(methodVisitor, access, descriptor); &#125; &#125;else &#123; if(!\"&lt;init&gt;\".equals(name))&#123; return new TimeCostMethodVisitor(methodVisitor, access, descriptor); &#125; &#125; return methodVisitor; &#125;&#125; TimeCostClassVisitor继承自ClassVisitor，因为我们只需要修改class文件中的方法，所以只重写了ClassVisitor的visit方法和visitMethod方法，其中visit方法中获取了当前访问的类的全限定名，它在visitMethod方法中与TimeCostPlugin扩展获取的package包名结合判定这个类的方法是否需要被过滤掉，如果这个类不属于package中的类，那么就不对这个类的class文件的方法做修改，跳过，如果这个类属于package中的类，就返回TimeCostMethodVisitor，在TimeCostMethodVisitor中修改class文件的方法，所以对于class文件中方法的修改的逻辑都在TimeCostMethodVisitor中，如下： 1234567891011121314151617181920212223242526272829303132333435363738class TimeCostMethodVisitor extends LocalVariablesSorter implements Opcodes &#123; //局部变量 int startTime, endTime, costTime, thisMethodStack; public TimeCostMethodVisitor(MethodVisitor methodVisitor, int access, String desc) &#123; super(ASM7, access, desc, methodVisitor); &#125; @Override public void visitCode() &#123; super.visitCode(); //...方法开头 //long startTime = System.currentTimeMillis(); &#125; @Override public void visitInsn(int opcode) &#123; if(opcode == RETURN)&#123; //...方法结尾 //long endTime = System.currentTimeMillis(); //long costTime = endTime - startTime; //if(costTime &gt; 100)&#123; // StackTraceElement thisMethodStack = (new Exception()).getStackTrace()[0];//获得当前方法的StackTraceElement // Log.e(\"TimeCost\", String.format( // \"===&gt; %s.%s(%s:%s)方法耗时 %d ms\", // thisMethodStack.getClassName(), //类的全限定名称 // thisMethodStack.getMethodName(),//方法名 // thisMethodStack.getFileName(), //类文件名称 // thisMethodStack.getLineNumber(),//行号 // costTime //方法耗时 // ) // ); //&#125; &#125; super.visitInsn(opcode); &#125;&#125; 我们需要做的就是在方法前后插入函数耗时检测逻辑的代码，而visitCode方法是开始生成方法字节码的时候调用，即方法开始时调用，而visitInsn方法在访问RETURN指令时就是表示访问到方法的return语句，即方法正常结束时调用，所以我们只需要在上述地方加入函数耗时检测逻辑的asm代码即可，asm会自动的替我们把asm代码转换为字节码，这样最终生成的方法字节码就会包含我们的函数耗时检测逻辑的字节码，TimeCostMethodVisitor继承自LocalVariablesSorter，而LocalVariablesSorter继承自MethodVisitor，LocalVariablesSorter扩展了MethodVisitor，使得我们很方便的在MethodVisitor的visitXX方法中通过asm代码使用局部变量，如：startTime、 endTime、 costTime、thisMethodStack。 那么我们可以通过前面介绍的ASM插件生成函数耗时检测的asm代码，如下： 由于生成的asm代码篇幅太长截图不完全，去除onCreate方法头、结尾和super.onCreate(savedInstanceState)这句代码的asm代码，剩下的就属于函数耗时检测逻辑的asm代码，我做了一些精简，把一些无用的visitLabel、visitLineNumber去掉，然后把它复制到TimeCostMethodVisitor中，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293class TimeCostMethodVisitor extends LocalVariablesSorter implements Opcodes &#123; //局部变量 int startTime, endTime, costTime, thisMethodStack; public TimeCostMethodVisitor(MethodVisitor methodVisitor, int access, String desc) &#123; super(ASM7, access, desc, methodVisitor); &#125; @Override public void visitCode() &#123; super.visitCode(); //long startTime = System.currentTimeMillis(); mv.visitMethodInsn(INVOKESTATIC, \"java/lang/System\", \"currentTimeMillis\", \"()J\", false); startTime = newLocal(Type.LONG_TYPE); mv.visitVarInsn(LSTORE, startTime); &#125; @Override public void visitInsn(int opcode) &#123; if(opcode == RETURN)&#123; //long endTime = System.currentTimeMillis(); mv.visitMethodInsn(INVOKESTATIC, \"java/lang/System\", \"currentTimeMillis\", \"()J\", false); endTime = newLocal(Type.LONG_TYPE); mv.visitVarInsn(LSTORE, endTime); //long costTime = endTime - startTime; mv.visitVarInsn(LLOAD, endTime); mv.visitVarInsn(LLOAD, startTime); mv.visitInsn(LSUB); costTime = newLocal(Type.LONG_TYPE); mv.visitVarInsn(LSTORE, costTime); //判断costTime是否大于sThreshold mv.visitVarInsn(LLOAD, costTime); mv.visitLdcInsn(new Long(TimeCostPlugin.sThreshold));//阀值由TimeCostPlugin的扩展属性threshold控制 mv.visitInsn(LCMP); //if costTime &lt;= sThreshold,就跳到end标记处，否则继续往下执行 Label end = new Label(); mv.visitJumpInsn(IFLE, end); //StackTraceElement thisMethodStack = (new Exception()).getStackTrace()[0] mv.visitTypeInsn(NEW, \"java/lang/Exception\"); mv.visitInsn(DUP); mv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Exception\", \"&lt;init&gt;\", \"()V\", false); mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Exception\", \"getStackTrace\", \"()[Ljava/lang/StackTraceElement;\", false); mv.visitInsn(ICONST_0); mv.visitInsn(AALOAD); thisMethodStack = newLocal(Type.getType(StackTraceElement.class)); mv.visitVarInsn(ASTORE, thisMethodStack); //Log.e(\"rain\", String.format（\"===&gt; %s.%s(%s:%s)方法耗时 %d ms\", thisMethodStack.getClassName(), thisMethodStack.getMethodName(),thisMethodStack.getFileName(),thisMethodStack.getLineNumber(),costTime)); mv.visitLdcInsn(\"TimeCost\"); mv.visitLdcInsn(\"===&gt; %s.%s(%s:%s)\\u65b9\\u6cd5\\u8017\\u65f6 %d ms\"); mv.visitInsn(ICONST_5); mv.visitTypeInsn(ANEWARRAY, \"java/lang/Object\"); mv.visitInsn(DUP); mv.visitInsn(ICONST_0); mv.visitVarInsn(ALOAD, thisMethodStack); mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/StackTraceElement\", \"getClassName\", \"()Ljava/lang/String;\", false); mv.visitInsn(AASTORE); mv.visitInsn(DUP); mv.visitInsn(ICONST_1); mv.visitVarInsn(ALOAD, thisMethodStack); mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/StackTraceElement\", \"getMethodName\", \"()Ljava/lang/String;\", false); mv.visitInsn(AASTORE); mv.visitInsn(DUP); mv.visitInsn(ICONST_2); mv.visitVarInsn(ALOAD, thisMethodStack); mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/StackTraceElement\", \"getFileName\", \"()Ljava/lang/String;\", false); mv.visitInsn(AASTORE); mv.visitInsn(DUP); mv.visitInsn(ICONST_3); mv.visitVarInsn(ALOAD, thisMethodStack); mv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/StackTraceElement\", \"getLineNumber\", \"()I\", false); mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Integer\", \"valueOf\", \"(I)Ljava/lang/Integer;\", false); mv.visitInsn(AASTORE); mv.visitInsn(DUP); mv.visitInsn(ICONST_4); mv.visitVarInsn(LLOAD, costTime); mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Long\", \"valueOf\", \"(J)Ljava/lang/Long;\", false); mv.visitInsn(AASTORE); mv.visitMethodInsn(INVOKESTATIC, \"java/lang/String\", \"format\", \"(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;\", false); mv.visitMethodInsn(INVOKESTATIC, \"android/util/Log\", \"e\", \"(Ljava/lang/String;Ljava/lang/String;)I\", false); mv.visitInsn(POP); //end标记处，即方法的末尾 mv.visitLabel(end); &#125; super.visitInsn(opcode); &#125;&#125; 上面每一句注释都表示了注释下面asm代码的含义，对于局部变量使用了LocalVariablesSorter的newLocal方法生成，其实如果你仔细观察生成的asm代码，它们还是很有规律的，使用MethodVisitor的visitXX方法生成方法字节码时它们的调用顺序如下（忽略注解注释）： 123456[visitCode][visitLabel | visitLineNumber | visitFrame | visitXXInsn | visitLocalVariable | visitTryCatchBlock][visitMax]visitEnd//其中[]表示可选，｜表示平级 与ClassVisitor类似，但以visitCode开头，表示开始生成方法体字节码，中间调用visitLabel、visitXXInsn等生成方法体字节码，然后以一个visitMax结尾，最终一定要调用一个visitEnd结束，如果这个方法没有方法体，那么调用一个visitEnd就行。 到这里这个函数耗时检测插件就完成了，使用方法就和平时使用gradle插件一样。 结语这个gradle插件还是很简陋，还可以继续扩展它，例如耗时阀值支持ns、发现耗时函数时把函数的调用栈打印出来等，不过本文的目的还是主要学习自定义个gradle插件的过程，还有asm和transform知识， 其实android gradle api从3.6开始很多apk打包时用到的内置transform基本都变成了直接使用Task来实现，如DesugarTransform -&gt; DesugarTask, MergeClassesTransform -&gt; MergeClassesTask等，可能是为了提高构建效率，这也说明了transform本质是依赖task来完成的，它只是android gradle api提供给外部，方便外部操作字节码的工具，同时android gradle api中也有很多apk构建时用的的插件，如AppPlugin、LibrayPlugin等，我们编写gradle插件时也可以选择一个作为参考。 以上就是本文的全部内容！ 本文源码地址 参考资料： Android Gradle Plugin打包Apk过程中的Transform API 一起玩转Android项目中的字节码 一文读懂 AOP Android Gradle Plugin 主要流程分析","tags":[{"name":"gradle","slug":"gradle","permalink":"http://yoursite.com/tags/gradle/"},{"name":"asm","slug":"asm","permalink":"http://yoursite.com/tags/asm/"},{"name":"aop","slug":"aop","permalink":"http://yoursite.com/tags/aop/"}]},{"title":"Gradle的快速入门学习","date":"2020-06-26T14:36:22.000Z","path":"2020/06/26/Gradle的快速入门学习/","text":"前言Gradle是一个灵活和高效自动化构建工具，它的构建脚本采用Groovy或kotlin语言编写，Groovy或Kotlin都是基于JVM的语言，它们的语法和java的语法有很多的类似并且兼容java的语法，所以对于java开发者，只需很少的学习成本就能快速上手Gradle开发，同时Gradle也是Android官方的构建工具，学习Gradle，能够帮助我们更好的了解Android项目的构建过程，当项目构建出现问题时，我们也能更好的排查问题，所以Gradle的学习能帮助我们更好的管理Android项目，Gradle的官方地址如下： Gradle官网 Github地址 Gradle的特点1、Gradle构建脚本采用Groovy或Kotlin语言编写，如果采用Groovy编写，构建脚本后缀为.gradle，在里面可以使用Groovy语法，如果采用Kotlin编写，构建脚本后缀为.gradle.kts，在里面可以使用Kotlin语法； 2、因为Groovy或Kotlin都是面向对象语言，所以在Gradle中处处皆对象，Gradle的.gradle或.gradle.kts脚本本质上是一个Project对象，在脚本中一些带名字的配置项如buildscript、allprojects等本质上就是对象中的方法，而配置项后面的闭包{}就是参数，所以我们在使用这个配置项时本质上是在调用对象中的一个方法； 3、在Groovy或Kotlin中，函数和类一样都是一等公民，它们都提供了很好的闭包{}支持，所以它们很容易的编写出具有DSL风格的代码，用DSL编写构建脚本的Gradle比其他采用xml编写构建脚本的构建工具如maven、Ant等的可读性更强，动态性更好，整体更简洁； 4、Gradle中主要有Project和Task对象，Project是Gradle中构建脚本的表示，一个构建脚本对应一个Project对象，Task是Gradle中最小的执行单元，它表示一个独立的任务，Project为Task提供了执行的上下文。 Groovy基础入门本文的所有示例都是采用Groovy语言编写，在阅读本文前先简单的入门Groovy： Groovy 使用完全解析 下面主要讲Groovy与java的主要区别： 1、Groovy语句后面的分号可以忽略 1234567int num1 = 1int num2 = 2int result = add(num1, num2)int add(int a, int b)&#123; return a + b&#125; 2、Groovy支持动态类型推导，使用def来定义变量和方法时可以不指定变量的类型和方法的返回值类型，同时定义方法时参数可以不指定类型 1234567def num1 = 1def num2 = 2def result = add(num1, num2)def add(a, b)&#123; return a + b&#125; 3、Groovy的方法调用传参时可以不添加括号，方法不指定return语句时，最后一行默认为返回值 12345def result = add 1, 2def add(a, b)&#123; a + b&#125; 4、Groovy可以用单、双、三引号来表示字符串，其中单引号表示普通字符串，双引号表示的字符串可以使用取值运算符${}，而$在单引号只只是表示一个普通的字符，三引号表示的字符串又称为模版字符串，它可以保留文本的换行和缩进格式，三引号同样不支持$ 123456789101112def world = 'world'def str1 = 'hello $&#123;world&#125;'def str2 = \"hello $&#123;world&#125;\"def str3 = '''hello&amp;&#123;world&#125;'''//打印输出：//hello $&#123;world&#125;//hello world//hello//&amp;&#123;world&#125; 5、Groovy会为类中每个没有可见性修饰符的字段生成get/set方法，我们访问这个字段其实是调用它的get/set方法，同时如果类中的方法以get/set开头，我们也可以像普通字段一样访问这个方法 12345678910111213141516171819class Person&#123; def name private def country def setNation(nation)&#123; this.country = nation &#125; def getNation()&#123; return country &#125;&#125;def person = new Person()//访问字段person.name = 'rain9155'println person.name//像字段一样访问这个以get/set开头的方法person.nation = \"china\"println person.nation 6、Groovy中的闭包是用{参数列表 -&gt; 代码体}表示的代码块，当参数 &lt;= 1个时，-&gt;箭头可以省略，同时当只有一个参数时，如果不指定参数名默认以it为参数名，在Groovy中闭包对应的类型是Closure，所以闭包可以作为参数传递，同时闭包有一个delegate字段, 通过delegate可以把闭包中的执行代码委托给任意对象来执行 1234567891011121314151617181920class Person&#123; def name def age&#125;def person = new Person()//定义一个闭包def closure = &#123; name = 'rain9155' age = 21&#125;//把闭包委托给person对象执行closure.delegate = person//执行闭包，或者调用closure.call()也可以执行闭包closure()//以上代码把闭包委托给person对象执行，所以闭包就执行时就处于person对象上下文//所以闭包就可以访问到person对象中的name和age字段，完成赋值println person.name//输出：rain9155println person.age//输出：21 在Gradle中很多地方都使用了闭包的委托机制，通过闭包完成一些特定对象的配置，在Gradle中，如果你没有指定闭包的delegate，delegate默认为当前项目的Project对象。 以上Groovy知识，认为对于有java基础的人来说，用于学习Gradle足够了，当然对于一些集合操作、文件操作等，等以后使用到时可以到Groovy官网来查漏补缺。 Gradle的安装配置官方教程：Installing Gradle 安装Gradle前需要确保你的电脑已经配置好JDK，JDK的版本要求是8或更高，可以通过包管理器自动安装Gradle或手动下载Gradle安装两种方式，在Window平台下我推荐使用手动安装，在Mac平台下我推荐使用Homebrew包管理器自动安装： 1、Window平台 1、在Gradle的安装页面选择一个Gradle版本，下载它的binary-only或complete版本，binary-only版本表示下载的Gradle压缩包只包含Gradle的源码，complete版本表示下载的Gradle压缩包包含Gradle的源码和源码文档说明，这里我下载了gradle-6.5-bin版本； 2、下载好Gradle后，把它解压到特定目录，如我这里解压到：D:/gradle，然后像配置java环境一样把D:/gradle/gradle-6.5/bin路径添加到系统的PATH变量下； 3、打开cmd，输入gradle -v校验是否配置成功，输出以下类似信息则配置成功. 1234567891011121314C:\\Users\\HY&gt;gradle -v------------------------------------------------------------Gradle 6.5------------------------------------------------------------Build time: 2020-06-02 20:46:21 UTCRevision: a27f41e4ae5e8a41ab9b19f8dd6d86d7b384dad4Kotlin: 1.3.72Groovy: 2.5.11Ant: Apache Ant(TM) version 1.10.7 compiled on September 1 2019JVM: 10.0.2 (\"Oracle Corporation\" 10.0.2+13)OS: Windows 10 10.0 amd64 2、Mac平台 1、安装Homebrew； 2、打开终端，输入brew install gradle，它默认会下载安装binary-only版本; 3、当Homebrew安装Gradle完成后，在终端输入gradle -v校验是否安装成功. Gradle的项目结构Gradle项目可以使用Android Studio、IntelliJ IDEA等IDE工具或文本编辑器来编写，这里我以Mac平台为例采用文本编辑器配合命令行来编写，Window平台类似。 新建一个目录，如我这里为：～/GradleDemo，打开命令行，输入cd ~/GradleDemo切换到这个目录，然后输入gradle init，接着gradle会执行init这个task任务，它会让你选择生成的项目模版、编写脚本的语言、项目名称等，我选择了basic模版(即原始的Gradle项目)、Groovy语言、项目名称为GradleDemo，如下： 这样会init任务就会自动替你生成相应的项目模版，如下： 忽略掉以.开头的隐藏文件或目录，gradle init为我们自动生成了以下文件或目录： 1、build.gradle它表示Gradle的项目构建脚本，在里面我们可以通过Groovy来编写脚本，在Gradle中，一个build.gradle就对应一个项目，build.gradle放在Gradle项目的根目录下，表示它对应的是根项目，build.gradle放在Gradle项目的其他子目录下，表示它对应的是子项目，Gradle构建时会为每一个build.gradle创建一个对应的Project对象，这样编写build.gradle时就可以使用Project接口中的方法。 2、settings.gradle它表示Gradle的多项目配置脚本，存放在Gradle项目的根目录下，在里面可以通过include来决定哪些子项目会参与构建，Gradle构建时会为settings.gradle创建一个对应的Settings对象，include也只是Settings接口中的一个方法。 3、Gradle Wrappergradle init执行时会同时执行wrapper任务，wrapper任务会创建gradle/wrapper目录，并创建gradle/wrapper目录下的gradle-wrapper.jar、gradle-wrapper.properties这两个文件，还同时创建gradlew、gradlew.bat这两个脚本，它们统称为Gradle Wrapper，是对Gradle的一层包装。 Gradle Wrapper的作用就是可以让你的电脑在不安装配置Gradle环境的前提下运行Gradle项目，例如当你的Gradle项目被用户A clone下来时，而用户A的电脑上没有安装配置Gradle环境，用户A通过Gradle构建项目时，Gradle Wrapper就会从指定下载位置下载Gradle，并解压到电脑的指定位置，然后用户A就可以在不配置Gradle系统变量的前提下在Gradle项目的命令行中运行gradlew或gradlew.bat脚本来使用gradle命令，假设用户A要运行gradle -v命令，在linux平台下只需要运行./gradlew -v，在window平台下只需要运行gradlew -v，只是把gradle替换成gradlew。 Gradle Wrapper的每个文件含义如下： 1、gradlew：用于在linux平台下执行gradle命令的脚本； 2、gradlew.bat：用于在window平台下执行gradle命令的脚本； 3、gradle-wrapper.jar：包含Gradle Wrapper运行时的逻辑代码； 4、gradle-wrapper.properties：用于指定Gradle的下载位置和解压位置； gradle-wrapper.properties中各个字段解释如下： 字段名 解释 distributionBase 下载的Gradle的压缩包解压后的主目录，为GRADLE_USER_HOME，在window中它表示C:/用户/你电脑登录的用户名/.gradle/，在mac中它表示～/.gradle/ distributionPath 相对于distributionBase的解压后的Gradle的路径，为wrapper/dists distributionUrl Grade压缩包的下载地址，在这里可以修改下载的Gradle的版本和版本类型(binary或complete)，例如gradle-6.5-all.zip表示Gradle 6.5的complete版本，gradle-6.5-bin.zip表示Gradle 6.5的binary版本 zipStoreBase 同distributionBase，不过是表示存放下载的Gradle的压缩包的主目录 zipStorePath 同distributionPath，不过是表示存放下载的Gradle的压缩包的路径 使用Gradle Wrapper后，就可以统一项目在不同用户电脑上的Gradle版本，同时不必让运行这个Gradle项目的人安装配置Gradle环境，提高了开发效率。 Gradle的多项目配置现在我们创建的Gradle项目默认已经有一个根项目了，它的build.gradle文件就处于Gradle项目的根目录下，如果我们想要添加多个子项目，这时就需要通过settings.gradle进行配置。 首先我们在GradleDemo中创建多个文件夹，这里我创建了4个文件夹，分别为：subproject_1、subproject_2，subproject_3，subproject_4，然后在每个新建的文件夹下创建build.gradle文件，如下： 接着打开settings.gradle，添加如下： 1include ':subproject_1', ':subproject_2', ':subproject_3', ':subproject_4' 这样就完成了子项目的添加，打开命令行，切换到GradleDemo目录处，输入gradle projects，执行projects任务展示所有项目之间的依赖关系，如下： 123456789101112# in ~/GradleDemo $ gradle projects &gt; Task :projectsRoot project 'GradleDemo'+--- Project ':subproject_1'+--- Project ':subproject_2'+--- Project ':subproject_3'\\--- Project ':subproject_4'BUILD SUCCESSFUL in 540ms1 actionable task: 1 executed 可以看到，4个子项目依赖于根项目，接下来我们来配置项目，配置项目一般在当前项目的build.gradle中进行，可以通过buildscript方法、repositories方法、dependencies方法等Project接口提供的方法进行配置，但是如果有多个项目时，而每个项目的某些配置又一样，那么在每个项目的build.gradle进行相同的配置是很浪费时间，而Gradle的Project接口为我们提供了allprojects和subprojects方法，在根项目的build.gradle中使用这两个方法可以全局的为所有子项目进行配置，allprojects和subprojects的区别是：allprojects的配置包括根项目而subprojects的配置不包括根项目，例如: 123456789101112//根项目的build.gradle//为所有项目添加maven repo地址allprojects &#123; repositories &#123; mavenCentral() &#125;&#125;//为所有子项目添加groovy插件subprojects &#123; apply plugin: 'groovy'&#125; Gradle构建的生命周期当在命令行输入gradle build构建整个项目或gradle task名称执行某个任务时就会进行Gradle的构建，它的构建过程分为3个阶段： init(初始化阶段) -&gt; configure(配置阶段) -&gt; execute(执行阶段) init：初始化阶段主要是解析settings.gradle，生成Settings对象，确定哪些项目需要参与构建，为需要构建的项目创建Project对象； configure：配置阶段主要是解析build.gradle，配置init阶段生成的Project对象，构建根项目和所有子项目，同时生成和配置在build.gradle中定义的Task对象，构造Task的关系依赖图，关系依赖图是一个有向无环图； execute：根据configure阶段的关系依赖图执行Task. Gradle在上面3个阶段中每一个阶段的开始和结束都会hook一些监听，暴露给开发者使用，方便开发者在Gradle的不同生命周期阶段做一些事情。 settings.gradle和build.gradle分别代表Settings对象和Project对象，它们都有一个Gradle对象，我们可以在Gradle项目根目录的settings.gradle或build.gradle中获取到Gradle对象，然后进行生命周期监听，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//build.gradle或settings.gradlethis.gradle.buildStarted &#123; println \"Gradle构建开始\"&#125;//---------------------init开始--------------------------------this.gradle.settingsEvaluated &#123; println \"settings.gradle解析完成\"&#125;this.gradle.projectsLoaded &#123; println \"所有项目从settings加载完成\"&#125;//---------------------init结束-------------------------------- //-------------------configure开始-----------------------------this.gradle.beforeProject &#123;project -&gt; //每一个项目构建之前被调用 println \"$&#123;project.name&#125;项目开始构建\"&#125;this.gradle.afterProject &#123;project -&gt; //每一个项目构建完成被调用 println \"$&#123;project.name&#125;项目构建完成\"&#125;this.gradle.projectsEvaluated &#123; println \"所有项目构建完成\"&#125;this.gradle.taskGraph.whenReady &#123; println(\"task图构建完成\")&#125;//-------------------configure结束-----------------------------//-------------------execute开始-----------------------------this.gradle.taskGraph.beforeTask &#123;task -&gt; //每个task开始执行时会调用这个方法 println(\"$&#123;task.name&#125;task开始执行\")&#125;this.gradle.taskGraph.afterTask &#123;task -&gt; //每个task执行结束时会调用这个方法 println(\"$&#123;task.name&#125;task执行完成\")&#125;//-------------------execute结束-----------------------------this.gradle.buildFinished &#123; println \"Gradle构建结束\"&#125; 上面监听方法的放置顺序就是整个Gradle构建的顺序，但是要注意的是Gradle的buildStarted方法永远不会被回调，因为我们注册监听的时机太晚了，当解析settings.gradle或build.gradle时，Gradle就已经构建开始了，所以这个方法也被Gradle标记为废弃的了，因为我们没有机会监听到Gradle构建开始，同时如果你是在build.gradle中添加上面的所有监听，那么Gradle的settingsEvaluated和projectsLoaded方法也不会被回调，因为settings.gradle的解析是在build.gradle之前，在build.gradle中监听这两个方法的时机也太晚了。 也可以通过Gradle对象的addBuildListener方法添加BuildListener来监听Gradle的整个生命周期回调 上面是监听整个Gradle构建的生命周期回调监听，那么我怎么监听我的当前单个项目的构建开始和结束呢？只需要在你当前项目的build.gradle中添加： 12345678//build.gradlethis.beforeEvaluate &#123; println '项目开始构建'&#125;this.afterEvaluate &#123; println '项目构建结束'&#125; 但是要注意的是在根项目的build.gradle添加上述方法，其beforeEvaluate方法是无法被回调的，因为注册时机太晚，解析根项目的build.gradle时根项目已经开始构建了，但是子项目的build.gradle添加上述方法是可以监听到项目构建的开始和结束，因为根项目构建完成后才会轮到子项目的构建。 Task1、Task的创建Task是Gradle中最小执行单元，它是一个接口，默认实现类为DefaultTask，在Project中提供了task方法来创建Task，所以Task的创建必须要处于Project上下文中，这里我在subproject_1/build.gradle中创建Task，如下： 1234567891011//subproject_1/build.gradle//通过Project的task方法创建一个Tasktask task1&#123; doFirst&#123; println 'one' &#125; doLast&#123; println 'two' &#125;&#125; 上述代码通过task方法创建了一个名为task1的Task，在创建Task的同时可以通过闭包配置它的doFirst和doLast动作，doFirst和doLast都是Task中的方法，其中doFirst方法会在Task的action执行前执行，doLast方法会在Task的action执行后执行，而action就是Task的执行单元，在后面自定义Task会介绍到，除此之外还可以在创建Task之后再指定它的doFirst和doLast动作，如下： 12345678910//subproject_1/build.gradle//通过Project的task方法创建一个Taskdef t = task task2t.doFirst &#123; println 'one'&#125;t.doLast&#123; println 'two'&#125; 上面通过Project的task方法创建的Task默认被放在Project的TaskContainer类型的容器中，我们可以通过Project的getTasks方法获取到这个容器，而TaskContainer提供了create方法来创建Task，如下： 1234567891011//subproject_1/build.gradle//通过TaskContainer的create方法创建一个Tasktasks.create(name: 'task3')&#123; doFirst&#123; println 'one' &#125; doLast&#123; println 'two' &#125;&#125; 以上就是创建Task最常用的几种方式，创建Task之后，就可以执行它，执行一个Task只需要把task名称接在gradle命令后，如下我在命令行输入gradle task1执行了task1: 123456789# in ~/GradleDemo $ gradle task1 &gt; Task :subproject_1:task1onetwoBUILD SUCCESSFUL in 463ms1 actionable task: 1 executed 如果你想精简输出的信息，只需要添加-q参数，如：gradle -q task1，这样输出就只包含task1的输出： 1234# in ~/GradleDemo $ gradle -q task1onetwo 如果要执行多个Task，多个task名称接在gradle命令后用空格隔开就行，如：gradle task1 task2 task3。 2、Task的属性配置Gradle为每个Task定义了默认的属性(Property)， 比如description、group、dependsOn、inputs、outputs等, 我们可以配置这些Property，如下配置Task的描述和分组： 123456789101112//subproject_2/build.gradle//我们可以在定义Task时对这些Property进行赋值task task1&#123; group = 'MyGroup' description = 'Hello World' doLast&#123; println \"task分组：$&#123;group&#125;\" println \"task描述：$&#123;description&#125;\" &#125;&#125; Gradle在执行一个Task之前，会先配置这个Task的Property，然后再执行这个Task的执行代码块，所以配置Task的代码块放在哪里都无所谓，如下： 1234567891011121314151617181920212223242526272829303132333435//subproject_2/build.gradle//在定义Task之后才对Task进行配置task task2&#123; doLast&#123; println \"task分组：$&#123;group&#125;\" println \"task描述：$&#123;description&#125;\" &#125;&#125;task2&#123; group = 'MyGroup' description = 'Hello World'&#125;//等效于task2task task3&#123; doLast&#123; println \"task分组：$&#123;group&#125;\" println \"task描述：$&#123;description&#125;\" &#125;&#125;task3.description = 'Hello World!'task3.group = \"MyGroup\"//等效于task3task task4&#123; doLast&#123; println \"task分组：$&#123;group&#125;\" println \"task描述：$&#123;description&#125;\" &#125;&#125;task4.configure&#123; group = 'MyGroup' description = 'Hello World'&#125; 我们可以通过Task的dependsOn属性指定Task之间的依赖关系，如下： 1234567891011//subproject_2/build.gradle//创建Task时通过dependsOn声明Task之间的依赖关系task task5(dependsOn: task4)&#123; doLast&#123; println 'Hello World' &#125;&#125;//或者在创建Task之后再声明task之间的依赖关系task4.dependsOn task3 上述的依赖关系是task3 -&gt; task4 -&gt; task5，依赖的Task先执行，所以当我在命令行输入gradle task5执行task5时，输出： 1234567891011121314151617# in ~/GradleDemo $ gradle task5 &gt; Task :subproject_2:task3task分组：MyGrouptask描述：Hello World!&gt; Task :subproject_2:task4task分组：MyGrouptask描述：Hello World&gt; Task :subproject_2:task5Hello Worldtask5task执行完成BUILD SUCCESSFUL in 2s3 actionable tasks: 3 executed 依次执行task3、 task4 、task5。 3、自定义Task前面创建的Task默认都是DefaultTask类型，我们可以通过继承DefaultTask来自定义Task类型，Gradle中也内置了很多具有特定功能的Task，它们都间接继承自DefaultTask，如Copy(复制文件)、Delete(文件清理)等，我们可以直接在build.gradle中自定义Task，如下： 12345678910111213141516//subproject_3/build.gradleclass MyTask extends DefaultTask&#123; def message = 'hello world from myCustomTask' @TaskAction def println1()&#123; println \"println1: $message\" &#125; @TaskAction def println2()&#123; println \"println2: $message\" &#125;&#125; 在MyTask中，通过@TaskAction注解的方法就是该Task的action，action是Task最主要的组成，它表示Task的一个执行动作，当Task中有多个action时，多个action的执行顺序按照@TaskAction注解的方法放置的逆顺序，所以执行一个Task的过程就是：doFirst方法 -&gt; action方法 -&gt; doLast方法，在MyTask中定义了两个action，接下来我们使用这个Task，如下： 123456//subproject_3/build.gradle//在定义Task时通过type指定Task的类型task myTask(type: MyTask)&#123; message = 'custom message'&#125; 在定义Task时通过type指定Task的类型，同时还可以通过闭包配置MyTask中的message参数，在命令行输入gradle myTask执行这个Task，如下： 123456789# in ~/GradleDemo $ gradle myTask &gt; Task :subproject_3:myTaskprintln2: custom messageprintln1: custom messageBUILD SUCCESSFUL in 611ms1 actionable task: 1 executed 我们自定义的Task本质上就是一个类，除了直接在build.gradle文件中编写自定义Task，还可以在Gradle项目的根目录下新建一个buildSrc目录，在buildSrc/src/main/[java/kotlin/groovy]目录中定义编写自定义Task，可以采用java、kotlin、groovy三种语句之一，或者在一个独立的项目中编写自定义Task然后发布到远程仓库托管平台，在后面自定义Plugin时会讲到这几种方式。 4、让Task支持增量式构建上述我们自定义的Task每次执行时，它的action都会被执行，进行全量构建，其实Gradle支持增量式构建的Task，增量式构建就是当Task的输入和输出没有变化时，跳过action的执行，当Task输入或输出发生变化时，在action中只对发生变化的输入或输出进行处理，这样就可以避免一个没有变化的Task被反复构建，还有当Task发生变化时只处理变化部分，这样就会提高整个Gradle的构建效率，大大缩短整个Gradle的构建时间，所以当我们编写复杂的Task时，让Task支持增量式构建是很有必要的，让Task支持增量式构建只需要做到两步： 1、让Task的inputs和outputs参与Gradle的Up-to-date检查； 2、让Task的action支持增量式构建; 下面我们通过这两步自定义一个简单的、支持增量式构建的Copy任务，这个Copy任务的作用是把输入的文件复制到输出的位置中： 首先我们要让Copy任务的inputs和outputs参与Gradle的Up-to-date检查，每一个Task都有inputs和outputs属性，它们的类型分别为TaskInputs和TaskOutputs，Task的inputs和outputs主要有以下三种类型： 可序列化类型：可序列化类型是指实现了Serializable的类或者一些基本类型如int、string等； 文件类型：文件类型是指标准的java.io.File或者Gradle衍生的文件类型如FileCollection、FileSystemLocation等； 自定义类型：自定义类型是指自己定义的类，这个类含有Task的部分输入和输出属性，或者说任务的部分输入和输出属性嵌套在这个类中. 我们可以在自定义Task时通过注解指定Task的inputs和outputs，通过注解指定的inputs和outputs会参与Gradle的Up-to-date检查，它是编写增量式Task的前提，Up-to-date检查是指Gradle每次执行Task前都会检查Task的输入和输出，如果一个Task的输入和输出自上一次构建以来没有发生变化，Gradle就判定这个Task是可以跳过执行的，这时你就会看到Task构建旁边会有一个UP-TO-DATE文本，Gradle提供了很多注解让我们指定Task的inputs和outputs，常用的如下： 注解 对应的类型 含义 @Input 可序列化类型 指单个输入可序列化的值，如基本类型int、string或者实现了Serializable的类 @InputFile 文件类型 指单个输入文件，不表示文件夹，如File、RegularFile等 @InputDirectory 文件类型 指单个输入文件夹，不表示文件，如File、Directory等 @InputFiles 文件类型 指多个输入的文件或文件夹，如FileCollection、FileTree等 @OutputFile 文件类型 指单个输出文件，不表示文件夹，如File、RegularFile等 @OutputDirectory 文件类型 指单个输出文件夹，不表示文件，如File、Directory等 @OutputFiles 文件类型 指多个输出的文件，如FileCollection、Map&lt;String, File&gt;等 @OutputDirectories 文件类型 指多个输出的文件夹，如FileCollection、Map&lt;String, File&gt;等 @Nested 自定义类型 指一种自定义的类，这个类它可能没有实现Serializable，但这个类里面至少有一个属性使用本表中的一个注解标记，即这个类会含有Task的输入或输出 @Internal 任何类型 它可以用在可序列化类型、文件类型、还有自定义类型上，它指该属性只在Task的内部使用，即不是Task的输入也不是Task的输出，通过@Internal注解的属性不参与Up-to-date检查 @Optional 任何类型 它可以用在可序列化类型、文件类型、还有自定义类型上，它指该属性是可选的，通过@Optional注解的属性可以不为它赋值，关闭校验 @Incremental Provider&lt;FileSystemLocation&gt; 或者 FileCollection 它和@InputFiles或@InputDirectory一起使用，它用来指示Gradle跟踪文件属性的更改，通过@Incremental注解的文件属性可以通过InputChanges的getFileChanges方法查询文件的更改，帮助实现增量构建Task @SkipWhenEmpty 文件类型 它和@InputFiles或@InputDirectory一起使用，它用来告诉Gradle如果相应的文件或文件夹为空就跳过该Task，通过@SkipWhenEmpty注解的所有输入属性如果都为空，就会导致Gradle跳过这个Task，从而在控制台产出一个NO-SOURCE输出结果 我们自定义Task时可以使用表中的注解来指定输入和输出，其中@InputXX是用来指定输入属性，@OuputXX是用来指定输出属性，@Nested是用来指定自定义类，这个类里面至少含有一个使用@InputXX或@OuputXX指定的属性，而@Internal和@Optional是可以用来指定输入或输出的，最后的@Incremental和@SkipWhenEmpty是用来与@InputFiles或@InputDirectory一起使用的，用于支持增量式构建任务，后面会讲，还有一点要注意的是这些注解只有声明在属性的get方法中才有效果，前面讲过groovy的字段默认都生成了get/set方法，而如果你是用java自定义Task的，要记得声明在属性的get方法中，我们来看Copy任务的实现，如下： 1234567891011121314151617181920212223242526272829303132333435//subproject_3/build.gradleclass CopyTask extends DefaultTask&#123; //使用@InputFiles注解指定输入 @InputFiles FileCollection from //使用@OutputDirectory注解指定输出 @OutputDirectory Directory to //复制过程：把from的文件复制到to文件夹 @TaskAction void execute()&#123; File file = from.getSingleFile() if(file.isDirectory())&#123; from.getAsFileTree().each &#123; copyFileToDir(it, to) &#125; &#125;else&#123; copyFileToDir(from, to) &#125; &#125; private static void copyFileToDir(File src, Directory dir)&#123; File dest = new File(\"$&#123;dir.getAsFile().path&#125;/$&#123;src.name&#125;\") if(!dest.exists())&#123; dest.createNewFile() &#125; dest.withOutputStream &#123; it.write(new FileInputStream(src).getBytes()) &#125; &#125;&#125; 这里Copy任务只使用了@InputFiles和@OutputDirectory，通过@InputFiles指定Copy任务复制的来源文件，通过@OutputDirectory指定Copy任务复制的目标文件夹，然后在action方法中执行复制步骤，然后我们来使用这个Copy任务，如下： 123456//subproject_3/build.gradletask copyTask(type: CopyTask)&#123; from = files('from') to = layout.projectDirectory.dir('to')&#125; 为了使用这个Copy任务，我在subproject_3目录下创建了一个from文件夹，里面只有一个名为text1.txt的文本文件，然后把from文件夹指定为Copy任务的输入，to文件夹指定为Copy任务的输出，在命令行输入gradle copyTask执行这个Task，如下： 1234567# in ~/GradleDemo $ gradle copyTask&gt; Task :subproject_3:copyTaskBUILD SUCCESSFUL in 2s1 actionable task: 1 executed 任务执行成功后就可以把from文件夹中的文件复制到to文件夹，此时文件结构如下： 123456subproject_3|_ build.gradle|_ from| |_ text1.txt |_ to |_ text1.txt 接着我们再次在命令行输入gradle copyTask执行这个Task，如下： 1234567# in ~/GradleDemo $ gradle copyTask&gt; Task :subproject_3:copyTask UP-TO-DATEBUILD SUCCESSFUL in 634ms1 actionable task: 1 up-to-date 再次执行时由于Copy任务的输入和输出都没有变化，所以Gradle判定为UP-TO-DATE，跳过执行。 目前Copy任务已经支持Up-to-date检查，但还不支持增量构建，即如果此时我们往from文件夹新增一个text2.txt文件，由于Copy任务的输入发生变化，这时重新执行Copy任务时就会重新执行action方法，进行全量构建，把text1.txt、text2.txt文件复制到to文件夹中，你会发现text1.txt被重复复制了，我们希望的是每次from中新增或修改文件时，只对新增或修改的文件进行复制，而之前没有变化的文件不进行复制，所以要做到这一步，还要让Task的action方法支持增量构建，要让Task的action方法支持增量式构建，只需要让action方法带一个InputChanges类型的参数就可以，带InputChanges类型参数的action方法表示这是一个增量任务操作方法，该参数告诉Gradle，该action方法仅需要处理更改的输入，此外，Task还需要通过使用@Incremental或@SkipWhenEmpty来指定至少一个增量文件输入属性，我们继续看Copy任务的实现，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//subproject_3/build.gradleclass CopyTask extends DefaultTask&#123; //新增@Incremental注解 @Incremental @InputFiles FileCollection from @OutputDirectory Directory to // @TaskAction // void execute()&#123; // File file = from.getSingleFile() // if(file.isDirectory())&#123; // from.getAsFileTree().each &#123; // copyFileToDir(it, to) // &#125; // &#125;else&#123; // copyFileToDir(from, to) // &#125; // &#125; //带有InputChanges类型参数的action方法 @TaskAction void executeIncremental(InputChanges inputChanges) &#123; println \"execute: isIncremental = $&#123;inputChanges.isIncremental()&#125;\" inputChanges.getFileChanges(from).each &#123;change -&gt; if(change.fileType != FileType.DIRECTORY)&#123; println \"changeType = $&#123;change.changeType&#125;, changeFile = $&#123;change.file.name&#125;\" if(change.changeType != ChangeType.REMOVED)&#123; copyFileToDir(change.file, to) &#125; &#125; &#125; &#125; private static void copyFileToDir(File src, Directory dir)&#123; File dest = new File(\"$&#123;dir.getAsFile().path&#125;/$&#123;src.name&#125;\") if(!dest.exists())&#123; dest.createNewFile() &#125; dest.withOutputStream &#123; it.write(new FileInputStream(src).getBytes()) &#125; &#125;&#125; Copy任务中通过@Incremental指定了需要增量处理的输入，然后在action方法中通过InputChanges进行增量复制文件，我们可以通过InputChanges的getFileChanges方法获取变化的文件，该方法接收一个FileCollection类型的参数，传入的参数必须要通过@Incremental或@SkipWhenEmpty注解，getFileChanges方法返回的是一个FileChange列表，FileChange持有变化的文件File、文件类型FileType和文件的变化类型ChangeType，这样我们就可以根据变化的文件、ChangeType、FileType进行增量输出，ChangeType有三种取值： ADDED：表示这个文件是新增的； MODIFIED：表示这个文件被修改了； REMOVED：表示这个文件被删除了. 同时并不是每次执行都是增量构建，我们可以通过InputChanges的isIncremental方法判断本次构建是否是增量构建，当处于以下情况时，Task会以非增量形式即全量执行： 该Task是第一次执行； 该Task只有输入没有输出； 该Task的upToDateWhen条件返回了false； 自上次构建以来，该Task的某个输出文件已更改; 自上次构建以来，该Task的某个属性输入发生了变化，例如一些基本类型的属性； 自上次构建以来，该Task的某个非增量文件输入发生了变化，非增量文件输入是指没有使用@Incremental或@SkipWhenEmpty注解的文件输入. 当Task处于非增量构建时，即InputChanges的isIncremental方法返回false时，通过InputChanges的getFileChanges方法能获取到所有的输入文件，并且每个文件的ChangeType都为ADDED，当Task处于增量构建时，即InputChanges的isIncremental方法返回true时，通过InputChanges的getFileChanges方法能获取到只发生变化的输入文件。 接下来让我们在上面的基础下执行Copy任务，在命令行输入gradle copyTask执行这个Task，如下： 123456789# in ~/GradleDemo $ gradle copyTask&gt; Task :subproject_3:copyTaskexecute: isIncremental = falsechangeType = ADDED, changeFile = text1.txtBUILD SUCCESSFUL in 22s1 actionable task: 1 executed 可以看到第一次执行Task，以非增量方式执行，把from/text1.txt文件复制到了to文件夹，接下来，我们在from文件夹下新增text2.txt、text3.text，然后再次在命令行输入gradle copyTask执行Copy任务，如下： 12345678910# in ~/GradleDemo $ gradle copyTask&gt; Task :subproject_3:copyTaskexecute: isIncremental = truechangeType = ADDED, changeFile = text2.txtchangeType = ADDED, changeFile = text3.txtBUILD SUCCESSFUL in 2s1 actionable task: 1 executed 可以看到当我们新增文件后第二次执行Task，以增量方式执行，只把新增的text2.txt、 text3.txt复制到to文件夹，而text1.txt没有被重复复制，此时文件结构如下： 12345678910subproject_3|_ build.gradle|_ from| |_ text1.txt | |_ text2.txt| |_ text3.txt|_ to |_ text1.txt |_ text2.txt |_ text3.txt 接下来我们把text1.txt修改在里面添加一行hello world，然后再次在命令行输入gradle copyTask执行Copy任务，如下： 123456789# in ~/GradleDemo $ gradle copyTask&gt; Task :subproject_3:copyTaskexecute: isIncremental = truechangeType = MODIFIED, changeFile = text1.txtBUILD SUCCESSFUL in 2s1 actionable task: 1 executed 可以看到当我们修改文件后第三次执行Task，以增量方式执行，只把修改的text1.txt复制到to文件夹，而其他文件没有被重复复制，接下来我们把to文件夹里的text1.txt删除，然后再次在命令行输入gradle copyTask执行Copy任务，如下： 1234567891011# in ~/GradleDemo $ gradle copyTask&gt; Task :subproject_3:copyTaskexecute: isIncremental = falsechangeType = ADDED, changeFile = text1.txtchangeType = ADDED, changeFile = text2.txtchangeType = ADDED, changeFile = text3.txtBUILD SUCCESSFUL in 2s1 actionable task: 1 executed 可以看到当我们删除某个输出文件后第四次执行Task，以非增量方式执行，把from文件夹下的文件重新复制到to文件夹，并且所有的文件状态都是ADDED，此时如果我们不做任何操作，再次在命令行输入gradle copyTask执行Copy任务会输出UP-TO-DATE。 到现在我们就实现了一个支持增量式构建的Copy任务，通过Gradle提供的注解和InputChanges，我们很容易就自定义一个支持增量构建的Task，当你编写的Task支持增量构建后，你还可以考虑更进一步，让你的Task的支持延迟配置 - Lazy Configuration，这是Gradle提供的对属性的一种状态管理，就不在本文展开了。 自定义PluginPlugin可以理解为一系列Task的集合，通过实现Plugin接口的apply方法就可以自定义Plugin，自定义的Plugin本质上也是一个类，所以和Task类似，在Gradle中也提供了3种方式来编写自定义Plugin： 1、在build.gradle中直接编写：可以在任何一个build.gradle文件中编写自定义Plugin，此方式自定义的Plugin只对该build.gradle对应的项目可见； 2、在buildSrc目录下编写：可以在Gradle项目根目录的buildSrc/src/main/[java/kotlin/groovy]目录中编写自定义Plugin，可以采用java、kotlin、groovy三种语句之一，Gradle在构建时会自动的编译buildSrc/src/main/[java/kotlin/groovy]目录下的所有类文件为class文件，供本项目所有的build.gradle引用，所以此方式自定义的Plugin只对本Gradle项目可见； 3、在独立项目中编写：可以新建一个Gradle项目，在该Gradle项目中编写自定义Plugin，然后把Plugin源码打包成jar，发布到maven、lvy等托管平台上，这样其他项目就可以引用该插件，所以此方式自定义的Plugin对所有Gradle项目可见. 由于在上面自定义Task的介绍中已经讲过了如何在build.gradle中直接编写，自定义Plugin也类似，所以下面就主要介绍2、3两种方式，而且这两种方式也是平时开发中自定义Plugin最常用的方式。 1、在buildSrc目录下编写在GradleDemo中新建一个buildSrc目录，然后在buildSrc目录新建src/main/groovy目录，如果你要使用java或kotlin，则新建src/main/java或src/main/kotlin，src/main/groovy目录下你还可以继续创建package，这里我的package为com.example.plugin，然后在该package下新建一个类MyPlugin.groovy，该类继承自Plugin接口，如下： 1234class MyPlugin implements Plugin&lt;Project&gt;&#123; @Override void apply(Project project)&#123;&#125;&#125; 现在MyPlugin中没有任何逻辑，我们平时是在build.gradle中通过apply plugin: ‘Plugin名’来引用一个Plugin，而apply plugin中的apply就是指apply方法中的逻辑，而apply方法的参数project指的就是引用该Plugin的build.gradle对应的Project对象，接下来我们让我们在apply方法中编写逻辑，如下： 123456789101112131415161718192021222324252627282930313233package com.example.pluginimport org.gradle.api.*class MyPlugin implements Plugin&lt;Project&gt;&#123; @Override void apply(Project project)&#123; //通过project的ExtensionContainer的create方法创建一个名为outerExt的扩展，扩展对应的类为OuterExt OuterExt outerExt = project.extensions.create('outerExt', OuterExt.class) //通过project的task方法创建一个名为showExt的Task project.task('showExt')&#123; doLast&#123; //使用OuterExt实例 println \"outerExt = $&#123;outerExt&#125;\" &#125; &#125; &#125; /** * 自定义插件的扩展对应的类 */ static class OuterExt&#123; String message @Override String toString()&#123; return \"[message = $&#123;message&#125;]\" &#125; &#125;&#125; 上述我在apply方法中创建了一个扩展和一个Task，其中Task好理解，那么扩展是什么？我们平时引用android插件时，一定见过这样类似于android这样的命名空间，如下： 1234567apply plugin: 'com.android.application'android &#123; compileSdkVersion 29 buildToolsVersion \"29.0.3\" //...&#125; 它并不是一个名为android的方法，它而是android插件中名为android的扩展，该扩展对应一个bean类，该bean类中有compileSdkVersion、buildToolsVersion等方法，所以配置android就是在配置andorid对应的bean类，现在回到我们的MyPlugin中，MyPlugin也定义了一个bean类：OuterExt，该bean类有messag字段，Groovy会自动为我们生成messag的get/set方法，而apply方法中通过project实例的ExtensionContainer的create方法创建一个名为outerExt的扩展，扩展对应的bean类为OuterExt，扩展的名字可以随便起，其中ExtensionContainer类似于TaskContainer，它也是Project中的一个容器，这个容器存放Project中所有的扩展，通过ExtensionContainer的create方法可以创建一个扩展，create方法返回的是扩展对应的类的实例，这样我们使用MyPlugin就可以这样使用，如下： 12345678910//subproject_4/build.gradleapply plugin: com.example.plugin.MyPluginouterExt &#123; message 'hello'&#125;//执行gradle showExt, 输出://outerExt = [message = hello] 扩展的特点就是可以通过闭包来配置扩展对应的类，这样就可以通过扩展outerExt来配置我们的Plugin，很多自定义Plugin都是都通过添加扩展这种方式来配置自定义的Plugin，很多人就问了，那么类似于android的嵌套DSL如何实现，如下： 1234567891011121314apply plugin: 'com.android.application'android &#123; compileSdkVersion 29 buildToolsVersion \"29.0.3\" defaultConfig &#123; applicationId \"com.example.myapplication\" minSdkVersion 16 targetSdkVersion 29 //... &#125; //...&#125; android{}中有嵌套了一个defaultConfig{}，但是defaultConfig并不是一个扩展，而是一个名为defaultConfig的方法，参数为Action类型，它是一个接口，里面只有一个execute方法，这里就我参考android 插件的内部实现实现了嵌套DSL，嵌套DSL可以简单的理解为扩展对应的类中再定义一个类，MyPlugin的实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.example.pluginimport org.gradle.api.*import org.gradle.api.model.* //新引入import javax.inject.Inject //新引入class MyPlugin implements Plugin&lt;Project&gt;&#123; @Override void apply(Project project)&#123; OuterExt outerExt = project.extensions.create('outerExt', OuterExt.class) project.task('showExt')&#123; doLast&#123; //使用OuterExt实例和InnerExt实例 println \"outerExt = $&#123;outerExt&#125;, innerExt = $&#123;outerExt.innerExt&#125;\" &#125; &#125; &#125; static abstract class OuterExt&#123; String message //嵌套类 InnerExt innerExt //定义一个使用@Inject注解的、抽象的获取ObjectFactory实例的get方法 @Inject abstract ObjectFactory getObjectFactory() OuterExt()&#123; //通过ObjectFactory的newInstance方法创建嵌套类innerExt实例 this.innerExt = getObjectFactory().newInstance(InnerExt.class) &#125; //定义一个方法，方法名为可以随意起，方法的参数类型为Action，泛型类型为嵌套类InnerExt void inner(Action&lt;InnerExt&gt; action)&#123; //调用Action的execute方法，传入InnerExt实例 action.execute(innerExt) &#125; @Override String toString()&#123; return \"[message = $&#123;message&#125;]\" &#125; static class InnerExt&#123; String message @Override String toString()&#123; return \"[message = $message]\" &#125; &#125; &#125;&#125; 使用MyPlugin就可以这样使用，如下： 123456789101112131415//subproject_4/build.gradleapply plugin: com.example.plugin.MyPluginouterExt &#123; message 'hello' //使用inner方法 inner&#123; message 'word' &#125;&#125;//执行gradle showExt, 输出://outerExt = [message = hello], innerExt = [message = word] outerExt {}中嵌套了inner{}，其中inner是一个方法，参数类型为Action，Gradle内部会把inner方法后面的闭包配置给InnerExt类，这是Gradle中的一种转换机制，总的来说，定义嵌套DSL的大概步骤如下： 1、定义嵌套的DSL对应的bean类，如这里为InnerExt； 2、定义一个使用@Inject注解的、抽象的获取ObjectFactory实例的get方法，或者定义一个使用@Inject注解的带ObjectFactory类型参数的构造，@Inject是javax包下的，ObjectFactory是属于Gradle的model包下的类，当Gradle实例化OuterExt时，它会自动注入通过@Inject注解的实例，例如这里就自动注入了ObjectFactory实例，需要注意的是通过@Inject注解的方法或构造必须是public的； 3、在构造中通过ObjectFactory对象的newInstance方法来创建bean类实例，通过ObjectFactory实例化的对象可以被闭包配置； 4、定义一个方法，该方法的参数类型为Action，泛型类型为嵌套的DSL对应的bean类，方法名随便起，如这里为inner，然后在方法中调用Action的execute方法，传入bean类实例. 上面4步就是定义嵌套DSL时需要在自定义Plugin中做的事，还有一点要注意的是，对于扩展对应的bean类，如果你把它定义在自定义的Plugin的类文件中，一定要用static修饰，如这里的OuterExt类、InnerExt类使用了static修饰，或者把它们定义在单独的类文件中。 除了以上这种为单个对象配置的方式，Gradle还为我们提供了更为灵活地对多个相同类型对象进行配置的方式，又名命名对象容器，它类似于android中buildType{}, 如下： 1234567891011android &#123; //... buildTypes &#123; release &#123; //.. &#125; debug &#123; //... &#125; &#125;&#125; 上面buildTypes中定义了2个命名空间，分别为：release、debug，每个命名空间都会生成一个BuildType配置，在不同的场景下使用，并且我还可以根据使用场景定义更多的命名空间如：test、testDebug等，buildTypes{}中的命名空间的数量不定、名字不定，这是因为buildTypes是通过NamedDomainObjectContainer容器实现的，下面在前面的基础上实现OuterExt对应的命名对象容器： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.example.pluginimport org.gradle.api.*import org.gradle.api.model.*import javax.inject.Injectclass MyPlugin implements Plugin&lt;Project&gt;&#123; @Override void apply(Project project)&#123; //通过project的ObjectFactory的domainObjectContainer方法创建OuterExt的Container实例 NamedDomainObjectContainer&lt;OuterExt&gt; outerExtContainer = project.objects.domainObjectContainer(OuterExt.class) //然后再通过project的ExtensionContainer的add方法添加名称和OuterExt的Container实例的映射 project.extensions.add('outerExts', outerExtContainer) //通过project的task方法创建一个名为showExts的Task project.task('showExts')&#123; doLast&#123; //遍历OuterExt的Container实例，逐个输出配置的值 outerExtContainer.each&#123;ext -&gt; println \"$&#123;ext.name&#125;: outerExt = $&#123;ext&#125;, innerExt = $&#123;ext.innerExt&#125;\" &#125; &#125; &#125; &#125; static abstract class OuterExt&#123; String message InnerExt innerExt @Inject abstract ObjectFactory getObjectFactory() //NamedDomainObjectContainer要求它的元素必须要有一个只可读的、名为name的常量字符串 private final String name //只可读的name表示name要私有的，并且提供一个get方法，name的值在构造函数中注入 String getName()&#123; return this.name &#125; //通过@Inject注解带有String类型参数的构造 @Inject OuterExt(String name)&#123; //在构造中为name赋值 this.name = name this.innerExt = getObjectFactory().newInstance(InnerExt.class) &#125; void inner(Action&lt;InnerExt&gt; action)&#123; action.execute(innerExt) &#125; @Override String toString()&#123; return \"[message = $&#123;message&#125;]\" &#125; static class InnerExt&#123; String message @Override String toString()&#123; return \"[message = $&#123;message&#125;]\" &#125; &#125; &#125;&#125; 使用MyPlugin就可以这样使用，如下： 12345678910111213141516171819202122232425262728//subproject_4/build.gradleapply plugin: com.example.plugin.MyPluginouterExts&#123; //定义名为ext1的命名空间 ext1&#123; message 'hello' inner&#123; message 'word' &#125; &#125; //定义名为ext2的命名空间 ext2&#123; message 'hello' inner&#123; message 'word' &#125; &#125;&#125;//执行gradle showExts, 输出://ext1: outerExt = [message = hello], innerExt = [message = word]//ext2: outerExt = [message = hello], innerExt = [message = word] outerExts可以想象为一个容器，然后容器的元素就是OuterExt，放进容器中的元素都要有一个名字，这个名字是任意的，上面我们通过DSL在outerExts扩展中配置了两个OuterExt，一个名为ext1，一个名为ext2，然后我们在Plugin中就可以通过遍历outerExts获取每个元素对应的配置，所以总的来说，定义命名对象容器作为扩展的大概步骤如下： 1、首先要确定NamedDomainObjectContainer容器的元素类型，如我这里为OuterExt类，容器中的每个元素必须要有一个只可读的、名为name的常量字符串，然后提供一个使用@Inject注解的带有String类型参数的构造，在构造中为name赋值，这个name就对应你在DSL中填写的命名，如我这里为ext1、ext2，当我们在DSL中添加命名空间时，其实就是在往容器中添加元素，这时Gradle会自动调用元素带有String类型参数的构造来实例化它，并在构造中传入命名字符串； 2、通过Project的getObjects方法获取ObjectFactory实例，调用ObjectFactory的domainObjectContainer方法创建容器实例，前面讲过通过ObjectFactory实例化的对象可以被闭包配置，如我这里创建的容器为NamedDomainObjectContainer&lt;OuterExt&gt;； 3、然后再通过Project的getExtensions方法获取ExtensionContainer实例，调用ExtensionContainer的add方法添加扩展名和容器实例的映射，如我这里添加了名为outerExts的扩展，扩展对应的类为NamedDomainObjectContainer&lt;OuterExt&gt;. 上面3步就是定义命名对象容器作为扩展时需要在自定义Plugin中做的事，1、2步骤是如何定义一个命名对象容器，2步骤是把命名对象容器添加为一个扩展，但是往往命名对象容器只是作为某个扩展中的一个嵌套DSL，而不是直接作为扩展，这时我们只需要结合前面讲过的定义扩展步骤、定义嵌套DSL步骤和这里的1、2步骤就行，这时我们就可以实现下面的DSL写法： 123456789101112131415 //扩展outerExt&#123; message 'hello' //通过命名对象容器配置 exts&#123; ext1&#123; message 'word' &#125; ext2&#123; message 'word' &#125; &#125;&#125; 这时我们已经很接近android gradle plugin提供的android{}扩展的DSL写法了，在自定义Plugin中如何实现就留给大家自己实现了，只要结合一下前面所讲过的方法就行，上面所介绍的扩展、嵌套DSL、命名对象容器已经能满足自定义Plugin开发时获取配置的大部分场景了。 2、在独立项目中编写在独立项目中编写和在buildSrc目录下编写是一样的，只是多了一个发布过程，这里我为了方便就不新建一个独立项目了，而是在GradleDemo中新增一个名为gradle_plugin的子项目，然后在gradle_plugin下新建一个src/main/groovy和src/main/resources目录，接着把刚刚在buildSrc编写的com.example.plugin.MyPlugin复制到src/main/groovy下，最后在GradleDemo新建一个repo目录，当作待会发布插件时的仓库，此时GradleDemo结构如下： 在Gradle中有两种方式在脚本中引入一个Plugin，一种是在buildScript中引入类路径，然后通过apply plugin引入插件，如下 123456789101112//build.gradlebuildscript &#123; repositories &#123; //定义插件所属仓库 &#125; dependencies &#123; classpath '插件类路径' &#125;&#125;apply plugin: '插件id' 一种是直接通过plugins DSL引入，如下： 1234567891011//setting.gradlepluginManagement&#123; repositories&#123; //定义插件所属仓库 &#125;&#125;//build.gradleplugins&#123; id '插件id' version '插件版本'&#125; 两种方式分别对应着两种类型的发布方式，下面分别介绍： 2.1、自定义META-INF发布因为gradle_plugin项目中的MyPlugin.groovy使用了Gradle的相关api，如Project等，所以你要在gradle_plugin/build.gradle中引进Gradle api，打开gradle_plugin/build.gradle，添加如下： 123456//gradle_plugin/build.gradledependencies &#123; //这样gradle_plugin/src/main/groovy/中就可以使用Gradle和Groovy语法 implementation gradleApi()&#125; 现在MyPlugin已经有了，我们需要给插件起一个名字，在gradle_plugin/src/main/resources目录下新建META-INF/gradle-plugins目录，然后在该目录下新建一个XX.properties文件，XX就是你想要给插件起的名字，就是apply plugin后填写的插件名字，也称为插件id，例如andorid gradle plugin的插件id叫com.android.application，所以它的properties文件为com.android.application.properties，这里我给我的MyPlugin插件起名为myplugin，所以我新建myplugin.properties，如下： 打开myplugin.properties文件，添加如下： 12# 在这里指明自定义插件的实现类implementation-class=com.example.plugin.MyPlugin 通过implementation-class指明你要发布的插件的实现类，如这里为com.example.plugin.MyPlugin，接下来我们就来发布插件。 发布插件你可以选择你要发布到的仓库，如maven、lvy，我们最常用的就是maven了，所以这里我选择maven，Gradle提供了maven-publish插件来帮助我们发布到maven仓库，在gradle_plugin/build.gradle添加如下： 123456789101112131415161718192021222324252627282930313233343536//gradle_plugin/build.gradleplugins&#123; //引入maven-publish, maven-publish属于Gradle核心插件，核心插件可以省略version id 'maven-publish'&#125;//publishing是maven-publish提供的扩展，通过repositories定义发布的maven仓库位置，可以指定本地目录地址或远端repo地址publishing.repositories &#123; //这里我指定了项目根目录下的repo目录 maven &#123; url '../repo' &#125; //可以指定远端repo地址 //maven&#123; // url 'https://xxx' // credentials &#123; // username 'xxx' // password xxx // &#125; //&#125;&#125;//通过publications定义发布的组件publishing.publications &#123; //类似于命令容器对象，添加名为myplugin的的发布 myplugin(MavenPublication)&#123; //配置自定义插件的groupId、artifactId和version groupId = 'com.example.customplugin' artifactId = 'myplugin' version = '1.0' //通过from引入打包jar的components from components.java &#125;&#125; 我们首先通过repositories{}定义了发布仓库，这里为本地目录，然后在publications{}中定义了名为myplugin的发布，它会被maven-publish插件用来生成发布任务，在其中通过groupId、artifactId和version配置了插件的GAV坐标，这样发布后我们就可以通过GAV坐标引用插件，即在dependencies{}中使用groupId:artifactId:version的形式来引用我们发布的插件，同时还引入了components.java，它是java插件为我们提供的把代码打包成jar的能力，当你做完这一切后，同步Gradle项目，maven-publish插件会为我们生成两种类型的发布任务：publishXXPublicationToMavenRepository和publishXXPublicationToMavenLocal，publishXXPublicationToMavenRepository任务表示把插件发布到maven远程仓库中，publishXXPublicationToMavenLocal任务表示把插件发布到maven本地仓库，其中XX就是在publications{}定义的发布名字，如我这里为myplugin。 接着在Gradle项目所处目录的命令行输入gradle publishMypluginPublicationToMavenLocal把myplugin插件发布到maven本地仓库，任务执行成功后，在maven本地仓库(mac下为～/.m/repository/，在window下为：C:/用户/用户名/.m/repository/)中会看到发布的插件jar和pom文件，如下： 接着在Gradle项目所处目录的命令行输入gradle publishMypluginPublicationToMavenRepository把myplugin插件发布到maven远程仓库，任务执行成功后，在GradleDemo/repo/中会看到发布的插件jar和pom文件，如下： 现在MyPlugin 1.0已经发布成功了，接下来让我们使用这个插件，在subproject_4/build.gradle中添加如下： 123456789101112131415161718192021//subproject_4/build.gradlebuildscript &#123; repositories &#123; //添加maven本地仓库 mavenLocal() //添加发布时指定的maven远程仓库 maven &#123; url uri('../repo') &#125; //可以添加maven中央仓库 //mavenCentral() &#125; dependencies &#123; //classpath填写插件的GAV坐标，gradle编译时会扫描该classpath下的所有jar文件并引入 classpath 'com.example.customplugin:myplugin:1.0' &#125;&#125; 这里使用了Project的buildscript方法，通过该方法可以为当前项目的build.gradle脚本导入外部依赖，在该方法中可以使用repositories方法和dependencies方法指定外部依赖的所在仓库和类路径，当前项目在构建时会去repositories定义的仓库地址寻找classpath指定路径下的所有jar文件并引入，如我这里repositories方法中指定了mavenLocal()和maven {url uri(‘../repo’)}，其中mavenLocal()对应maven的本地仓库即/.m/repository，maven {url uri(‘../repo’)}就是刚刚发布时指定的maven远程仓库，如果你通过发布任务发布插件到了maven中央仓库，则可以新增mavenCentral()，它代表maven中央仓库的远端地址，而dependencies方法中则通过classpath指定了myplugin插件在仓库下的类路径即GAV坐标: com.example.customplugin:myplugin:1.0，现在我们可以通过apply plugin使用myplugin了，在subproject_4/build.gradle中添加如下： 12345678910111213141516//subproject_4/build.gradle//通过插件id引用插件apply plugin: 'myplugin'//使用DSL配置插件的属性outerExt&#123; message 'hello' inner&#123; message 'word' &#125;&#125;//执行gradle showExt，输出：//outerExt = [message = hello], innerExt = [message = word] 其中apply plugin后面的插件id就是我们在gradle_plugin/src/main/resources/META-INF/gradle-plugins目录下编写的properties文件的名称。 现在已经成功发布了一个插件并引入使用，但是上面的发布过程和引入插件过程不免有点繁琐，Gradle为我们提供了java-gradle-plugin用于简化我们的发布过程，同时根据java-gradle-plugin发布的插件使用时只需要直接引入插件id就行，而无需在buildscript中指定classpath。 2.2、使用java-gradle-plugin生成META-INF发布还是上面MyPlugin的例子，我们在gradle_plugin/build.gradle中引入java-gradle-plugin插件，通过java-gradle-plugin提供的gradlePlugin{}扩展配置插件的META-INF信息，同时通过Project的setGroup方法和setVersion方法定义插件发布的groupId和version，我们还要引入maven-publish插件，因为要依赖它提供的发布能力，如下: 123456789101112131415161718192021222324252627282930313233343536373839404142//gradle_plugin/build.gradleplugins&#123; //用来生成插件元数据(META-INF)和插件标记工件(Plugin Marker Artifact) id 'java-gradle-plugin' //用来生成发布插件任务 id 'maven-publish'&#125;//通过maven-publish提供的publishing.repositories&#123;&#125;定义发布的maven仓库位置publishing.repositories&#123; maven &#123; url '../repo' &#125;&#125;//插件发布的groupIdgroup = 'com.example.customplugin'//这里没有定义artifactId，maven-publish会自动取当前项目的名字作为artifactId，这里为gradle_plugin//插件发布的versionversion = '2.0'//通过java-gradle-plugin提供的gradlePlugin&#123;&#125;配置插件gradlePlugin &#123; plugins &#123; //配置myplugin插件 myplugin&#123; //插件id id = 'com.example.customplugin.myplugin' //插件实现类 implementationClass = 'com.example.plugin.MyPlugin' &#125; //myplugin2&#123; // id = 'xxx' // implementationClass = 'xxx' //&#125; //以此类推可以配置多个插件 &#125;&#125; 通过在gradlePlugin{}中的配置，执行发布任务时java-gradle-plugin会自动为我们生成插件的META-INF信息并打包进插件的jar中，同时java-gradle-plugin会自动为我们在dependencies引入gradleApi()，除此之外，执行发布任务时java-gradle-plugin还为插件生成了一个插件标记工件 - Plugin Marker Artifact，它的作用就是用来定位插件的位置，我们在plugins DSL中通过插件id来引用插件时并不需要定义插件的classpath即GAV坐标就可以直接使用插件，那么Gradle是如何根据插件id定位到插件的呢？答案就是插件标记工件，它跟插件发布时一起发布，它里面只有一个pom文件，pom文件里面依赖了插件真正的GAV坐标，这样通过插件id来引用插件时就会先下载这个pom文件，从而解析到插件的GAV坐标，再根据插件的GAV坐标把插件的jar文件引入，那么Gradle又是如何定位到插件标记工件的呢？答案就是使用插件id按一定的规则生成插件标记工件的GAV坐标，插件标记工件的GAV生成规则为pluginId:pluginId.gradle.plugin:pluginVersion，如这里myplugin的插件标记工件生成的GAV为com.example.customplugin.myplugin:com.example.customplugin.myplugin.gradle.plugin:2.0，发布插件时会同时把插件标记工件发布到生成的GAV处，然后通过插件id引用时又根据插件id拼接出相同的GAV从而定位到插件标记工件，这么说有点绕，让我们执行发布任务看看生成的产物就懂了。 我们在Gradle项目所处目录的命令行输入gradle publishPluginMavenPublicationToMavenRepository publishMypluginPluginMarkerMavenPublicationToMavenRepository来执行插件发布任务和插件标记工件发布任务，这两个任务都是maven-publish根据java-gradle-plugin定义的发布过程为我们生成好的，除此之外还生成了发布到maven本地仓库的任务，这里只以发布到maven远程仓库任务做示例，两个任务执行成功后，在GradleDemo/repo/中会看到发布的插件和插件标识工件，如下： 可以看到在repo下发布了两个组件，一个为插件，artifactId为gradle_plugin，一个为插件标识工件，artifactId为com.example.customplugin.myplugin.gradle.plugin，它们都处于com.example.customplugin空间下，版本都为2.0，我们看一下插件标识工件里面的内容，如下： 可以看到插件标识工件中并没有jar文件只有pom文件，我们打开它的pom文件，如下： 可以看到依赖了真正的插件的GAV坐标，为com.example.customplugin:gradle_plugin:2.0，这样通过插件id引用时就可以根据插件标识工件定位到插件，通过java-gradle-plugin这种方式发布插件时还有一点要注意的是，插件的id最好以groupId为前缀，这样才能保证插件标识工件和插件发布时都处于同一个仓库路径。 现在MyPlugin 2.0已经发布成功了，接下来让我们使用这个插件，需要通过plugins DSL引用的插件不需要定义classpath，但还是要定义仓库位置，我们在settings.gradle中添加如下： 1234567891011//settings.gradle//一定要放在settings.gradle中的第一行pluginManagement&#123; repositories&#123; //添加发布时指定的maven远程仓库 maven &#123; url uri('repo') &#125; &#125;&#125; plugins DSL通过pluginManagement{}管理插件仓库还有插件，而且pluginManagement{}必须要放在settings.gradle脚本的头部，然后我们可以通过plugins DSL使用myplugin了，在subproject_4/build.gradle中添加如下： 123456789101112131415161718//subproject_4/build.gradle//通过插件id引用插件plugins&#123; id 'com.example.customplugin.myplugin' version '2.0'&#125;//使用DSL配置插件的属性outerExt&#123; message 'hello' inner&#123; message 'word' &#125;&#125;//执行gradle showExt，输出：//outerExt = [message = hello], innerExt = [message = word] plugins DSL根据插件id寻找插件时默认会先从Gradle中央仓库 - Gradle Plugin Portal找，找不到再从pluginManagement中指定的仓库找。 上面发布时为了讲解原理把发布任务逐个执行，其实maven-publish还为我们生成了更为方便的publishAllPublicationsToMavenRepository 、publishToMavenLocal、publish发布任务，只需要执行一个任务就可以把多个发布任务同时执行： 执行publishAllPublicationsToMavenRepository任务表示执行所有发布到maven远程仓库的任务； 执行publishToMavenLocal任务表示执行所有发布到maven本地仓库的任务； 执行publish任务表示执行publishAllPublicationsToMavenRepository和publishToMavenLocal任务 结语本文通过Gradle的特点、项目结构、生命周期、Task、自定义Plugin等来全面的学习Gradle，掌握上面的知识已经足够让你入门Gradle，但是如果你想要更进一步的学习Gradle，掌握本文的知识点是完全不足的，你可能还需要熟悉掌握Project中各个api的使用、能独立的自定义一个有完整功能的Plugin、能熟练地编写Gradle脚本来管理项目等，下面有一份Gradle DSL Reference，你可以在需要来查找Gradle相关配置项的含义和用法： Gradle DSL Reference 对于android开发者，我们引入的android插件中也有很多配置项，下面的Android Plugin DSL Reference，你可以在需要来查找android 插件相关配置项的含义和用法： Android Plugin DSL Reference 本文的源码位置： GradleDemo 以上就是本文的全部内容，希望大家有所收获！ 参考内容： Gradle官网 Gradle学习系列 Gradle插件从入门到进阶 Gradle 源码分析","tags":[{"name":"gradle","slug":"gradle","permalink":"http://yoursite.com/tags/gradle/"}]},{"title":"java学习总结之I/O操作","date":"2020-05-30T15:20:42.000Z","path":"2020/05/30/java输入输出/","text":"前言I/O(Input/Output)操作，即输入输出操作，它是一个相对的过程，我们一般站在位于内存中的程序的角度来思考这个操作的过程，输入就是程序需要数据，把数据从数据源中流入程序，输出就是程序需要保存或传输数据，把数据从程序中流出到数据源，这个数据源一般为文件、网络、压缩包等，所以数据源和程序就通过数据流通道组成了一个半双工的输入/输出模式，如下： java从更高层次把输入和输出抽象出来，封装成一些对程序员友好的API，我们只需要操作这些I/O接口就能简单的实现I/O操作，了解了输入输出模式的大体结构后，下面进入正文讲解。 I/O框架 有关I/O的类主要都在java .io包中，从上图可以看出，java中的I/O流根据数据的单位划分可以分为字节流和字符流，两类都有输入和输出操作： 字节流：字节流主要用来处理字节(byte)或二进制对象，字节流的标志就是以Stream结尾，在字节流中，输入数据使用InputStream，输出数据使用OutputStream，InputStream/OutputStream是其他所有输入/输出字节流的抽象父类； 字符流：字符流主要用来处理字符(char)或字符串，字符流的标志就是以Reader或Writer结尾，在字符流中，输入数据使用Reader，输出数据使用Writer，Reader/Writer是其他所有输入/输出字符流的抽象父类. 不管是字节流还是字符流，它们都有一个close方法，用来关闭资源，因为它们都实现了Closeable接口，所以我们在通过这些流对象操作了文件后，记得调用close方法关闭资源，不然流对象就会一直关联着文件，导致文件无法释放，造成内存泄漏。 在磁盘上保存或在网络上传输的数据最终都是二进制字节数据而不是字符数据，之所以存在字符流，是因为字符流中增加了对编码的处理，对多国语言支持比较好，所以如果需要处理文本、字符串等建议使用字符流，但是如果是处理音频、视频、图片等建议使用字节流。 字节流1、InputStream InputStream是所有字节输入流的抽象父类，为所有字节输入流提供一个标准的、基本的读取字节的方法，它常用方法如下： 方法 描述 int read() 从输入流中读取下一个字节数据(0~255)，已到达最后没有可读取数据时返回-1 int read(byte[] b) 从输入流中读取b.length个字节到数组b中，并返回实际读取的字节数，已到达最后没有可读取数据时返回-1 int read(byte[] b, int off, int len) 读取字节保存在b数组的下标off到len - 1处，已到达最后没有可读取数据时返回-1 int available() 返回可以从输入流中读取的字节数(估计值) InputStream的常用子类如下： InputStream子类 描述 FileInputStream 文件字节输入流，用于从文件中读取信息 ByteArrayInputSream 字节数组输入流，允许将内存的缓冲区作为输入流使用，用于读取其内置缓存字节数组中的字节 ObjectInputStream 对象字节输入流，从输入流中读取对象 BufferedInputStream 缓冲字节输入流，使用缓冲区的输入流，它常常用来装饰其他字节输入流，为其提供缓冲功能，提高访问效率 DataInputStream 数据字节输入流，可以从输入流中读取基本的数据类型，如int、char、long等 使用InputStream读取数据的大概流程如下： 123456789void main(String[] args) throws IOException&#123; InputStream in = new FileInputStream(\"file.txt\"); int size = in.available(); byte[] b = new byte[size]; int len = in.read(b, 0, size); String value = new String(b); System.out.println(\"读取出的内容：value = \" + value); in.close();&#125; 2、OutputStream OutputStream是所有字节输出流的抽象父类，为所有字节输出流提供一个标准的、基本的写入字节的方法，它常用方法如下： 方法 描述 void write() 将指定的字节写入到输出流中 void write(byte[] b) 将字节数组b的内容写入到输出流中 void write(byte[] b, int off, int len) 将字节数组中下标off到len - 1的字节写入到输出流中 void flush() 清除输出流中的缓存，强制写出任何输出缓冲中的字节 OutputStream的常用子类如下： OutputStream子类 描述 FileOutputStream 文件字节输出流，用于把字节写入到文件中 ByteArrayOutputSream 字节数组输出流，允许将内存的缓冲区作为输出流使用，用于把字节写入到内置缓存字节数组中 ObjectOutputStream 对象字节输出流，用于把对象写入到输出流中 BufferedOutputStream 缓冲字节输出流，使用缓冲区的输出流，它常常用来装饰其他字节输出流，为其提供缓冲功能，提高访问效率 DataOutputStream 数据字节输出流，可以把基本的数据类型写入到输出流中 使用OutputStream写入数据的大概流程如下： 1234567void main(String[] args) throws IOException&#123; OutputStream os = new FileOutputStream(\"file.txt\", true); String content = \"待写入的内容\"; os.write(content.getBytes()); os.flush(); os.close();&#125; 字符流1、Reader Reader是所有字符输入流的抽象父类，为所有字符输入流提供一个标准的、基本的读取字符的方法，它常用方法如下： 方法 描述 int read() 从输入流中读取下一个字符(0~65535)，已到达最后没有可读取数据时返回-1 int read(char[] cbuf) 从输入流中读取b.length个字符到数组b中，并返回实际读取的字符数，已到达最后没有可读取数据时返回-1 int read(char[] cbuffer,int off,int len) 读取字符保存在b数组的下标off到len - 1处，已到达最后没有可读取数据时返回-1 boolean ready() 判断输入流是否做好读的准备 Reader的常用子类如下： Reader子类 描述 CharArrayReader 字符数组输入流，实现了字符缓冲区的输入流，将其内置字符缓存数组中的数据（通过构造方法传入）读取到程序中 InputStreamReader 字节转换流，用于将字节流转换成字符流，它读取字节，并使用指定的charset将其解码为字符 FileReader 文件字符输入流，以字符的形式读取文件中的内容 BufferedReader 缓冲字符输入流，它是一个装饰类，装饰其他字符输入流，为其提供缓冲功能，提高效率 使用Reader读取数据的大概流程如下： 1234567891011121314151617181920212223242526272829void main(String[] args) throws IOException&#123; FileReader reader = new FileReader(\"file.txt\"); BufferedReader bReader = new BufferedReader(reader); StringBuilder content = new StringBuilder(); String line; //readLine方法是BufferedReader中的方法，它一次读取一行，比read方法一次读取一个字符的效率快很多 while((line = bReader.readLine()) != null)&#123; content.append(line); content.append(\"\\r\\n\"); &#125; System.out.println(\"读取到的内容：content\" + content); bReader.close(); reader.close();&#125; //将字节流转换为Buffer字符流，同样可以使用readLine方法一行一行地读public void main(String[] args) throws IOException&#123; StringBuilder content = new StringBuilder(); String line; BufferedReader reader = new BufferedReader( new InputStreamReader(new FileInputStream(\"file.txt\")) ); while((line = reader.readLine()) != null)&#123; content.append(line); content.append(\"\\r\\n\"); &#125; System.out.println(\"读取到的内容：content\" + content); reader.close();&#125; 2、Writer Writer是所有字符输出流的抽象父类，为所有字符输出流提供一个标准的、基本的写入字符的方法，它常用方法如下： 方法 描述 void write() 将指定字符写入到输出流中 void write(char[] cbuf) 将字符数组b的内容写入到输出流中 void write(char[] cbuffer,int off,int len) 将字符数组中下标off到len - 1的字符写入到输出流中 void flush() 将缓存区中的所有数据写到文件中 Writer的常用子类如下： Reader子类 描述 CharArrayWriter 字符数组输出流，实现了字符缓冲区的输出流，将字符写入到内置的字符缓存数组中 InputStreamWriter 字节转换流，用于将字节流转换成字符流，它可以使用指定的charset来写入字符 FileWriter 文件字符输出流，将字符写入到指定的文件中 BufferedWriter 缓冲字符输出流，它是一个装饰类，装饰其他字符输出流，为其提供缓冲功能，提高效率 使用Writer写入数据的大概流程如下： 123456789void main(String[] args)&#123; FileWriter writer = new FileWriter(\"file.txt\", true); BufferedWriter bWriter = new BufferedWriter(writer); StringBuilder content = new StringBuilder(\"待写入的内容\"); writer.write(content.toString()); bWriter.flush(); bWriter.close(); writer.close();&#125; RandomAccessFileRandomAccessFile它是属于IO系统的一部分，在java中，RandomAccessFile用来表示可随机访问的文件，前面我们所讲的字符流或字节流都是一种顺序流，通过顺序流打开的文件只能按顺序地从上往下地访问，不能说从后往前，或者说从中间开始访问，而通过RandomAccessFile打开的文件可以让我们不按顺序地读取文件，RandomAccessFile内部其实是通过称为file point的指针来进行文件地读写，我们可以设置指针在文件中的位置，从而达到从任意位置开始读写的目的，它的常用方法如下： 方法 描述 RandomAccessFile(File f, String mode) 使用指定的File对象和模式(r/rw)创建随机文件流 long getFilePointer() 返回以字节计算的文件偏移量(从文件开始计算)，作为下一个read或writer的起点 long length() / setLength(long) 返回文件中的字节数 / 为文件设置新的长度 int read() / int read(byte[]) 从文件中读取字节数据 void seek(long pos) 设置文件偏移量，以字节为单位 int skipBytes(int n) 跳过n个字节 void write(byte[] b) 将指定的字节数组写入到文件中，从当前的文件指针开始写 下面是它的一些基本使用： 12345678910111213141516//从指定的位置开始读取数据public static void main(String[] args) throws IOException &#123; File file=new File(\"file.txt\"); RandomAccessFile randomFile = new RandomAccessFile(file,\"r\"); // 获取 RandomAccessFile对象文件指针的位置，初始位置为0 System.out.print(\"输入内容：\" + randomFile.getFilePointer()); //移动文件记录指针的位置 randomFile.seek(1000); byte[] b=new byte[1024]; int hasRead = 0; while((hasRead = randomFile.read(b))&gt;0)&#123; //输出文件读取的内容 System.out.print(new String(b, 0, hasRead)); &#125; randomFile.close();&#125; 通过RandomAccessFile很容易地实现断点下载。 File文件是输入/输出流的操作对象之一，java中用File代表文件，File类中封装了很多对文件或文件夹操作的方法，我把File类中常用的方法分为四类：状态检测、路径和名称操作、文件操作、目录操作。 File中的状态检测方法： 方法 描述 boolean canExecute() 判断此File实例对应的文件是否是可执行文件 int length() 返回此File实例对应文件的长度，单位为字节 boolean canRead() 判断此File实例对应的文件是否可读 boolean canWrite() 判断此File实例对应的文件是否可写 boolean isHidden() 判断此File实例对应的文件是否是隐藏文件 long lastModified() 返回此File实例的最后修改时间 File路径和名称操作方法： 方法 描述 String getAbsolutePath() 获取此File实例对应文件或文件夹的绝对路径 String getPath() 获取此File实例对应文件或文件夹的相对路径 String getName() 获取此File实例对应文件或文件夹的名称 File getParentFile() 获取此File实例对应文件的上级目录文件 String getParent() 获取此File实例对应文件的上级目录路径 File中的文件操作方法： 方法 描述 boolean exists() 判断此File实例对应的文件是否存在 boolean isFile() 判断此File实例是否是一个标准文件 boolean delete() 删除此File实例对应的文件 boolean createNewFile() 根据File实例创建新的文件 void deleteOnExit() 在JVM终止时删除File实例对应的文件 boolean renameTo(File dest) 根据dest重命名此File实例对应的文件 static File createTempFile(String prefix, String suffix, File directory) 在directory目录下创建prefix.suffix临时文件 File中的目录(文件夹)操作方法： 方法 描述 boolean isDirectory() 判断此File实例是否是一个文件夹 boolean mkdir() 根据File实例对应的文件夹创建当前目录（一级目录） boolean mkdirs() 根据File实例对应的文件夹创建当前目录和上级目录（多级目录） String[] list() 根据File实例对应的文件夹列出当前目录中所有文件和文件夹的路径 File[] listFiles() 根据File实例对应的文件夹列出当前目录中所有文件和文件夹的File实例 static File[] listRoots() 列出可用的文件系统盘符(根路径) File[] listFiles(FileFilter filter) 返回一个File数组，表示当前File实例下满足指定过滤器filter的所有文件和目录 我们可以发现File中的方法只能获取或设置文件相应的信息，并不能获取或设置文件里面的内容，想要获取或设置文件里面的内容需要通过前面讲过的流操作来完成，除此之外File还有一些静态字段用来表示与系统无关的属性，例如目录分隔符separator、属性分隔符pathSeparator，这些分隔符在不同的操作系统上的表示是不一样的，例如在window上通过File的separator和pathSeparator获取到的输出是 \\ 和 ; ，在Unix上获取到的输出是 / 和 ：。 结语本文从字节流、字符流，文件操作等介绍了java的IO系统，同时这些基于流的IO操作又被称为传统的IO操作，为什么说它是传统的呢，因为早在java4就推出NIO，即New IO，NIO相对与传统的IO的主要区别是NIO是基于通道和缓冲区的，同时NIO是非阻塞的，所以它比传统的IO更高效，所以在java4之后，NIO完全可以替代传统的IO，但是话虽是这么说，传统的IO也十分重要，毕竟在一些简单的场景下它的使用还是更加的方便，NIO更多地是使用在高并发的服务端上。 参考资料： Java：带你全面了解神秘的Java NIO Java IO体系架构图","tags":[{"name":"I/O","slug":"I-O","permalink":"http://yoursite.com/tags/I-O/"}]},{"title":"java学习总结之反射","date":"2020-03-19T06:59:32.000Z","path":"2020/03/19/java反射/","text":"前言在java中，反射就是在程序运行时动态的获取某一个类的元数据(metadata，描述数据的数据)的过程，这些元数据包括构造器、方法、成员变量、内部类、接口、父类等，通过反射，我们可以在程序运行时动态地去操作类的方法、成员变量等信息，所以，在java中，反射为我们提供了一种动态访问、修改类的能力，掌握反射，对我们加深java语言的理解很有帮助，反射大部分所使用到的类都在java.lang.reflect包下。 为什么使用反射首先我们要知道在java中，对象分为编译时类型和运行时类型，例如：Object obj = new String(“123”)； 其中obj变量的编译时类型为Object类型，运行时类型为String类型，编译时类型在编译期就确定了变量的类型，而运行时类型则在运行期才确定变量的类型。 这时假设我需要通过obj 变量调用String中的length()方法，当我写下obj.length()这句代码时，编译就会报错，因为编译时会检查obj变量的编译时类型Object，发现它不存在length()方法，编译不通过，报错，这时的解决方法是：把obj强转成String，然后再调用length()方法，如：((String)obj).length()；这时编译就通过了。 但是如果此时我并不知道obj变量的运行时类型是String，我怎么强转，我怎么调用它的length()方法？这时就要通过反射来实现了，例如下面的场景： 123456789101112//外部调用getLen方法，把obj变量传入方法public static void main(String[] args)&#123; Object obj = new String(\"123\"); System.out.println(getLen(obj));&#125;//在方法内部的我们只知道obj的编译时类型为Object，并不知道它的运行时类型是什么？public int getLen(Object obj)&#123; //通过反射调用obj的length()方法 Method method = obj.getClass().getMethod(\"length\"); return (Integer) method.invoke(obj);&#125; 上述我们在执行一个getLen方法，方法传入了一个Object类型的对象，但是我们却需要调用对象运行时类型的方法length()，我们此时并不知道该对象的运行时类型，只知道对象编译时类型是Object，这时就需要通过反射来实现该方法的调用，obj变量在运行时是String类型，所以上述代码在运行时通过反射调用了obj的length()方法。 所以为什么要使用反射呢？这是因为有时候我们在编译时无法预知对象的运行时类型，但却需要使用对象的运行时类型的信息，这时就需要通过反射来实现。 反射的基本使用1、获取Class对象每个类被加载进JVM时，JVM会为这个类创建一个java.lang.Class对象，Class对象就是类的元数据，通过这个Class对象，我们可以在代码运行时访问到这个类的所有信息，Class对象是代码运行时访问类信息的唯一入口，所以要想使用反射，我们首先要获取到类的Class对象，获取Class对象主要有以下3种方法： 1、使用Class的forName(String className)方法：该方法需要传入类的全限定名，通过类的全限定名加载这个类进入JVM，并返回该类的Class对象，如果无法加载这个类就抛出一个ClassNotFoundException异常； 2、调用某个类的class属性：每个类都有一个class属性，调用类.class会返回该类的Class对象； 3、调用某个对象的getClass方法：getClass方法是Object类中的一个方法，所以java中的所有对象都可以调用这个方法，getClass方法会返回该对象所属类的Class对象； 下面使用上面的3种方法获取String类的Class对象，如下： 12345678public static void main(String[] args) throws ClassNotFoundException &#123; //1、使用Class的forName(String className)方法 Class&lt;?&gt; stringClass1 = Class.forName(\"java.lang.String\"); //2、调用String类的class属性 Class&lt;String&gt; stringClass2 = String.class; //3、调用String对象的getClass方法 Class&lt;?&gt; stringClass3 = new String().getClass();&#125; 在JDK5之后，Class添加了泛型支持，允许使用泛型来限制Class的类型，例如上面的String.class，它的Class类型为Class&lt;String&gt;，它表示Class对应的类为String类，如果Class对应的类未知，可以使用Class&lt;?&gt;或Class表示，在java中，通过forName或getClass方法获取的Class对象的对应的类是未知的，而通过某个类的class属性返回的Class对象的对应的类是确定的，通过泛型限制，可以避免使用反射创建对象时进行强制类型转换。 在java中，除了类有对应的Class对象外，8大基本数据类型+void类型都有自己的Class对象，但是这些基本类型并不是对象，所以它们不能通过getClass方法获取Class对象，同时基本类型也没有类名的概念，所以它们也不能通过forName方法获取Class对象，它们只能通过XX.class的方式获取相应的Class对象，如：int.class、byte.class、short.class、long.class、double.class、float.class、char.class、boolean.class和void.class，JVM中会内置这九大类型的Class对象，无需我们从外部加载，同时在这九大类型的对应的包装类中都有一个TYPE常量，这个TYPE常量就是对应基本类的Class对象，但是包装类的Class对象并不等于基本类的Class对象，以int为例，如下： 1234public static void main(String[] args) throws ClassNotFoundException &#123; System.out.println(int.class == Integer.TYPE);//输出true System.out.println(int.class == Integer.class);//输出false&#125; 在java中，数组也是一个引用类型，也是一个对象，所以数组也有自己的Class对象，数组可以通过getClass方法和XX.class方式获取自己的Class对象，以int[]为例，如下： 1234567public static void main(String[] args) throws ClassNotFoundException &#123; int[] ints = &#123;&#125;; //1、通过XX.class方式获取数组的Class对象 Class&lt;int[]&gt; intsClass1 = int[].class; //2、通过getClass方法获取数组的Class对象 Class&lt;?&gt; intsClass2 = ints.getClass();&#125; 2、通过Class对象获取类信息一旦获取到类的Class对象后，就可以通过Class对象获取类中的所有信息，这些信息包括：构造器、方法、成员变量、内部类、外部类、接口、父类、注解、类的修饰符，类名、类所在包等，但是我们常用的类信息只有构造器、方法、成员变量，它们的元数据代表如下： Constructor：代表类的构造器对象； Method：代表类的方法对象； Field：代表类的成员变量对象； 在Class类中都有这些元数据的相应的获取方法，通过Class对象获取这些元数据的相应方法的名称命名都有一个规律：如果获取方法中不带Declared关键字的，那么这个方法只能获取到类的public属性，包括继承的；而如果这个获取方法带Declared关键字，那么这个方法就能获取到类的所有public、protected、default、private属性，但不包括继承的，而子类是无法继承父类的构造器的，所以通过子类获取构造器时，是无法获取到父类的构造器，只能获取到属于子类的构造器，而对于方法、成员变量它们是可以继承自父类的。 下面分别介绍它们的获取方法和使用场景： 2.1、获取类的Constructor下面的4个方法可以获取Class对应类的构造器对象Constructor： 1、Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;… parameterTypes)：返回此Class对应类的、带指定形参列表的public构造器对象，传入的形参也要用对应类型的Class对象表示； 2、Constructor&lt;?&gt;[] getConstructors()：以数组的形式返回此Class对应类的所有public构造器对象； 3、 *Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) *：返回此Class对应类的、带指定形参列表的构造器对象，与访问权限无关，传入的形参也要用对应类型的Class对象表示； 4、Constructor&lt;?&gt;[] getDeclaredConstructors()：以数组的形式返回此Class对应类的所有构造器对象，与访问权限无关. 获得到构造器对象Constructor后，就可以调用Constructor的newInstance(Object … initargs)方法创建对应类的实例，newInstance方法的initargs参数就是构造器中需要传入的参数，它是一个可变参数，如下我通过反射创建了一个值为123的String对象： 1234567891011//通过反射创建对象public static void main(String[] args) throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123; //1、获取String类的Class对象 Class&lt;String&gt; stringClass = String.class; //2、通过Class对象获取一个带String类型参数的构造器Constructor Constructor&lt;String&gt; stringConstructor = stringClass.getConstructor(String.class); //3、使用Constructor的newInstance方法创建String对象，并传入该构造器需要的参数“123” String string = stringConstructor.newInstance(\"123\"); //输出：123 System.out.println(string);&#125; 如果你需要调用类的默认构造器来创建对象，这时调用Constructor的newInstance方法时就不需要传入参数，类的默认构造器就是没有参数的那个构造器，同时为了简化获取Constructor这一步骤，java允许我们直接使用Class对象的newInstance()方法来调用类的默认构造器来创建对象，如下我通过Class对象的newInstance方法创建了一个空String对象： 12345678//通过反射创建对象public static void main(String[] args) throws IllegalAccessException, InstantiationException&#123; //1、获取String类的Class对象 Class&lt;String&gt; stringClass = String.class; //2、调用String类的默认构造器来创建对象 String string = stringClass.newInstance(); System.out.println(string);&#125; Class对象的newInstance方法从java9之后就被标记为Deprecated，java9之后推荐使用Constructor的newInstance方法来反射创建对象实例。 为什么要使用Constructor来创建对象呢，直接使用new不行吗？这是因为某些场景下我们无法直接调用某个类的构造器，例如在一些框架中，传给我们的都是关于类的字符串(类的全限定名)，我们只能通过Class的forName方法获取到Class对象，然后获取到Constructor对象，然后通过Constructor对象来创建实例。 2.2、获取类的Method下面的4个方法可以获取Class对应类的方法对象Method： 1、Method getMethod(String name, Class&lt;?&gt;… parameterTypes) **：返回此Class对应类的、指定名称的、带指定形参列表的public**方法对象，传入的形参也要用对应类型的Class对象表示； 2、Method[] getMethods() **：以数组的形式返回此Class对应类的所有public**方法对象； 3、Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) **：返回此Class对应类的、非继承的**、指定名称的、带指定形参列表的方法对象，与访问权限无关，传入的形参也要用对应类型的Class对象表示； 4、 Method[] getDeclaredMethods() **：以数组的形式返回此Class对应类的、非继承的**所有方法对象，与访问权限无关. 获取到方法对象Method后，就可以通过Method的invoke(Object obj, Object… args)方法来调用Method对应的方法，其中invoke方法的返回值就是被调用方法的返回值，而invoke方法的obj参数表示被调用方法的所属对象，args参数表示被调用方法的需要传入的参数，如下我通过反射调用String对象的length方法： 1234567891011//通过反射调用方法public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123; //1、获取String类的Class对象 Class&lt;String&gt; stringClass = String.class; //2、通过Class对象获取名称为length、没有参数的方法对象method Method method = stringClass.getMethod(\"length\"); //3、通过invoke方法执行String对象的length方法，返回String的长度 Integer len = (Integer) method.invoke(stringClass.newInstance()); //输出：0 System.out.println(len);&#125; 如果需要调用的是静态方法，那么invoke方法的第一个参数obj参数就要传入null，因为静态方法不属于任何对象，静态方法只属于对应的类，如下我通过反射调用String的valueOf(int)静态方法： 123456789101112//通过反射调用静态方法public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException &#123; //1、获取String类的Class对象 Class&lt;String&gt; stringClass = String.class; //2、通过Class对象获取名称为valueOf、参数类型为int的方法对象method Method method = stringClass.getMethod(\"valueOf\", int.class); //3、通过invoke方法执行String类的valueOf方法，返回字符串“123” //注意：这里第一个参数传入了null，而不是String实例 String num = (String) method.invoke(null, 123); //输出：123 System.out.println(num);&#125; 如果需要调用的方法有一个数组类型或可变参数类型的参数，那么调用时就需要注意，而可变参数底层实现其实就是数组，下面我以数组为例，如下： 12345678910111213141516171819202122232425262728293031323334public class Main &#123; //通过反射调用参数含有数组类型的方法 public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; //获取Main类的Class对象 Class&lt;Main&gt; mainClass = Main.class; //情况1：数组的元素类型为基本数据类型 Method method1 = mainClass.getMethod(\"doWork\", int[].class); //method1.invoke(null, 1, 2, 3);//错误 method1.invoke(null, new int[]&#123;1, 2, 3&#125;);//正确 method1.invoke(null, new Object[]&#123;new int[]&#123;1, 2, 3&#125;&#125;);//正确 //情况2：数组的元素类型为引用类型 Method method2 = mainClass.getMethod(\"doWork\", String[].class); //method2.invoke(null, \"1\", \"2\", \"3\");//错误 //method2.invoke(null, new String[]&#123;\"1\", \"2\", \"3\"&#125;);//错误 method2.invoke(null, new Object[]&#123;new String[]&#123;\"1\", \"2\", \"3\"&#125;&#125;);//正确 &#125; //数组的元素类型为基本数据类型 public static void doWork(int[] nums)&#123; for(int num : nums)&#123; System.out.print(num + \" \"); &#125; &#125; //数组的元素类型为引用类型 public static void doWork(String[] strs)&#123; for(String str : strs)&#123; System.out.print(str + \" \"); &#125; &#125;&#125; 可以看到反射调用的方法的参数含有数组类型，在执行invoke方法时传参会很容易出错，所以为了保险起见，建议以后反射调用参数含有数组类型的方法时，把被调用方法的实际参数统统作为Object数组的元素即可，如：Method对象.invoke(方法所属对象，new Object[]{参数1，参数2，…})。 2.3、获取类的Field下面的4个方法可以获取Class对应类的成员变量对象Field： 1、Field getField(String name) **：返回此Class对应类的、指定名称的public**成员变量对象； 2、Field[] getFields() **：以数组的形式返回此Class对应类的所有public**成员变量对象； 3、Field getDeclaredField(String name) **：返回此Class对应类的、非继承的**、指定名称的成员变量对象，与访问权限无关； 4、Field[] getDeclaredFields() **：以数组的形式返回此Class对应类的、非继承的**所有成员变量对象，与访问权限无关. 获得成员变量对象Field后，就可以通过Field的setXX(Object obj)方法和getXX(Object obj)方法为成员变量赋值和向成员变量取值，其中setXX或getXX方法中的obj参数表示成员变量所属的对象实例，而XX对应8种基本数据类型，如果成员变量为引用类型，则取消setXX或getXX方法中XX，例如下面我通过反射为一个引用类型变量和一个基本数据类型变量赋值和取值： 12345678910111213141516171819202122232425262728public class Main &#123; //引用类型 public String str = \"123\"; //基本数据类型 public int num = 123; //通过反射访问成员变量 public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Main mainInstance = new Main(); //1、获取Main类的Class对象 Class&lt;Main&gt; mainClass = Main.class; //2、通过Class对象分别获取名为str和名为num的成员变量对象Field Field field1 = mainClass.getField(\"str\"); Field field2 = mainClass.getField(\"num\"); //3、分别通过Field的setXX方法赋值，getXX方法取值 //重新赋值，如果是引用类型就直接调用set方法就行，如果是基本数据类型就可以调用setXX方法 field1.set(mainInstance, \"321\"); field2.setInt(mainInstance, 321); //取值，如果是引用类型就直接调用get方法就行，如果是基本数据类型就可以调用getXX方法 String str = (String) field1.get(mainInstance); int num = (Integer)field2.getInt(mainInstance); //输出 System.out.println(str);//输出：321 System.out.println(num);//输出：321 &#125; &#125; 如果成员变量为静态成员变量，那么调用setXX或getXX方法时第一个参数就直接传null，如果这个成员变量是一个私有变量，那么还要调用setAccessible(true)方法后才能访问这个变量，如下我通过反射访问了一个名为data的私有变量： 1234567891011121314151617181920public class Main &#123; //私有成员变量 private int data = 123; //通过反射访问私有成员变量 public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Main mainInstance = new Main(); //1、获取Main类的Class对象 Class&lt;Main&gt; mainClass = Main.class; //2、通过Class对象获取名为data的成员变量对象Field，这里使用了getDeclaredField方法，因为getDeclaredField方法可以获取到私有变量 Field field = mainClass.getDeclaredField(\"data\"); //注意：这里调用了setAccessible(true)方法把私有成员变量设置为可访问 field.setAccessible(true); //3、通过Field的getXX方法取值 int data = field.getInt(mainClass.newInstance()); //输出：123 System.out.println(data); &#125;&#125; 对变量调用了setAccessible(true)后，就会在使用时关闭访问权限的检查，该变量就不会受访问权限的控制，我们就可以任意的修改和访问它。 其实不止Field可以调用setAccessible方法，对于Constructor、Method等也可以调用setAccessible方法，因为setAccessible方法是在AccessibleObject类中，而Field、Constructor、Method都继承自AccessibleObject，所以当以后想要通过Class对象访问private的Field、Constructor、Method时，都需要先调用setAccessible(true)关闭访问权限的检查后才能访问。 3、小结以上就是反射的基本使用，下面再总结一下： 通过反射创建对象，需要通过下面三个步骤： 1、获取该类的Class对象； 2、利用Class对象的getConstructor或getDeclaredConstructor方法来获取指定的构造器对象Constructor； 3、调用Constructor的newInstance方法来创建相应的对象. 通过反射调用方法，需要通过下面三个步骤： 1、获取该类的Class对象； 2、利用Class对象的getMethod或getDeclaredMethod方法来获取指定的方法对象Method; 3、调用Method的invoke方法来执行相应的方法. 通过反射访问成员变量，需要通过下面三个步骤： 1、获取该类的Class对象； 2、利用Class对象的getField或getDeclaredField方法来获取指定的成员变量对象Field; 3、调用Field的setXX和getXX方法来访问相应的成员变量。 如果通过Class对象获取到的属性是私有的，还要调用setAccessible(true)方法关闭访问权限的检查。 通过反射获取变量的类型在JDK5之前，java中只有原始类型(raw types)和基本类型(primitive types)，它们都用Class类表示，从JDK5开始引入了泛型(ParameterizedType)，这时为了统一表示这些类型就引入了Type接口，同时为了扩展java的泛型，还引入了数组类型(GenericArrayType)、类型变量(TypeVariable)、通配符类型(WildcardType)，这5种类型的父接口都是Type，他们的各自含义如下： Class：原始类型或基本类型，原始类型表示我们平常所使用的类、注解、枚举、数组等，基本类型表示基本数据类型，如int、byte、short等，它们都用Class类表示； ParameterizedType：参数化类型，表示java5引入的泛型类型，如List&lt;String&gt;、Map&lt;String, Integer&gt;等； GenericArrayType：数组类型，表示带有泛型的数组，如T[]、List&lt;String&gt;[]等； TypeVariable：类型变量，表示泛型的尖括号中的类型，如T、K、V等； WildcardType：通配符类型，表示泛型尖括号中带有上限或下限的通配符表达式，如? extends String、? super String等. 泛型经过编译后会被自动擦除，所以最终JVM中运行的都是Class文件，Class类是反射的基础。 当一个成员变量被定义在类中的时候，它的编译时类型就已经确定，当我们通过Class对象获取到这个成员变量的Field对象后，就可以通过Field的getType方法返回它的编译时类型，即这个成员变量的数据类型，getType方法会返回一个Class对象，代表这个数据类型的Class对象，如下： 12345678910111213public class Main &#123; public String str = \"123\"; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException &#123; Class&lt;Main&gt; mainClass = Main.class; Field field = mainClass.getField(\"str\"); //调用Field的getType方法返回Field对应变量的数据类型 Class&lt;?&gt; type = field.getType(); //输出：java.lang.String System.out.println(type.getName()); &#125;&#125; 但是如果这个成员变量的类型是一个泛型，那么Field的getType方法返回的Class对象就会丢失了泛型尖括号中的类型参数，例如：Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;()；获取到map变量的Field对象后，调用getType方法返回的Class类就是java.util.Map，丢失了尖括号中的类型参数信息，所以如果成员变量的类型是一个泛型，你可以通过Field的getGenericType方法返回它的参数化类型ParameterizedType，通过ParameterizedType就可以获取到泛型信息，如下： 1234567891011121314151617181920212223242526272829public class Main &#123; public Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); public static void main(String[] args) throws NoSuchFieldException&#123; Class&lt;Main&gt; mainClass = Main.class; Field field = mainClass.getField(\"map\"); //调用Field的getGenericType方法返回Field对应变量的数据类型 //注意：getGenericType方法的返回值是一个Type类型，这说明它可以向下转型为Class、ParameterizedType、GenericArrayType、TypeVariable、WildcardType中的一个 Type type = field.getGenericType(); //我们已经知道它是一个泛型 if (type instanceof ParameterizedType) &#123; //强转为参数化类型ParameterizedType ParameterizedType parameterizedType = (ParameterizedType) type; //通过ParameterizedType的getRawType方法返回它的原始类型 Type rawType = parameterizedType.getRawType(); //通过ParameterizedType的getActualTypeArguments方法返回泛型中的类型信息 Type[] types = parameterizedType.getActualTypeArguments(); System.out.println(\"原始类型：\" + rawType.getTypeName()); for(Type t : types)&#123; System.out.println(\"类型形参： \" + t.getTypeName()); &#125; //输出： //原始类型：java.util.Map //类型形参： java.lang.Integer //类型形参： java.lang.String &#125; &#125;&#125; 可以看到，如果成员变量的类型是一个泛型，就可以通过ParameterizedType的getRawType方法返回它的没有泛型信息的原始类型，通过ParameterizedType的getActualTypeArguments方法返回它的泛型信息，getActualTypeArguments方法它的返回值是一个Type数组，因为泛型的&lt;&gt;中会有多个Type，所以如果泛型的&lt;&gt;中某个Type是一个类型变量T，那么就可以把这个Type转成TypeVariable，通过TypeVariable的相应方法获取更多关于T的信息，如果&lt;&gt;中某个Type是一个通配符类型? extends XX或？super XX，那么就可以把这个Type转成WildcardType，通过WildcardType的相应方法获取更多关于通配符的信息，GenericArrayType同理。 所以对于数据类型为基本类型或原始类型的成员变量来说，通过getType方法就可以获取它的相应类型的Class对象；对于数据类型含有泛型的成员变量来说，就可以通过getGenericType方法获取它的相应类型，它返回一个Type，这个Type可以向下转型为ParameterizedType、GenericArrayType、TypeVariable中的一个，通过实际类型的相应方法获取泛型信息。 结语本文通过对Class、Constructor、Method、Field、Type的基本使用来简单的介绍了一下java的反射，正是由于反射的存在，才使得java具有动态性、灵活性，反射在一些java的框架上应用非常广泛，如Spring等，对于我们平常开发的应用，主要就是本文的内容，同时反射也会和一些设计模式结合使用，让设计模式具有更好的扩展性，具体可以查看以下两篇文章: 工厂方法模式 静态和动态代理模式 但同时反射也有它的缺点，反射的缺点就是执行效率低，因为反射需要按名称来检索类和方法，有一定的时间开销，同时反射会很容易破坏类的原本结构，所以在一些不必要的场景下不要频繁的使用反射。 以上就是本文的全部内容，希望大家有所收获！ 参考资料： java中的Type 了解神秘的Java反射机制","tags":[{"name":"反射","slug":"反射","permalink":"http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"}]},{"title":"这是一份关于HTTP协议的学习总结","date":"2020-01-17T07:33:15.000Z","path":"2020/01/17/Http网络请求浅析/","text":"前言随着互联网的发展，网络已经越来越普及了，绝大多数的网络请求都是基于HTTP协议的，因此在开发中，了解HTTP的基本原理是必要的，在TCP/IP四层体系结构中，HTTP协议位于应用层，它是应用层主要使用的协议，应用层往下一层就是运输层，HTTP在运输层采用的是TCP协议来保证可靠传输，知道这些后，接下来详细介绍一下 Http。 一、HTTP协议版本演变 我们先来简单了解一下 HTTP 协议的历史演变： HTTP/1.0：1996年，HTTP/1.0 版本发布，可以传输文字，图像、视频、二进制文件，它的特点是每次请求都需要建立一个单独的TCP连接，发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接，上一次请求和下一次请求完全分离，这种非持续连接过程又叫做短连接。它的特点也是它的缺点，客户端和服务端每次请求都要建立TCP连接，而建立TCP连接和关闭TCP连接都是相对比较费时的过程，严重影响客户端和服务端的性能。 HTTP/1.1：1997年，HTTP/1.1 版本发布，1999年广泛应用于各大浏览器网络请求中，直到现在HTTP/1.1也是使用最为广泛的HTTP协议，它进一步完善了HTTP/1.0，HTTP/1.1支持在一个TCP连接上传送多个HTTP请求和响应，即一个TCP连接可以被多个请求复用，减少了建立和关闭连接的消耗延迟，一定程度上弥补了HTTP/1.0每次请求都要创建连接的缺点，这种持续连接过程又叫做长连接，HTTP/1.1默认使用长连接。 HTTP/2.0：2015年，HTTP/2 .0版本发布，前面的两个版本都是基于超文本的协议，HTTP 2.0把基于超文本的协议改成了基于二进制的，把HTTP请求和响应变成数据帧，这样易于实现多路复用，在一个TCP连接上可以同时“混合”发送多个HTTP的请求和响应，效率大大提高。 *长连接和多路复用的区别: * 上面讲到HTTP/1.1的长连接和HTTP 2.0的多路复用都是复用TCP连接，它们之间有什么区别呢？在讲解它们的区别之前先来聊一聊HTTP/1.1的长连接，HTTP/1.1的长连接可以分为非流水线和流水线工作方式： 非流水线：在同一个TCP连接下，客户端的下一个请求只有收到当前请求的响应后才能发出； 流水线：又称Pipelining、管道化，在同一个TCP连接下，客户端可以连续的发送请求，而不用等待响应返回，当请求一个接着一个到达服务器时，服务器能够连续发回响应； 如图： 所以你会发现非流水线工作方式的长连接的若干个请求只能排队发送，后面的请求等待前面请求的响应返回才能获得执行机会，一旦有某请求处理超时，后续请求只能被阻塞，这样会导致TCP连接空闲，浪费资源；而流水线工作方式的长连接就可以连续的发送多个请求而不必等待响应的返回，这样看起来效率提高了一些。 所以流水线工作方式就是好的吗？这里根据我查到的资料是：Pipelining在现代浏览器中是默认关闭的，因为由于技术和安全的关系，实现Pipelining在HTTP/1.X上是很复杂，同时Pipelining技术不支持所有的请求方法，而且就算开启了，由于队头阻塞的存在，它的效率也不会提高多少，假设多个请求按顺序 (现实情况可能由于网络拥堵不会按顺序到达) 到达服务端，多个请求会在服务端缓存那边排队，如果第一个请求处理时间过长，会导致后面的请求阻塞，而且很有可能后面有优先级更高的请求，这样导致高优先级请求不能被优先处理，所以不管有没有流水线工作方式，请求还是要排队处理，队头阻塞还是存在，流水线工作方式只能说是对非流水线方式的一种改进。 那么就没有办法提高响应效率了吗？为了解决这些问题，HTTP1.x支持在同一个域名(host)下建立多个TCP连接，现代浏览器支持同时建立5~10个TCP连接，即支持并行发送请求，每个浏览器都有一个Max-Connection最大连接限制，例如谷歌浏览器的Max-Connection值为6，即同一个域名下最多建立6个TCP连接，一次最多同时发送6个请求，超过限制后续请求就会被阻塞。 所以，综上所述，由于Pipelining技术在浏览器中默认是关闭的，所以HTTP1.1长连接的工作方式是非流水线形式，为了实现并行发送请求只能通过建立多个TCP连接，这在HTTP1.x时代中已经很不错了，但是随着技术的发展，现在一个网站每秒简简单单就上百个请求，而频繁的建立和保留TCP连接又是一件工作量不小的工作，所以并行TCP连接带来的效率有时也会很低。 所以为了解决以上所有问题，HTTP/2.0就诞生了，HTTP/2.0的多路复用(multiplexing)才是做到了同一个TCP连接下的真正的并发请求，多个请求可同时在一个TCP连接上并行发送，某个请求任务超时，不会影响到其它连接的正常执行，而且每个请求都可以分配优先级，优先级高的先执行。 如图： HTTP/2.0从协议的层面改进了HTTP，是未来的应用，对于HTTP2.0的更多优点可以查看HTTP2.0新特性, 由于HTTP/2.0还未大规模应用，所以下面的讨论都是围绕HTTP/1.x。 HTTP1.1的长连接在浏览器中是默认开启的，通过指定首部Connection：Keep-Alive，后面会讲到长连接的工作原理。 二、HTTP工作过程 HTTP是基于TCP的应用层协议，从更高层次封装了TCP的使用细节，使得网络操作更为简单，一个HTTP请求就是一个典型的C/S模式，HTTP协议首先要和服务端建立TCP连接，当建立TCP连接的三报文握手的前两次报文握手完成后，在第三次握手，客户端就把HTTP请求报文作为第三个握手报文的数据发送给服务端，服务端收到请求报文后，就把所请求的文档作为响应报文返回给客户端，如下： HTTP的工作特点可以总结为以下3点： 1、面向无连接的：即通信双方在交换HTTP报文时不需要向建立HTTP连接，但HTTP使用了面向连接的TCP作为运输层协议； 2、无状态的：服务端不会记得每个客户访问的状态，同一个客户访问两次服务端上的页面时，服务端响应与第一次访问相同，所以出现了Cookie/Session机制维护连接的状态； 3、面向事务的：即对一系列信息的交换，要么所有信息交换都完成，要么一次交换都不进行。 三、HTTP的请求方法 HTTP协议提供了几种请求方式，大家熟知的请求方式有8种GET、POST、DELETE、PUT、HEAD、TRACE、OPTIONS、CONNECT，其中最常用的是PUT（增）、DELETE(删)、POST（改）、GET（查）。下面以一张表来看看它们各自的作用。 请求 作用 GET 获取资源：客户端通过URL获取服务端中的某个资源，请求参数放在URL中，然后服务端返回对应资源给客户端 POST 传输实体主体：POST请求通常会用来提交HTML表单，把数据填在表单中，传给服务器，然后服务器对这些数据进行处理，虽然GET方法也可以用来传输主体实体，但是一般采用POST方法 PUT 传输文件：与GET相反，PUT向服务器写入数据，一般用来传输文件，把需要传输的文件放在请求报文的主体上，然后保存到URL指定的位置 DELETE 删除文件：与PUT相反，DELETE请求求服务器删除URL所指定的资源，请求参数放在URL中，但是服务端可以在客户端不知情下撤销此请求 HEAD 获取报文首部：HEAD与GET类似，但服务器在响应中只返回首部不会返回主体部分，HEAD是用来在不获取资源的情况下获取资源的首部进行检查，如查看响应的状态码，看看资源是否被修改，对象是否存在 TRACE 追踪路径：客户端发起一个请求时，可能要穿过防火墙，代理，网关等，每一个中间点都会修改HTTP原始请求报文，TRACE允许请求最终发送给服务端时，看看它最终变成什么样，服务端会返回一个状态码200 OK的响应报文，报文主体包含了TARCE信息 OPTIONS 询问支持的方法：OPTIONS询问服务端支持的用来查询指定URL资源的方法，这就让客户端不用访问那些实际的资源就能判定访问各种资源的最优方法 CONNECT 要求使用隧道协议连接代理：CONNECT要求在与代理服务器通信时建立隧道，实现用隧道进行TCP通信，隧道就是经过加密的通信信路，一般使用SSL/TLS协议把通信内容加密后经隧道传输 HTTP/1.0支持的方法有： GET、POST、PUT、HEAD、DELETE； HTTP/1.1新增的方法有： OPTIONS、TARCE、CONNECT。 代理服务器：代理服务器是一种具有转发功能的服务器，它扮演了服务器和客户端之间的中间人角色，它可以接收客户端发来的请求并转发给服务端，也可以接收服务端返回的响应并转发给客户端，在这个过程中它不会改变任何URL，报文每经过一个代理服务器，都需要在首部via字段的末尾插入一个可以代表代理服务器的独特的字符串, 代理服务器主要作用有：缓存代理(减少网络带宽)、访问控制(提高安全性)等。 四、HTTP的报文格式 用于HTTP协议交换的信息称为HTTP报文，客户端发出的HTTP报文叫做请求报文，服务端返回的HTTP报文叫做响应报文，它们都是由多行数据构成的字符串文本，用CR + LF (回车符 + 换行符) 作为换行符，HTTP报文大体分为报文首部和报文主体两块，由第一个出现的空行(CR + LF)划分，其中报文主体不是必须的，如下： 其中报文首部又可以分为：开始行、首部行；开始行根据报文的不同又分为：请求行、状态行；首部行根据报文的不同与首部字段的作用又可以分为：请求首部字段、响应首部字段、通用首部字段、实体首部字段。 下面分别简单介绍一下HTTP的请求报文和响应报文： 1、请求报文一个HTTP的请求报文通常由请求行，请求首部，空行(CR + LF)，请求主体4个部分组成，如图： 请求行 又叫起始行，就是报文的第一行，在请求报文中说明要以什么方式做什么请求； 请求首部又叫首部，在请求行之后，由零个或多个首部字段组成，每个字段包含一个key和value，用冒号 : 分割，如Connection：keep-Alive，每个首部字段以一个CR + LF结束； 请求主体又叫主体，其中可以包含任意类型的数据，如图片，视频、文本等，而请求首部和请求行只能是文本形式，在请求主体中包括了要发送给Web服务端的数据。 不同的请求方式，它们的请求报文格式可能有点差别的，有些请求方式它的请求主体为空，有些则不为空，但是请求行和请求首部是必须存在的，下面以GET、POST请求报文举例： 1.1、GET的请求报文对于GET方法来说，它所有的请求参数都是拼接在URL最后，第一个参数前通过”?”连接，然后请求参数按照”key=value”格式进行追加，每个请求参数之间通过”&amp;”连接，如 ： http://www.myhost.com/text/?id=1&amp;name=rain 这个URL对于GET请求表示获取 http://www.myhost.com/text/ 位置下用户id为1，名为rain的文本，相应的请求报文格式如下： 123GET /text/?id=1&amp;name=rain HTTP/1.1Host: www.myhost.comCache-Control: no-cache 从上面的HTTP请求报文格式知，第一行为请求行，表明请求方式为GET，子路径为 /text/?id=1&amp;name=rain，HTTP版本为1.1，后两行为请求首部，Host为主机地址，Cache-Control为no-cache，表示客户端不接受服务端缓存过的资源，而GET的请求参数都在URL中，所以请求主体为空。 注意：对于URL的最长长度，不同的浏览器又不同的限制，大约为1024字节（1KB）。 1.2、POST的请求报文对于POST方法来说，它们的报文格式一般是表单格式，也就是说请求参数存储在请求主体位置上，如下： 123456789101112131415161718192021POST /local/ HTTP/1.1Host: www.myhost.comAccept-Encoding：gzipContent-Length: 222222Content-Type: multipart/from-data；boundary=dRGP2cPPTxE6WRTssnh4jC7HJLcSdeConnection：Keep-Alive--dRGP2cPPTxE6WRTssnh4jC7HJLcSdeContent-Disposition：from-data；name=“username” //name = usernameContent-Type：text/plain：charset=UTF-8Content-Transfer-Encoding: 8bitrain //value = rain--dRGP2cPPTxE6WRTssnh4jC7HJLcSdeContent-Diaposition:from-data:name=\"image\" //name = imagefilename=\"/storage/emulated/0/image/1234.png\"Content-Type:application/octet-streamContent-Transfer-Encoding:binary//...省略二进制数据 //value = 二进制数据--dRGP2cPPTxE6WRTssnh4jC7HJLcSde-- 上述的请求报文的含义是向 http://www.myhost.com/local/ 这个地址发送一个POST请求，接受的内容编码方式为gzip，请求的数据长度为222222字节，请求的数据格式为 multipart/from-data（表单），报文的boundary值为dRGP2cPPTxE6WRTssnh4jC7HJLcSde，Keep-Alive为开启长连接，空行之后，接下来就是请求报文的主体，主体有两个请求参数： 一个是名为username，值为rain的文本； 一个是名为image，值为二进制数据的图片. 请求参数是以两横杠+boundary开始的，然后是请求参数的一些首部，又称实体首部字段，如参数名，格式等，然后加上一个空行，最后才是参数的值，如上述的username=name，其表示如下： 123456--dRGP2cPPTxE6WRTssnh4jC7HJLcSde //两横杠加boundary作为参数的开始Content-Disposition：from-data；name=“username” //name = usernameContent-Type：text/plain：charset=UTF-8Content-Transfer-Encoding: 8bit rain //value = rain 当报文主体中包含多个参数时，都要遵守这种格式：每个参数以两横杠+boundary分隔，参数首部字段与值之间有一个空行。 请求主体的最后是以两横杆+boundary+两横杠作为整个报文的结束符，如上面报文的最后一个参数 (图片二进制数据) 最后的- -dRGP2cPPTxE6WRTssnh4jC7HJLcSde- -，如下： 12345678--dRGP2cPPTxE6WRTssnh4jC7HJLcSde //两横杠加boundary作为参数的开始Content-Diaposition:from-data:name=\"image\" //name = imagefilename=\"/storage/emulated/0/image/1234.png\" Content-Type:application/octet-streamContent-Transfer-Encoding:binary //不可省略的空行//...省略二进制数据 //value = 二进制数据--dRGP2cPPTxE6WRTssnh4jC7HJLcSde-- //整个报文的结束符 2、响应报文一个HTTP的响应报文通常由状态行、响应首部、空行(CR + LF)、响应主体组成，如下： 状态行 在响应报文中粗略的说明了报文的执行结果； 响应首部 又叫首部，在状态行之后，由零个或多个首部字段组成，每个字段包含一个key和value，用冒号 : 分割，每个首部以一个CR + LF结束； 响应主体 其中可以包含任意类型的数据，如图片，视频、文本等，而首部和状态行只能是文本形式，在响应主体中包含了服务端要返回给客户端的数据. 可以看到响应报文与请求报文的格式类似，最大的不同的就是第一行用状态信息代替了请求信息，格式如下： 1HTTP-Version Status-Code Reason-Phrase CRLF 其中HTTP-Version代表HTTP协议版本，Status-Code代表响应状态码，Reason-Phrase代表状态码的文本描述，其中状态码的5种取值范围如下： 取值范围 含义 100~199 信息状态码，表示请求已被接收，正在处理 200~299 成功状态码，表示请求已被成功处理 300~399 重定向状态码，表示完成请求必须要进行进一步的操作 400~499 客户端错误状态码，表示客户端请求有语法错误或请求无法实现 500~599 服务端错误状态码，表示服务端处理请求时出错 例如这是一个GET请求的返回的响应报文格式： 123456789HTTP1.1 200 OKData:Sat, 30, Dec 2006 23:23:00 GMTContent-Type:text/html；charset=UTF-8Content-Length:852&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt; //...省略文档内容&lt;/html&gt; 上面HTTP响应报文表示，HTTP协议版本为1.1，响应状态码为200，表示请求成功，返回数据的类型为text/html（html）, 编码为UTF-8，返回数据的内容长度为852字节，空行之后，接下来就是返回的数据，是一个html文档。 五、常见的状态码 状态码的职责是当客户端向服务端发送请求时，描述服务端返回的请求结果，借助状态码，我们就可以得知服务端是正常处理了请求，还是出现了错误，下面是开发中经常遇见的状态码： 1、2XX成功2XX的响应结果表示请求被正常处理了. 200 OK：该状态码表示从客户端发来的请求在服务端被正常处理了，在返回的响应报文中，随状态码返回的信息会因为请求方法的不同而不同。例如GET方法，响应报文的主体会包含请求的资源，而对于HEAD方法，响应报文不包含主体部分，只包含响应首部； 204 No Content：该状态码表示服务端接收的请求已成功处理，但是在返回的响应报文中不包含主体部分，这说明请求处理成功，但是没有任何资源返回。比如当浏览器发出的请求处理后，返回204响应，那么浏览器显示的页面将不会发生任何更新； 206 Partial Content: 该状态码表示客户端进行了范围请求，而服务端成功返回了这一部分范围的资源，即响应报文的主体部分中会包含由Content-Range指定范围的内容。 2、3XX重定向3XX的响应结果表示客户端需要执行某些特殊操作后，服务端才能继续处理请求. 301 Moved Permanently：永久性重定向，该状态码表示请求的资源已被分配了新的URL，以后都应使用新的URL来访问该资源，这时响应报文首部的Location字段会提示新的URL。例如你使用这个最后忘记加斜杠 / 的地址 http://www.myhost.com 来访问服务端，就会返回301状态码，提示你使用正确的地址访问，不过这些重定向的操作浏览器在背后已经替我们处理了，所以用户是无法感知的； 302 Found：临时重定向，该状态码表示请求的资源暂时被分配了新的URL，本次应使用新的URL来访问该资源，302和304的区别就是一个是临时性，一个是永久性，302代表资源不是被永久移动，而是临时移动，即本次会重定向到地址a，下一次可能会重定向到地址b或者不变，所以响应报文首部的Location字段提示的新URL并不是永久性的，而是临时性的； 303 See Other：临时重定向，该状态码表示请求的资源暂时被分配了新的URL，本次应使用新的URL通过GET方法来访问该资源，303和302功能相似，但是303明确表示客户端重定向时应采用GET方法获取资源，而302就没有这个要求。（但是在现实中，大部分浏览器都没有遵循规范，不管是301、302还是303，都会把POST改成GET，然后重新获取资源）； 304 Not Modified：304虽然被划分在3XX中，但是它和重定向没有任何关系，该状态码表示客户端访问的资源存在，但是未符合请求的附带条件，不允返回，这时返回的304响应报文不包含主体部分，请求的附带条件是指请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部。例如客户端想要检查本地资源缓存是否过期，就在GET请求中附带If-Modified-Since条件，If-Modified-Since的值是本地资源的Last-Modified(上一次修改时间)的值，服务端接收请求后，就会检查资源在服务端的上一次修改的时间是否比If-Modified-Since的值更新，如果没有，说明资源没有被修改过，返回304响应报文，告诉客户端可以继续使用本地缓存。(关于HTTP的缓存机制可以查看HTTP 协议缓存机制详解 )。 3、4XX客户端错误4XX的响应结果表示客户端发生错误的原因所在. 400 Bad Request：该状态码表示客户端的请求报文中有语法错误，不能被服务端理解，当发生该错误后需要修改请求内容后再次发送； 401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证的认证信息，401的响应报文会包含一个被请求资源的WWW-Authenticate首部用来质询用户信息，当浏览器初次接收到401响应，会弹出认证窗口，当浏览器第二次收到401响应，表示认证失败； 403 Forbidden：该状态码表示服务端收到了请求，但是拒绝提供服务，服务端不会给出拒绝的详细理由，例如没有文件的访问权限等都会返回404响应； 404 Not Found：该状态码表示请求资源在服务端上不存在，或者服务端拒绝请求但不想说明理由也会返回404； 4、5XX服务端错误5XX的响应结果表示服务端发送错误的原因所在. 500 Internal Server Error：该状态码表示服务端执行请求时发生了不可预估的错误，它表明服务端Web应用存在bug或其他故障； 503 Server Unavailable：该状态码表示服务端当前不能处理客户端请求，一段时间后可能恢复正常，它表明服务端暂时处于超负载或停机维护状态，如果服务端得知故障恢复时间，它会在响应报文的Retry-After首部字段写入返回给客户端。 更多状态码信息请访问HTTP状态码 六、常见的首部字段 下面列举了HTTP/1.1中的47种常见首部字段，分为通用首部字段、请求首部字段、响应首部字段、实体首部字段： 1、通用首部字段表示请求报文和响应报文双方都会使用的首部。 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 允许客户端和服务端指定与请求/响应连接相关的选项 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 告知接收端为了保证报文的可靠传输性，对报文采用了什么的编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 ### 2、实体首部字段 表示请求报文和响应报文的主体的实体部分使用的首部，主要作用是补充资源内容的更新时间与实体相关的信息，可以看到大多都是以Content开头的。 首部字段名 说明 Allow 资源可支持的 HTTP 方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小 Content-Location 替代对应资源的 URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 3、请求首部字段表示从客户端向服务端发送请求报文时使用的首部，主要作用是补充请求的附加内容、客户端信息、响应内容相关优先级、编码等信息。 首部字段名 说明 Accept 客户端可识别的内容类型列表 Accept-Charset 客户端可识别的字符集 Accept-Encoding 客户端可识别的数据编码 Accept-Language 客户端可识别的语言（自然语言） Authorization Web 认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求的主机名 If-Match 比较实体标记（ETag） If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与 If-Match 相反） If-Range 资源未更新时发送实体 Byte 的范围请求 If-Unmodified-Since 比较资源的更新时间（与 If-Modified-Since 相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中 URI 的原始获取方 TE 传输编码的优先级 User-Agent 发出请求的浏览器类型，可以自行设置 4、响应首部字段表示服务端向客户端返回响应报文时使用的首部，主要作用是补充响应的附加内容、要求客户端附加额外的内容等信息 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定 URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP 服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 下面列举几个对HTTP首部的常见使用。 5、具体应用5.1、 长连接原理从HTTP/1.1起，默认都开启了长连接保持连接特性，通过在首部指定Connection：Keep-Alive，Keep-Alive也是一个首部，简单地说，当一个网页打开完成后，客户端和服务端之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务端上的网页，会继续使用这一条已经建立的TCP连接，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同服务端软件中设置这个时间。 那么，长连接是如何工作的呢？长短连接是运输层（TCP）的概念，HTTP是应用层协议，它只能说告诉运输层我打算一段时间内复用TCP通道，而没有自己去建立、释放TCP通道的能力，那么HTTP是如何告诉运输层复用TCP通道的呢？分为以下几个步骤： 1、客户端第一次发送请求报文时，顺带发送一个Connection: Keep-Alive的Header，表示需要保持连接，同时客户端可以顺带发送Keep-Alive: timeout=5, max=100这个Header给服务端； 2、然后服务端识别Connection: Keep-Alive这个Header，并且通过响应报文Header带同样的Connection: Keep-Alive，告诉客户端我可以保持连接； 3、客户端和服务端之间通过保持的TCP连接收发数据； 4、当客户端最后一次发送请求报文，顺带发送Connection：close这个Header，表示长连接关闭。 Keep-Alive: timeout=5,max=100表示TCP连接空闲时最多保持5秒，长连接接受100次请求就断开，长连接虽好，但是长时间的TCP连接容易导致系统资源无效占用，浪费系统资源，所以需要有一些限制。 Connection首部除了用于管理连接外，还能控制不再转发的首部，格式为：Connection: 不再转发的首部，当经过代理服务器时，代理服务器会把Connection首部字段中指定的首部删除后，再把报文转发给服务端。 5.2、内容协商一个网站在服务器中可能有多种语言版本、有多份相同内容的页面，例如英文版的网页和中文版的网页，在HTTP通信时客户端与服务端进行内容协商，让服务端返回最合适的内容给客户端，内容协商会以类型、字符集、编码、语言等方式为标准返回合适的响应资源。 客户端可以在请求报文中设定特定的Accept-XX首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language等，服务端根据这些字段返回特定的资源，这些字段的解释如下: Accept： 示例：Accept: text/html，image/jepg;q=0.8，video/mpeg;q=0.5，*/*;q=0.1 客户端在Accept首部中列举了它支持的内容类型，服务端从这些内容类型中挑选出一个优先级最高的类型，返回这个类型的内容给客户端，内容类型一般是type/subtybe形式，例如文本类型text/html、text/plain、…，图片类型image/jepg、image/gif、…，视频类型video/mpeg、…，等，多个类型之间用逗号 , 分隔，可以用 *** 通配符表示接受所有类型，通过q=表示优先级，与类型用分号 **; 分隔, q值越大，优先级越高，q值得范围是(0~1），如果不指定优先级，默认优先级都是1.0，内容类型放置顺序按优先级排序； Accept-Charset 示例：Accept-Charset: iso-8859，unicode-1-1;q=0.5 客户端在Accept-Charset首部中列举了它支持的字符集，服务端从这些字符集中挑选出一个优先级最高的字符集，返回这个字符集的内容给客户端，与Accept相同，可以通过q=指定字符集的优先级，并且和Accept一样，字符集的放置顺序按优先级排序； Accept-Encoding 示例：Accept-Encoding: gzip，compress，deflate;q=0.5 客户端在Accept-Encoding首部中列举了它支持的内容压缩格式，服务端从这些内容压缩格式中挑选出一个优先级最高的，把响应内容用这种格式压缩后再返回给客户端，客户端收到压缩的内容后，用相应的解压算法解压内容，再显示出来，与Accept相同，可以通过q=指定优先级，通过 ***** 通配符表示支持任意压缩格式； Accept-Language 示例：Accept-Language: zh-cn，en-us;q=0.5 客户端在Accept-Language首部中列举了它支持的语言，服务端从这些语言中挑选出一个优先级最高的，返回相应语言版本的内容给客户端，如果没有优先级最高的语言版本，就返回次优先级的语言版本，例如示例中，没有中文版时，就返回英文版。 当服务器从各种选择列表中挑选出客户端支持的类型、字符集、编码、语言后，就会在响应报文的首部指定Content-XX首部字段，告诉客户端响应内容的类型、字符集、编码、语言，例如Content-Type、Content-Encoding、Content-Language等，Content-Type表示内容类型，还会指明内容的字符集，Content-Encoding表示内容的编码类型，Content-Language表示内容的语言。 上述的内容协商叫做服务器驱动协商，即由客户端通过首部告诉服务端它支持的东西，然后服务端做出选择，但是对于用户来说，浏览器替我们做的决定不一定是最优的，例如我看不懂英文，浏览器根据代理地理位置做了判断，返回了英文版的内容，这然对用户来说不是最优的，所以还有一种叫做客户端驱动协商，由用户告诉服务端他想要什么类型的内容，这时浏览器会弹出选择列表让用户选择，用户选择后，浏览器把用户的选择填入Accept-XX首部，再发送给服务端。 5.3、Cookie机制Cookie是用来管理客户端和服务端之间的状态，它是服务器发送到客户端并保存在本地的小型文本文件，其内容为一系列的键值对，Cookie并不属于HTTP/1.x的规范，但是由于HTTP的无状态特性，Cookie被广泛应用于各大Web网站的状态管理及用户识别。 Cookie的工作过程主要使用到了Set-Cookie和Cookie这两个首部，Set-Cookie首部存在于响应报文中，Set-Cookie首部包含服务端返回给客户端状态管理使用的Cookie信息，客户端收到响应后会从Set-Cookie首部中取出Cookie信息保存到本地；Cookie首部存在于请求报文中，Cookie首部包含客户端从服务端接收到的Cookie信息，每次客户端发起请求时，都会在请求报文的Cookie首部中携带Cookie信息发送给服务端。 Cookie需要和服务端的Session配合使用，Cookie是存储在客户端中，而Session是存储在服务器端中，Session是服务端保存用户状态的方式，它们的工作过程大概如下： 1、当用户登陆网站时，填入账号、密码等信息，然后提交表单，这些信息会被放入HTTP的请求报文，然后发送给服务端； 2、服务端收到请求后，验证该用户名和密码，如果正确，则为该用户创建一个Session对象，Session对象中保存了用户的状态信息，并生成Session对象的唯一ID，称为Session ID，然后把Session对象存储到内存或数据库中，根据Session ID可以从内存或数据库获取到Session对象； 3、接着服务端把Session ID的值以name=value的形式放入响应报文的Set-Cookie首部中，其中name为Session ID的名字，value就是Session ID的值，name=value形式的Session ID就称为Cookie，Set-Cookie首部除了Session ID之外，还有一些其他信息，如Cookie的有效期、Cookie的域名范围等，然后把这个响应报文发送给客户端； 4、客户端收到响应报文之后从Set-Cookie首部中取出所有Cookie信息，然后把它保存到本地，客户端有时候会收到不止一个Set-Cookie首部，如果有多个，每个Set-Cookie首部中的Cookie信息都要保存； 5、客户端之后对同一个服务端进行请求时都会从本地取出Cookie信息，这时可以校验Cookie的有效期、路径、域名等信息，然后取出其中的Cookie值放入请求报文的Cookie首部字段，如果有多个Cookie值，Cookie首部中就用 ; 分隔，然后把这个请求报文发送给服务端； 6、服务器收到请求后，从Cookie首部中取出Cookie，从Cookie中取出Session ID，然后用Session ID从内存或数据库取出用户信息，恢复用户之前的操作状态。 下面是我登陆掘金时在响应报文找到的Set-Cookie首部，如下： 123456HTTP/1.1 200 OK//...省略很多首部Set-Cookie: ab=&#123;&#125;; path=/; expires=Fri, 15 Jan 2021 11:13:21 GMT; secure; httponlySet-Cookie: auth.sig=nl1rsPof1lOURBJ1F81MyhGsoxs; path=/; expires=Thu, 23 Jan 2020 11:13:21 GMT; secure; httponlySet-Cookie: QINGCLOUDELB=8015b18e7b6ee1bafcfd11812d999975a4db71eff5b47ab5974a1647066247c5|XiBFV|XiBFO; path=/; HttpOnlySet-Cookie: auth=eyJ0b2tlbiI6ImV5SmhZMk5sYzNOZmRHOXJaVzRpT2lKdVNYTkJVVzlOWldwMWNuSkJjamQ2SWl3aWNtVm1jbVZ6YUY5MGIydGxiaUk2SWpNMWNYZzVhME52V21wMFNuUXdVbTRpTENKMGIydGxibDkwZVhCbElqb2liV0ZqSWl3aVpYaHdhWEpsWDJsdUlqb3lOVGt5TURBd2ZRPT0iLCJjbGllbnRJZCI6MTU3OTE3MTcxNTI0OCwidXNlcklkIjoiNWI0MzcxNzNlNTFkNDUxOTFkNzljMjdhIn0=; path=/; expires=Thu, 23 Jan 2020 11:13:21 GMT; secure; httponly 可以看到它发送了4个Cookie给我，这个4个Cookie分别为ab=XX、_auth.sig=XX、_QINGCLOUDELB=XX、auth=XX，后面的一些path=XX、expires=XX、secure、httponly都是Cookie的附加信息，待会解释。 我随便点开几篇文章，它的请求报文里的Cookie首部都会携带上面的Cookie，如下： 123GET /user/5b437173e51d45191d79c27a/posts HTTP/1.1//...省略很多首部Cookie: ab=&#123;&#125;;auth=eyJ0b2tlbiI6ImV5SmhZMk5sYzNOZmRHOXJaVzRpT2lKdVNYTkJVVzlOWldwMWNuSkJjamQ2SWl3aWNtVm1jbVZ6YUY5MGIydGxiaUk2SWpNMWNYZzVhME52V21wMFNuUXdVbTRpTENKMGIydGxibDkwZVhCbElqb2liV0ZqSWl3aVpYaHdhWEpsWDJsdUlqb3lOVGt5TURBd2ZRPT0iLCJjbGllbnRJZCI6MTU3OTE3MTcxNTI0OCwidXNlcklkIjoiNWI0MzcxNzNlNTFkNDUxOTFkNzljMjdhIn0=; auth.sig=nl1rsPof1lOURBJ1F81MyhGsoxs;QINGCLOUDELB=7526744c262201bf8ae89c7035a8ce8c9eb2c663a78c233d245e9356cc89386b|XiBG2|XiBG2;//省略了一些其他Cookie值 可以看到Cookie首部都携带上了ab=XX、_auth.sig=XX、_QINGCLOUDELB=XX、auth=XX这4个Cookie。 挑一个Set-Cookie值解释一下它里面每个属性的含义，如下： 1Set-Cookie: ab=&#123;&#125;; path=/; expires=Fri, 15 Jan 2021 11:13:21 GMT; secure; httponly 可以看到服务器端返回的Set-Cookie首部值中，每个属性用分号 ; 分隔，这些属性的解释如下： 属性 解释 NAME=VALUE 表示Cookie的名称和值，上面已经说过了，它是name=value形式的，在这里Cookie为ab={}，ab就是名称，{}就是值，每一个Set-Cookie首部都必需含有这个，在客户端发送请求时，Cookie会放在Cookie首部中 path=路径 Path属性指定了服务端下的哪些路径可以接受Cookie值，以斜杠/ 作为路径分隔符，子路径也会被匹配，在这里path=/，表示根目录包括根目录下的所有子路径都可以接受这个Cookie值 domain=域名 虽然上面举的例子里没有domain属性，但是domain属性常常和path属性一起指定Cookie的作用域， domain属性指定了哪些域名的服务端可以接受Cookie，如果指定了domain属性，子域名也会包含，例如设置 domain=.example.com，则 子域名www2.example.com也可以使用这个Cookie，如果不指定，默认为当前服务端，但不包含子域名 expires=过期时间 expires属性表示Cookie的有效期，在服务端发送Cookie给客户端时，可以设定Cookie的过期时间，当省略expires属性时，Cookie的有效期仅维持到浏览器关闭之前，携带过期的Cookie给服务端是无效的，服务端发送过来的新的Cookie可以覆盖过期的Cookie secure 含有secure属性表示仅在进行HTTPS连接时，才允许发送这个Cookie httponly 含有httponly属性表示这个Cookie不能被JavaScript脚本调用，因为跨站脚本攻击 (XSS) 常常使用 JavaScript 的 *document.cookie *api窃取用户的 Cookie 信息，而Cookie附加了httponly属性后，document.cookie这个api就无法访问Cookie信息，从而避免了XSS，但是在Web页面内还是可以对Cookie进行读取操作 跨站脚本攻击 (XSS): 是指攻击者诱用户进入圈套，由用户在不知情的情况下执行攻击代码，攻击者事先编写脚本植入到用户的浏览器页面，用户在运行这些页面时就会触发脚本，发起攻击，常见的攻击有：利用脚本窃取用户的Cookie值、利用虚假输入表单骗取用户个人信息、显示伪造的图片或文章等。 七、HTTPS是什么 1、HTTP的问题讲到HTTP不得不讲HTTPS，HTTPS并非一种新的协议，HTTPS就是安全版的HTTP，由于HTTP设计简单，使用简单，导致了它存在了大量安全问题，主要体现在以下三个方面： 1、HTTP通信双方使用不加密的明文，内容可能会被窃听：HTTP是使用明文在网络上进行报文的传输，而在网络上进行传输的任何内容，都有可能被截获，例如通过一些Wireshark、Fiddler等抓包工具就可以抓取HTTP的报文，从而查看报文中的内容，而报文中的内容是未经过加密的明文，那么一些重要的信息就被别人窃取到了； 2、HTTP无法验证报文的完整性，所以报文有可能遭到篡改：无法验证报文的完整性是指通信方收到这个报文时，无法证明这个报文没有经过中间人的篡改，无法判断报文中的信息是否正确，因为HTTP在发出请求到接收响应的这段时间内，有可能被其他中间人拦截报文，中间人拦截后可能会把报文中的信息做了一些恶意的修改后才发送给通信双方，这样通信方收到报文后，就无法得知报文内容的正确性，虽然HTTP有消息摘要校验方法，但是不可靠； 3、HTTP通信不验证通信方的身份，因此有可能遇到伪装的通信方：HTTP是基于请求/响应的方式工作，只要客户端发出请求，服务端就要返回响应，在这个过程HTTP不会验证通信双方的身份，所以很有可能客户端会遇到伪装的服务端，服务端会遇到伪装的客户端，这样就会把一些重要的信息发送给伪装者。 所以，为了解决以上3个安全问题，就出现了HTTPS。 2、HTTPS的解决办法HTTPS使用加密 + 完整性保护 + 认证的方法解决上述3个问题，通过在HTTP的应用层与运输层之间加了一层SSL/TLS，如下： HTTP协议运行在TCP之上，HTTPS协议运行在SSL/TLS之上，SSL/TLS协议运行在TCP之上，使用HTTPS，所有传输的内容都要通过SSL/TLS层，加密 + 完整性保护 + 认证的工作就在SSL/TLS层中进行，换句话说HTTPS = HTTP + SSL/TLS。 SSL(Secure Socket Layer)与TLS(Transport Layer Security)都是安全性协议，TLS是以SSL为原型开发的协议，所以TLS是基于SSL，有时会把SSL和TLS统称为TLS，目前的主流使用是TLS1.2、TLS1.3。 下面简单讲解一下加密、完整性保护、认证的实现方式： 2.1、采用混合加密机制进行加密为了防止报文内容被窃听，HTTPS采用了对称加密 + 非对称加密的混合加密机制。 对称加密：算法是公开的，在对称加密算法中，加密和解密都是使用的同一个密钥，因此对称加密算法要保证安全性的话，密钥要做好保密，只能让使用的人知道，不能对外公开； 非对称加密：算法是公开的，在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的，用来加密的密钥叫做公钥，用来解密的密钥叫做私钥，公钥是公开的，所有人都可以获得，私钥就需要做好保密，只能让使用的人知道，不能对外公开，非对称密钥除了用来加密，还可以用来进行签名，因为私钥无法被其他人获取，因此通信发送方使用其私钥进行签名(加密)，通信接收方使用发送方的公钥对签名进行解密，就能判断这个签名是否正确. HTTPS在通信的时候使用对称加密，但是使用对称加密就有一个问题，如何把密钥安全的发送给对方？如果简单的通过HTTP把密钥发送给对方，就有可能被中间人截获，这样对称加密就没有意义了，所以HTTPS采用了非对称加密来发送对称加密的密钥，这个过程如下： 1、首先服务端通过非对称加密算法生成一对密钥：公钥和私钥； 2、服务端把公钥发送给客户端，私钥自己保存； 3、客户端收到公钥后，利用公钥对对称加密使用的密钥S进行加密得到T，然后再发送给服务端； 4、服务端收到T后，利用私钥解密T，得到密钥S； 5、这样客户端和服务端都拥有了对称加密使用的密钥S，在之后的通信过程中就使用对称加密进行。 在这个过程中，就算中间人得到了T和公钥，想要通过公钥把T破解得到密钥S是非常困难的，以目前的技术来说，是几乎不可能实现，所以这样比直接发送密钥安全了很多。 综上所述，混合加密使得通信过程的安全得到保证，上述是为了讲解方便，在实际中，对称密钥不会只在客户端生成的，它同时会在服务端生成，这在后面的HTTPS的通信过程中讲到。 既然非对称加密破解困难，安全，为什么通信时不一直使用？首先非对称加密的运算比对称加密的运算复杂很多，运算速度慢，所以不可能一直使用非对称加密来通信，而对称加密的运算速度比非对称加密快，效率高，所以，HTTPS就充分利用两者的优缺点，结合使用，在交换密钥时使用非对称加密保证安全，在通信时使用对称加密保证安全和效率。 2.2、采用数字签名进行进行完整性保护在讲解数字签名校验之前，先来讲一下HTTP的消息摘要校验，又称散列值校验。 消息摘要(Message Digest)：原文通过MD5、SHA-1等散列值生成算法计算出的散列值就称为消息摘要，无论输入的消息有多长，它的输出长度总是固定的，并且输出值是随机的，消息摘要生成函数是单向函数，即无法通过消息摘要恢复到原文，消息摘要广泛应用于数字签名中。 HTTP的消息摘要校验过程是这样的： 1、服务端在发送报文之前，先用散列值生成算法生成报文的消息摘要，然后把报文和消息摘要一并发送给客户端； 2、客户端接收到报文和消息摘要后，就用相同散列值生成算法(已经协商过了)重新计算报文的消息摘要，如果重新计算的消息摘与发送来的消息摘要相同，就说明报文在中途没有被篡改过，否则被篡改过； 为什么HTTP的消息摘要校验是不可靠的？假设中间人拦截了上述过程的报文，首先通过穷举法找出你所用的散列值生成算法，修改报文后，用散列值生成算法重新计算报文的消息摘要，然后替换掉原本的消息摘要，然后把修改后的报文和重新计算的消息摘要一并发给客户端，客户端按照上述相同的验证流程，会得出报文没有被篡改过的结论，但其实报文已经被被篡改过了，所以HTTP的消息摘要校验是不可靠的，HTTP的消息摘要校验不可靠主要在于中间人可以重新生成篡改后报文的消息摘要。 所以为了解决HTTP消息摘要校验的缺点，HTTPS采用了数字签名进行完整性保护，其中签名使用到了非对称加密的公钥和私钥。 数字签名(Digital Signature)：用私钥对原文进行加密后生成的密文称为数字签名，数字签名可以通过公钥进行验证，把数字签名通过公钥解密后，如果和原文相同，就说明原文是完整的，没有被篡改过。 所以采用了数字签名后，校验过程是这样的： 1、服务端在发送报文之前，先用散列值生成算法生成报文的消息摘要，然后再用私钥加密消息摘要生成数字签名，把数字签名与报文一起发送给客户端； 2、客户端接收到报文和数字签名后，先用相同的散列值生成算法重新计算报文的消息摘要，然后再用公钥解密数字签名得到报文的消息摘要，然后比较两份消息摘要是否相同，如果相同，说明报文在中途没有被篡改过，否则被篡改过； HTTPS的数字签名是如何保证可靠性的？假设中间人截获了报文，把报文修改后重新生成消息摘要，但是中间人没有私钥对生成的消息摘要进行签名，因为私钥是保密的，这样他就无法重新生成新的数字签名，由于中间人没有办法生成修改后报文的数字签名，所以这就保证数字签名的可靠性，接收方收到数字签名和报文后，通过数字签名的校验流程，就能判断出报文的正确性。 综上所述，数字签名使得消息的完整性得到保证，在HTTPS中，数字签名一般会用到数字证书的传递上，下面会讲。 为什么HTTPS要生成报文的消息摘后，再对消息摘要进行签名，而不对报文直接签名？这是因为报文内容一般都很长，而报文的消息摘要输出的长度是固定，比报文长度短，这样通过私钥进行加密的运算量就大大减少，提高效率，所以当非对称加密与消息摘要结合使用后，便形成了一种高效又安全的数字签名方案。 2.3、采用数字证书进行身份认证大家有没有发现，前面所讲的数字签名和混合加密技术，客户端都必须事先知道服务端的公钥，如果一开始公钥就被中间人篡改了，那么坏人就会被你当成好人，你就会拿着这把假的公钥和假的服务端通信，所以如何保证公钥是真正的服务端颁发，又是另外一个问题，为了保证公钥的安全可信，HTTPS通过数字证书来解决服务端的身份认证问题。 数字证书(Digital Certificate)：数字证书是由数字认证机构(Certificate Authority, 简称CA)颁发的公开密钥证书，它里面大概包含如下信息： 1、发布机构(Issuer): 表示该证书是由哪个机构（CA）颁发的； 2、有效期(Validity): 表示证书的使用期限，过了有效期，证书就失效了 3、名称（Subject)：表示证书所有人的名字，这个证书是发给谁的，一般是某个人或者某个公司名称、机构的名称、公司网站的网址等； 4、公钥(Public-Key): 表示证书所有人想要公布出去的公钥； 5、签名算法(Signature algorithm): 表示证书的数字签名所使用的加密算法，这样就可以使用证书发布机构的公钥，根据这个算法对数字签名进行解密； 6、数字签名(Digital Signature)：表示证书发行者CA对该证书的数字签名，用于保证数字证书的完整性，确保证书没有被修改过. 数字认证机构是处于客户端和服务端双方都信赖的第三方机构，由CA颁发的数字证书一定是可靠、可信的，下面来简单介绍一下服务端向CA申请数字证书的流程： 1、服务端的运营人员向CA提交自己的公钥、组织信息、域名等信息，然后CA会通过各种渠道、各种手段来判断服务端的身份是否真实，是否合法等（在这里就可以杜绝中间人非法申请证书）； 2、服务端的身份审核通过后，CA就会把服务端的公钥和证书的其他信息通过散列值算法生成一个消息摘要，然后用CA的私钥对消息摘要进行签名生成数字签名，然后把数字签名放入证书中，然后把这个证书颁发给服务端，所以数字证书最终包含服务端公钥 + 证书的数字签名 + 证书的其他信息，如下： 现在服务端拿到了数字证书，客户端第一次请求服务端时，服务端就会把这个数字证书发送给客户端，客户端收到数字证书后，就会用CA的公钥对数字证书进行数字签名的验证，如果验证通过，说明数字证书中途没有被篡改过，是可靠的，从而知道数字证书中的公钥也是可靠的，所以客户端就放心的取出数字证书中的公钥进行以后的HTTPS通信。 在对数字证书的数字签名进行验证之前，必须先知道CA的公钥，因为数字证书的数字签名是由CA的私钥进行签名的，所以CA的公钥必须安全的转交给客户端，如何安全的转交又是一个困难的问题，所以，大多数浏览器开发商发布版本时，会事先在内部植入常用的CA机构的根证书, 这些根证书中会包含CA的公钥，也就是说CA的公钥已经内置在浏览器中了。 综上所述，数字证书可以确认服务端的身份，可以解决公钥的安全发放问题，同时数字证书也是通过数字签名来验证的。 浏览器内置的CA都是常用的、信任的CA机构，所以如果服务端发来的数字证书的相关CA机构刚好不在浏览器的内置CA列表中，浏览器就会找不到该数字证书的CA公钥，就会判定该数字证书是非法，这时浏览器会提示你手动安装该数字证书的CA机构的根证书，这个时候你就要自己承担风险了，很有可能这个网站是不可信任的，安装了根证书后就可以拿到CA的公钥进行数字证书的验证，验证通过后就能与服务端通信。 打开一个由HTTPS连接 (地址栏上有一个锁的标志) 的网站，通过以下方式查看它的数字证书，如下： 3、HTTPS的通信过程在进行HTTPS通信前，必须先进行TCP三次握手建立TCP连接，然后进行TLS握手，进行完TLS握手后才会开始加密的HTTPS通信，在TLS握手的过程中主要进行密钥交换(对称加密使用的密钥)、身份认证等步骤，根据密钥交换时使用的算法不同，TLS握手可以分为RSA握手和DH握手，目前主流的是DH握手，而且RSA握手由于它没有向前保密，已经在TLS1.3中被淘汰了，关于这两个握手算法的主要细节与区别可以查看下面文章，限于篇幅，本文不展开讨论： Keyless SSL: The Nitty Gritty Technical Details HTTPS篇之SSL握手过程详解 我通过抓取各大主流网站的TLS包发现，目前HTTPS使用的TLS版本几乎都是TLS1.2和TLS1.3版本，下面的分析都是基于TLS1.2的DH握手过程，下面是我打开第一次打开csdn博客时抓取的TLS包(经过过滤后)，如下： 其中info栏的信息表示TLS握手过程中客户端和服务端之间交互时发送的TLS包的名称，有Server Key Exchange包表示它本次的握手类型是DH握手，上面的TLS握手过程可以用下图表示，如下： 上图省略了New Session Ticket包，New Session Ticket包是用于会话复用，并不是必要的，省略它并不会影响对TLS握手过程的理解，在TLS握手完成之前，报文的传输都是明文，TLS握手过程的每个步骤的解释如下： 步骤1：客户端发送Client Hello报文给服务端，表示开始TLS握手，Client Hello报文中包含客户端支持的TLS版本(Version)、支持的加密组件列表(Cipher Suites)、客户端生成的随机数(Random)等信息； 步骤2：服务端收到Client Hello报文后，如果可以开始进行通信，就会发送Server Hello报文给客户端作为回应，Server Hello报文中包含支持的TLS版本(Version)、从加密组件列表中选择的加密组件(Cipher Suite)、服务端生成的随机数(Random)等信息，其中加密组件用于告诉客户端接下来身份认证、密钥交换、对称加密等过程使用的算法； 步骤3：紧接着服务端就会发送Certificate报文，报文中包含服务端的数字证书，即公钥证书，客户端收到证书后，就会对服务端进行身份认证，身份认证使用的算法就是在步骤2协商好的认证算法，一般会使用RSA； 步骤4：接着服务端就会发送Server Key Exchange报文，Server Key Exchange报文中包含服务端根据相应的DH算法生成DH参数(PubKey)，这个DH算法就是在步骤2协商好的密钥交换算法； 步骤5: 最后服务端发送Server Hello Done报文通知客户端它完成了TLS握手的一半，服务端到目前为止向客户端发送了服务端的随机数、证书、服务端的DH参数； 步骤6：接下来客户端向服务端发送Client Key Exchange报文，Client Key Exchange报文中包含客户端根据相应的DH算法生成的DH参数(PubKey)，这个DH算法同样是在步骤2协商好的密钥交换算法； 步骤7：紧接着客户端就会使用在步骤1自己生成的随机数、在步骤2收到的服务端随机数、在步骤4收到的服务端DH参数、在步骤6自己生成的DH参数这四个参数，通过在步骤2协商好的对称加密算法来生成以后通信过程中使用的密钥，这里记为S，然后客户端就会发送Change Cipher Spec报文通知服务端对称加密使用的密钥生成完毕，接下来客户端向服务端发送的数据都会经过密钥加密； 步骤8：最后客户端发送Encrypted Handshake Message报文通知服务端它完成了TLS握手的所有内容，Encrypted Handshake Message报文包含至今所有报文的整体校验值，并用*S加密，本次握手能否成功，取决于服务端能否解密这个报文，Encrypted Handshake Message报文下面的两个Application Data报文就是客户端经过加密后发给服务端的数据，客户端到目前为止向服务端发送了客户端的随机数、客户端的DH参数； 步骤9：紧接着服务端就会使用在步骤2自己生成的随机数、在步骤1收到的客户端随机数、在步骤6收到的客户端DH参数、在步骤4自己生成的DH参数这四个参数，通过在步骤2协商好的对称加密算法来生成以后通信过程中使用的密钥，这里记为T，由于DH算法的保证：T == S，这样客户端和服务端都拥有了通信加密使用的密钥，然后服务端就会发送Change Cipher Spec报文通知客户端对称加密使用的密钥生成完毕，接下来服务端向客户端发送的数据都会经过密钥加密； 步骤10：最后服务端发送Encrypted Handshake Message报文通知客户端它完成了TLS握手的所有内容，Encrypted Handshake Message报文包含至今所有报文的整体校验值，并用*T加密，本次握手能否成功，取决于客户端能否解密这个报文。 如果客户端和服务端都成功解密了最后那个Encrypted Handshake Message报文，证明客户端和服务端的对称密钥生成完毕，TLS握手都全部完成，接下来双方都可以通过对称密钥进行加密通信，Application Data报文中的数据就是加密后的HTTP报文，当HTTPS通信结束后，由客户端主动发出Client Close Notify报文断开连接。 由上面DH握手过程可以看出，对称密钥是根据一些参数在各端生成，并不是在客户端生成后通过公钥加密传输给服务端，这样做是为了保证服务端的私钥不和对称密钥有关联，什么意思呢？如果在客户端生成密钥通过公钥加密传输给服务端，服务端可以由私钥解密出密钥，这样私钥就参与了对称密钥的解密，到也就是说，只要我拥有服务端的私钥，我就可以解密出密钥，所以如果中间人把你TLS握手过程中的所有报文拦截、保存，直到某一天服务端的私钥泄漏了，中间人就可以使用私钥在保存的报文中解密出密钥，这样，中间人就轻松的解密出客户端和服务端以后的通信内容，而通过DH参数的交换就可以避免这个漏洞，为什么DH交换就可以? 这归根到底是一个数学问题，大家可以自行查找资料。 大家只需要知道在TLS握手中，对称密钥是服务端和客户端各自生成的，服务端公钥和私钥的功能被削弱到用来进行身份认证或者签名验证，这么做的目的都是为了保证通信的向前保密、安全。 HTTPS这么安全，为什么不所有网站都使用？1、效率问题：与HTTP的明文通信相比，加密通信需要消耗更多的CPU资源与内存；2、部署问题：使用HTTPS需要有权威CA的证书颁发，从证书的选择、购买到部署都是一个耗时耗力的过程；3、成本问题：购买证书也是一笔开销. 结语网络请求已经成为了一个应用最基本的部分，所以熟悉HTTP对于我们开发很重要，我们不仅会用开发环境提供给我们的API，还要属性它的原理，本文从发展历史、工作特点、报文格式、状态码、常见首部、HTTPS这几个方面总结了一番HTTP，当然，HTTP肯定不止这一些，一篇文章是无法讲完的，限于篇幅，还有HTTP的缓存机制没有讲，这也是很重要的内容，掌握以上这些足够平常使用了。 以上就是本文全部内容，希望大家有所收获。 参考资料： 图解HTTP HTTP1.0、HTTP1.1 和 HTTP2.0 的区别 深度解密 HTTP 通信细节 HTTP/1.x 的连接管理 深入理解https工作原理 SSL中的RSA、DHE、ECDHE、ECDH流程与区别 Cookie/Session的机制与安全","tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"https","slug":"https","permalink":"http://yoursite.com/tags/https/"}]},{"title":"你知道有多少种方式实现单例模式？","date":"2019-11-16T06:32:26.000Z","path":"2019/11/16/单例模式/","text":"前言单例模式是应用最广的模式之一，也是最简单的模式，但越是简单的东西，就越容易忽略它的细节，在应用这个模式时，同一个进程内，单例对象的类必须保证只有一个实例存在，比如在一个应用中，应该只有一个ImagerLoader实例，因为这个ImagerLoader中含有线程池、缓存系统、网路请求等，创建一次需要消耗很多资源，因此，没有理由让它构造多个实例，这种不能自由的构造对象，确保某一个类有且只有一个对象实例的情况，就是单例模式的使用场景，那么你知道有多少种方式实现单例？具我所了解的，有六种，下面分别介绍。 类图简单看一下单例模式的类图： 角色介绍： Client - 高端客户层 Singleton - 单例类 实现方式以公司中的CEO来举例，一个公司中只能有一个CEO，所以CEO就是单例，可以使用单例模式来实现，下面以这个例子来实现单例. 1、饿汉方式1234567891011public class CEO&#123; //静态对象 private static CEO mCeo = new CEO(); //构造函数私有 private CEO()&#123;&#125; //公有的静态函数，对外暴露获取单例对象的接口 public static CEO getInstance()&#123; return mCeo; &#125;&#125; 这种方式叫做饿汉方式，它的关键点是： 1、构造函数私有; 2、通过一个静态方法返回一个静态对象实例. 为什么这种方式能够保证实例的唯一性呢？因为在同一个类加载器下，类的初始化只会进行一次，并且在多线程环境下，JVM会保证只有一个线程执行类的初始化，所以当我们第一次调用getInstance方法，访问mCeo静态变量时，CEO类还没有没有进行初始化，就会首先进行CEO类的初始化，类的初始化之前会经历加载、验证、准备、解析阶段，然后才到初始化阶段，在初始化阶段中JVM会执行static语句块，此时就会为CEO在java堆上为分配一块内存，然后把mCeo指向这块内存，即实例化了CEO，接着getInstance方法就会返回CEO的实例，当我们第二次调用getInstance()方法时，它会返回上次在类初始化阶段创建的CEO实例，而不会再进行一次类的初始化，所以这就保证了每次调用getInstance()方法都是返回同一个实例。 饿汉方式的优点是线程安全，类初始化时就完成实例的创建，以后调用getInstance方法获取对象实例时速度比较快，缺点是会造成类初始化过程变慢，还可能会提前初始化单例类，例如CEO中有另外一个静态方法hello()，我第一次调用时并不是调用getInstance方法而是调用hello方法，它也会进行CEO类的初始化，导致单例类也完成实例创建，但此时我并没有使用这个单例类，所以说饿汉方式的优点也是它的缺点。 类的初始化和类的实例化是两个不同的过程，在类的实例化过程中，如果发现类还未进行初始化，就会先进行类的初始化. 2、静态内部类形式1234567891011121314151617public class CEO&#123; //构造函数私有 private CEO()&#123;&#125; public static CEO getInstanse()&#123; //返回静态内部类中的静态变量实例 return SingletonHolder.mCeo; &#125; /** * 静态内部类 */ private static class SingletonHolder&#123; private static CEO mCeo = new CEO(); &#125; &#125; 静态内部类方式的关键点是： 1、构造函数私有； 2、通过一个静态方法返回静态内部类中的静态变量实例. 静态内部类形式的特点和饿汉方式一样都是基于类的初始化保证实例的唯一性，同时它在饿汉方式的基础上增加了延迟初始化，在饿汉方式中说到在CEO类初始化时，就会完成单例类实例的创建，这样就可能导致了提前初始化了单例类，造成资源浪费，而静态内部类就解决了这个缺点，当第一次初始化CEO类时并不会创建CEO实例，只有在调用getInstance方法时才会导致CEO类实例化，因为第一次调用getInstance方法时会让JVM初始化SingletonHolder类，在初始化SingletonHolder类的同时完成了CEO单例类实例的创建，然后返回CEO实例，以后调用getInstance方法时都会返回同一实例. 这种方式的优点是不仅能保证线程安全，也能保证单例对象的唯一性，同时也延迟了单例的实例化，所以这是推荐使用的单例模式；它的缺点就是第一次加载时反应稍慢。 为什么基于类初始化的单例就是线程安全的呢？这是因为类的初始化过程其实是在执行clinit方法，clinit方法又叫做类构造器，clinit方法是由编译器收集所有的静态变量赋值动作和static语句块合并形成的，在多线程环境下，JVM执行clinit方法时，会给clinit方法加锁，多个线程初始化类时，只有一个线程会获得clinit方法的执行权，其他线程会阻塞等待，等某个线程执行完clinit方法后，就完成了类的初始化，这时就会唤醒其他等待线程，其他等待线程发现类已经执行过clinit方法了，就不再重复执行了，所以这就是单例模式线程安全实现的保证，也是单例模式实例唯一性的保证。 3、懒汉模式（线程安全）1234567891011121314public class CEO &#123; private static CEO mCeo; //构造函数私有 private CEO()&#123;&#125; //方法加上synchronized关键字 public static synchronized CEO getInstance()&#123; //判空处理，保证只实例化一次 if(mCeo == null)&#123; mCeo = new CEO(); &#125; return mCeo; &#125;&#125; 这种方式叫做线程安全的懒汉模式，它的关键点是： 1、构造函数私有； 2、通过一个同步静态方法返回静态对象实例； 3、静态对象实例创建时加入了判空处理，保证只实例化一次. 通过给 getInstance方法加synchronized关键字，保证了在多线程环境下只有一个线程对CEO进行初始化，同时又加入了判空处理，避免了重复创建对象实例，保证每次调用getInstance方法都会返回同一个实例. 这种懒汉模式的优点是线程安全，单例只有在使用时才会被实例化，节约资源，即延迟初始化；缺点是第一次加载时需要及时进行实例化，反应稍慢，还有每次调用getInstance方法时都进行同步，造成不必要的同步开销，这种模式不建议使用。 还有一种叫非线程安全的懒汉模式，与线程安全的懒汉模式相比，只是少了一个synchronized关键字，不适合在多线程环境下使用，因为没有正确同步会造成创建多个实例，适合在单线程环境下使用。 4、Double Check Lock（DCL）12345678910111213141516171819public class CEO &#123; private static CEO mCeo = null; //构造函数私有 private CEO()&#123;&#125; public static CEO getInstance()&#123; //第一次判空，保证只同步一次 if(mCeo == null)&#123;//1 //synchronized语句块，锁住的是类的Class对象 synchronized (CEO.class)&#123; //第二次判空，保证只实例化一次 if(mCeo == null)&#123; mCeo = new CEO();//2 &#125; &#125; &#125; return mCeo; &#125;&#125; 这种方式的名字叫双重检查锁定，简称DCL，它的关键点是： 1、构造函数私有； 2、通过一个静态方法返回静态对象实例； 3、静态对象实例创建时加入了双重判空处理 + synchronized块，保证只同步一次和只实例化一次. 在getInstance方法中对实例进行了俩次判空：第一次判空是为了避免不必要的同步，解决了懒汉模式每次调用getInstance方法都需要同步的缺点，只有对象为null的情况下才进入synchronized块，才需要同步；第二次判空则是为了进入synchronized块后只有对象为null的情况下才创建实例，避免重复创建对象实例，而且synchronized块锁住的是类的Class对象，保证了在多线程环境下只有一个线程进入synchronized块，所以采用DCL方式每次调用 getInstance方法返回的都是同一个实例。 DCL优点是资源利用率高，第一次执行getInstance方法时单例对象才会被实例化，即延迟初始化，第一次实例化时才进行同步，减少了同步开销，并且能在大多数情况下保证单例唯一性；缺点是第一次加载反应稍慢，因为又要加锁，又要初始化对象，导致第一次调用getInstance方法返回较慢。 为什么说DCL在大多数情况能下保证单例唯一性？这说明在少数情况下DCL还是会出现问题的，问题就出现在注释2：mCeo = new CEO(); 在CEO第一次进行实例化过程中，这个实例化过程可以分为以下3步： 1、在java堆分配中CEO对象的内存空间； 2、进行CEO类的初始化过程； 3、把mCeo指向1步骤中分配的内存空间. 某些JVM会把这3个步骤进行指令重排序，变为以下顺序： 1、在java堆分配中CEO对象的内存空间； 3、把mCeo指向1步骤中分配的内存空间； 2、进行CEO类的初始化过程. 如果在单线程环境下这样是没有问题的，因为就算指令重排，在getInstance方法返回时mCeo指向的对象已经完成了初始化，但是在多线程环境下就出现问题了，假设现在有两个线程A、B，线程A执行到了getInstance方法的注释2，即进行CEO的实例化，由于指令重排，线程A先执行1、3步骤，此时mCeo已经指向了分配的内存空间，导致此时的mCeo != null，而恰好线程B此时执行到了getInstance方法的注释1，进入判断 if(mCeo == null)，因为此时mCeo != null，所以条件判断为false，不进入if语句，直接来到return语句，返回了还没初始化完毕的mCeo ，这样就可能导致程序崩溃！因为你在使用一个还未初始化完成的对象。 针对DCL的错误，有两种解决办法，第一种办法是使用Volatile关键字，因为Volatile会禁止指令重排序，保证对象实例化过程按1、2、3步骤进行；第二种办法是再加一个局部变量做一层缓冲，下面分别使用来完善DCL: 解决方法1：使用Volatile关键字12345678910111213141516public class CEO &#123; //加上Volatile关键字修饰 private volatile static CEO mCeo = null; private CEO()&#123;&#125; public static CEO getInstance()&#123; if(mCeo == null)&#123; synchronized (CEO.class)&#123; if(mCeo == null)&#123; mCeo = new CEO(); &#125; &#125; &#125; return mCeo; &#125;&#125; 熟悉Volatile特性的朋友都知道，在多线程环境下，Volatile会禁止指令重排序保证内存可见性，所以线程执行到mCeo = new CEO()时，保证CEO类初始化完毕后才把mCeo引用指向java堆的内存空间，避免另外一个线程访问到未初始化完毕的mCeo。 解决方法2：增加一个局部变量1234567891011121314151617181920public class CEO &#123; private static CEO mCeo = null; private CEO()&#123;&#125; public static CEO getInstance()&#123; //1、增加一个局部变量，同为CEO类型 CEO ceo = null; if(mCeo == null)&#123; synchronized (CEO.class)&#123; if(mCeo == null)&#123; //2、执行实例时，先实例化这个局部变量 ceo = new CEO(); //3、待局部变量实例化完毕后，才把这个实例赋值给要返回的静态变量mCeo mCeo = ceo; &#125; &#125; &#125; return mCeo; &#125;&#125; 这种方法也能够保证DCL的正确性，因为它是先把同为CEO类型的局部变量ceo实例化后，才赋值给mCeo，这就不管ceo实例化过程中怎么样重排序，在ceo还未初始化完毕之前，mCeo一直为null，当ceo实例化完毕后，mCeo才指向它，这样就避免了mCeo指向一个未初始化完毕的对象。 使用DCL时，建议使用解决方法1、2中的DCL方式。 5、枚举模式123456789public enum CEO&#123; INSTANCE; //枚举中还可以定义一些方法和字段 String name = \"ceo\"; public void doSomething()&#123; System.out.println(\"do Something\"); &#125;&#125; 枚举模式的关键点是：在枚举类中定义一个枚举，叫什么名字都可以，这里叫INSTANCE，而且只能定义一个枚举，不能定义第二个枚举如INSTANCE2。 写法简单是枚举单例最大的优点，枚举实例的创建天生就是线程安全的，并且任何情况下它都是一个单例，我们直接通过CEO.INSTANCE就可以访问到这个单例，枚举中还可以为这个单例定义一些方法，例如这里我定义了一个doSomething方法，我通过CEO.INSTANCE.doSomething()就可以调用这个方法，字段的访问同理。 那么枚举的实现原理是什么？接下来把CEO.java文件编译成CEO.class，然后通过jad工具反编译，如下： 123456789101112131415161718192021//CEO枚举类反编译后的java代码public final class CEO extends Enum&#123; //... private CEO(String s, int i)&#123; super(s, i); name = \"ceo\"; &#125; public static final CEO INSTANCE; String name; public void doSomething()&#123; System.out.println(\"do Something\"); &#125; static &#123; INSTANCE = new CEO(\"INSTANCE\", 0); //... &#125;&#125; 我省略了一些无关代码，可以看到CEO继承自一个Enum类，所以枚举类本质还是一个类，并且它是final的，所以它不可被继承，它里面的构造方法私有，并且INSTANCE字段是一个静态变量，在static语句块中实例化，所以枚举模式保持单例唯一性的本质还是基于类的初始化，它的原理和前面讲过的饿汉方式、静态内部类形式一样。 在effective java中，枚举模式被推荐为实现的单例是最好的方式。 6、使用容器实现前面所讲的方式都是针对单个类的单例，如果一个程序中存在着多种类型的单例，就可以通过一个容器把它们集中管理： 123456789101112131415public class SingletonManager extends Staff &#123; private static Map&lt;String, Object&gt; mServices = new HashMap&lt;&gt;(); private SingletonManager()&#123;&#125; public static void registerService(String key, Object instance)&#123; //加入了一个判断处理，避免重复添加 if(!mServices.containsKey(key))&#123; mServices.put(key, instance); &#125; &#125; public static Object getService(String key)&#123; return mServices.get(key); &#125; 这种方式的关键点是：将多种类型的单例注入到一个统一的管理类中，且只能注入一次(注入时判断)，在使用时根据key可以获取对象对应的单例。 这种方式可以让我们管理多种类型的单例，并且使用时通过统一的接口进行获取，例如在Android中，各种类型的服务在应用启动时都注册在Context内的一个容器中，我们需要使用各种服务时，可以通过Context的getService方法获得服务的单例，服务不能重复创建，会很消耗资源。 考虑反序列化上面所介绍的6种实现单例的方法中，除了使用容器实现单例模式的方法，其他5种方法都有以下共同的关键点： 1、构造函数私有； 2、通过一个静态方法或枚举返回单例对象； 3、在多线程环境下，确保单例类的实例只有一个. 一般要实现单例模式，做到这3个点就行了，这样就能确保在同一个进程内单例类只有一个实例存在，但是，如果你的单例类是可以保存到磁盘或通过网络传输，换句话说你的单例类是支持序列化的，那么你就要保证单例类在反序列化时不会重新创建新的对象实例，因为反序列化时会创建一个和单例一模一样的实例的，java中通过ObjectInputStream的readObject方法来实现反序列化，它里面会通过反射来创建一个新的实例，所以就算你的构造方法私有，它还是可以通过setAccessible(true)来获得单例构造器的访问权，从而创建一个新的对象实例，反序列化的本质就是反射，换句话说，反射会破坏单例模式的实例唯一性。 那么如何确保单例类反序化时不会重新创建新实例呢？只要在单例类中加入以下方法： 12345678910public class CEO&#123; private static CEO mCeo = null; //... private Object readResolve() throws ObjectStreamException &#123; //返回单例对象 return mCeo; &#125;&#125; 加入readResolve方法后就可以改变反序列化的规则，在readObject方法中，它发现该类定义了readResolve方法，它就会通过反射调用readResolve方法返回对象实例，而不是默认的通过反射重新创建一个新的对象，所以只要我们在readResolve方法中返回单例对象，readObject方法就会返回单例对象，这样就防止了单例模式被反序列化的破坏。 注意：对于枚举模式不存在反序列化重新生成实例的情况，所以对于枚举模式实现的单例不用考虑反序列化情况，因为枚举的反序列化不是通过反射实现的，而是通过其他方式实现，枚举有自己的一套处理反序列化的机制，类似于使用容器的方式，有兴趣可以自己查找资料，而对于饿汉模式、静态内部类形式、懒汉模式、DCL、容器中的单例就需要考虑反序列情况。 总结本文讲解了6种方式实现单例模式，分别是饿汉方式、静态内部类形式、懒汉模式、DCL、枚举模式和容器方式，不管使用哪种形式实现单例，其核心思想都是以下4点： 1、构造函数私有化； 2、通过静态方法获取单例； 3、保证线程安全； 4、避免反序列化重新生成实例. 这6种方式的优缺点如下： 饿汉方式 静态内部类方式 懒汉模式（线程安全） DCL 枚举模式 容器方式 优点 安全，获取单例速度快 安全，延迟初始化 安全，延迟初始化 安全，延迟初始化 写法简洁，延迟初始化，安全，反射也无法破坏单例 实现简单，获取单例速度快 缺点 提前初始化单例类，浪费空间 第一次使用反应慢 第一次使用反应慢，效率低，同步开销大 写法复杂，第一次使用反应慢 暂时没发现缺点，枚举是java5之后才加入，使用的人少，很多人不熟悉枚举 需要保证线程安全 这么多种方式实现单例模式，我们如何选择呢？ 首先如果你确保程序是在单线程环境下工作，那么推荐你使用不加synchronized关键字的懒汉模式；但是如果程序是在多线程环境下工作，这时就要考虑线程安全问题，基于类的初始化的单例模式天生线程安全，可以使用饿汉方式、静态内部类方式、枚举模式；如果你要明确的延迟初始化要求，推荐使用静态内部类方式、DCL、枚举模式；如果你有选择困难症，那不用考虑那么多了，推荐你使用DCL和静态内部类形式；不管在什么场合，都不要考虑使用加synchronized关键字的懒汉模式，它的缺点最多。 以上就是本文的全部内容，希望大家有所收获。 本文源码相关位置 参考资料： 多线程问题与double-check小结 枚举的线程安全性及序列化问题","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"java学习总结之集合框架","date":"2019-11-05T10:33:15.000Z","path":"2019/11/05/java集合/","text":"前言在JDK1.2之前，java是没有完整的集合框架的，只有一些简单的可以扩展的容器类，如Vector、Stack、Hashtable等，这些容器类它们解决了数组不能动态扩容和使用复杂的问题，到了JDK1.2之后，为了管理这些容器类，就出现了集合框架这个概念，集合框架是为了表示和操作集合而规定的一种统一的标准的体系结构，它包含三大内容：对外的接口、接口的实现和对集合运算的算法（对某一种数据结构的算法），所以有了集合框架后，容器类一般改为叫集合类，常用的集合类有：Set、List、Map、Queue，下面会首先简单介绍集合框架的整体架构，然后分别介绍Set、List、Map、Queue的各自特点。 本文源码都是基于java7 一、Collection框架图片来源Java集合类的类图 从这个类图中，可以看到各个集合类之间的继承关系，其中Map没有继承Collection接口，所以它独立出来，但是它也是集合框架的一部分，而且这里还有一个点没有画出来的是，Collection接口是继承自Iterable的，Iterable中有一个 iterator方法，它返回一个Iterator，可以用于遍历集合的元素，而Map是没有继承自Iterable的，但是它的各自实现类内部也实现了各自的Iterator，例如KeyIterator，ValueIterator和EntryIterator，通过特定方法返回，集合框架中的所有接口和类都在java.util包中，并且集合框架中所有的具体类都实现了Cloneable和Serialization接口，即它们的实例都是可以复制和可序列化的，有以下四种主要类型的集合： List(线性表)：存储一组有序的元素 Set(规则集)：存储一组不重复的元素 Map(映射表)：存储一组key-value映射，一个Map中不能包含相同的key，每个key只能映射一个value Queue(队列)：存储一组用先进先出方式处理的元素 下面分别讲解. 二、List List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置，用户能够使用索引来访问List中的元素，这类似于Java的数组，List允许有重复的元素，除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator方法，返回一个ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历List，List常见的实现类有：ArrayList，LinkedList，Stack和Vector. 1、ArrayList1transient Object[] elementData 它是一个大小可变的数组，在内存中分配连续的空间，它允许存储任意类型的对象，包括null，每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小，这个容量可随着不断添加新元素而自动增加，ArrayList是一个线程不安全的类，ArrayList是集合框架出现之后用来取代Vector类的，两者的底层原理都是基于数组的算法，几乎一模一样。 在java7之前使用new ArrayList()创建一个List对象时，会初始化一个Capacity为10的Object数组，但是我并没有存储元素，就会造成空间的浪费；从java7之后，就开始优化了这个设计，使用new ArrayList()创建一个List对象时，底层只会初始化一个Capacity为0的空数组，只有在第一次调用add方法时，才会去初始化这个数组。 2、LinkedList123456private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; //...&#125; 它使用双向链表链表存储元素，它是单向队列、双向队列、List的实现类，所以它有着多种数据结构的实现，每一种数据结构的操作方法不同，它允许存储所有元素，包括null，提供了从两端提取、插入和删除元素的方法，LinkedList是一个线程不安全的类，和ArrayList不同，虽然它实现了List接口，但是它没有索引的概念，所以LinkedList不擅长查询操作。 LinkedList类作为List接口的实现类，List中提供了根据索引查询元素的方法，如Object get(int index)，表示根据index位置获取对应的元素，但是LinkedList是链表，它没有索引的概念，所以LinkedList内部会采用遍历链表的方式获取到index位置的元素，该方法尽量少用，效率不高。 3、Vector1protected Object[] elementData; 它是一个大小可变的数组，在内存中分配连续的空间，它允许存储任意类型的对象，包括null，Vector是一个线程安全的类，它的方法都有synchronized修饰，它的常用方法如下： Vector非常类似ArrayList，由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被当前线程使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。 ArrayList是集合框架出现之后用来取代Vector类的，ArrayList中的方法实现都是基于Vector的方法实现。 4、Stack123class Stack&lt;E&gt; extends Vector&lt;E&gt;&#123; //...&#125; 它继承自Vector，是java中栈的实现，它的存储特点是LIFO，即后进先出，它把数组的最后一个元素当作栈顶，它的常用方法如下： 官方建议：如果要使用栈，尽量使用ArrayDeque，它是Deque接口的实现类，表示双向队列，Deque接口提供了LIFO的堆栈操作和更完整的set，如Deque stack = new ArrayDeque&lt;&gt;()； 5、ArrayList和Vector的区别与选择相同点： 底层都是基于数组的算法，实现的逻辑大概一致，功能相同，在很多情况下可以互用。 不同点： 1、Vector线程安全，它的方法都用synchronized修饰，而ArrayList线程不安全，但是速度快； 2、但需要扩容时，Vector默认增长一倍，而ArrayList增长50%，有利于节约空间。 如何选择？ ArrayList可以完全替代Vector，因为它效率高且节约空间，同时在线程不安全的环境下，可以使用List list = Collections.synchronizedList(new ArrayList())来返回一个线程安全的ArrayList，所以在开发中，应该先考虑使用ArrayList。 6、ArrayList和LinkedList的区别与选择相同点： 大家都实现了List接口，都是线程不安全的类。 不同点： 1、LinkedList底层数据结构是双向链表，而ArrayList底层数据结构是数组； 2、LinkedList底层采用的是链表结构的算法，所以它的插入和删除操作很快，而ArrayList底层采用的是数组结构的算法，所以它的查询和修改操作很快。 如何选择？ 如果是插入和删除操作频繁，优先考虑LinkedList，如果是查询和修改操作频繁，优先考虑ArrayList，但在平时开发中，使用ArrayList较多，根据开发环境来选择。 三、Map Map是以键-值存储元素的容器，根据关键字Key找到对应的数据Value，它常见的实现类有：HashMap、TreeMap、HashTable、LinkedHashMap. 1、HashTable123456789private transient Entry&lt;K,V&gt;[] table;private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; int hash;//Key的hashCode经过hash方法计算后的hash值 final K key; V value; Entry&lt;K,V&gt; next; //...&#125; HashTable采用了数组加链表的数据结构，能在查询和修改时分别继承数组和链表的优良特性，它是从java1就出现了，历史悠久，它是线程安全的哈希表，即它的put、get、remove等方法都加上了synchronized关键字，所以它的效率比较低，它不可以存储null键和值，它的初始容量initialCapacity 可以在构造函数时由用户指定，默认值为11，它里面有5个主要的成员，如下： count： 映射数量，Hashtable中Entry对象（映射）的个数; loadFactor：负载因子，在其容量自动增加之前可以达到多满的一种尺度，默认为0.75; threshold： 扩容阈值，对Hashtable进行扩容的阈值，等于initialCapacity * loadFactor; table[]: Entry数组，一个由Entry对象组成的链表数组，table数组的每一个数组成员就是一个链表； modCount：结构性修改次数， 记录Hashtable生命周期中结构性修改的次数，便于快速失败机制. 快速失败机制是指其在并发环境中进行迭代操作时，若其他线程对其进行了结构性的修改，这时迭代器能够立马感知到并且立即抛出ConcurrentModificationException异常，而不是等到迭代完成之后才告诉你。 当我们使用put(key, value)存储对象到HashTable中时，HashTable会先调用hash方法计算Key的hashCode，并返回新的hash值，然后通过与数组长度取模运算，定位到table数组中相应位置来储存Entry对象，如果该位置已经有元素了，即发生冲突，就调用equals() 比较Key，相同则替换旧的Value值，都不相同则创建新的Entry链入到该位置的链表中，即采用拉链法来解决冲突，在链入新的Entry前，会先检查数组是否达到threshold值，如果达到了，就需要resize，扩容（2倍 + 1）后重排。 如果使用到哈希表（HashMap、HashTable、HashSet等），作为key的对象要正确复写equals和hashCode方法。 2、HashMap123456789transient Entry&lt;K,V&gt;[] table;static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash;&lt;K,V&gt; ； //...&#125; HashMap和HashTable一样，底层都是基于hash的算法，都是数组加链表的数据结构，HashMap是非线程安全的，所以它效率高，它可以接收null键和值，HashMap中同样有size(和count一样)、loadFactor、threshold、table[]和modCount这5个重要的成员，含义都一样，HashMap的初始容量initialCapacity 也可以在构造函数时由用户指定，默认值为16，且HashMap的大小必须为2^n，如果你传入的initialCapacity 不是2^n，它会自动的替你取最接近initialCapacity 的2^n大小。 当你使用put(key, value)存储对象到HashMap中时，它的过程和HashTable的几乎一样，其中不同的有以下几点： 1、HashMap允许存储Key和Value为null的对象，如果Key为null，就会把这个映射放在数组的第一个位置，且只允许有一个Key为null的映射存在； 2、HashMap中用于定位映射在数组中的位置是通过&amp;运算，而不是HashTable那样的%运算，所以HashMap的效率更高； 3、在HashMap的插入K/V对的过程中，总是先插入后检查是否需要扩容，而Hashtable则是先检查是否需要扩容后再插入，且HashMap的扩容大小是原来的2倍，而不是2倍+1； 4、HashMap的put操作是非线程安全的，而HashTable的是线程安全的。 至于get方法，大家可以自己分析并总结出它们的不同。 在java8之后，HashMap引入了红黑树，在单个hash值存储的元素个数大于8个时，就会把链表转换为红黑树，保证在最坏的情况下查询的效率是O(logn)，n是单个hash值存储的元素个数。 3、LinkedHashMap1234567private transient Entry&lt;K,V&gt; header;private final boolean accessOrder;//false表示按照插入顺序迭代，true表示按访问顺序迭代，默认为false private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; //... &#125; LinkedHashMap继承自HashMap，在此基础上，添加了双向链表头结点header 和 标志位accessOrder ，所以LinkedHashMap就是HashMap + 双向链表，它拥有HashMap的所有特性，同时额外维护了一个双向链表用于保持迭代顺序，HashMap中有一个init方法，会在构造函数执行完后调用，LinkedHashMap重写了该方法，完成了双向链表头结点的初始化，如下： 12345//LinkedHashMap.java@Override void init() &#123; header = new Entry&lt;&gt;(-1, null, null, null); header.before = header.after = header;&#125; 我们发现这个双向链表是循环链表，通过header.after就可以拿到链表中的第一个结点，通过header.before就可以拿到链表中的最后一个结点。 所以LinkedHashMap是可以保持插入的顺序的（当你调用put时，它会把插入的元素的放到链表的底部），它还可以在构造时指定accessOrder = true来保持访问的顺序（当你调用get时，它会把访问过元素的放到链表的底部），这样当你在迭代LinkedHashMap时，它会从头到尾遍历双向链表，逐一输出双向链表的各个结点，这样就保持了LinkedHashMap的有序性，所以如果有人问你LinkedHashMap的有序性是怎样实现的，你就告诉他：LinkedHashMap通过双向列表保证元素插入或访问的顺序，并重写了HashMap 的迭代器，当你迭代LinkedHashMap时，它会把其维护的双向链表进行迭代输出，这样就保证输出的元素是有序的。 把accessOrder 置为true，就可以通过LinkedHashMap实现LRU算法 (Least recently used, 最近最少使用)，需要做到以下2个步骤：（假设当元素大于10个时就要删除最久没有被使用的元素） 1、编写一个类继承自LinkedHashMap，并重写LinkedHashMap的removeEldestEntry方法，返回size() &gt; 10; 2、在构造这个类时，通过构造函数，指定accessOrder为true. 这样当你put或get时，它会把这个元素移动到链表的底部，从而保持链表的底部的元素是最近访问过的，而链表的头部的元素是最久没有被使用过的，当元素达到10以上时，LinkedHashMap自动会把链表头部的那个元素删除掉。 4、TreeMap123456789101112private transient Entry&lt;K,V&gt; root = null;static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left = null; Entry&lt;K,V&gt; right = null; Entry&lt;K,V&gt; parent; boolean color = BLACK; //...&#125; TreeMap和前面3个Map不一样，并不是数组加链表的实现，而是基于红黑树实现的，所以TreeMap底层没有hash算法的实现，它的put、get、remove等都是基于红黑树的操作，所以Entry中就没有hash这个变量，取而代之的是left(左孩子结点)、right(右孩子结点)、parent(父亲结点)、color(是红色还是黑色结点)属性，红黑树是一颗自平衡的二叉查找树，它通过旋转和变色来保持树的平衡，保证在最坏的情况下查询的效率是O(logn)。 所以如果你想深入的了解TreeMap，你只要熟悉红黑树这种数据结构就行，推荐阅读30张图带你彻底理解红黑树。 TreeMap和LinkedHashMap一样都是可以保证元素的有序性，但TreeMap并不是保证元素的插入顺序而是保证Key的自然排序，例如对于Key为对Integer来说，其自然排序就是数字的升序，对于Key为String来说，其自然排序就是按照字母表排序，那么它是如何保证的呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private final Comparator&lt;? super K&gt; comparator;//默认构造器，comparator为null public TreeMap() &#123; comparator = null; &#125;//通过构造器指定TreeMap的comparator public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator; &#125;//以put方法举例 public V put(K key, V value) &#123; //红黑树根节点 Entry&lt;K,V&gt; t = root; if (t == null) &#123; root = new Entry&lt;&gt;(key, value, null); //... &#125; int cmp; Entry&lt;K,V&gt; parent; //首先尝试获取Comparator Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; do &#123; parent = t; //如果Comparator不为null，就使用Comparator的compare方法来比较两个Key的大小 cmp = cpr.compare(key, t.key); //... &#125; while (t != null); &#125;else &#123; if (key == null) throw new NullPointerException(); //如果Comparator为null, 就尝试把Key转成Comparable Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; //使用Comparable的compareTo方法来比较两个Key的大小 cmp = k.compareTo(t.key); //... &#125; while (t != null); &#125; //... return null; &#125; 我们发现，它的内部还有一个Comparator，可以通过构造函数指定，如果不指定默认为null，当我们添加元素时，它首先会尝试使用Comparator来比较两个元素的大小，如果Comparator为null，就尝试把Key转成Comparable，使用Comparable比较两个Key的大小，如果这个使用Key没有实现Comparable接口，就会报错，我们还发现Comparator的优先级大于Comparable，Comparable和Comparator都是用来比较大小的，关于它们的区别，推荐阅读Comparable与Comparator浅析。 所以如果有人问你TreeMap的有序性是怎样实现的，你就告诉他：TreeMap的有序性保证是通过使用Comparator或Comparable，把它保存的键值对根据Key排序，基于红黑树，从而保证TreeMap中所有键值对处于有序状态。 对于Integer、Long等包装类和String类都实现了Comparable接口，所以以它们作为Key，TreeMap可以对它们进行自然排序，但是如果你的Key是自定义类，但是没有实现Comparable接口，在你插入元素时就会报错，所以如果你的Key是自定义类，你需要为TreeMap指定Comparator或为你的自定义类实现Comparable接口，自定义排序规则。 5、HashTable和HashMap的区别与选择相同点： 底层都是基于hash算法实现，底层数据结构都是数组+链表。 不同点： 1、HashTable和HashMap的实现模板不一样，HashTable继承自陈旧的Dictionary抽象类，在java1.0引入，而HashMap是继承自AbstractMap抽象类，在java1.2引入，其中AbstractMap实现了Map接口，有很多Map的骨干实现； 2、HashTable是线程安全的，而HashMap是非线程安全的； 3、HashTable不允许存储为null的Key和Value，而HashMap允许存在一个为null的Key和多个为null的Value； 4、HashTable是把hash值通过对长度取模来定位映射在数组中的位置，而HashMap是通过与（长度-1）相与来定位映射在数组中的位置. 如何选择？ 在非并发环境下，HashMap完全可以替代HashTable，因为HashMap是非线程安全的，所以它的效率比HashTable更高，而且它是把hash值通过与（长度-1）相与来定位映射在数组中的位置，所以它比HashTable的取模运算更快。 在并发环境下，HashMap是非线程安全的，这时可以用ConcurrentHashMap来替代HashTable，ConcurrentHashMap是HashMap在并发环境下的一个实现，它不像HashTable在读写数据时直接锁住整个数组，它采用分段锁，在读写数据时只锁住你要读写的那一部分数据，所以ConcurrentHashMap可以支持多个线程执行并发写操作及任意数量线程的读操作，所以并发效率远远超过HashTable。 综上所述，在并发环境下选择ConcurrentHashMap，在非并发环境下选择HashMap。 6、TreeMap和HashMap的区别与选择相同点： 大家都继承自AbstractMap抽象类，大家的Value都可以为null的。 不同点: 1、HashMap底层是数组+链表，而TreeMap底层是红黑树; 2、HashMap中的元素是无序的，而TreeMap中所有的元素都按Key的自然排序; 3、HashMap中的Key可以为null，而TreeMap不可以。 如何选择： 如果你对集合的顺序没有要求，那么优先考虑HashMap，由于使用到hash算法，在HashMap中插入、删除和定位元素的平均效率是比TreeMap高的。 如果你对集合的顺序有要求，例如在迭代的情况下，我要求元素的输出是有序的，那么优先考虑LinkedHashMap或TreeMap，如果你希望你的元素是按插入或访问顺序排序的，你要选择LinkedHashMap；如果你对希望你的元素是按Key的自然顺序排序的，那么你要选择TreeMap。 综上所述，在没有顺序要求下，选择HashMap，因为TreeMap要保持元素的有序性，会导致效率比HashMap低，在有顺序要求下，看情况选择LinkedHashMap和TreeMap。 四、Set Set是用来操作一组唯一、无序的对象，它最多有一个null元素，它有3个常用的实现类： HashSet：用来存储互不相同的任何元素. LinkedHashSet：继承自HashSet，使用链表扩展实现HashSet类，支持对元素的排序. TreeSet：可以确保所有元素是有序的. 其中LinkedHashSet继承自HashSet，LinkedHashSet的底层实现是LinkedHashMap，HashSet的底层实现是HashMap，TreeSet的底层实现是TreeMap，所以掌握了Map就等于掌握了Set. 1、HashSet12345678910111213141516171819202122232425262728private transient HashMap&lt;E,Object&gt; map;private static final Object PRESENT = new Object();//map的Vaule，起到占位的作用public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125;public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125;//如果调用3个参数的构造函数，可以把HashSet的底层实现指定为LinkedHashMap//注意它的访问修饰符不是public，所以我们不可以使用这个构造函数，这个构造函数是内部使用的，如LinkedHashSet//这个dummy参数可以忽略，没有什么作用HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; 我们可以看到，除了最后一个构造函数，其他所有的构造函数都是根据构造参数new了一个HashMap，至于最后一个3个参数的构造函数，我们无法调用，所以我们可以说HashSet的底层实现就是HashMap，我们知道HashMap中的Key是唯一、可null、无序的，所以HashSet就利用了这一个特性，当我们往HashSet中保存元素时，这个元素就被作为Key，如下： 1234567public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; 所以我们对HashSet中元素的操作就是对其内部map的Key的操作，其实在HashMap中，Value的地位是比Key低的，Value只是作为Key的附属，有点男重女轻的思想，所以如果不需要建立映射关系，保存元素时，采用HashSet能有HashMap一样的效率。 2、LinkedHashSet123456789101112131415161718public LinkedHashSet(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor, true);&#125;public LinkedHashSet(int initialCapacity) &#123; super(initialCapacity, .75f, true);&#125;public LinkedHashSet() &#123; super(16, .75f, true);&#125;public LinkedHashSet(Collection&lt;? extends E&gt; c) &#123; super(Math.max(2*c.size(), 11), .75f, true); addAll(c);&#125; LinkedHashSet继承自HashSet，所以它的父类是HashSet，我们发现LinkedHashSet的构造函数都调用HashSet的带有3个构造参数的构造函数，在HashSet介绍中讲到，3个参数的构造函数中会把HashSet的底层实现指定为LinkedHashMap，所以LinkedHashSet的底层实现就是LinkedHashMap，而且LinkedHashSet类中只有这4个构造函数，没有重写任何方法，所以对LinkedHashSet操作就是对HashSet操作，只是HashSet的底层实现由HashMap变成了LinkedHashMap。 3、TreeSet1234567891011121314151617181920212223private static final Object PRESENT = new Object();TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m;&#125;public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;());&#125;public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;&gt;(comparator));&#125;public TreeSet(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125;public TreeSet(SortedSet&lt;E&gt; s) &#123; this(s.comparator()); addAll(s);&#125; 从构造函数发现，TreeSet的底层实现都指定为TreeMap，和HashSet的逻辑一样，就不再累述了。 4、HashSet、LinkedHashSet和TreeSet的选择区别就不讲了，和Map家族的区别差不多，这里讲一下它们的使用场景，如果不需要维护元素被插入的顺序，就应该使用HashSet，更加高效，因为HashSet底层使用hash算法来定位元素，如果产生的冲突少的话，它的效率可以达到O(1)常数级别，而TreeSet因为要保持有序性，所以就要进行比较等额外操作，它的时间复杂度为O(logn)； 如果需要保持元素的有序性，看情况选择LinkedHashSet（插入或访问有序）和TreeSet（Key自然排序或你自定义排序规则）。 五、Queue Queue通常用于操作存储一组队列方式的对象，它的特点是先进先出（FIFO），Deque继承自Queue，是双端队列的简称(double-ended queue)，支持在两端插入和删除元素，在Deque接口增加的方法有：addFirst(e)、removeFirst(e)、addLast(e)、removeLast(e)、getFirst()和getLast()等，我们常用的有LinkedList、ArrayDeque，这里就简单介绍一下： LinkedList：底层是双向链表的实现，在添加和删除元素时比ArrayList具有更好的性能，在查询和更新元素方便弱于ArrayList，如果数据量都不大，两者的性能差不多，LinkedList作为队列使用时，尽量避免Collection的add()和remove()方法，而是要使用offer()来加入元素，使用poll()来获取并移出元素，它们的优点是通过返回值可以判断成功与否，add()和remove()方法在失败的时候会抛出异常。 ArrayDeque：底层是数组的实现，这个数组是循环数组，因为要满足在数组两端插入或删除元素的需求，它可以作为队列、双端队列、栈来使用，它是官方推荐用来代替Stack的，它的默认容量为16，容量必须为2的幂次方（和HashMap的一样，因为它的底层也是通过位运算来定位元素，2^n更方便完成一些位运算的骚操作），它的性能比LinkedList还好。 以上是非阻塞队列的两个实现，在java中，还有阻塞队列这一说，它在java5中加入，使用阻塞队列更加方便的实现生产者-消费者，阻塞队列经常用于多线程环境，如线程池中，关于阻塞队列的介绍可以看java线程池，阻塞队列都继承自BlockingQueue接口 ，而BlockingQueue 继承自Queue接口。 六、集合的遍历方式集合的遍历大同小异，可以分别Collection家族的遍历和Map家族的遍历. 1、Collection的遍历以List为例，对于List来说，有3种遍历方式，分别是： 通过for循环遍历 使用迭代器遍历(对于List来说，可以使用Iterator或ListIterator) 通过foreach循环遍历（语法糖，反编译后还是通过迭代器来遍历） 12345678910111213141516171819202122List&lt;Integer&gt; list = new ArrayList&lt;&gt;()&#123;&#123; add(1); add(2); add(3); add(4);&#125;&#125;;//1、通过for循环遍历for(int i = 0; i &lt; list.size(); i++)&#123; System.out.print(list.get(i) + \" \");&#125;System.out.println();//2、使用迭代器遍历Iterator&lt;Integer&gt; listIterator = list.iterator();while (listIterator.hasNext())&#123;//hasNext()：判断当前指针后是否有下一个元素 System.out.print(listIterator.next() + \" \");//next()：移动指针，获取下一个元素&#125;System.out.println();//3、通过foreach循环遍历for(Integer num : list)&#123; System.out.print(num + \" \");&#125; 对于Set来说，它不能通过for循环遍历，它只能使用迭代器和foreach遍历，因为它没有索引的概念，对于Queue来说，它能通过循环+poll方法、迭代器和foreach遍历，如果要遍历List集合，对于ArrayList、Vector来说，使用for循环的效率更高，对于LinkedList来说，使用迭代器的效率更高。 2、Map的遍历以HashMap为例，对于HashMap来说，有2种遍历方式，分别是： 通过Map的ketSet方法返回KeySet，遍历KeySet，通过Key取出Value（二次取值） 通过Map的entrySet方法返回EntrySet，遍历EntrySet，取出Key和Value（Map数量量大时，推荐使用本方法遍历Map） 不管是KeySet还是EntrySet，它们都是Set集合，Set集合可以通过迭代器和foreach遍历，下面示例使用foreach遍历： 1234567891011121314151617Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;()&#123;&#123; put(1, \"1\"); put(2, \"2\"); put(3, \"3\"); put(4, \"4\");&#125;&#125;;//1、遍历KeySet，通过Key取出ValueSet&lt;Integer&gt; keySet = map.keySet();for(Integer key : keySet)&#123; System.out.print(key + \"--\" + map.get(key) + \" \");&#125;System.out.println();//2、遍历EntrySet，取出Key和ValueSet&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = map.entrySet();for(Map.Entry&lt;Integer, String&gt; entry : entrySet)&#123; System.out.print(entry.getKey() + \"--\" + entry.getValue() + \" \");&#125; foreach遍历底层其实还是通过迭代器遍历。 总结其实还有两个很少用到，但在特殊场景却一定会用到它的两个集合没有讲到，分别是：PriorityQueue(优先级队列)、WeakHashMap(Key为弱引用的HashMap)，PriorityQueue可以指定比较器实现小顶堆和大顶堆，WeakHashMap可以用在内存有限的环境下，防止OOM，关于它们的具体使用可以自行查阅资料。 本文主要简单介绍了集合框架中经常用到的集合类：ArrayList、LinkedList、HashMap、LinkedHashMap、TreeMap、HashSet、LinkedHashSet、TreeSet、ArrayDeque，和一些古老的容器类：Stack、Vector、HashTable，其中容器类已经不推荐使用了，它们都有各自的替代品，分别是：ArrayDeque、ArrayList、HashMap，本文还讲解了集合类之间各自的区别和使用场景，还有集合的迭代方式，在使用集合时，要善用Collections和Arrays工具类，它里面有很多对集合操作的工具方法，能在开发中简化我们的工作量。 以上就是本文的全部内容，如有错误，欢迎指出！ 参考资料： 彻头彻尾理解 LinkedHashMap 彻头彻尾理解 HashTable Java集合类详解 Java ArrayDeque源码剖析 Java中modCount的作用","tags":[{"name":"list","slug":"list","permalink":"http://yoursite.com/tags/list/"},{"name":"set","slug":"set","permalink":"http://yoursite.com/tags/set/"},{"name":"map","slug":"map","permalink":"http://yoursite.com/tags/map/"},{"name":"queue","slug":"queue","permalink":"http://yoursite.com/tags/queue/"},{"name":"集合","slug":"集合","permalink":"http://yoursite.com/tags/%E9%9B%86%E5%90%88/"}]},{"title":"通过源码全面解剖Retrofit2的整体流程","date":"2019-10-23T14:00:22.000Z","path":"2019/10/23/通过源码全面解剖Retrofit2的整体流程/","text":"前言上两篇文章： okhttp3源码分析之请求流程 okhttp3源码分析之拦截器 Retrofit与Okhttp是Android开发中最最热门的网络请求库，它们都来自square公司，Okhttp在前面的两篇文章中已经通过源码从请求流程和拦截器两个角度分析过，本文的主角是Retrofit，经过这几天的研究，我发现Retrofit只是一个对Okhttp网络请求框架的巧妙包装，它通过注解去定义一个HTTP请求，然后在底层通过Okhttp发起网络请求，就是这样的一个简单的过程，其间运用了很多的设计模式：外观模式、动态代理模式、适配器模式、装饰者模式等，其最核心的是动态代理模式，所以在此之前大家对动态代理要有一个了解： 静态和动态代理模式 其他的设计模式我会在讲解的过程中简单介绍，除了使用了大量的设计模式，Retrofit还应用了面向接口编程的思想，使得整个系统解耦彻底，本文会通过一个简单的Retrofit使用示例，然后引出Retrofit的核心类，面向接口思想、构建过程、动态代理和网络请求过程，通过这几部分来解剖Retrofit。 Retrofit的项目地址：Retrofit 本文源码基于Retrofit2.4 一、Retrofit的简单使用首先来回忆一下Retrofit的使用，我这里使用的是Github平台的开放api，这个api根据用户名获取一个用户信息，首先在你的AndroidManifest.xml中声明网络权限，然后： 1、创建一个Api接口 123456public interface GithubService &#123; @GET(\"users/&#123;user&#125;\") Call&lt;ResponseBody&gt; getUserInfo(@Path(\"user\") String user);&#125; 我用Retrofit的注解声明了一个GET请求的方法，Call是Retrofit中的Call，而不是Okhttp中的Call，而ResponseBody是Okhttp的ResponseBody。 2、创建Retrofit实例 123Retrofit Retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .build(); 使用Builder模式构建Retrofit实例，传入baseUrl，我们平常开发一般会添加Rxjava2CallAdapterFactory和GsonConverterFactory，但这里我没有使用addCallAdapterFactory(Factory)来添加CallAdapterFactory，也没有使用addConverterFactory(Factory)来添加ConverterFactory，都使用默认的CallAdapter和Converter，默认的CallAdapter返回的就是Retrofit中的Call类型，默认的Converter会把网络请求返回数据转化为Okhttp中的ResponseBody，这也就是我上面定义接口时，Cal的T是ResponseBody的原因。 3、创建Api接口实例 1GithubService service = Retrofit.create(GithubService.class); 通过Retrofit实例的create方法创建Api接口实例GithubService。 4、调用Api接口的方法，生成Call 1Call&lt;ResponseBody&gt; call = service.getUserInfo(\"rain9155\"); 调用Api接口的方法，会返回一个Call实例。 5、通过Call发起同步或异步请求，然后获取返回结果Response 123456789101112131415161718192021//同步请求Response&lt;ResponseBody&gt; response = call.execute();或//异步请求 call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response)&#123; //通过Response获取网络请求返回结果 ResponseBody body = response.body(); try &#123; Log.d(TAG, \"请求结果：\" + body.string()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; &#125; &#125;); 通过Call的execute或enqueue方法发起网络请求，当网络请求结果返回时，就可以通过Response的body方法获取，这里因为使用默认的Converter，所以获取到的body的是Okhttp的ResponseBody，log的输出结果是JSON数据。 这就是Retrofit发起网络请求的五步曲，如果除去第一步，和Okhttp的使用还是非常的相似的，因为Retrofit和Okhttp的类名有很多的重复，下面如果涉及Okhttp的相关类，我会特别说明，否则默认都是属于Retrofit的。 二、Retrofit的相关类介绍先简单的介绍一下重要的类，会对后面的阅读有帮助，当我们把Retrofir的源码clone下来，发现里面有4个主要的模块，分别是： retrofit-adapter retrofit-converters retrofit-mock retrofit 其中retrofit-mock是测试时用的，不关我们的事，和我们开发相关的是retrofit-adapter、retrofit-converters和retrofit模块，当我们没有使用外置的CallAdapter和Converters时，我们只需要依赖retrofit模块，retrofit模块中有3个非常重要的接口，分别是： Call: 网络请求执行器，用于执行同步或异步的网络请求，内部最终通过Okhttp的Call发起网络请求 CallAdapter：网络请求适配器，它用于把默认的网络请求执行器的调用形式，适配成在不同平台下的网络请求执行器的调用形式，例如Retrofit默认通过Call，内部使用ExecutorCallbackCall通过handler来执行网络请求后的线程切换，通过添加RxjavaCallAdapter后，RxjavaCallAdapter把默认的网络请求执行器适配成Observerable或Flowable，这样我可以使用Rxjava的链式调用方式来执行网络请求后的线程切换。 Converter：数据转化器，两个方向的转化，把Api接口方法的参数注解的值转化为网络请求执行器需要的数据类型，和把网络返回的数据转化为我们需要的数据类型。 还有一个Callback接口，用于回调网络请求成功或失败，很简单，就不介绍了，其中CallAdapter和Converter内部都有一个Factory类，它都是通过工厂模式创建，工厂模式就是将复杂对象的实例化任务交给一个类去实现，使得使用者不用知道具体参数就可以实例化出所需要的对象，在Retrofit中，想要获得CallAdapter或Converter的实例都需要通过Factory来获取。下面分别简单的介绍一下Call、CallAdapter和Converter接口的作用和在Retrofit下的默认实现。 1、Call网络请求执行器，用于执行同步或异步的网络请求，Call接口如下： 1234567891011121314151617181920212223public interface Call&lt;T&gt; extends Cloneable &#123; //发起同步请求，返回Response Response&lt;T&gt; execute() throws IOException; //发起异步请求，使用callback把Response回调出去 void enqueue(Callback&lt;T&gt; callback); //当执行了execute或enqueue后，该方法返回true boolean isExecuted(); //取消这次网络请求 void cancel(); //当执行了cancel()后，这个方法返回true boolean isCanceled(); //clone一个Call Call&lt;T&gt; clone(); //返回HTTP网络请求，这个Request是来自okhttp的 Request request();&#125; Retrofit的Call和Okhttp的Call接口定义的方法差不多，只是多了一个clone方法，在Retrofit中，Call的默认实现类是OkHttpCall，如下： 1234567891011121314151617181920212223242526272829303132333435363738final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123; private final ServiceMethod&lt;T, ?&gt; serviceMethod;//这个ServiceMethod很重要，它封装了Api接口方法中的注解和参数信息，一个ServiceMethod对应一个Method（在创建Api接口实例会讲到） private final @Nullable Object[] args;//代表着Api接口方法中的参数 private @Nullable okhttp3.Call rawCall;//这是一个来自Okhttp的Call private @Nullable Throwable creationFailure; private boolean executed; private volatile boolean canceled; Override public Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; //... call = rawCall; return parseResponse(call.execute()); &#125; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; okhttp3.Call call; call = rawCall; //... call.enqueue(new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123; //... callback.onResponse(OkHttpCall.this, response); &#125; @Override public void onFailure(okhttp3.Call call, IOException e) &#123; callFailure(e); &#125; &#125;); &#125; //...&#125; 一个OkHttpCall实例就代表着一次网络请求，OkHttpCall里面大部分方法的逻辑都是转发给Okhttp的Call方法。 在本文，不管来自Okhttp的Call，还是来自Retrofit的Call，都可以理解为网络请求执行器。 2、CallAdapter网络请求适配器，用于把默认的网络请求执行器的调用形式，适配成在不同平台下的网络请求执行器的调用形式，CallAdapter接口如下： 123456789101112131415161718192021222324252627282930public interface CallAdapter&lt;R, T&gt; &#123; //返回响应body转换为Java对象时使用的类型 //例如Call&lt;ResponseBody&gt;, Type就是ResponseBody，Type是来自java.lang.reflect包的 Type responseType(); //把Call&lt;R&gt;适配成 T 类型，就是将Retrofit的Call适配成另外一个T类型的'Call' T adapt(Call&lt;R&gt; call); //用于创建CallAdapter实例，通过get方法可以返回一个CallAdapter实例或null abstract class Factory &#123; //根据Api接口定义的方法的返回值和注解信息，创建一个CallAdapter实例返回，如果这个Factory不能处理这个方法的返回值和注解信息，返回null， //注意这里的returnType != 上面的responseType，例如Call&lt;ResponseBody&gt;，returnType的Type就是Call public abstract @Nullable CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit Retrofit); //返回ParameterizedType的上限，即泛型类型的上限 //例如Call&lt;? extends ResponseBody&gt;, Type就是ResponseBody protected static Type getParameterUpperBound(int index, ParameterizedType type) &#123; return Utils.getParameterUpperBound(index, type); &#125; //返回Type的原始类型 //例如Type为Call&lt;ResponseBody&gt;，返回Call.class protected static Class&lt;?&gt; getRawType(Type type) &#123; return Utils.getRawType(type); &#125; &#125;&#125; CallAdapter接口很简单，只有两个方法responseType和adapt方法，和一个Factory类，其中Factory类的get方法可以获取一个CallAdapter示例，CallAdapter的responseType方法就是获得Call中的T类型，这个Call就是我们在定义Api接口方法时方法的返回参数，CallAdapter的adapt方法用于把传入的Call适配成另外一个我们所期待的’Call’，这里使用到了适配器模式，适配器模式就是在两个因接口不兼容的类之间加一个适配器，将一个类的接口变成客户端所期待的另一种接口，从而使得它们工作在一起，至于怎么适配就需要看适配器中得adapt方法的实现，接下来我们看adapt方法在Retrofit中的默认实现。（在Android Platform下的默认实现，Platform的概念在构建过程中会讲到） 在Retrofit中，CallAdapter的默认实现是一个匿名类，可以通过CallAdapter的Factory获得，CallAdapter的Factory的默认实现是ExecutorCallAdapterFactory，如下： 12345678910111213141516171819202122232425262728293031323334353637383940final class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; //线程切换执行器（在Retrofit的创建过程中会讲） final Executor callbackExecutor; ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit Retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; //可以通过returnType获得responseType //因为returnType = Call&lt;T&gt;, 有了Call&lt;T&gt;, 当然可以获得Call中的T，而T就是responseType final Type responseType = Utils.getCallResponseType(returnType); //返回一个CallAdapter匿名类 return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; //返回responseType return responseType; &#125; @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; //默认CallAdapter的adapt方法返回 return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; //网络请求执行器（在创建Api接口实例中会讲） static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; //... &#125; &#125; 在ExecutorCallAdapterFactory的get方法中，new了一个CallAdapter返回，在CallAdapter的adapt方法实现中，new了一个ExecutorCallbackCall返回，并把入参call和callbackExecutor传进了ExecutorCallbackCall的构造中，ExecutorCallbackCall就是一个实现了Call接口的类，还是一个Call，它就是Retrofit的默认网络请求执行器，可以看到Retrofit的默认的网络请求执行器适配，即adapt方法的默认实现就是用ExecutorCallbackCall包装传进来的Call，并返回ExecutorCallbackCall，这个传进来的Call就是Call的默认实现OkHttpCall，待会在Retrofit的构建过程中还会讲到。 既然CallAdapter能把默认的网络请求执行器的调用形式，适配成在不同平台下的网络请求执行器的调用形式，那么它支持哪些平台呢？这个在retrofit-adapter 模块中可以找到答案，如下： Retrofit还支持guava、java8、rxjava、scala这四个平台，它们里面都各自实现了retrofit模块暴露出去的CallAdapter接口和CallAdapter接口中的Factory接口，在CallAdapter的adapt方法中提供各自平台的适配，我们可以通过addCallAdapterFactory(Factory)来添加不同平台的CallAdapter工厂。 3、Converter数据转化器，把我们在Api接口定义的方法注解和参数转化为网络请求执行器需要的请求类型，和把网络返回的数据转化为我们需要的数据类型，Converter接口如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243public interface Converter&lt;F, T&gt; &#123; //把F 转化为 T，用于在网络请求中实现对象的转化 T convert(F value) throws IOException; //通过Factory的responseBodyConverter或requestBodyConverter方法获得一个Converter实例或null abstract class Factory &#123; //返回一个处理网络请求响应（Response）的body的Converter实例，如果不能处理这些类型(type)和注解，返回null //这个Converter会把 ResponseBody 转化成 ?，这个ResponseBody是来自okhttp的 //例如使用GsonConverter，？代表某个java对象类型 public @Nullable Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit Retrofit) &#123; return null; &#125; //返回一个处理网络请求（Request）的body的Converter实例，如果不能处理这些类型(type)和注解，返回null //这个Converter会把 ？转化成 RequestBody，这个RequestBody是来自okhttp的 //这个Converter主要处理@Body、 @Part、@PartMap类型的注解 public @Nullable Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit Retrofit) &#123; return null; &#125; //返回一个处理网络请求（Request）的body的Converter实例 //这个Converter会把 ？转化成 String //这个Converter主要处理@Field、@FieldMap、@Header、HeaderMap @HeaderMap、@Path、@Query、@QueryMap类型的注解 public @Nullable Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations, Retrofit Retrofit) &#123; return null; &#125; //下面两个方法和上面CallAdapter的Factory中同名方法的意思一样 protected static Type getParameterUpperBound(int index, ParameterizedType type) &#123; return Utils.getParameterUpperBound(index, type); &#125; protected static Class&lt;?&gt; getRawType(Type type) &#123; return Utils.getRawType(type); &#125; &#125;&#125; Converter接口也很简单，只有一个convert方法，和一个Factory类，因为Converter要提供两个方向的转化，所以Factory类就提供了两个方法用于获取不同方向的转化，其中responseBodyConverter方法就是获得一个把网络返回的数据转化为我们需要的数据类型的Converter实例，而requestBodyConverter方法就是获得一个把我们在Api接口定义的方法注解和参数转化为网络请求的Converter实例，那么要怎么转化呢？就要看Converter的convert方法的实现，convert方法把F类型 转化为 T类型，接下来我们看convert方法在Retrofit中的默认实现。 Converter在Retrofit的默认实现有五个，都是Converter的Factory的内部类，可通过Converter的Factory获得，Converter的Factory的默认实现是BuiltInConverters，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485final class BuiltInConverters extends Converter.Factory &#123; @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit Retrofit) &#123; if (type == ResponseBody.class) &#123;//支持ResponseBody类型的转化 //如果是二进制流形式，就返回StreamingResponseBodyConverter实例 //如果是字符流形式，就返回BufferingResponseBodyConverter实例 return Utils.isAnnotationPresent(annotations, Streaming.class) ? StreamingResponseBodyConverter.INSTANCE : BufferingResponseBodyConverter.INSTANCE; &#125; if (type == Void.class) &#123;//支持Void类型的转化 //返回VoidResponseBodyConverter实例 return VoidResponseBodyConverter.INSTANCE; &#125; //除了以上两种类型，其他类型都不支持，返回null return null; &#125; @Override public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit Retrofit) &#123; //支持向RequestBody类型转化 if (RequestBody.class.isAssignableFrom(Utils.getRawType(type))) &#123; //返回RequestBodyConverter实例 return RequestBodyConverter.INSTANCE; &#125; //除了RequestBody类型，不支持向其他类型转化，返回null return null; &#125; static final class VoidResponseBodyConverter implements Converter&lt;ResponseBody, Void&gt; &#123; static final VoidResponseBodyConverter INSTANCE = new VoidResponseBodyConverter(); @Override public Void convert(ResponseBody value) &#123; value.close(); return null; &#125; &#125; static final class RequestBodyConverter implements Converter&lt;RequestBody, RequestBody&gt; &#123; static final RequestBodyConverter INSTANCE = new RequestBodyConverter(); @Override public RequestBody convert(RequestBody value) &#123; return value; &#125; &#125; static final class StreamingResponseBodyConverter implements Converter&lt;ResponseBody, ResponseBody&gt; &#123; static final StreamingResponseBodyConverter INSTANCE = new StreamingResponseBodyConverter(); @Override public ResponseBody convert(ResponseBody value) &#123; return value; &#125; &#125; static final class BufferingResponseBodyConverter implements Converter&lt;ResponseBody, ResponseBody&gt; &#123; static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter(); @Override public ResponseBody convert(ResponseBody value) throws IOException &#123; try &#123; // Buffer the entire body to avoid future I/O. return Utils.buffer(value); &#125; finally &#123; value.close(); &#125; &#125; &#125; static final class ToStringConverter implements Converter&lt;Object, String&gt; &#123; static final ToStringConverter INSTANCE = new ToStringConverter(); @Override public String convert(Object value) &#123; return value.toString(); &#125; &#125;&#125; BuiltInConverters实现了Factory中的responseBodyConverter和requestBodyConverter方法，内部含有五个Converter默认实现类，在Factory的responseBodyConverter和requestBodyConverter方法中分别返回这几Converter实例，其中只有ToStringConverter没有使用到，我们还发现了这五个Converter的convert方法的实现除了BufferingResponseBodyConverter，大部分都是，入参是是什么，返回就是什么，所以Retrofit中Converter默认实现的convert方法大部分都没有对数据进行转化，返回原始数据，这些原始数据是String或来自Okhttp的ResponseBody、RequestBody，例如ResponseBodyConverter的convert方法就是返回Okhttp的ResponseBody，RequestBodyConverter的convert方法就是返回Okhttp的RequestBody。 Converter除了默认的返回原始数据，它还支持哪些数据转化呢？这个在retrofit-converters模块中可以找到答案，如下： 可以看到Retrofit还支持json、xml、protobuf等多种数据类型的转化，这些子模块都各自实现了retrofit模块暴露出来的Converter接口和Converter接口中的Factory接口，在Converter的adapt方法中实现不同数据类型的转化逻辑，我们可以通过addConverterFactory(Factory)来支持不同数据类型转化的Converter工厂。 4、面向接口设计在retrofit模块中提供了Call、Callback、CallAdapter、Converter接口供外部模块使用，CallAdapter和Converter接口中还有相应的Factory接口，各模块之前通过接口依赖主模块Retrofit，将网络请求、网络请求适配、请求处理与返回解析完全解耦，当需要修改Retrofit中的默认实现时，只需要add一个外部模块提供的工厂，具体创建什么样的实例由工厂方法来负责，这样就能以最小的代价（不需要改动代码）换成其他模块上的实现，Retrofit本身并不参与这个过程，它只是负责提供一些主要的参数供它们进行决策，以及进行参数的处理，模块之间依赖于接口，而不依赖于具体的实现，这是一种很好的编程思路，面向接口编程。 面向接口编程：也被熟知为基于接口的设计，是一种基于组件级别的，面向对象语言的模块化编程设计实现，面向接口编程是面向对象编程的一种模块化实现形式，理论上说具有对象概念的程序设计都可以称之为面向对象编程，而面向接口编程则是从组件的级别来设计代码，将抽象与实现分离。 好了，在简单的了解了一下待会和构建过程涉及到的相关类，接下来分析Retrofit的构建过程。 三、Retrofit的创建过程123Retrofit Retrofit = new Retrofit.Builder()//1、构造Builder .baseUrl(\"https://api.github.com/\")//2、配置Builder .build();//3、创建Retrofit实例 Retrofit是使用Builder模式构建出一个Retrofit实例的，Builder模式的好处就是将一个复杂对象的构建和它的表示分离，在用户在不知道内部构建细节的情况下，可以更加精准的控制对象的构造过程，所以我们直接看Retrofit的内部类Builder就行，因为在Builder中配置的字段最终都在build时赋值给Retrofit中相应的字段，Builder只是暂时保存这些配置字段而已，下面我们分注释的3步去看Retrofit的Builder. 1、构造BuilderBuilder类如下： 1234567891011121314151617181920212223242526//Retrofit.javapublic static final class Builder &#123; private final Platform platform;//Retrofit运行的平台 //... //根据Platform构造 Builder(Platform platform) &#123; this.platform = platform; &#125; public Builder() &#123; //调用Platform的get方法获取一个Platform this(Platform.get()); &#125; //根据另外一个Retrofit构造 Builder(Retrofit Retrofit) &#123; platform = Platform.get(); callFactory = Retrofit.callFactory; baseUrl = Retrofit.baseUrl; //... &#125; //... &#125; new Retrofit.Builder()，我们使用了无参的构造函数来创建Builder，Builder的无参构造函数首先通过Platform.get()获取了一个Platform实例赋值给了platform字段，前面提到过Retrofit是有Platform的概念，Retrofit支持java和Android平台，我们来看一下Platform这个类，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Platform &#123; //单例 private static final Platform PLATFORM = findPlatform(); //get方法 static Platform get() &#123; //返回Platform实例 return PLATFORM; &#125; private static Platform findPlatform() &#123; try &#123; //android.os.Build这个类是Android独有的 //这里要求JVM查找并加载Build.class对象 Class.forName(\"android.os.Build\"); if (Build.VERSION.SDK_INT != 0) &#123; //如果是Android平台，创建一个Android实例返回，Android继承自Platform return new Android(); &#125; &#125; catch (ClassNotFoundException ignored) &#123; //找不到android.os.Build，会抛出异常，捕捉，继续执行 &#125; try &#123; //java.util.Optional这个类是java8之后才有的，是java独有的 Class.forName(\"java.util.Optional\"); //创建一个Java8实例返回，Java8继承自Platform return new Java8(); &#125; catch (ClassNotFoundException ignored) &#123; //找不到java.util.Optional，会抛出异常，捕捉，继续执行 &#125; //返回默认Platform实例 return new Platform(); &#125; //返回默认的线程切换执行器 Executor defaultCallbackExecutor() &#123; return null; &#125; //返回默认的网络请求适配器工厂 CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123; if (callbackExecutor != null) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; return DefaultCallAdapterFactory.INSTANCE; &#125; boolean isDefaultMethod(Method method) &#123; return false; &#125; @Nullable Object invokeDefaultMethod(Method method, Class&lt;?&gt; declaringClass, Object object, @Nullable Object... args) throws Throwable &#123; throw new UnsupportedOperationException(); &#125; @IgnoreJRERequirement // Only classloaded and used on Java 8. static class Java8 extends Platform &#123; //... &#125; static class Android extends Platform &#123; //... &#125;&#125; 首先Platform的get方法通过单例模式返回了一个Platform实例，单例模式就是保证单例对象的类在同一进程中，只有一个实例存在，Platform实例通过findPlatform方法创建，可以看到findPlatform方法里面区分了Android、java和其他平台返回了不同的Platform实现，由于我这里是Android平台，只关注Android平台的实现，Android类如下： 1234567891011121314151617181920212223//Platform.javastatic class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) &#123; if (callbackExecutor == null) throw new AssertionError(); return new ExecutorCallAdapterFactory(callbackExecutor); &#125; //线程切换执行器 static class MainThreadExecutor implements Executor &#123; //构造Handler时通过Looper.getMainLooper()来构造 //所以Handler的消息都会执行在主线程 private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125;&#125; Android继承自Platform，重写了它其中的两个方法：defaultCallbackExecutor方法和defaultCallAdapterFactory方法，defaultCallbackExecutor方法返回了一个MainThreadExecutor，它是一个Executor，它的execute方法的实现就是简单通过Handler把任务Runnable切换回主线程执行，就是说，线程池会把每一个线程提交的任务都切回主线程执行，我们再来看defaultCallAdapterFactory方法，这个方法返回了我们上面介绍过的ExecutorCallAdapterFactory，并把callbackExecutor传了进去，其实这个callbackExecutor就是MainThreadExecutor，待会在第3步构建Retrofit实例时就会讲到。 这里我们来小结一下： new Retrofit.Builder()里面会通过Platform的get方法来获取一个Platform实例，在Android中，它会返回Android平台实例，这样就指定了Retrofit的运行平台是Android，然后就可以通过Android平台实例的defaultCallbackExecutor方法返回一个线程切换执行器MainThreadExecutor，它用于把任务切换回主线程执行，和通过defaultCallAdapterFactory方法返回一个网络请求适配器工厂ExecutorCallAdapterFactory，工厂中持有一个线程切换执行器实例，通过工厂就可以获取网络请求适配器实例。 有了Builder实例后，下面开始配置Builder. 2、配置Builder1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//Retrofit.javapublic static final class Builder &#123; private final Platform platform;//Retrofit运行的平台 private @Nullable okhttp3.Call.Factory callFactory;//网络请求执行器工厂，用创建网络请求执行器实例，来自okhttp, 不是Retrofit中的那个Call private HttpUrl baseUrl;//网络请求的Url地址 private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;();//数据转化器工厂列表 private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;();//网络请求适配器工厂列表 private @Nullable Executor callbackExecutor;//线程切换执行器 private boolean validateEagerly;//标志位，是否提前对serviceMethod进行缓存(在创建Api接口实例会讲到) //... //我们传入的String类型的Url，最终还是会解析成HttpUrl类型，它是Retrofit中url的代表 public Builder baseUrl(String baseUrl) &#123; checkNotNull(baseUrl, \"baseUrl == null\"); HttpUrl httpUrl = HttpUrl.parse(baseUrl); if (httpUrl == null) &#123; throw new IllegalArgumentException(\"Illegal URL: \" + baseUrl); &#125; return baseUrl(httpUrl); &#125; public Builder baseUrl(HttpUrl baseUrl) &#123; checkNotNull(baseUrl, \"baseUrl == null\"); List&lt;String&gt; pathSegments = baseUrl.pathSegments(); if (!\"\".equals(pathSegments.get(pathSegments.size() - 1))) &#123; //baseUrl最后一定要接一个 / throw new IllegalArgumentException(\"baseUrl must end in /: \" + baseUrl); &#125; this.baseUrl = baseUrl; return this; &#125; //把ConverterFactory添加到数据转化器工厂列表中 public Builder addConverterFactory(Converter.Factory factory) &#123; converterFactories.add(checkNotNull(factory, \"factory == null\")); return this; &#125; //把CallAdapterFactory添加到网络请求适配器工厂列表中 public Builder addCallAdapterFactory(CallAdapter.Factory factory) &#123; callAdapterFactories.add(checkNotNull(factory, \"factory == null\")); return this; &#125; //获取网络请求适配器工厂列表 public List&lt;CallAdapter.Factory&gt; callAdapterFactories() &#123; return this.callAdapterFactories; &#125; //获取数据转化器工厂列表 public List&lt;Converter.Factory&gt; converterFactories() &#123; return this.converterFactories; &#125; //修改validateEagerly标志位 public Builder validateEagerly(boolean validateEagerly) &#123; this.validateEagerly = validateEagerly; return this; &#125; //...&#125; Builder中所有的字段都贴出来了，方法只贴了几个常用的出来，我们调用Builder的相应方法，就是在为Builder的相应字段赋值，很简单，就不介绍了。 其中要注意的是：当我们添加ConverterFactory或CallAdapterFactory时，它们都是添加到各自的列表中，这说明在Retrofit中Converter和CallAdapter是可以存在多个的，为什么呢？这是因为Retrofit允许我们为Api接口里面定义的每一个方法都定义对应的Converter和CallAdapter，每当我们调用到Api接口的某个方法时，Retrofit都会遍历网络请求适配器工厂列表callAdapterFactories，把方法的返回值returnType和注解信息annotations传进每个Factory的get方法中，看某个Factory是否愿意处理这个方法，为这个方法创建对应CallAdapter实例；同理，当Retrofit解析某个Api接口方法的网络请求数据时，它同样会遍历数据转化器工厂列表converterFactories，把方法的相关信息传给Factory的responseBodyConverter或requestBodyConverter方法，看某个Factory是否愿意处理这个方法，为这个方法创建对应ResponseBodyBodyConverter或RequestBodyConverter实例，这两个过程在待会的源码分析都会体现到。由于我们平常开发都只添加了一个CallAdapter和一个Converter，所以Retrofit对Api接口定义的每一个方法的adapt和convert都是相同的处理。 配置好Builder后，接下来调用build方法创建Retrofit实例. 3、创建Retrofit实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Retrofit.javapublic static final class Builder &#123; //... public Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException(\"Base URL required.\"); &#125; //配置网络请求执行器工厂callFactory okhttp3.Call.Factory callFactory = this.callFactory; //如果没有指定，使用默认的 if (callFactory == null) &#123; //默认指定为OkHttpClient， OkHttpClient实现了Call.Factory接口，OkHttpClient和Call都是来自okhttp的 callFactory = new OkHttpClient(); &#125; //配置线程切换执行器callbackExecutor Executor callbackExecutor = this.callbackExecutor; //如果没有指定，使用默认的 if (callbackExecutor == null) &#123; //默认指定为运行平台默认的线程切换执行器 //在Android中，defaultCallbackExecutor方法的返回值就是MainThreadExecutor实例 callbackExecutor = platform.defaultCallbackExecutor(); &#125; //配置网络请求适配器工厂列表 //添加用户指定的网络请求适配器工厂列表 List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories); //添加运行平台默认的网络请适配器工厂到列表中 //在Android中，defaultCallAdapterFactory方法返回值就是ExecutorCallAdapterFactory实例，并把MainThreadExecutor实例传进方法，所以ExecutorCallAdapterFactory持有MainThreadExecutor实例（回去看构造Builder阶段） callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); //配置数据转化器工厂列表 List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(1 + this.converterFactories.size()); //添加Retrofit默认的数据转化器工厂BuiltInConverters converterFactories.add(new BuiltInConverters()); //添加用户指定的数据转化器工厂列表 converterFactories.addAll(this.converterFactories); //创建一个Retrofit实例返回，并把上面的配置好的字段传进构造 //这些字段和Retrofit中相应的字段同名,unmodifiableList就是创建一个不可修改的列表 return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories), unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly); &#125;&#125; build方法中把没有在配置Builder阶段中赋值的字段指定了默认值，然后把网络请求Url地址baseUrl、网络请求执行器工厂callFactory、线程切换执行器callbackExecutor、网络请求适配器工厂列表callAdapterFactories、数据转化器工厂列表converterFactories、标志位validateEagerly这六件套传进了Retrofit的构造，创建一个Retrofit实例返回。 其中要注意的是，按照添加顺序，工厂列表的优先级为：用户指定的网络请适配器工厂列表 &gt; 运行平台默认的网络请求适配器工厂；Retrofit默认的数据转化器工厂 &gt; 用户指定的数据转化器工厂列表。在遍历这些列表时是从前往后遍历的，越靠前的越先被访问。 4、小结经过这3步后，指定了Retrofit的运行平台，配置好了Retrofit的网络请求Url地址、网络请求执行器工厂、线程切换执行器、网络请求适配器工厂列表、数据转化器工厂列表等字段，并创建了一个Retrofit实例. 有了Retrofit实例后，就可以通过Retrofit的create方法创建一个Api接口实例，这也是整个Retrofit最核心的地方. 四、创建Api接口实例1GithubService service = Retrofit.create(GithubService.class); 我先讲一下Retrofit的create方法的作用，Retrofit的create方法里面干了两件事，首先它会根据validateEagerly标志位是否为true，而从决定是否把Api接口里定义的所有方法的注解和参数信息提前封装到ServiceMethod中然后缓存起来，接着就通过Proxy的newProxyInstance方法为GithubService接口创建一个代理对象返回，这里就使用到了外观模式，外观模式就是定义一个统一接口，外部（用户）通过该统一的接口对子系统里的其他接口进行访问，这里的这个统一的接口就是Retrofit.create方法，我们只需要调用create方法，Retrofit内部就替我们把这两件事给做了，不用我们访问Retrofit的内部子系统，降低了我们使用的复杂度。 Retrofit的create方法如下： 12345678910111213141516171819202122232425262728293031323334//Retrofit.java//泛型T就是GithubService接口public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; //传进来的必须是一个接口，并且这个接口没有继承其他接口，否则抛异常 Utils.validateServiceInterface(service); //1、判断validateEagerly标志位是否为true if (validateEagerly) &#123; //如果为true，把Api接口里定义的所有方法的注解和参数信息封装到ServiceMethod中，提前缓存起来 eagerlyValidateMethods(service); &#125; //2、通过Proxy的newProxyInstance方法为GithubService接口创建一个代理对象 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; //... &#125; &#125;); &#125;//Retrofit.javaprivate void eagerlyValidateMethods(Class&lt;?&gt; service) &#123; //首先获取运行平台，这里为Android Platform platform = Platform.get(); //getDeclaredMethods方法会以 Method[] 形式返回接口定义的所有方法的Method对象，所以这里就是在遍历接口的所有方法 for (Method method : service.getDeclaredMethods()) &#123; //在Android平台，isDefaultMethod方法返回false if (!platform.isDefaultMethod(method)) &#123; //为每一个方法都调用一次loadServiceMethod方法 //loadServiceMethod方法中就会把方法的注解和参数信息封装到ServiceMethod中，然后缓存起来 loadServiceMethod(method); &#125; &#125; &#125; 我们先看create方法的注释1，validateEagerly这个标志位决定是否对serviceMethod进行提前缓存，默认为false，当为true时，create方法中就会调用eagerlyValidateMethods方法，里面会遍历Api接口的所有方法，为每一个方法都调用一次loadServiceMethod方法（invoke方法中会讲到这个方法），loadServiceMethod方法中就会把方法的注解和参数信息封装到ServiceMethod中，以方法method为键，ServiceMethod为值，放入一个名叫serviceMethodCache的Map中缓存起来，这个Map定义在Retrofit中，如下： 1234public final class Retrofit &#123; private final Map&lt;Method, ServiceMethod&lt;?, ?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;(); //...&#125; 可以看到这个Map是一个线程安全的HashMap，它的key = Method，value = ServiceMethod。所以可以根据需要设置validateEagerly标志位开启ServiceMethod的预加载，这样等到动态执行invoke方法时可以直接从缓存中获取ServiceMethod实例。 我们重点看create方法的注释2，通过Proxy的newProxyInstance方法为GithubService接口创建一个代理对象，这里就使用了动态代理模式，Proxy的newProxyInstance方法会在代码运行时，根据第一个参数的ClassLoader，生成一个代理Class对象，该代理Class对象实现了传入的第二个参数对应的Interface列表，在获取到代理Class对象后，根据第三个参数InvocationHandler引用通过反射创建一个代理对象实例，所以newProxyInstance最终的结果是生成一个代理对象实例，该代理对象会实现给定的接口列表，同时内部持有一个InvocationHandler引用，我们调用代理对象的方法时，这个方法处理逻辑就会委托给InvocationHandler实例的invoke方法执行。 小结当我们调用Retrofit的create方法后，它返回了一个代理对象实例，这个代理对象实现了create方法传进去的接口，接下来当我们调用Api接口的方法时，就是在调用代理对象的同名方法，这个方法处理逻辑就会委托给InvocationHandler实例的invoke方法执行，使用了动态代理之后的好处就是我们可以把发起网络请求的参数获取都集中到invoke方法中处理，而不需要为每一个接口定义一个实现类，这样降低了实现的难度。 接下来我们开始调用Api接口的方法，它会返回一个网络请求执行器。 五、调用Api接口实例的方法1Call&lt;ResponseBody&gt; call = service.getUserInfo(\"rain9155\"); 根据动态代理的知识，我们知道，当我们调用Api接口实例的方法，就是在调用代理对象的方法，这个方法处理逻辑就会委托给InvocationHandler实例的invoke方法执行，也就是说，当我们在外部调用Api接口的相应方法时，这些方法都会转到invoke方法执行，例如我调用service.getUserInfo(“rain9155”)时，这个方法会转到invoke方法去执行。 所以我们直接看InvocationHandler的invoke方法逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243//Retrofit.javapublic &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; //... return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); /** * 当我调用service.getUserInfo(\"rain9155\")时，这个方法会转到invoke方法去执行。 * @param proxy 代理对象实例 * @param method 被调用的方法，如这里的getUserInfo方法 * @param args 被调用的方法的参数，如这里的\"rain9155\" */ @Override public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable &#123; //如果这个方法是Object类的，调用Object类的方法 if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; //在Android平台，isDefaultMethod方法返回false，不会进入这个分支 if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; //走到这里表示，调用的不是Object类的方法，而是GithubService接口的相应方法 //1、调用loadServiceMethod方法，为这个方法获取一个ServiceMethod ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); //2、把该方法的ServiceMethod和args传进okHttpCall，创建一个okHttpCall实例 //args就是方法的参数 OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); //3、调用adapt方法，传入okHttpCall，把okHttpCall适配成另一个Call //里面其实调用的是CallAdapter的adapt方法 return serviceMethod.adapt(okHttpCall); &#125; &#125;); &#125; invoke方法中分为注释1、2、3，下面分别讲解： 注释1、loadServiceMethod方法12//1、调用loadServiceMethod方法，为这个方法获取一个ServiceMethodServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); loadServiceMethod方法如下： 123456789101112131415161718192021//Retrofit.java ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123; //首先从serviceMethodCache根据方法method获取ServiceMethod ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method); //如果获取得到就直接返回 if (result != null) return result; //如果获取不到就为这个method创建一个ServiceMethod //上锁，所以创建的ServiceMethod是一个单例 synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; //1、为method创建一个ServiceMethod result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); //然后以方法method为键，ServiceMethod为值，放入serviceMethodCache缓存起来 serviceMethodCache.put(method, result); &#125; &#125; return result; &#125; 可以看到这里首先从serviceMethodCache根据方法method获取ServiceMethod，如果获取不到再为方法创建一个ServiceMethod，然后以方法method为键，ServiceMethod为值，放入serviceMethodCache缓存起来，并返回，我们重点来看注释1，看这个ServiceMethod是怎样根据方法的Method对象创建出来的。 1、ServiceMethod的创建过程12result = new ServiceMethod.Builder&lt;&gt;(this, method)//1 .build();//2 ServiceMethod同样是通过Builder模式创建，所以我们同样分注释的2步去看ServiceMethod的创建. 1.1、构造Builder所以我们先看ServiceMethod的Builder的构造，如下： 12345678910111213141516171819//ServiceMethod.javastatic final class Builder&lt;T, R&gt; &#123; final Retrofit retrofit; final Method method; final Annotation[] methodAnnotations; final Annotation[][] parameterAnnotationsArray; final Type[] parameterTypes; //... Builder(Retrofit retrofit, Method method) &#123; this.retrofit = retrofit; this.method = method; //获取方法里的所有注解，如@GET、@POST，@PATCH等 this.methodAnnotations = method.getAnnotations(); //获取方法里的所有参数类型，如int、String等 this.parameterTypes = method.getGenericParameterTypes(); //获取方法里所有参数的注解，如@Query，@Body、@PartMap等 this.parameterAnnotationsArray = method.getParameterAnnotations(); &#125; 构造中依此获取方法的注解、参数类型、参数的注解并依此赋值给methodAnnotations、parameterAnnotationsArray、parameterTypes，注意parameterAnnotationsArray是一个二维数组，因为一个参数可以被多个注解修饰，一个注解可以修饰多个参数。 1.2、创建ServiceMethod实例我们接着看Builder的build方法，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//ServiceMethod.javastatic final class Builder&lt;T, R&gt; &#123; final Retrofit retrofit; final Method method; final Annotation[] methodAnnotations; final Annotation[][] parameterAnnotationsArray; final Type[] parameterTypes; Type responseType; ParameterHandler&lt;?&gt;[] parameterHandlers; Converter&lt;ResponseBody, T&gt; responseConverter; CallAdapter&lt;T, R&gt; callAdapter; //... public ServiceMethod build() &#123; //1、调用createCallAdapter方法创建网络请求适配器CallAdapter callAdapter = createCallAdapter(); //通过CallAdapter的responseType方法获取返回数据的响应body的类型 //如Call&lt;ResponseBody&gt;，获取到ResponseBody类型 responseType = callAdapter.responseType(); //....省略异常处理 //2、调用createResponseConverter方法创建网络返回数据的数据转化器Converter responseConverter = createResponseConverter(); //遍历该方法的所有注解 for (Annotation annotation : methodAnnotations) &#123; //3、调用parseMethodAnnotation方法解析注解，如@GET、@POST，@PATCH等 parseMethodAnnotation(annotation); &#125; //...省略异常处理 int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; //为方法中的每个参数创建一个ParameterHandler&lt;?&gt;对象并解析每个参数使用的注解 for (int p = 0; p &lt; parameterCount; p++) &#123; //获取参数类型，如int、String等 Type parameterType = parameterTypes[p]; //...省略异常处理 //获取修饰参数的注解，如@Query，@Body、@PartMap等 Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; //...省略异常处理 //4、调用parseParameter方法解析每个参数使用的注解，并返回一个parameterHandlers parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; //...省略异常处理 //创建ServiceMethod实例，并把Builder实例传进去 //ServiceMethod构造里面会把Builder配置好的字段赋值给ServiceMethod中相应的字段 return new ServiceMethod&lt;&gt;(this); &#125; build方法里面分4步，我们先看注释1、2，注释1调用createCallAdapter方法创建网络请求适配器CallAdapter，并赋值给callAdapter字段，createCallAdapter方法如下： 12345678910111213141516171819202122232425262728293031323334//ServiceMethod::Builder.javaprivate CallAdapter&lt;T, R&gt; createCallAdapter() &#123; //获取方法的返回值类型，如Call&lt;ResponseBody&gt; Type returnType = method.getGenericReturnType(); //...省略异常处理 //获取方法的所有注解，如@GET、@POST，@PATCH等 Annotation[] annotations = method.getAnnotations(); try &#123; //调用Retrofit的callAdapter方法，返回一个CallAdapter实例 return (CallAdapter&lt;T, R&gt;) retrofit.callAdapter(returnType, annotations); &#125; //...省略异常处理&#125;//Retrofit.java public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) &#123; return nextCallAdapter(null, returnType, annotations); &#125;public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) &#123; //...省略异常处理 int start = callAdapterFactories.indexOf(skipPast) + 1; //遍历网络请求适配器工厂callAdapterFactories for (int i = start, count = callAdapterFactories.size(); i &lt; count; i++) &#123; //把该方法的返回值类型returnType和注解信息annotations传给CallAdapterFactory的get方法，通过get方法获取一个CallAdapter实例或null //在Retrofit相关类介绍讲过，Android平台的CallAdapterFactor的默认实现是ExecutorCallAdapterFactory，ExecutorCallAdapterFactory的get方法返回一个CallAdapter匿名实现类或null CallAdapter&lt;?, ?&gt; adapter = callAdapterFactories.get(i).get(returnType, annotations, this); if (adapter != null) &#123; return adapter; &#125; &#125; createCallAdapter方法中，获取到方法的返回值类型（如Call类型）和注解信息后，就调用Retrofit的callAdapter方法，callAdapter方法就调用nextCallAdapter方法，在nextCallAdapter方法中，会遍历Retrofit的网络请求适配器工厂callAdapterFactories，把方法的返回值returnType和注解信息annotations传进每个Factory的get方法中，看某个Factory是否愿意处理这个方法，如果愿意，就为这个方法创建对应CallAdapter实例，在Android平台中，CallAdapterFactor的默认实现是ExecutorCallAdapterFactory，ExecutorCallAdapterFactory的get方法返回一个CallAdapter匿名实现类。（查看前面讲过的Retrofit相关类介绍，里面有对ExecutorCallAdapterFactory的详细介绍） 我们再看build方法里的注释2，注释2调用createResponseConverter方法创建网络返回数据的数据转化器Converter，赋值给responseConverter字段，createResponseConverter方法如下： 12345678910111213141516171819202122232425262728293031323334//ServiceMethod::Builder.javaprivate Converter&lt;ResponseBody, T&gt; createResponseConverter() &#123; //获取方法的所有注解，如@GET、@POST，@PATCH等 Annotation[] annotations = method.getAnnotations(); try &#123; //调用Retrofit的responseBodyConverter方法，返回一个Converter实例 return retrofit.responseBodyConverter(responseType, annotations); &#125; //...省略异常处理&#125;//Retrofit.javapublic &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) &#123; return nextResponseBodyConverter(null, type, annotations);&#125;public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter( @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) &#123; //...省略异常处理 int start = converterFactories.indexOf(skipPast) + 1; //遍历数据转化器工厂converterFactories for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123; //把该方法的返回值的泛型类型和注解信息annotations传给ConverterFactory的responseBodyConverter方法，通过responseBodyConverter方法获取一个处理网络返回数据的数据转化器Converter实例或null //在Retrofit相关类介绍讲过，Retrofit的ConverterFactory的默认实现是BuiltInConverters，BuiltInConverters的responseBodyConverter方法返回一个处理网络返回数据的数据转化器Converter实例或null Converter&lt;ResponseBody, ?&gt; converter = converterFactories.get(i).responseBodyConverter(type, annotations, this); if (converter != null) &#123; //noinspection unchecked return (Converter&lt;ResponseBody, T&gt;) converter; &#125; &#125; //...省略异常处理&#125; createResponseConverter方法中的流程和createCallAdapter方法的流程差不多，最终是遍历Retrofit的数据转化器工厂converterFactories，把该方法的返回值的泛型类型（如Call，泛型类型就是ResponseBody类型）和注解信息annotations传给每个Factory的responseBodyConverter方法中，看某个Factory是否愿意处理这个方法，如果愿意，就为这个方法创建对应的网络返回数据的数据转化器Converter实例，在Android平台中ConverterFactory的默认实现是BuiltInConverters（查看前面讲过的Retrofit相关类介绍，里面有对BuiltInConverters的详细介绍）。有ResponseConverter就有相应的RequestConverter，RequestConverter用来处理网络请求数据的数据转化，RequestConverter并不在ServiceMethod的build方法中创建，而是在parseParameter方法中创建。 至于build方法的注释3、4的parseMethodAnnotation方法和parseParameter方法，限于篇幅，就留给大家自己探索了，我讲一下里面的大体逻辑： parseMethodAnnotation方法：该方法里面首先判断是哪种HTTP请求的注解，然后为不同的HTTP请求注解调用parseHttpMethodAndPath方法，该方法里面会获取注解中省略域名的Url和把Url里面需要替换地方用正则找出来放到一个Set中，如：@GET(“users/{user}”)，省略域名的Url = users/{user}，需要替换的地方是{user}，把user找出来，最终parseMethodAnnotation方法获取到的信息是： HTTP请求方式、省略域名的Url和Url中需要替换值的地方。 parseParameter方法：这个方法是解析方法参数的注解，如@Quary、@Path等，里面会判断是哪种类型的注解，根据不同类型的注解，取出注解中的值，创建一个RequestConverter实例，最后把注解的值和RequestConverter实例传进ParameterHandler构造，为这个注解创建一个ParameterHandler实例返回，不同的注解有不同的ParameterHandler类型，如@Quary就有ParameterHandler.Quary，@Path就有ParameterHandler.Path。 都是通过注解解析出注解参数，然后一并封装到ServiceMethod中去，build方法执行完毕，就创建了一个ServiceMethod实例返回。 我们来小结一下ServiceMethod的创建过程： 经过这2步后，为这个方法method创建了一个对应的ServiceMethod实例，这个ServiceMethod封装了网络请求所需要的所有参数和持有CallAdapter实例、处理网络返回数据转化的Converter实例，同时这个ServiceMethod是一个单例，也就是说Api接口里的每一个方法都分别对应着一个ServiceMethod实例，这个ServiceMethod实例持有着网络请求所需要的所有参数。 我们继续回到loadServiceMethod方法中。 2、小结调用loadServiceMethod方法后，创建了一个ServiceMethod实例并缓存到一个Map中，第二次使用时直接从缓存获取ServiceMethod实例，不必重复创建，提高效率。 我们回到invoke方法，有了ServiceMethod实例后，就可以创建一个okHttpCall实例. 注释2、创建一个okHttpCall实例12//2、把该方法的ServiceMethod和args(args就是方法的参数)传进okHttpCall，创建一个okHttpCall实例OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); OkHttpCall的构造如下： 123456789101112final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123; private final ServiceMethod&lt;T, ?&gt; serviceMethod;//封装了Api接口方法中的注解和参数信息，一个ServiceMethod对应一个Method private final @Nullable Object[] args;//代表着Api接口方法中的参数 private @Nullable okhttp3.Call rawCall;//这是一个来自Okhttp的Call //... OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, @Nullable Object[] args) &#123; this.serviceMethod = serviceMethod; this.args = args; &#125; //... 可以看到Okhttp把刚刚得到的ServiceMethod实例和接口方法的参数保存起来，OkHttpCall在前面的Retrofit的相关类介绍已经简单介绍过了，它就是实现了Call的一个类，它里面的方法大部分逻辑都转发给Okhttp的Call 。 得到okHttpCall实例后，通过adapt方法把它适配成另外一个Call. 注释3、把OkHttpCall适配成另一个Call12 //3、调用adapt方法，传入okHttpCall，把okHttpCall适配成另一个Callreturn serviceMethod.adapt(okHttpCall); ServiceMethod的adapt方法如下： 1234//ServiceMethod.javaT adapt(Call&lt;R&gt; call) &#123; return callAdapter.adapt(call);&#125; adapt方法传进来的call是OkhttpCall实例，callAdapter就是刚刚用createCallAdapter方法创建的CallAdapter实例，在Android平台中，这个CallAdapter实例的adapt方法的默认实现就是用ExecutorCallbackCall包装传进来的OkHttpCall，并返回ExecutorCallbackCall实例，如下： 12345678910111213141516171819202122232425262728293031323334353637final class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; //线程切换执行器, 在创建Retrofit实例时传进ExecutorCallAdapterFactory中 //在Android平台，就是MainThreadExecutor实例 final Executor callbackExecutor; ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; //get方法 @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit Retrofit) &#123; //... final Type responseType = Utils.getCallResponseType(returnType); //返回一个CallAdapter匿名类 return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; //adapt方法 @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; //创建了一个ExecutorCallbackCall，并把线程切换执行器实例和OkhttpCall实例传进构造 return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; //网络请求执行器 static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; //... &#125;&#125; 所以callAdapter.adapt(call)就是把OkhttpCall 适配成 ExecutorCallbackCall，我们来看一下ExecutorCallbackCall，它是ExecutorCallAdapterFactory的内部类，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//ExecutorCallAdapterFactory.java//网络请求执行器static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor;//线程切换执行器实例, 在get方法通过构造传进 final Call&lt;T&gt; delegate;//OkhttpCall实例, 在get方法通过构造传进 ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate; &#125; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, \"callback == null\"); //ExecutorCallbackCall的enqueue方法委托给OkhttpCall执行 delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; //当网络数据返回时，通过线程切换执行器callbackExecutor，切换到主线程执行callback回调 callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; //当网络数据返回时，通过线程切换执行器callbackExecutor，切换到主线程执行callback回调 callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;); &#125; @Override public Response&lt;T&gt; execute() throws IOException &#123; //ExecutorCallbackCall的execute方法委托给OkhttpCall执行 return delegate.execute(); &#125; //...&#125; 可以看到，ExecutorCallbackCall和OkhttpCall一样都实现了Call接口中的方法，并且ExecutorCallbackCall中持有OkhttpCall的实例，它的enqueue方法和execute方法都委托给OkhttpCall的enqueue方法和execute方法执行，当网络数据返回时，通过线程切换执行器callbackExecutor，切换到主线程执行callback回调，这里采用了装饰者模式，采用装饰者模式的好处就是不用通过继承就可以扩展一个对象的功能，动态的给一个对象添加一些额外的操作，这里额外的操作就是通过线程切换执行器切换回主线程后再执行callback回调，因为OkHttpCall的enqueue方法是进行网络的异步请求，当异步请求结果返回时，回调是在子线程中，需要通过线程切换执行器转换到主线程中再进行callback回调。 最终，ServiceMethod的adapt方法把OkhttpCall 适配成不同平台的网络请求执行器，并返回，在Android平台中，OkhttpCall 适配成了 ExecutorCallbackCall实例。 4、小结当我们调用Api接口实例中的方法时，这些方法的处理逻辑都会转发给invoke方法，在invoke方法中，会为每一个方法创建一个ServiceMethod，这个ServiceMethod封装了网络请求所需要的所有参数和持有CallAdapter实例、处理网络返回数据转化的Converter实例，接着就会把这个ServiceMethod实例和接口方法的参数传进OkhttpCall的构造中，创建一个OkhttpCall实例，接着把这个OkhttpCall实例传给ServiceMethod的adapt方法，ServiceMethod的adapt方法就会调用CallAdapter实例的adapt方法，把OkhttpCall适配成不同平台的网络请求执行器，所以如果你添加了其他平台的CallAdapterFactory，你就可以得到不同平台下的网络请求执行器，在Android平台中，CallAdapter实例的adapt方法会把OkhttpCall适配成ExecutorCallbackCall，这个ExecutorCallbackCall持有OkhttpCall实例和线程切换器MainThreadExecutor实例，当我们发起网络请求时，ExecutorCallbackCall就会委托OkhttpCall发起网络请求，当网络请求数据返回时，ExecutorCallbackCall就会通过MainThreadExecutor把线程切换主线程执行回调。 得到网络请求执行器之后，就可以发起，网络请求了. 六、发起网络请求（以异步为例）不同平台下的网络请求执行器不同，在Android平台，调用Api接口实例的方法后返回的是ExecutorCallbackCall，有了ExecutorCallbackCall后，我们就可以发起同步或异步请求，同步和异步请求的流程类型，唯一不同的是异步请求需要把结果通过Callback回调给上层，而同步请求则是直接return结果给上层。 下面以异步请求为例： 123456789101112131415161718//用户发起异步请求 call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response)&#123; //通过Response获取网络请求返回结果 ResponseBody body = response.body(); try &#123; Log.d(TAG, \"请求结果：\" + body.string()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; &#125; &#125;); 调用的是ExecutorCallbackCall的enqueue方法，如下： 12345678910111213141516171819202122232425262728293031//ExecutorCallAdapterFactory::ExecutorCallbackCall.javapublic void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, \"callback == null\"); //ExecutorCallbackCall的enqueue方法委托给OkhttpCall执行 delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; //当网络数据返回时，通过线程切换执行器callbackExecutor，切换到主线程执行callback回调 callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; callback.onFailure(ExecutorCallbackCall.this, new IOException(\"Canceled\")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; //当网络数据返回时，通过线程切换执行器callbackExecutor，切换到主线程执行callback回调 callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;); 调用的是OkhttpCall的enqueue方法，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//OkhttpCall.javaprivate @Nullable okhttp3.Call rawCall;//这是一个来自Okhttp的Callpublic void enqueue(final Callback&lt;T&gt; callback) &#123; checkNotNull(callback, \"callback == null\"); //来自Okhttp的Call okhttp3.Call call; Throwable failure; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already executed.\"); executed = true; //1、获取Okhttp的Call实例 call = rawCall; failure = creationFailure; if (call == null &amp;&amp; failure == null) &#123; try &#123; //第一次发起网络请求，创建Okhttp的Call call = rawCall = createRawCall(); &#125; catch (Throwable t) &#123; throwIfFatal(t); failure = creationFailure = t; &#125; &#125; &#125; if (failure != null) &#123; //通过callback把错误回调出去 callback.onFailure(this, failure); return; &#125; if (canceled) &#123; call.cancel(); &#125; //2、调用Okhttp的Call的enqueue方法发起异步请求 //传入的是Okhttp的Callback call.enqueue(new okhttp3.Callback() &#123; //Okhttp的结果回调 @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) &#123; Response&lt;T&gt; response; try &#123; //3、调用parseResponse方法把Okhttp的Response解析成Retrofit的Response response = parseResponse(rawResponse); &#125; catch (Throwable e) &#123; callFailure(e); return; &#125; try &#123; //通过callback把结果回调出去 callback.onResponse(OkHttpCall.this, response); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; //Okhttp的错误回调 @Override public void onFailure(okhttp3.Call call, IOException e) &#123; callFailure(e); &#125; private void callFailure(Throwable e) &#123; try &#123; //通过callback把错误回调出去 callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; &#125;); &#125; OkhttpCall的enqueue方法大体分为3步： 1、获取Okhttp的Call实例，赋值给临时变量call： ​ 1.1、如果是第一次发起网络请求，就调用createRawCall方法就创建来自Okhttp的Call，赋值给临时变量call和成员变量rawCall; ​ 1.2、如果不是第一次发起网络请求，就把上次的rawCall实例赋值给临时变量call. 2、调用Okhttp的Call的enqueue方法发起异步请求（更多细节请查看上一篇文章okhttp3源码分析之请求流程）； 3、当网络请求结果正确返回时，用parseResponse方法把Okhttp的Response解析成Retrofit的Response. 所以我们来看一下两个关键的办法，createRawCall方法和parseResponse方法： 1、创建Okhttp的CallcreateRawCall方法如下： 12345678910//OkhttpCall.javaprivate okhttp3.Call createRawCall() throws IOException &#123; //调用serviceMethod的toCall方法，并把args即接口方法参数传了进去 //args在创建OkhttpCall实例时通过构造传进来的 okhttp3.Call call = serviceMethod.toCall(args); if (call == null) &#123; throw new NullPointerException(\"Call.Factory returned null.\"); &#125; return call; &#125; createRawCall方法调用ServiceMethod的toCall方法，如下： 123456789101112131415161718192021222324//ServiceMethod.javaokhttp3.Call toCall(@Nullable Object... args) throws IOException &#123; //1、创建一个用于构造Request的Builder，并把ServiceMethod中封装的参数传进去 RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody, isFormEncoded, isMultipart); ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers; int argumentCount = args != null ? args.length : 0; //...省略异常处理 //2、遍历每个方法参数的ParameterHandler for (int p = 0; p &lt; argumentCount; p++) &#123; //调用ParameterHandler的apply方法，把ParameterHandler中的参数apply到requestBuilder中 handlers[p].apply(requestBuilder, args[p]); &#125; //3、requestBuilder.build方法创建一个Request实例传进newCall方法，这个Request是来自Okhttp的 //然后调用callFactory的newCall方法创建一个Call //这个callFactory就是OkHttpClient时，在创建Retorfit时配置 //所以这里返回的是来自Okhttp的Call return callFactory.newCall(requestBuilder.build());&#125; 首先创建一个用于构造Request的requestBuilder，并把ServiceMethod中封装的参数传进去，然后遍历每个方法参数的ParameterHandler，通过apply方法取出ParameterHandler中的参数放入requestBuilder中，ParameterHandler前面讲过，它里面保存了每个方法参数的注解的值和处理这些值的Converter实例，构造Request的参数都有了，接着就通过requestBuilder.build方法创建一个Okhttp的Request实例并传进newCall方法，最后通过OkHttpClient的newCall方法创建一个Okhttp的Call实例返回。 最终createRawCall方法返回一个来自Okhttp的Call实例。 2、解析返回结果parseResponse方法如下： 1234567891011121314151617//ServiceMethod.javaResponse&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; //取出Okhttp的Response的body ResponseBody rawBody = rawResponse.body(); //...省略的是一些状态码处理 //用ExceptionCatchingRequestBody包装一下rawBody ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; //调用ServiceMethod的toResponse方法把原始的body转化成我们需要的数据类型 T body = serviceMethod.toResponse(catchingBody); // return Response.success(body, rawResponse); &#125; //...省略异常处理&#125; 首先把Okhttp的Response的body取处理，然后用ExceptionCatchingRequestBody包装一下，这个ExceptionCatchingRequestBody是继承自Okhttp的ResponseBody，接着把这个ResponseBody传进ServiceMethod的toResponse方法，里面会使用ServiceMethod保存的处理网络返回数据的Converter实例来把这个ResponseBody转化成我们需要的数据类型，ServiceMethod的toResponse方法如下： 1234//ServiceMethod.javaR toResponse(ResponseBody body) throws IOException &#123; return responseConverter.convert(body); &#125; 这个responseConverter就是在创建ServiceMethod时用createResponseConverter方法创建的Converter实例，把body转化成R类型，不同的数据转化有不同的实现，在Retrofit的默认实现中，它就是直接返回ResponseBody。 我们再回到parseResponse方法，调用完ServiceMethod的toResponse方法，得到了转化后的body，最后调用了Response的success方法，把Okhttp的Response和转化后的body传了进去，最终返回一个Retrofit的Response。 3、小结以异步为例，Retrofit通过ExecutorCallbackCall的enqueue方法发起网络请求，最终会通过OkhttpCall的enqueue方法来发起网络请求，OkhttpCall的enqueue方法中，首先会调用创建一个来自Okhttp的Call实例，然后通过这个Okhttp的Call实例的enqueue方法来发起异步请求，当网络结果Okhttp的Response返回时，调用parseResponse方法解析Response，parseResponse方法里面还会调用ServiceMethod的toResponse方法通过Converter实例的convert方法把ResponseBody转化成我们想要的数据，不同的数据转化有不同的实现，在Retrofit的默认实现中，它就是直接返回Okhttp的ResponseBody，最后把这个转化后的body和原始的Okhttp的Response一并封装成Retrofit的Response返回，最后把parseResponse方法返回的Response通过callback回调出去，这时ExecutorCallbackCall收到回调，通过线程切换执行器callbackExecutor，切换到主线程执行callback回调，一次异步请求就完成了，同步请求也是大同小异，只是少了个回调，就留给大家自己分析了。 总结能够阅读到这里，说明你对Retrofit的理解又更上一层楼了，其实从整体去看Retrofit，它的流程并不复杂，它的使用也非常的简单，这得益于它优秀的架构，和运用得当的设计模式，其中最核心的当属动态代理模式，通过一个代理类InvocationHandler代理N多个接口，它把每一个方法的处理逻辑都集中到了invoke方法中，这样就能在同一处地方处理所有方法的注解解析，还有它那面向接口的设计，使得各个子模块之间降低耦合，让我们以最小的代价替换成我们需要的实现，Retrofit的整体流程图如下： 一句话概括Retrofit：它是一个通过动态代理把Api接口方法的注解解析成网络请求所需参数，最后通过Okhttp执行网络请求的封装库。 以上就是本文的所有内容，如有错误，欢迎指出。 参考资料： Retrofit解析之面向接口编程 ​","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"retrofit","slug":"retrofit","permalink":"http://yoursite.com/tags/retrofit/"}]},{"title":"使用AIDL来进行进程间通信","date":"2019-10-21T13:04:01.000Z","path":"2019/10/21/使用AIDL来进行进程间通信/","text":"前言AIDL它是Android众多进程间通信方式中的一种，底层是Binder机制的实现，所以想要读懂AIDL自动生成的代码中各个类的作用，就必须对Binder有一定的了解，其实不止AIDL，Android进程间通信的大多数方式的底层都是Binder机制，本文主要介绍AIDL的使用，所以不会介绍Binder机制的原理，关于Binder机制的原理，我推荐下面的一篇文章，零基础也能看懂： 写给 Android 应用工程师的 Binder 原理剖析 看完上面的文章你也就能对Binder原理的实现有大概的了解，对于我们Android应用开发也就足够了，如果你还不满足，想从底层和源码了解Binder机制，你可以阅读下面的两个链接： Android Bander设计与实现 Binder系列—开篇 上面两个系列就是从设计和源码的角度去解读Binder，有点深入。好了，对Binder有一个大体上的认识后，接下来我们就要通过AIDL的使用来完成Android进程间通信的实践。 Android进程间通信的方式在介绍AIDL之前，我们先来看一下Android中除了AIDL还有哪些进程间通信的方式： 1、Bundle Bundle实现了Parcelable，所以在Android中我们可以通过Intent在不同进程间传递Bundle数据。 但是在Intent 传输数据的过程中，用到了 Binder，Intent中的数据，即Bundle数据，会作为 Parcel 存储在Binder 的事务缓冲区(Binder transaction buffer)中的对象进行传输，而这个 Binder 事务缓冲区具有一个有限的固定大小，约为1MB，而且这个1Mb并不是当前操作独享的，而是前进程所共享的，所以由于1Mb的限制，Bundle不能存放大量的数据，不然会报TransactionTooLargeException，并且Bundle中存放的数据也要求能够被序列化，所以Bundle只适用于数据量小和简单的进程间通信，每次通过Intent传输数据时最好不要超过200K。 2、文件共享 两个进程间通过读写同一个文件来交换数据。 但是由于Android允许并发的对同一个文件读写，所以如果两个进程同时的对这个文件写，就会出现问题，所以这适用于对数据同步要求不高的进程间通信。 3、ContentProvider ContentProvider是Android中专门用于不同应用之间，即不同进程之间进行数据共享的方式，它的底层实现是Binder。 ContentProvider是四大组件之一，它的使用比较简单，我们只需要继承自ContenProvider，并重写它的六个方法：onCreate、query、updata、insert、delete和getType，其中onCreate用于初始化，getType用于返回一个Uri请求代表的MIME类型，剩下的都是CRUD操作，除了onCreate方法运行在主线程，其他方法都运行在Binder线程池，然后在另外一个进程中注册这个ContentProvider，在本进程的Activity中通过getContentResolver()获得ContentResolver后，再通过ContentResolver来完成对这个ContentProvider的CRUD操作。 4、套接字(Socket) 一种传统的Linux IPC方式，除了用于不同进程之间还可以用于不同机器之间（通过网络传输）的通信，但是它的传输效率也是非常的低。 5、Messenger 通过Messenger可以在不同进程之间传递Message对象，Message中可以放入我们需要传递的数据，它的底层实现是AIDL。 但是Messenger在服务端的Handler是以串行的方式处理来自客户端的Message，所以如果有大量的并发请求，Messenger就效率低下，所以Messenger适用于数据并发量低的进程间通信。 6、AIDL 也就是本文的主角，它的底层实现是Binder。 可以看到Android中进程间通信的方式中，除了文件共享和Socket，底层都是需要通过Binder来传输数据，可见Binder对Android的进程间通信来说是多么的重要。 进程间通信的准备1、 序列化Android中要在进程间传输的数据都要是可序列化的，序列化就是把对象转换成二进制（字节流），从而可以存储到存储设备或者通过网络进行传输，有序列化，就有反序列，反序列化就是把二进制（字节流）转化为对象，其中8种基本数据类型默认可以在进程间传输，没有序列化的概念，序列化的作用对象是对象。在Android中，对象通过实现Serializable或Parcelable接口来实现序列化，下面简单介绍一下它们之间使用和区别： 1.1、SerializableSerializable是java中提供的一个序列化接口，它是一个空接口，对象实现这个Serializable接口，就标记这个对象是可序列化的，然后我们通过ObjectOutputStream的writeObject方法就能完成对象的序列化，如下： 1234User user = new User();ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream(\"D://test.txt\"));os.writeObject(user);os.close(); 同理，通过ObjectOutputStream的readObject方法就能完成对象的反序列化，如下： 123ObjectOutputStream in = new ObjectInputStream(new FileInputStream(\"D://test.txt\"));User user = in.readObject();in.close(); 如果你在序列化这个对象之后有可能会改变这个对象的类结构，例如为类添加新的字段，这时在序列化这个对象之前你就要为这个对象的类加上一个serialVersionUID参数，如下： 1234public class User&#123; //serialVersionUID取什么值没关系，只要保持不变就行 private static final long serialVersionUID = 1L;&#125; 如果你确保这个对象的类结构在序列化之后是一直不变的，那么这个serialVersionUID可以忽略，为什么会这样呢？这是因为在序列化的时候，系统会把当前类的serialVersionUID写入到序列化的文件中，当反序列化时系统就会去检测文件中的serialVersionUID是否和当前类的serialVersionUID相同，如果相同就说明序列化的类和当前类的版本是相同的，这时候系统可以正确的反序列化，如果不一致，就说明序列化的类和当前类相比发生了某些变化，例如当前类添加了新的字段，这时就会反序列化失败，抛出异常。所以如果你手动指定了serialVersionUID的值，并一直保持不变，就算你改变了类的结构（不要改变类名和变量类型），序列化和反序列化时两者的serialVersionUID都是相同的，可以正常的进行反序列化，相反，如果你没有指定serialVersionUID的值，系统会根据类的结构自动生成它的hash值作为serialVersionUID的值，这时你改变了类的结构，在进行序列化和反序列化时两者生成的serialVersionUID不相同，这时反序列化就会失败，所以当你没有指定serialVersionUID的值，你要确保这个对象的类结构在序列化之后是一直不变。当然大多数情况下我们还是会指定serialVersionUID的值，以防我们不小心修改类的结构导致无法恢复对象。 这里只是列举了用Serializable实现对象序列化最简单的使用，其实我们可以通过transient关键字控制哪些字段不被序列化，还有静态成员不属于对象，不会参与序列化过程，还可以手动控制Serializable对象的序列化和反序列化过程，还关于Serializable更多使用方式可以看Java对象表示方式1：序列化、反序列化和transient关键字的作用。 1.2、ParcelableParcelable是Android提供的一个接口，一个对象只要实现了这个接口，就可以实现序列化，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class User implements Parcelable &#123; private final String name; private final String password; public User(String name, String password) &#123; this.name = name; this.password = password; &#125; public String getName() &#123; return name == null ? \"\" : name; &#125; public String getPassword() &#123; return password == null ? \"\" : password; &#125; //下面就是实现Parcelable接口需要实现的方法 @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(this.name); dest.writeString(this.password); &#125; public static final Parcelable.Creator&lt;User&gt; CREATOR = new Parcelable.Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel source) &#123; return new User(source); &#125; @Override public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;; protected User(Parcel in) &#123; this.name = in.readString(); this.password = in.readString(); &#125;&#125; User中需要序列化的字段都会包装进Parcel中，当反序列化时，从Parcel中读取数据，Parcel内部包装了可序列化的数据，可以在进程间传输，其中describeContents方法用来完成内容描述，一般返回0，writeToParcel方法用来实现序列化，CREATOR对象的内部方法用来实现反序列化，其中createFromParcel方法用来从序列化后的对象中创建原始对象，newArray方法用来创建指定长度的原始对象数组。 Parcelable的用法相比Serializable复杂了一点，如果每次需要序列化一个对象，都要写这么多重复样本代码，会有点累，这里我推荐一个插件android-parcelable-intellij-plugin，专门用于自动生成这些重复样本代码。 1.3、Serializable和Parcelable的区别Serializable和Parcelable都可以实现序列化，用于进程间的数据传递，它们之间有什么区别呢？在编码上，Serializable使用简单，而Parcelable稍显复杂；在效率上，Serializable的开销很大，因为它只是一个空接口，我们无需实现任何方法，Java便会对这个对象进行序列化操作，这是因为java会通过反射创建所需方法，导致序列化的过程较慢，而Parcelable的效率高，它的速度比Serializable快十倍，通过把一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现了传递对象的功能；在使用场景上，Parcelable主要用在内存序列化上，它不能使用在要将数据序列化在磁盘上的情况，因为在外界有变化的情况下，Parcelable不能很好的保证数据的持续性，所以如果需要序列化到磁盘或通过网络传输建议使用Serializable，尽管它的效率低点。 综上所述，在Android开发中，如果有序列化的要求，我们多点考虑使用Parcelable，毕竟它是Android自带的，虽然它使用稍显复杂，但是有插件的帮助，加上它的效率高，就略胜Serializable了。 2、开启多进程模式既然是进程间通信，就一定会涉及到两个或两个进程以上，我们知道，在Android中，启动一个应用就代表启动了一个进程，但其实除了启动多个应用外，其实在一个应用中，也可以存在多个进程，只要你为四大组件在AndroidMenifest中指定“android:process”属性就行，比如我希望ClientActivity启动的时候，运行在独立的进程，我就会在AndroidMenifest中这样写，如下： 12345678910&lt;activity android:name=\".MainActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;activity android:name=\".ClientActivity\" android:process=\"com.example.aidltest.client\"/&gt; 可以看到我只是简单的ClientActivity指定了“android:process”属性，这样ClientActivity在启动的时候就会运行在进程名为com.example.aidltest.client的独立进程上，而MainActivity启动时，就会运行在默认进程上，默认进程的进程名为当前包名即com.example.aidltest。 需要注意的是，此时这两个Activity虽然在同一个应用，但是却不在同一个进程，所以它们是不共享内存空间的，Android会为每一个进程分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，所以MainActivity和ClientActivity的内存地址空间不一样，它们要访问对方的数据的时候，都要通过进程间通信的方式来进行。 接下来为了方便后面的讲解，我把ClientActivity指定为主活动，把MainActivity删除，再创建一个Server，并为它指定process属性，如下： 123456789101112&lt;activity android:name=\".ClientActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;service android:name=\".RemoteService\" android:enabled=\"true\" android:exported=\"true\" android:process=\"com.example.aidltest.remote\"/&gt; ClientActivity启动时会运行在默认的进程上，RemoteService启动时会运行在名为com.example.aidltest.remote的进程上，它们在本文分别代表为本地客户端和远程服务端。 通过给四大组件指定”android:process“属性开启多进程时，进程名以 : 开头属于当前应用的私有进程，其他应用的组件不能和它跑在同一个进程中；不以 : 开头的进程属于全局进程，其他应用如果签名相同时，可以通过sharedUserId方式和它跑在同一个进程中，本文没有使用 : 开头，而是直接给新进程指定名字，所以新进程属于全局进程。 使用AIDL前面花了一点篇幅来讲解序列化和其他进程间通信的方式，主要是让大家有个心理准备，下面进入正文： 1、AIDL是什么它全称是Android Interface Definition Language，即Android接口定义语言，为了使其他的进程也可以访问本进程提供的服务，Android使用AIDL来公开服务的接口，它里面定义了本进程可以为其他进程提供什么服务，即定义了一些方法，其他进程就可以通过RPC（远程调用）来调用这些方法，从而获得服务，其中提供服务的进程称为服务端，获取服务的进程称为客户端。 2、AIDL接口的创建AIDL接口用来暴露服务点提供给客户端的方法，新建一个AIDL接口文件，只需要在你的项目中 点击包名 -&gt; 右键 -&gt; new -&gt; AIDL -&gt; Aidl.file，然后输入AIDL接口名称，这里我输入了IUserManager，然后点击Finish，就会在你的main目录下创建了一个aidl文件夹，aidl文件夹里的包名和java文件夹里的包名相同，里面用来存放AIDL接口文件，如下： 在里面你会发现你刚刚创建的AIDL接口IUserManager，点进去，如下： 12345678910111213// IUserManager.aidlpackage com.example.aidltest;// Declare any non-default types here with import statementsinterface IUserManager &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 里面声明了一个方法，写着AIDL支持的一些数据类型(int、long、boolean、float、double、String)，除了这些，AIDL还支持其他的基本数据类型、ArrayList(里面的每个元素都要被AIDL支持)、HashMap(里面的每个元素都要被AIDL支持)、实现了Parcelable接口的对象和AIDL接口本身，还有AIDL接口中只支持声明方法，不支持声明静态常量。 其中如果要在AIDL接口文件中使用AIDL对象，必须显式的 import 进来，即使它们在同一个包内，还有如果在AIDL接口文件用到了Parcelable对象，必须新建一个和它同名的AIDL文件，并在其中声明它为parcelable类型，接下来我要使用User这个Parcelable对象，所以我要在aidl文件夹下新建一个和他同名的AIDL文件，如下： 然后在User.aidl中添加如下内容： 1234// User.aidlpackage com.example.aidltest;parcelable User; 在里面，我声明了User.java这个对象为parcelable类型，接下来把IUserManager中的basicTypes方法删除，添加一个根据用户姓名获得用户信息的方法，如下： 123456789// IUserManager.aidlpackage com.example.aidltest;import com.example.adiltest.User;interface IUserManager &#123; User getUser(String name);&#125; 在里面我显示的 import 了User这个AIDL文件，即使它们在同一个包内，并声明了一个getUser方法，这个方法将会在服务端实现，然后在客户端调用(RPC)。 3、根据AIDL接口生成 对应的Binder类有了AIDL接口后我们需要根据AIDL接口生成客户端和服务端对应的Binder类，有两种方式生成，一种是通过SDK自动生成，另外一种是我们自己手动编码实现，其中能够进行手动编码实现的前提是基于对SDK自动生成的各种Binder类的充分理解，下面我们先来介绍SDK自动生成的Binder类。 3.1、SDK自动生成我们在AS导航栏 Build -&gt; ReBuild Project，SDK就会替我们在 app\\build\\generated\\aidl_source_output_dir\\debug\\compileDebugAidl\\out\\包名 下生成一个IUserManager.java，它就是根据IUserManager.aidl文件生成的，里面没有缩进，所以看起来不习惯，使用快捷键ctrl+alt+L，格式化一下代码，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//IUserManager.java/** * 1、IUserManager接口，getUser方法定义在其中 **/public interface IUserManager extends android.os.IInterface &#123; /** * 1、抽象类Stub，需要在远程服务端实现 */ public static abstract class Stub extends android.os.Binder implements com.example.aidltest.IUserManager &#123; private static final java.lang.String DESCRIPTOR = \"com.example.aidltest.IUserManager\"; public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; public static com.example.aidltest.IUserManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.example.aidltest.IUserManager))) &#123; return ((com.example.aidltest.IUserManager) iin); &#125; return new com.example.aidltest.IUserManager.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; java.lang.String descriptor = DESCRIPTOR; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(descriptor); return true; &#125; case TRANSACTION_getUser: &#123;//case TRANSACTION_getUser分支 data.enforceInterface(descriptor); java.lang.String _arg0; _arg0 = data.readString(); //调用getUser方法的具体实现 com.example.aidltest.User _result = this.getUser(_arg0); reply.writeNoException(); if ((_result != null)) &#123; reply.writeInt(1); _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; reply.writeInt(0); &#125; return true; &#125; default: &#123; return super.onTransact(code, data, reply, flags); &#125; &#125; &#125; /** * 2、代理类Proxy，客户端使用 */ private static class Proxy implements com.example.aidltest.IUserManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public com.example.aidltest.User getUser(java.lang.String name) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); com.example.aidltest.User _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); _data.writeString(name); //传进了TRANSACTION_getUser字段 mRemote.transact(Stub.TRANSACTION_getUser, _data, _reply, 0); _reply.readException(); if ((0 != _reply.readInt())) &#123; _result = com.example.aidltest.User.CREATOR.createFromParcel(_reply); &#125; else &#123; _result = null; &#125; &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; &#125; static final int TRANSACTION_getUser = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); &#125; public com.example.aidltest.User getUser(java.lang.String name) throws android.os.RemoteException;&#125; 这个文件有3个主要的类： 1、IUserManager接口 它声明了IUserManager.aidl定义的getUser方法，继承自IInterface。 2、IUserManager.Stub抽象类 IUserManager的静态内部类，它继承自Binder，说明它是一个 Binder 本地对象（Binder下面介绍），它虽然实现了IUserManager接口，但是它继续声明为一个抽象类，并没有实现IUserManager接口中的getUser方法，表明子类需要实现getUser方法，返回具体的User信息，而服务端将会实现这个Stub抽象类。 *3、IUserManager.Stub.Proxy代理类 * IUserManager.stub的静态内部类，它实现了IUserManager接口，并且实现了getUser方法，但是里面只是把数据装进data这个Parcel对象，通过mRemote的transact方法发送给服务端，接着用reply这个Parcel对象等待服务端数据的返回，这一切都是通过mRemote这个IBinder对象进行，mRemote代表着Binder对象的本地代理（IBinder下面介绍），mRemote会通过Binder驱动来完成与远程服务端的Stub的通信。 可以看到Stub类和Stub.Proxy类都实现了IUserManager接口，这就是一个典型的代理模式，它们的getUser方法有着不同的实现，Stub类它将会在远程的服务端完成getUser方法的具体实现，而Stub.Proxy类是本地客户端的一个代理类，它已经替我们默认的实现了getUser方法，该方法里面通过mRemote这个Binder引用的transact方法把请求通过驱动发送给服务端，我们注意到mRemote发送请求时还传进了TRANSACTION_getUser这个代表着getUser方法的标识名，这表示客户端告诉服务端我要调用getUser这个方法，当驱动把请求转发给服务端后，服务端的Stub类的onTransact方法就会回调，它里面有一个switch语句，根据code来调用不同的方法，这时它就会走到case TRANSACTION_getUser这个分支，然后调用getUser方法的在服务端的具体实现，如果有返回值的话，还会通过reply返回给客户端，这样就通过Binder驱动完成了一次远程方法调用(RPC)。 这里要注意的是客户端通过mRemote的transact方法把请求发送给客户端之后，这时会阻塞UI线程等待服务端的返回，而服务端的onTransact方法回调时，服务端的getUser方法会被回调，这时服务端的getUser方法是运行在服务端Binder线程池中，所以如果此时有UI操作需要回到UI线程再进行UI操作。 我们还注意到IUserManager接口继承了IInterface，IUserManager.Stub继承自Binder，它们是干什么的？我们来认识一下： IInterface 这是一个接口，用来表示服务端提供了哪些服务，如果服务端需要暴露调用服务的方法给客户端使用，就一定要继承这个接口，它里面有个asBinder方法，用于返回当前的Binder对象。 IBinder 这时一个跨进程通信的Base接口，它声明了跨进程通信需要实现的一系列抽象方法，实现了这个接口就说明可以进行跨进程通信，Binder和BinderProxy都继承了这个接口。 Binder 代表的是 Binder 本地对象（Binder实体），它继承自IBinder，所有本地对象都要继承Binder，Binder中有一个内部类BinderProxy，它也继承自IBinder，它代表着Binder对象的本地代理(Binder引用)，Binder实体只存在于服务端，而Binder引用则遍布于各个客户端。 接下来我们动手实践一下，首先在服务端RemoteService中，我们要这样做： 1234567891011121314151617181920public class RemoteService extends Service &#123; //1、实现Stub类中的getUser方法 private IUserManager.Stub mBinder = new IUserManager.Stub() &#123; @Override public User getUser(String name) throws RemoteException &#123; //这里只是简单的返回了一个用户名为name，密码为123456的用户实例 return new User(name, \"123456\"); &#125; &#125;; public RemoteService() &#123; &#125; @Override public IBinder onBind(Intent intent) &#123; //2、在onBinder方法中返回Stub类的实现，Stub类继承自Binder，Binder实现了IBinder，这样返回是没问题的 return mBinder; &#125;&#125; 在服务端我们需要实现Stub类中的getUser方法，然后在onBinder方法中返回Stub类的实现，这样客户端绑定服务时就会收到这个Stub类的Binder引用。 然后在客户端ClientActivity中，我们要这样做： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ClientActivity extends AppCompatActivity &#123; private static final String TAG = ClientActivity.class.getSimpleName(); //1、创建ServiceConnection private ServiceConnection mServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.d(TAG, \"onServiceConnected, 与服务端连接成功！\"); //把服务端返回的Binder引用，通过Stub.asInterface方法包装成本地代理类IUserManager.Stub.Proxy，Proxy类实现了IUserManager，所以这样写是没问题的 IUserManager userManager = IUserManager.Stub.asInterface(service); try &#123; //通过本地代理对象远程调用服务端的方法 User user = userManager.getUser(\"rain\"); Log.d(TAG, \"onServiceConnected，向服务端获取用户信息成功，User = [\" + \"name = \" + user.getName() + \"password = \" + user.getPassword()); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d(TAG, \"onServiceDisconnected, 与服务端断开连接\"); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //2、启动并通过ServiceConnection绑定远程服务 bindService( new Intent(this, RemoteService.class), mServiceConnection, Context.BIND_AUTO_CREATE ); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //3、解绑服务 unbindService(mServiceConnection); &#125;&#125; 在服务端我们首先要创建ServiceConnection，然后通过ServiceConnection来绑定RemoteService，在成功绑定后，ServiceConnection的onServiceConnected方法就会回调，它的第二个输入参数就是RemoteService在onBind方法返回的Stub类的Binder引用，我们拿到这个引用后，就可以通过通过Stub.asInterface方法转换为本地代理类Stub.Proxy，然后调用它的getUser方法，Proxy的getUser方法会远程调用RemoteService的getUser方法，方法返回后，在log中打印出User的信息，最后，活动结束，我们记得解绑服务，这个过程和上面介绍的一次RPC过程是一样的。 我们发现完成一次进程间的通信是非常的简单，这就好像只是简单的调用一个对象的方法，但其实这都得益于Binder在底层为我们做了更多工作，我们上层使用得有多简单，它得底层实现就有多复杂，上面的一次进程间通信，可以简单的用下图表示： 其中ServiceManager就是根据Binder的名字查找Binder引用并返回，如果你对Binder的通信架构有一定的了解，理解这个就不难，对象转换就是完成Binder实体 -&gt; Binder引用，Binder引用 -&gt; Binder实体的转换，在java层继承自Binder的都代表Binder本地对象，即Binder实体，而Binder类的内部类BinderProxy就代表着Binder对象的本地代理，即Binder引用，这两个类都继承自IBinder, 因而都具有跨进程传输的能力，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。 我们重点讲一下图中的第3步：将Binder引用赋值给Proxy的mRemote字段，Proxy就是前面介绍的Stub.Proxy，所以接着我们看看IUserManager.Stub.asInterface(IBinder)方法是如何把服务端返回的Binder引用赋值给本地的代理类Proxy的mRemote字段，asInterface方法如下： 1234567891011121314151617181920212223242526//IUserManager.Stub.javapublic static com.example.aidltest.IUserManager asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; //根据DESCRIPTOR调用IBinder的queryLocalInterface方法 android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.example.aidltest.IUserManager))) &#123; return ((com.example.aidltest.IUserManager) iin); &#125; return new com.example.aidltest.IUserManager.Stub.Proxy(obj);&#125;//Binderpublic @Nullable IInterface queryLocalInterface(@NonNull String descriptor) &#123; if (mDescriptor != null &amp;&amp; mDescriptor.equals(descriptor)) &#123; //mOwner等于Stub类实例 return mOwner; &#125; return null;&#125;//Binder#BinderProxypublic IInterface queryLocalInterface(String descriptor) &#123; return null;&#125; 可以发现它里面根据DESCRIPTOR标识调用IBinder的queryLocalInterface方法在查找一些什么，DESCRIPTOR是什么？DESCRIPTOR是Binder实体的唯一标识，一般用当前的Binder的类名表示，它定义在Stub类中，如本文的Stub的 DESCRIPTOR = “com.example.aidltest.IUserManager”，前面已经讲过Binder和BinderProxy都继承自IBinder，所以它们的queryLocalInterface有不同的实现，我们看到BinderProxy的直接返回null；而Binder的需要和自己的DESCRIPTOR比较，如果相同就返回mOwner，否则返回null，其中mOwner就等于Stub类实例，在Stub类构造的时候赋值，如下： 123456789101112131415public static abstract class Stub extends android.os.Binder implements com.example.aidltest.IUserManager &#123; private static final java.lang.String DESCRIPTOR = \"com.example.aidltest.IUserManager\"; public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; public void attachInterface(@Nullable IInterface owner, @Nullable String descriptor) &#123; mOwner = owner; mDescriptor = descriptor; &#125; //...&#125; 这说明了如果queryLocalInterface的返回不为空，iin != null，表示obj是Binder实体（Stub的子类），客户端和服务端在同一个进程，asInterface方法返回的就是Binder实体；如果queryLocalInterface的返回为空，iin == nul，表示obj实际上是Binder引用，客户端和服务端在不同的进程，asInterface构造一个Proxy对象返回，并把Binder引用通过构造传了进去，我们看Proxy的构造函数，如下： 123456789private static class Proxy implements com.example.aidltest.IUserManager &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; //...&#125; 可以看到，传进去的Binder引用赋值给了mRemote字段，所以Proxy中的mRemote就是Binder引用，客户端就是通过这个mRemote来和服务端通信。 也就是说，如果在同一个进程，asInterface返回的是Stub的实现类，因为不存在跨进程调用，直接调用该方法就行，如果在不同进程，asInterface返回的是Proxy对象，客户端调用Proxy中的同名方法，通过mRemote的transact方法挂起当前线程等待服务端返回，服务端收到请求后响应返回数据。 到这里，相信大家在SDK把帮助下已经会使用AIDL来完成简单的进程间通信，接下来通过手动编码实现。 3.2、手动编码实现我们发现使用AIDL系统会自动的帮我们生成上述代码，是为了方便我们的开发，系统根据AIDL文件生成的java文件格式是固定，我们完全可以抛开AIDL直接手写对应的Binder类，下面我们本着单一原则把原本IUserManager.java的里面的Stub类和Stub类中的Proxy类独立出来，所以我们总共要写3个类，分别是：IUserManager、Stub、Proxy。 1、声明一个继承自IInterface的接口 声明一个继承自IInterface的接口，在里面定义我们想要让客户端调用的方法，如下： 123public interface IUserManager extends IInterface &#123; User getUser(String name);&#125; 2、声明服务端的Stub类 Stub类需要继承Binder，表明它是一个Binder本地对象，它还需要实现IUserManager接口，但是继续声明为抽象类，不需要实现IUserManager的getUser方法，接着我们做以下几步： 1、在里面定义一个字符串DESCRIPTOR，表示Binder实体的唯一标识，用当前的Stub类的类名表示，并把它的可见修饰符改为public，待会在Proxy需要用到. 2、在构造函数中把this 和 DESCRIPTOR字符串 attach 给父类Binder中的mOwner和mDescriptor字段. 3、定义一个TRANSACTION_getUser整型数值代表着getUser方法的标识名，赋值格式照抄自动生成的Stub类的TRANSACTION_getUser. 4、定义一个asInterface静态方法，里面的内容实现照抄自动生成的Stub类的asInterface方法，需要注意里面的IUserManager接口需要换成我们刚刚定义的IUserManager接口. 5、最后重写IInterface的asBinder方法和Binder的onTransact方法，里面的内容实现照抄自动生成的Stub类的asBinder和onTransact方法. 最终这个Stub类如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public abstract class Stub extends Binder implements IUserManager &#123; public static final String DESCRIPTOR = \"com.example.aidltest.Stub\";//这里改成com.example.aidltest.Stub static final int TRANSACTION_getUser = (IBinder.FIRST_CALL_TRANSACTION + 0); public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; public static IUserManager asInterface(android.os.IBinder obj) &#123;//导入我们自定义的IUserManager if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof IUserManager))) &#123; return (IUserManager) iin; &#125; return new Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; java.lang.String descriptor = DESCRIPTOR; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(descriptor); return true; &#125; case TRANSACTION_getUser: &#123; data.enforceInterface(descriptor); java.lang.String _arg0; _arg0 = data.readString(); com.example.aidltest.User _result = this.getUser(_arg0); reply.writeNoException(); if ((_result != null)) &#123; reply.writeInt(1); _result.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; reply.writeInt(0); &#125; return true; &#125; default: &#123; return super.onTransact(code, data, reply, flags); &#125; &#125; &#125;&#125; 3、声明客户端的Proxy类 Proxy类只需要实现IUserManager接口，并且实现IUserManager中的getUser方法，接着我们做以下几步： 1、定义一个IBinder类型的mRemote字段，并在构造函数中赋值. 2、实现IUserManager中的getUser方法和IInterface的asBinder方法，里面的内容实现照抄自动生成的Stub.Proxy的getUser方法和asBinder方法，需要注意getUser中的一些字段需要导入我们刚刚在Stub类中定义的字段. 最终这个Proxy类如下： 123456789101112131415161718192021222324252627282930313233343536public class Proxy implements IUserManager &#123; private IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; @Override public com.example.aidltest.User getUser(java.lang.String name) throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); com.example.aidltest.User _result; try &#123; _data.writeInterfaceToken(Stub.DESCRIPTOR);//这里引用我们自己写的Stub的DESCRIPTOR _data.writeString(name); mRemote.transact(Stub.TRANSACTION_getUser, _data, _reply, 0);//这里引用我们自己写的Stub的TRANSACTION_getUser _reply.readException(); if ((0 != _reply.readInt())) &#123; _result = com.example.aidltest.User.CREATOR.createFromParcel(_reply); &#125; else &#123; _result = null; &#125; &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125;&#125; 最终整个工程目录如下： 4、使用 使用就很简单了，只需要把上面自动生成的IUserManager、IUserManager.Stub、IUserManager.Stub.Proxy替换成我们自己写的IUserManager、Stub、Proxy就行，就不再贴代码了，输出如下： 学完AIDL能干什么平常在Android中应用到进程间通信的场景非常的少，但这并不是说AIDL没有用，一个最直观的应用就是在阅读Android系统源码的时候，例如Activity的启动流程： Activity的启动流程（1） Activity的启动流程（2） 在android8.0之后Activity的有关进程间的通信都是通过AIDL来实现，Android根据IActivityManager.aidl文件来生成进程间通信所需的Binder类，如ApplicationThread在AMS的本地代理，AMS在ActivityThread的本地代理，当我们通过startActiivty发起Activity的启动请求时，ActivityThread就会通过AMS本地代理调用AMS的相应方法，当Actiivty在AMS准备好后，AMS就会通过ActivityThread本地代理回调应用进程的Activity的生命周期方法，这里就不在多述了，这个过程如下： 主要是通过这个例子说明，学习完AIDL后，能够帮助我们更好的理解系统源码有关跨进程的一些术语，类等，通过AIDL也能更好的加深我们对Android进程间通信的原理的理解，也掌握了一种进程间通信的方式。 结语本文简单的介绍了一下Android几种进程间通信的方式，然后通过SDK自动生成AIDL代码来理解了一下生成的代码中各个类的作用和关系，还根据自动生成AIDL代码来手动实现了一遍简单的跨进程通信，加深理解，掌握了一些基础AIDL知识，可能会有些不全面，但是足够基本使用，想要了解更全面的AIDL知识，最好的途径还是参阅官方文档：Android 接口定义语言 (AIDL) 本文源码地址 参考资料： Android系统中Parcelable和Serializable的区别 关于Binder，作为应用开发者你需要知道的全部 如何理解Android的多进程","tags":[{"name":"IPC","slug":"IPC","permalink":"http://yoursite.com/tags/IPC/"},{"name":"AIDL","slug":"AIDL","permalink":"http://yoursite.com/tags/AIDL/"}]},{"title":"策略模式","date":"2019-10-19T14:56:38.000Z","path":"2019/10/19/策略模式/","text":"介绍在开发中也经常遇到这种情况，实现某一个功能往往有许多算法或者策略，我们在实际开发中选择不同的算法或策略来完成该功能。一般的情况是我们会把所有的算法或策略写入一个类中，通过if…else…或case语句来根据实际情况来选择具体算法或策略，但是这种方法会使这个类臃肿，维护难，当增加一种算法或策略时又要修改源代码，违反了面向对象的单一原则和开闭原则。如果将这些算法或者策略抽象出来，提供一个统一的接口，不同的算法或策略有不同的实现类，在实际使用时通过动态注入来实现算法或策略的替换，这种模式扩展性高，维护性好，也就是本次所说的策略模式。 定义策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们相互可以替换。让算法独立于客户端变化。 使用场景（1）需要安全的封装多种同一类型的操作时 （2）出现同一抽象类有多个子类，而又需要使用if..else..或case语句来选择具体子类时 类图 角色介绍： Context - 用来操作策略的上下文环境 Stragety - 策略的抽象 ConcreteStragetyA、B - 具体的策略实现 简单实现我们在写代码时经常会遇到对一个数组排序，排序的算法有很多比如插入排序，归并排序，冒泡排序等，我们在实际开发中要选择一种算法来对数组排序，一般情况下我们会这样写: 1234567891011121314151617181920212223242526272829303132333435363738394041public class Client &#123; private static final int INSERT_SORT = 0;//插入排序 private static final int MERGE_SORT = 1;//归并排序 private static final int BUBBLE_SORT = 2;//冒泡排序 public static void main(String[] args)&#123; Client client = new Client(); int[] a = new int[]&#123;1, 2, 3, 4, 5, 6&#125;; client.show(a, INSERT_SORT); &#125; //显示结果 private void show(int[] a, int type)&#123; if(type == INSERT_SORT)&#123; insetSort(a); &#125;else if (type == MERGE_SORT)&#123; mergeSort(a); &#125;else if (type == BUBBLE_SORT)&#123; bubbleSort(a); &#125; for(int b : a)&#123; System.out.print(b + \" \"); &#125; &#125; //插入排序算法 private void insetSort(int[] a)&#123; //TODO... &#125; //归并排序算法 private void mergeSort(int[] a)&#123; //TODO... &#125; //冒泡排序算法 private void bubbleSort(int[] a)&#123; //TODO... &#125;&#125; 这里并不是讨论算法，就没有给出算法的具体实现，上面我们使用type类型通过if…else…语句来动态决定使用哪一种排序算法，当我们增加一种算法时，就要在函数中增加一个判断，以此类推，这样会使代码变得臃肿，一改很多处都要改。下面用策略模式进行重构，首先定义一个抽象的排序接口。 抽象的排序接口，即抽象策略角色 123public interface Sort&#123; &lt;T&gt; void sort(T[] a);&#125; 具体策略实现类 123456public class BubbleSort implements Sort &#123; @Override public &lt;T&gt; void sort(T[] a) &#123; //这里实现冒泡排序 &#125;&#125; 1234567public class InsertSort implements Sort&#123; @Override public &lt;T&gt; void sort(T[] a) &#123; //这里实现插入排序 &#125;&#125; 1234567public class MergeSort implements Sort &#123; @Override public &lt;T&gt; void sort(T[] a) &#123; //这里实现归并排序 &#125;&#125; 客户端，用来操作策略的上下文环境，即Context角色。 12345678910111213141516171819202122232425public class Client &#123; private Sort mSort; public static void main(String[] args)&#123; Client client = new Client(); //设置策略 Sort bubbleSort = new BubbleSort(); client.setmSort(bubbleSort); Integer[] a = &#123;1, 2, 3, 4, 5, 6&#125;; client.show(a); &#125; public void setmSort(Sort mSort) &#123; this.mSort = mSort; &#125; public void show(Integer[] a)&#123; mSort.sort(a); for(Integer b : a)&#123; System.out.print(b + \" \"); &#125; &#125;&#125; 通过上述实例可以清晰的看出两者的区别，前面说通过if..else语句来解决问题，而后者是通过建立抽象，将不同的算法构建成一个个具体的策略实现，通过不同的策略注入实现算法替换。 结语策略模式主要用来分离算法，在简化逻辑结构的同时，增强了系统的可读性，稳定性，可扩展性，这对于复杂的业务逻辑显得更为直观，通过建立抽象，注入不同实现，从而达到很好的扩展性。 本文源码相关位置","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"静态和动态代理模式","date":"2019-10-15T12:05:03.000Z","path":"2019/10/15/代理模式/","text":"前言代理模式，也称委托模式，是结构型设计模式之一，何为代理呢? 在日常生活中就比如叫朋友替你拿个快递，叫朋友替你做一下作业，叫朋友替你买点东西等等，这个朋友就是你的代理，你把事情委托你的朋友做了，同样在代码的世界中也存在代理，而且在你以后阅读到更多的设计模式时，你会发现很多的设计模式中也有代理模式的影子，代理模式是一个非常重要的设计模式，代理模式分为静态代理和动态代理，本文将会通过一个简单的例子讲解静态代理，然后引出动态代理，并且深入的探讨一下动态代理的实现原理。 代理模式的定义为其他对象提供一种代理以控制这个对象的访问。 使用场景静态代理和动态代理都适用于以下场景： 1、当不想访问某个对象或访问某个对象存在困难时，就可以为这个对象创建一个代理，通过代理来间接的访问这个对象； 2、如果原始对象有不同的访问权限，可以使用代理控制对原始对象的访问，保护原始对象； 3、在访问原始对象时执行一些自己的附加操作； 4、为某个对象在不同的内存地址空间提供局部代理，使得系统可以将服务端的实现隐藏，客户端不必考虑服务端的存在，例如Android中的Binder。 下面先简单的讲解一下静态代理。 静态代理1、类图 角色介绍: Subject — 抽象主题类，定义了代理对象和真实对象的共同接口方法，既可以是接口也可以是抽象类。 RealSubject — 真实主题类，该类可以被称为被委托类或被代理类，该类定义了代理对象所表示的真实对象，实现了Subject接口，而Client端通过代理类间接的调用的真实主题类中的方法，由其执行真正的业务逻辑。 ProxySubject — 代理类，该类也被称为委托类或代理类，该类中持有一个真实主题类的引用，同样实现了Subject接口，在其实现的接口方法中调用真实主题类中相应的接口方法，以此起到代理的作用。 Client — 客户端，使用代理。 这个类图就是静态代理的结构，在下面小明通过中介租房的例子中会有体现这几个角色的作用，而动态代理的类图结构与静态代理的稍有不同，将会在动态代理那里讲到，但动态代理和静态代理的整体思想是相同的，我们还需要注意一下下面会提到的一些近义词： Subject = 公共接口； ProxySubject = 代理对象 = 代理类 = 委托类 = 代理人； RealSubject = 真实对象 = 被代理类 = 被委托类 = 被代理人； 在根据不同的上下文时我会用不同的词表示Subject 、ProxySubject 和 RealSubject，还有委托和代理这个两个动词要根据上下文含义理解。 2、使用静态代理使用静态代理的基本步骤： 1、定义代理对象和真实对象的公共接口； 2、真实对象实现公共接口中的方法； 3、代理对象实现公共接口中的方法，并把方法的逻辑转发给真实对象。 我们通过小明买房的这个例子来讲解静态代理，小明想要在大城市租房，但是他平时很忙没有时间去看房，于是他就找到一个房产中介，把自己的租房意愿告诉房产中介，让房产中介来替自己解决租房问题，很明显房产中介就是代理人，小明就是被代理的人。 我们用静态代理来实现这个过程，首先定义一个租房步骤的公共接口： 1234567//租房步骤公共接口，即Subject角色public interface IRoom &#123; void seekRoom();//找房 void watchRoom();//看房 void room();//给钱租房 void finish();//完成租房&#125; 4个步骤完成租房，很简单，然后我们定义具体的想要租房的人即小明： 1234567891011121314151617181920212223//被代理人，想要租房的小明，即RealSubject角色public class XiaoMing implements IRoom &#123; @Override public void seekRoom() &#123; System.out.println(\"找房\"); &#125; @Override public void watchRoom() &#123; System.out.println(\"看房\"); &#125; @Override public void room() &#123; System.out.println(\"给钱租房\"); &#125; @Override public void finish() &#123; System.out.println(\"完成租房\"); &#125;&#125; 该类实现了IRoom接口，实现了其中的具体逻辑，但是小明并不会自己去打租房，他委托房产中介去做，所以这里定义一个房产中介： 1234567891011121314151617181920212223242526272829//代理人，房产中介，即ProxySubject角色public class RoomAgency implements IRoom &#123; private IRoom mRoom;//持有一个被代理人（小明）的引用 public RoomAgency(IRoom room)&#123; this.mRoom = room; &#125; @Override public void seekRoom() &#123; mRoom.seekRoom(); &#125; @Override public void watchRoom() &#123; mRoom.watchRoom(); &#125; @Override public void room() &#123; mRoom.room(); &#125; @Override public void finish() &#123; mRoom.finish(); &#125;&#125; 在该类中会持有一个被代理人的引用，在这里指小明，可以看到房产中介所执行的方法的实质就是简单的调用被代理人中的方法，下面来看看Client中具体的执行关系： 1234567891011121314151617//客户端，即Client角色public class Client &#123; public static void main(String[] args)&#123; //小明想租房 XiaoMing xiaoMing = new XiaoMing(); //找一个代理人，房产中介 RoomAgency roomAgency = new RoomAgency(xiaoMing); //房产中介找房 roomAgency.watchRoom(); //房产中介看房 roomAgency.seekRoom(); //房产中介租房 roomAgency.room(); //房产中介完成租房 roomAgency.finish(); &#125;&#125; 输出结果: 1234看房找房给钱租房完成租房 上面就是傻瓜式的过程，一看就懂，房产中介代理了小明的找房、看房、租房等过程，可以看到静态代理模式还是很简单，就是一种委托机制，真实对象将方法委托给代理对象，那么房产中介继续代理其他人可以吗? 可以的，比如XiaoHong也想租房，我们再定义一个XiaoHong实现IRoom接口，并在Client中给房产中介RoomAgency代理就行。 3、缺点但是如果小明是想要买房而不是租房，这时房产中介还能满足小明的需求吗？很显然不能了，因为这个房产中介它只有替人租房的能力，没有替人买房的能力，这时就需要更换租房接口为买房接口，再定义一个专门买房的的房产中介，你会发现我每次更换接口，都需要更换代理类，这就是静态模式的缺点，只能为给定接口下的实现类做代理，如果接口不同就需要定义不同的代理类，随着系统的复杂度增加，就会很难维护这么多代理类和被代理类之间的关系，这时动态代理就应运而生，当需要频繁的更换接口，更换代理类时，采用动态代理是一个更好的选择，动态代理可以通过一个代理类来代理N多个被代理类，它在更换接口时，不需要重新定义代理类，因为动态代理不需要根据接口提前定义代理类，它把代理类的创建推迟到代码运行时来完成。 4、与动态代理的区别我们先来复习一下class文件的加载，我们编写的.Java文件经过javac编译之后，会产生.class文件，这种.class文件是二进制文件，里面的内容是只有JVM能够识别，在代码运行之前，JVM会读取.class文件，解析.class文件内的信息，取出二进制数据，加载进内存中，从而生成对应的Class对象。 而静态代理和动态代理最主要的区别就是：静态代理在我们的代码运行之前，代理类的.class文件就已经存在，例如上述的RoomAgency.java，在经过javac编译之后，就会变成RoomAgency.class；而动态代理则与静态代理相反，在代码运行之前不存在代理类的.class文件，在代码运行时才动态的生成代理类。 下面来讲解动态代理，并通过动态代理重新实现一遍小明买房的例子。 动态代理1、类图 这个就是动态代理的大概类图结构，其中Subject 、ProxySubject、 RealSubject和Client角色的作用和静态代理的一样，这里就不在累述，与静态代理相比，多了一个InvocationHandler角色和一个Proxy角色，InvocationHandler是java提供的一个接口，我们需要定义一个类实现InvocationHandler接口，这里就叫DynamicProxy角色；Proxy是java提供用于动态生成ProxySubject的一个类，它需要ProxySubject继承。 我们看到DynamicProxy在ProxySubject和RealSubject之前起到了中间人的角色，ProxySubject会把事情委托给DynamicProxy来做，而DynamicProxy最终把事情委托给RealSubject来做，可以这样说：ProxySubject代理了DynamicProxy，而DynamicProxy代理了RealSubject，其中最重要的一点是ProxySubject是在代码运行时才动态生成的，这是和静态代理的最大区别。 接下来简单介绍一下InvocationHandler接口和Proxy类。 1、InvocationHandler和Proxy的作用为了让我们更加容易的实现动态代理，java提供了动态代理接口InvocationHandler和动态代理类Proxy供我们使用，它们都在java.lang.reflect包中，可见动态代理和反射有不可逃脱的关系。 InvocationHandler接口 定义如下： 123456789public interface InvocationHandler &#123; /** * 这个方法的含义是：代理对象proxy要调用真实对象的method * @param proxy 代理对象 * @param method 真实对象被调用的方法 * @param args 被调用的方法的参数 */ Object invoke(Object proxy, Method method, Object[] args）throws Throwable;&#125; InvocationHandler接口的作用就是在invoke方法中执行真实对象的方法，可以看到里面只有一个invoke方法，我们需要为真实对象定义一个实现了这个接口中的invoke方法的动态代理类，同时在创建这个动态代理类的实例的时候，我们还要在方法或构造中传入真实对象的引用，即InvocationHandler的实现类需要持有真实对象的引用，这样才能执行真实对象的方法。 Proxy类定义如下： 1234567891011121314151617181920public class Proxy implements Serializable &#123; protected InvocationHandler h;//持有一个InvocationHandler类型的引用 protected Proxy(InvocationHandler h) &#123; this.h = h; &#125; //根据指定的类加载器和接口来获取代理对象的Class对象 public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class... interfaces) throws IllegalArgumentException &#123; //... &#125; //根据指定的类加载器和接口生成代理对象 public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; //... &#125; //...&#125; Proxy这个类的作用就是用来动态的创建一个代理对象，它内部会持有一个InvocationHandler引用，在构造中传入，它公开了getProxyClass方法和newProxyInstance方法： getProxyClass（重点方法）：这个方法的作用是在运行时根据.class的结构生成一个代理Class二进制流，并通过传入的ClassLoader去把代理Class二进制流加载成一个代理Class对象，该代理Class对象继承Proxy并实现了传入的第二个参数对应的Interface列表。 newProxyInstance (常使用的方法)： 这个方法的作用是在运行时根据代理Class对象生成代理对象实例，这个方法中会先调用了getProxyClass方法生成代理Class对象，在获取到代理Class对象后，通过反射创建代理对象实例并在构造中传入InvocationHandler实例，所以newProxyInstance最终的结果是生成一个代理对象实例，该代理对象会继承Proxy类并实现给定的接口列表，同时内部持有一个InvocationHandler引用。 以上两个方法过程现在看不懂不要紧，下面在讲解动态代理的源码分析时还会再分析一遍，我们通常会使用Proxy的newProxyInstance方法来生成一个代理对象实例。 3、使用动态代理使用动态代理的基本步骤如下： 1、定义代理对象和真实对象的公共接口；（与静态代理步骤相同） 2、真实对象实现公共接口中的方法；（与静态代理步骤相同） 3、定义一个实现了InvocationHandler接口的动态代理类； 4、通过Proxy类的newProxyInstance方法创建代理对象，调用代理对象的方法。 1和2步骤都是和静态代理步骤相同的，就不在累述了，和静态代理相比，少了的一个步骤是：代理对象实现公共接口的方法，因为前面讲过代理对象是代码运行时通过Proxy动态创建的，所以不需要提前编写代理对象的类；和静态代理相比，多了的两个步骤是：3、定义一个实现了InvocationHandler接口的动态代理类和4、通过Proxy类的newProxyInstance方法创建代理对象，调用代理对象的方法，我们接着静态代理的小明买房的例子，下面分别讲解： 步骤3：我们需要定义一个动态代理类，它用于执行真实对象的方法： 12345678910111213141516//实现了InvocationHandler接口的动态代理类public class DynamicProxy implements InvocationHandler &#123; private Object mObject;//真实对象的引用 public DynamicProxy(Object object)&#123; this.mObject = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //通过反射调用真实对象的方法 Object result = method.invoke(mObject, args); return result; &#125;&#125; 在该类中，我们声明了一个Object引用，该引用指向真实对象，真实对象在构造函数中传入，而在invoke方法中通过反射调用真实对象的具体方法，这里需要注意的是指向真实对象的引用类型最好定义为Objec类型而不是真实对象的具体类型如XiaoMing，这样做的好处是，当你要代理另外一个人时，例如xiaoHong，我在DynamicProxy的构造函数中只需要传入xiaoHong引用而不用更改DynamicProxy的类结构，这样一个DynamicProxy就可以代理很多人。 接着步骤4：通过Proxy类newProxyInstance方法创建代理对象，调用代理对象的方法，下面是Client端逻辑: 123456789101112131415161718192021222324public class Client &#123; public static void main(String[] args) &#123; //构造一个小明 IRoom xiaoMing = new XiaoMing(); //构造一个动态代理 InvocationHandler dynamicProxy = new DynamicProxy(xiaoMing); //获取被代理类小明的ClassLoader ClassLoader classLoader = xiaoMing.getClass().getClassLoader(); //1、通过Proxy类的newProxyInstance方法动态构造一个代理人房产中介 IRoom roomAgency = (IRoom) Proxy.newProxyInstance(classLoader, new Class[]&#123;IRoom.class&#125;, dynamicProxy); //调用代理对象的方法 //房产中介找房 roomAgency.watchRoom(); //房产中介看房 roomAgency.seekRoom(); //房产中介租房 roomAgency.room(); //房产中介完成租房 roomAgency.finish(); &#125;&#125; 运行结果和前面的静态代理一致，就不再贴出，在介绍Proxy时讲过，Proxy的newProxyInstance方法会根据传入的类加载器动态生成代理对象实例，生成的代理对象会继承Proxy类并实现传入的接口列表，这里的类加载器是小明的ClassLoader，即真实对象的类加载器，而接口列表则是IRoom，所以传入了IRoom的Class对象，除了这个两个参数，还传入了动态代理类InvocationHandler实例，这样Proxy类在创建代理对象的实例时就会把这个InvocationHandler引用传给代理对象，接下来当我们调用代理对象的方法时，这个方法的处理逻辑就会委托给InvocationHandler实例的invoke方法执行，invoke方法中就会通过反射调用我们真实对象的方法。 下面我们通过源码看一下是怎样生成代理对象以及生成的代理对象是长什么样的。 4、源码分析源码分析基于JDK 1.8版本，我们看Client的注释1： 12//1、通过Proxy类的newProxyInstance方法动态构造一个代理人房产中介IRoom roomAgency = (IRoom) Proxy.newProxyInstance(classLoader, new Class[]&#123;IRoom.class&#125;, dynamicProxy); 我们先看Client的注释1，Proxy的newProxyInstance方法会根据传入的类加载器动态生成代理对象实例，我们点进Proxy的newProxyInstance方法看一下，如下： 123456789101112131415161718192021222324252627282930//Proxy.java private static final Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler.class &#125;;public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123; Objects.requireNonNull(h); //clone一下传入的接口列表 final Class&lt;?&gt;[] intfs = interfaces.clone(); //getProxyClass会把逻辑转发给getProxyClass0，所以getProxyClass的作用 = getProxyClass0的作用，它们的区别只是一个是public，一个是private的 //1、调用getProxyClass0，获得一个代理Class对象 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); try &#123; //constructorParams = InvocationHandler.class //2、这里通过代理Class对象获取构造参数为InvocationHandler的Constructor final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); //传入的InvocationHandler引用 final InvocationHandler ih = h; //这个Constructor是protected的，所以要设置为Public if (!Modifier.isPublic(cl.getModifiers())) &#123; cons.setAccessible(true); &#125; //3、通过构造参数为InvocationHandler的Constructor反射创建代理对象实例，并传入InvocationHandler引用给构造 return cons.newInstance(new Object[]&#123;h&#125;); &#125; //...省略异常处理&#125; 这个方法里面的流程还是很简单的，首先注释1，调用getProxyClass0方法，获得一个代理Class对象，getProxyClass0等于前面讲过的getProxyClass的作用，如下： 1234567891011121314 public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) throws IllegalArgumentException&#123; //... //getProxyClass里面最终是调用了getProxyClass0 return getProxyClass0(loader, interfaces);&#125;private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; //... //proxyClassCache是WeakCache类型，是用来缓存代理Class对象，如果loader和interfaces对应的代理Class对象已经加载过，那么就直接返回缓存的，否则就通过ProxyClassFactory的apply方法生成一个新的代理Class对象并缓存返回 return proxyClassCache.get(loader, interfaces);&#125;//缓存代理Class对象private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory()); 可以看到，getProxyClass里面也是简单的调用getProxyClass0方法，而getProxyClass0方法中会去类型为WeakCache的proxyClassCache缓存中查找通过loader加载并实现了interfaces接口的代理Class对象，如果没有，就通过ProxyClassFactory的apply方法生成一个新的代理Class对象，这个新的代理Class对象会使用loader加载并实现了interfaces接口，ProxyClassFactory的apply方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123; //生成的代理Class类的名字前缀 private static final String proxyClassNamePrefix = \"$Proxy\"; //生成的代理Class类的名字唯一序号，自增 private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; //1、遍历interfaces，校验interface是否合法 Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; //校验loader是否可以加载这个interface Class&lt;?&gt; interfaceClass = null; try &#123; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + \" is not visible from class loader\"); &#125; //校验这个interface是否真的是一个接口 if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + \" is not an interface\"); &#125; //校验这个interface是否重复 if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( \"repeated interface: \" + interfaceClass.getName()); &#125; &#125; //2、根据规则生成代理Class类的名字 String proxyPkg = null; int accessFlags = Modifier.PUBLIC | Modifier.FINAL; //记录interfaces是否有private的 for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1)); if (proxyPkg == null) &#123;//如果有interface为private的，记录它的包名 proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( \"non-public interfaces from different packages\"); &#125; &#125; &#125; //如果proxyPkg为空，说明所有的interfaces都为public，这时记录包名为com.sun.proxy if (proxyPkg == null) &#123; //PROXY_PACKAGE的值为com.sun.proxy proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\"; &#125; long num = nextUniqueNumber.getAndIncrement(); //代理class类的名字，由proxyPkg、.、$Proxy、数字拼接而成 String proxyName = proxyPkg + proxyClassNamePrefix + num; //3、通过ProxyGenerator的generateProxyClass方法生成代理Class类的二进制流 byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags); try &#123; //4、最终通过defineClass0方法使用loader把代理Class类加载进JVM return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; throw new IllegalArgumentException(e.toString()); &#125; &#125;&#125; ProxyClassFactory的apply方法中首先会校验interfaces是否合法，然后根据interfaces的访问修饰符生成代理Class类的名字，如果interfaces都是public的，那么就会使用com.sun.proxy作为代理Class类的包名，如果interfaces含有private的接口，那么就会使用private接口的包名作为代理Class类的包名，然后再把包名拼接上$Proxy和数字作为代理Class类的名字，最后通过ProxyGenerator的generateProxyClass方法生成代理Class类的二进制流，这个代理Class类继承自Proxy并实现了Interfaces接口，然后通过defineClass0方法使用loader把代理Class类二进制流加载进JVM，defineClass0方法是一个native方法，它的作用就和ClassLoader中的defineClass方法类似：把Class类二进制流加载进JVM成为Class对象。 在通过ProxyGenerator的generateProxyClass方法生成代理Class类的二进制流时，有个saveGeneratedFiles字段，可以把生成的代理Class类保存一份到磁盘中，如下： 12345678910111213141516171819202122232425262728293031323334353637383940public class ProxyGenerator &#123; //... //属性为sun.misc.ProxyGenerator.saveGeneratedFiles private final static boolean saveGeneratedFiles = java.security.AccessController.doPrivileged(new GetBooleanAction(\"sun.misc.ProxyGenerator.saveGeneratedFiles\")).booleanValue(); public static byte[] generateProxyClass(final String name, Class&lt;?&gt;[] interfaces, int accessFlags) &#123; ProxyGenerator gen = new ProxyGenerator(name, interfaces, accessFlags); //通过ProxyGenerator的generateClassFile生成Class类的二进制流 final byte[] classFile = gen.generateClassFile(); //如果saveGeneratedFiles为true，就把Class类的二进制流保存一份到磁盘中 if (saveGeneratedFiles) &#123; java.security.AccessController.doPrivileged( new java.security.PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; try &#123; int i = name.lastIndexOf('.'); Path path; if (i &gt; 0) &#123; Path dir = Paths.get(name.substring(0, i).replace('.', File.separatorChar)); Files.createDirectories(dir); path = dir.resolve(name.substring(i+1, name.length()) + \".class\"); &#125; else &#123; path = Paths.get(name + \".class\"); &#125; Files.write(path, classFile); return null; &#125; catch (IOException e) &#123; throw new InternalError( \"I/O exception saving generated file: \" + e); &#125; &#125; &#125;); &#125; return classFile; &#125;&#125; 如果大家想知道代理类的Class文件生成过程细节，可以看ProxyGenerator的generateClassFile方法，这里就不展开了，而saveGeneratedFiles的对应值为sun.misc.ProxyGenerator.saveGeneratedFiles属性的值，我们可以设置这个属性值为true来查看动态生成的代理Class类。 接下来我们来看一下Client中动态生成的代理Class对象的真实面目，首先在Client的main函数的开头填入下面的一代码： 1System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\"); 由于IRoom接口是一个public接口，所以运行Client的main函数就会在的idea工作空间下的com/sun/proxy目录下生成一个$Proxy0.class文件，这个$Proxy0.class就是动态生成的代理Class对象，如下： 这个.class文件里面都是JVM才能看懂的二进制，用idea打开，它会自动替你反编译成.java文件，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public final class $Proxy0 extends Proxy implements IRoom&#123; private static Method m1; private static Method m3; private static Method m4; private static Method m2; private static Method m5; private static Method m6; private static Method m0; //调用父类Proxy的构造函数，传入InvocationHandler引用 public $Proxy0(InvocationHandler paramInvocationHandler)&#123; super(paramInvocationHandler); &#125; //下面四个方法都是实现自IRoom的方法，可以看到它们只是简单的调用了父类的h的invoke方法，并把代理对象 $Proxy0实例、要调用的方法method，还有参数传了进去 public final void watchRoom()&#123; try&#123; this.h.invoke(this, m3, null); return; &#125; //...省略异常处理 &#125; public final void room()&#123; try&#123; this.h.invoke(this, m4, null); return; &#125; //...省略异常处理 &#125; public final void seekRoom()&#123; try&#123; this.h.invoke(this, m5, null); return; &#125; //...省略异常处理 &#125; public final void finish()&#123; try&#123; this.h.invoke(this, m6, null); return; &#125; //...省略异常处理 &#125; //...我们只关注IRoom接口中的方法，所以我省略了Object中继承而来的toSting，hashcode方法等，里面逻辑都一样，都是调用父类的h的invoke方法 static&#123; try&#123; m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]); m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] &#123; Class.forName(\"java.lang.Object\") &#125;); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]); //获取IRoom接口方法的Method对象 m3 = Class.forName(\"com.example.hy.designpatternDemo.proxy.IRoom\").getMethod(\"watchRoom\", new Class[0]); m4 = Class.forName(\"com.example.hy.designpatternDemo.proxy.IRoom\").getMethod(\"room\", new Class[0]); m5 = Class.forName(\"com.example.hy.designpatternDemo.proxy.IRoom\").getMethod(\"seekRoom\", new Class[0]); m6 = Class.forName(\"com.example.hy.designpatternDemo.proxy.IRoom\").getMethod(\"finish\", new Class[0]); return; &#125; //...省略异常处理 &#125;&#125; 为了阅读方便，我省略了无关代码，可以看到Proxy类的getProxyClass0方法会替我们动态生成代理对象$Proxy0.class，这个代理对象会继承Proxy类和实现接口列表，而这里传入的接口只有IRoom，所以$Proxy0只会实现IRoom的方法，这些方法里面的逻辑都是调用父类的h的invoke方法，父类的h就是InvocationHandler引用，我们回去看newProxyInstance方法的注释2和3，你就会发现这个InvocationHandler引用是在通过反射创建$Proxy0实例时在构造中传入的。 我们在$Proxy0中还发现了很多Method对象，在$Proxy0的底部的static块中通过反射获取到我们IRoom接口所有方法的Method对象，当我们调用某个方法时，相应方法的method和代理对象$Proxy0实例、还有方法参数一起传进了父类的h的invoke方法中，所以我们在invoke方法中就可以根据method通过反射调用真实对象的相应方法，如下： 12345678910111213141516//实现了InvocationHandler接口的动态代理类public class DynamicProxy implements InvocationHandler &#123; private Object mObject;//真实对象的引用 public DynamicProxy(Object object)&#123; this.mObject = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //通过反射调用真实对象的方法 Object result = method.invoke(mObject, args); return result; &#125;&#125; 我们回到Client的注释1，所以当我们调用Proxy类的newProxyInstance方法，这个方法在里面创建了代理对象，并返回代理对象$Proxy0实例，所以当我们调用代理对象的方法时，我们就是在调用$Proxy0相应的方法，这个方法处理逻辑就会委托给InvocationHandler实例的invoke方法执行(代理对象的父类持有InvocationHandler引用)，invoke方法中就会通过反射调用我们真实对象的方法(InvocationHandler的实现类中持有真实对象的引用)，这就是整个动态代理的过程。 5、原理通过使用和源码分析，相信大家对动态代理有一个更加深入的了解，动态代理的原理就是一个代理类文件的动态加载过程，由于JVM可以通过.class文件的二进制信息加载class对象的，那么如果我们在代码运行时，遵循.class文件的格式和结构，生成相应的二进制数据，然后再把这个二进制数据通过JVM加载成对应的class对象，有了class对象，我们就可以在运行时通过反射创建出代理对象的实例，这样就完成了在代码运行时，动态的创建一个代理对象的能力，这就是动态代理的原理。 结语在静态代理模式中，代理类ProxySubject中的方法，都指定地调用了特定ReadSubject对应的方法；而在动态代理模式中，代理类ProxySubject中每一个方法的调用，都会交给InvocationHandler来处理，而InvocationHandler则调用了RealSubject的方法，以上就是我对静态代理和动态代理的理解，下面用一张表总结本文： 优点 缺点 区别 静态代理 1、代理类作为客户端和被代理类之间的中介，起到了保护被代理类的作用2、通过接口对代理类和被代理类进行解耦，降低了系统的耦合度 1、只能为给定接口下的实现类做代理，如果接口不一样那么就要重新定义不同的代理类，维护复杂2、由于在客户端和被代理类之间增加了代理对象，因此会造成请求的处理速度变慢 需要提前实现接口编写代理类，在代码运行之前，代理类的.class文件就已经存在 动态代理 1、代理类在程序运行时由反射自动生成，无需我们手动编写代理类代码，简化编程工作2、一个动态代理类InvocationHandler就能代理多个被代理类，较为灵活 1、动态代理只能代理实现了接口的类，而不能代理实现抽象类的类2、通过反射调用被代理类的方法，效率低 不需要提前实现接口编写代理类，在代码运行时，由JVM来动态的创建代理类 代理模式应用广泛，在实际开发中要根据实际情况进行选择。 本文源码位置 参考资料： JDK动态代理为什么必须要基于接口 动态代理模式学习指南","tags":[{"name":"静态代理","slug":"静态代理","permalink":"http://yoursite.com/tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"动态代理","slug":"动态代理","permalink":"http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"}]},{"title":"从进程的角度看Android的系统架构","date":"2019-10-08T08:32:55.000Z","path":"2019/10/08/从进程的角度看Android的系统架构/","text":"前言 上一篇文章Android的系统架构概述 上一篇文章从5个层次简述了Android的系统架构，那么这5个层次是怎么联系起来的呢？本文从进程的角度看Android的系统架构，简述一下Android系统启动的过程中，各大进程的启动顺序是如何的，本文并不会涉及到任何源码，只是为了让读者对Android的进程有个大概的了解。 先看一张图： 从这张图中可以找到Android官方给出的5个层次（Application、Framework（java）、库和运行时（native）、HAL、Kernel）的影子，java层与native层之间通过JNI调用打通，native层与kernel层通过Syscall调用打通。这个图就是你启动Android手机时Android系统的启动过程，下面从下到上分别介绍： 1、系统启动（Loader）长按电源键开机键： 1.1 Boot ROM引导芯片代码固化在ROM中，当你长按电源键开机时，会引导引导芯片代码从预定义的代码处开始执行，然后加载引导程序Boot Loader到RAM中。 1.2 Boot LoaderBoot Loader是Android系统启动之前的引导程序，顾名思义，就是将系统拉起来并启动。 2、Linux内核启动（Kernel）然后就到了Linux内核启动，内核启动时就会启动两个进程 — swapper（pid=0），kthreadd（pid=2）： 2.1、swapper（pid=0）swapper进程又称idle进程， 是系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作。 2.2、kthreadd（pid=2）kthreadd是Linux系统的内核进程，是所有内核进程的鼻祖，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。 3、init进程启动（Native）init进程是Linux系统的用户进程，它的pid=1，是所有用户进程的鼻祖，它是由许多源码文件组成的，它对应的源码目录在/system/core/init中。init进程有许多重要的职责： 孵化出许多用户空间的守护进程（ueventd、logd、healthd、installd、adbd、lmkd） 启动ServiceManager(binder服务管家)、bootanim(开机动画)等重要服务 孵化出Media Server进程，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。 孵化出Zygote进程 4、Zygote进程启动（Native -&gt; java Framework）Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，Zygote是所有Java进程的父进程，它是由init进程通过解析init.rc文件后fork生成的，Zygote的启动脚本放在/system/core/rootdir目录中。Zygote进程的职责主要有： 创建JVM虚拟机，并为JVM注册JNI方法 响应AMS的请求去创建新的应用进程 孵化出SystemServer进程 5、SystemServer进程启动（java Framework）SystemServer进程是Zygote孵化的第一个进程，负责创建系统服务如ActivityManagerService，WindowManagerService，PackageManagerService，InputManagerService等服务，和管理整个Java framework。SystemServer进程的职责主要有： 创建Binder线程池，这样就可以与其他进程进行跨进程通信 启动SystemServiceManger，它用来对系统服务进行创建、管理和启动 通过SystemServiceManger启动各种系统服务：引导服务（如AMS，PMS），核心服务，其他服务（如WMS，IMS） 6、Launcher进程启动（Application）SystemServer进程启动的过程中会启动PMS和AMS，PMS会把系统中的应用程序安装完成，然后AMS会请求Zygote将Launcher启动起来，这就是用户看到的app桌面，然后Launcher会将已经安装了的应用的应用图标显示出来。Launcher进程是Zygote进程孵化出来的第一个App进程。至此Android系统已经启动完毕，用户就可以点进桌面上的应用图标进入app，对于普通的app进程,跟SystemServer进程的启动过来有些类似，不同的是app进程是先发消息给SystemServer进程，由SystemServer向Zygote发出创建进程的请求，而SystemServer是由Zygote直接fork出来，前面已经说过Zygote是所有Java进程的父进程，SystemServer和所有的app进程都是由Zygote进程的子进程。 总结Android系统底层基于Linux Kernel, 当Kernel启动过程会创建init进程, 该进程是所有用户空间的鼻祖,init进程会启动ServiceManager(binder服务管家)、Zygote进程(Java进程的鼻祖)，Zygote进程会创建system_server进程以及各种app进程，下图是这几个系统重量级进程之间的层级关系。 从下而上，其中binder和socket都是Android中进程间的通信方式，而ServiceManager是binder服务的大管家，系统服务的binder实体都会注册到它身上。本文并没有深入的了解各个进程的启动，只是简单的让大家对Android系统主要的进程有个大概的了解，这样以后去研究相应的进程的源码时就会有个大概的方向。 参考资料： Android系统启动-综述","tags":[{"name":"进程","slug":"进程","permalink":"http://yoursite.com/tags/%E8%BF%9B%E7%A8%8B/"}]},{"title":"工厂模式","date":"2019-09-07T11:47:08.000Z","path":"2019/09/07/工厂模式/","text":"前言工厂方法模式是一种结构简单的模式，并且在我们的应用中很广泛，如Android中Activity的各个生命周期的回调，以onCreate方法为例，它就可以看做是一个工厂方法，我们在其中构造我们的View并返回给framework处理。 定义定义一个用于创建对象的接口，让子类决定实例化哪个类。 使用场景在任何需要生成复杂对象的地方，都可以使用工厂方法模式。复杂对象适合使用工厂方法模式，用new就能完成创建的对象无需使用工厂方法模式。 类图 角色介绍： Factory - 抽象工厂，是工厂方法的核心 ConcreteFactory - 具体工厂，实现了业务逻辑 Product - 抽象产品，是工厂方法模式所创建的产品的父类 ConcreteProduct - 为实现抽象产品的某个具体产品 简单实现下面生产汽车为例，要生产三款汽车，于是使用一条生产线来生产，我们先定义产品，产品是汽车。 抽象汽车，即抽象产品 123public abstract class Car &#123; public abstract void drive();&#125; 接下来是具体的车型 奥迪汽车，即具体的产品类 123456public class AudiCar extends Car &#123; @Override public void drive() &#123; System.out.println(\"奥迪汽车开始启动啦！\"); &#125;&#125; 奔驰汽车，即具体的产品类 1234567public class BenzCar extends Car &#123; @Override public void drive() &#123; System.out.println(\"奔驰车开始启动啦！\"); &#125;&#125; 宝马汽车，即具体的产品类 123456public class BWMCar extends Car &#123; @Override public void drive() &#123; System.out.println(\"宝马汽车开始启动啦！\"); &#125;&#125; 有了产品就要有工厂来生产，定义一个汽车抽象工厂。 抽象汽车工厂，即抽象工厂角色 123public abstract class CarFactory &#123; public abstract Car createCar();&#125; 接下来是具体的车型工厂。 生产奥迪车的工厂，即具体工厂类 12345678public class AudiCarFactory extends CarFactory &#123; @Override public Car createCar() &#123; return new AudiCar(); &#125;&#125; 生产奔驰车的工厂，即具体工厂类 123456public class BenzCarFactory extends CarFactory &#123; @Override public Car createCar() &#123; return new BenzCar(); &#125;&#125; 生产宝马车的工厂，即具体工厂类 123456public class BWMCarFactory extends CarFactory &#123; @Override public Car createCar() &#123; return new BWMCar(); &#125;&#125; 最后我们将各个汽车的生产组装成一条生产线。 客户端 12345678910111213141516171819202122public class Client &#123; public static void main(String[] args)&#123; //制造各个工厂 CarFactory audiFactory = new AudiCarFactory(); CarFactory benzFactory = new BenzCarFactory(); CarFactory bwmFactory = new BWMCarFactory(); //生产各种车 Car audiCar = audiFactory.createCar(); Car benzCar = benzFactory.createCar(); Car bwmCar = bwmFactory.createCar(); //车启动 audiCar.drive(); benzCar.drive(); bwmCar.drive(); &#125;&#125;输出结果:奥迪汽车开始启动啦！奔驰车开始启动啦！宝马汽车开始启动啦！ 可以看到我们需要哪种车型就可以定义哪种车型的具体工厂，像这样拥有多个工厂的的方式我们称之为多工厂模式，每个工厂各司其职。 但上面的方式不好的是会产生大量工厂，使代码臃肿，在实际开发中，我们可以使用反射的方式更加简洁的来生产具体的产品对象，此时需要在工厂方法的参数列表中传入一个Class类来决定是哪一个产品类。 使用反射的方式来生产具体的产品对象，抽象工厂角色 12345678public abstract class CarFactory2 &#123; /** * 抽象工厂方法，具体生产什么产品由子类决定 */ public abstract &lt;T extends Car&gt; T createCar(Class&lt;T&gt; car);&#125; 对于 具体的工厂，则通过反射获取类的实例即可 123456789101112131415161718public class ConcreteCarFactory extends CarFactory2 &#123; @Override public &lt;T extends Car&gt; T createCar(Class&lt;T&gt; car) &#123; Car c = null; try &#123; c = (T) Class.forName(car.getName()).newInstance(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return (T) c; &#125; &#125; 客户端 123456789101112131415public class Client &#123; public static void main(String[] args)&#123; //创建工厂 CarFactory2 carFactory = new ConcreteCarFactory2(); //生产车 AudiCar audiCar = carFactory.createCar(AudiCar.class); BenzCar benzCar = carFactory.createCar(BenzCar.class); BWMCar bwmCar = carFactory.createCar(BWMCar.class); //车启动 audiCar.drive(); benzCar.drive(); bwmCar.drive(); &#125;&#125; 输出和和上面一样，使用反射的方式，需要哪一个产品的对象，就传入哪一个产品的类的型即可，这种方式比较简洁，动态。 上面我们有三个工厂，如果我们只需要生产一种车型，即我们只有一个工厂时，我们就可以把抽象工厂简化掉，将对应的工厂方法改为静态方法，像下面，我们只生产一辆五菱车。 一个工厂，只生产一种产品 1234567public class Factory &#123; public static Car createWuLingCar()&#123; return new WuLingCar(); &#125; &#125; 像这样的方式又称为简单工厂方式或静态工厂方式，它是工厂方式模式的一个弱化版本。 总结工厂模式依赖于抽象的架构，将实例化的具体任务交给子类去完成，有非常好的扩展性。 本文源码相关位置","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"Builder模式","date":"2019-09-07T11:35:25.000Z","path":"2019/09/07/Builder模式/","text":"前言Builder模式是一步步创建一个复杂对象的创建型模式，它允许用户在不知道内部构建细节的情况下，可以更加精准的控制对象的构造过程，为了在构建过程中，对外部隐藏实现细节，就可以使用Builder模式将部件和组装过程分离，使得构建过程和部件可以自由扩展，两者之间的耦合度也降到最低。 定义将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。 使用场景（1）相同的方法不同的执行顺序产生不同的事件结果时 （2）多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不同时 （3）产品类比较复杂或者产品类中的调用顺序不同产生不同的作用时 （4）当初始化一个对象非常复杂，如参数非常多，且很多参数都具有默认值时 类图 类图介绍： Produc - 产品的抽象类 Builder - 抽象的Builder类，规范产品的组建，一般由子类实现具体的组建过程 ConcreteBuilder - 具体的Builder类 Director - 统一组装过程 简单实现计算机的组装过程比较复杂且组装顺序说不固定的，下面把计算机的组装过程简化为构建主机，设置操作系统，设置显示器3部分，然后通过Director和具体Builder来构建计算机对象。 计算机抽象类，即Product 12345678910111213141516171819202122232425262728293031323334public abstract class Computer &#123; protected String mBroad;//主板 protected String mDisplay;//显示器 protected String mOS;//操作系统 protected Computer()&#123;&#125; /** * 设置主板 * @param broad */ public void setmBroad(String broad)&#123; mBroad = broad; &#125; /** * 设置显示器 * @param display */ public void setmDisplay(String display)&#123; mDisplay = display; &#125; /** * 设置操作系统 */ public abstract void setmOS(); @Override public String toString() &#123; return \"Computer &#123;mBroad = \" + mBroad + \", mDisplay = \" + mDisplay + \", mOS = \" + mOS + \"&#125;\"; &#125;&#125; 苹果电脑，具体的Product 123456789public class Macbook extends Computer &#123; protected Macbook() &#123;&#125; @Override public void setmOS() &#123; mOS = \"Mac OS X 10.10\"; &#125;&#125; 抽象Builder类 12345678public abstract class Builder &#123; public abstract void buildBroad(String broad);//设置主机 public abstract void buildDisplay(String display);//设置显示器 public abstract void buildOS();//设置操作系统 public abstract Computer create();//创建Computer&#125; 具体的Builder类，构造苹果电脑 123456789101112131415161718192021222324public class MacBuilder extends Builder &#123; private Computer mComputer = new Macbook(); @Override public void buildBroad(String broad) &#123; mComputer.setmBroad(broad); &#125; @Override public void buildDisplay(String display) &#123; mComputer.setmDisplay(display); &#125; @Override public void buildOS() &#123; mComputer.setmOS(); &#125; @Override public Computer create() &#123; return mComputer; &#125;&#125; Director类，负责构造Computer 12345678910111213141516171819public class Director &#123; private Builder mBuilder; public Director(Builder builder) &#123; this.mBuilder = builder; &#125; /** * 构建对象 * @param broad * @param display */ public void construct(String broad, String display)&#123; mBuilder.buildBroad(broad); mBuilder.buildDisplay(display); mBuilder.buildOS(); &#125;&#125; 测试代码 123456789101112public class Test &#123; public static void main(String[] args)&#123; Builder builder = new MacBuilder(); Director director = new Director(builder); director.construct(\"英特尔主板\", \"Retina 显示器\"); System.out.println(\"Computer Info: \" + builder.create().toString()); &#125;&#125;输出结果 :Computer Info: Computer &#123;mBroad = 英特尔主板, mDisplay = Retina 显示器, mOS = Mac OS X 10.10&#125; 上面代码中，通过具体的MacBuilder来构建Macbook对象，而Director封装构建复杂对象的过程，对外隐藏细节。Builder与Director一起将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的对象。 但在现实开发中，Director常常被忽略，直接使用一个Builder对象来进行链式调用构造，它的关键点是每个setter返回自身，如下，我们来组装一个华硕电脑： 华硕电脑，具体的产品类 1234567public class ASUSbook extends Computer &#123; @Override public void setmOS() &#123; mOS = \"Windows 10 专业版\"; &#125;&#125; 抽象Builder类 12345678public abstract class Builder2 &#123; public abstract Builder2 buildBroad(String broad);//设置主机 public abstract Builder2 buildDisplay(String display);//设置显示器 public abstract Builder2 buildOS();//设置操作系统 public abstract Computer create();//创建Computer &#125; 具体的Builder类，构造ASUS电脑 123456789101112131415161718192021222324252627public class ASUSBuilder extends Builder2 &#123; private Computer mComputer = new ASUSbook(); @Override public Builder2 buildBroad(String broad) &#123; mComputer.setmBroad(broad); return this; &#125; @Override public Builder2 buildDisplay(String display) &#123; mComputer.setmDisplay(display); return this; &#125; @Override public Builder2 buildOS() &#123; mComputer.setmOS(); return this; &#125; @Override public Computer create() &#123; return mComputer; &#125;&#125; 测试代码 12345678910111213141516171819public class Test &#123; public static void main(String[] args)&#123; Builder2 builder2 = new ASUSBuilder(); ASUSbook asusbook = (ASUSbook) builder2 .buildBroad(\"AMDB350socketAM4\") .buildDisplay(\"AOC 显示器\") .buildOS() .create(); System.out.println(\"Computer Info: \" + asusbook.toString());// Builder builder = new MacBuilder();// Director director = new Director(builder);// director.construct(\"英特尔主板\", \"Retina 显示器\");// System.out.println(\"Computer Info: \" + builder.create().toString()); &#125;&#125;输出结果 :Computer Info: Computer &#123;mBroad = AMDB350socketAM4, mDisplay = AOC 显示器, mOS = Windows 10 专业版&#125; 链式调用形式不仅去除Director角色，让整个结构简单，而且也能对product对象的组装过程有更加精准的控制。 然而上面的只是经典的实现方式，下面才是现在开发中最常用的，通过把Builder与产品类封装在一起，建立于上面的基础。 联想电脑，把Builder与产品类封装在一起 1234567891011121314151617181920212223242526272829303132333435363738394041public class LenovoBook extends Computer &#123; private LenovoBook(Builder builder)&#123; setmOS(); setmBroad(builder.broad); setmDisplay(builder.display); &#125; @Override public void setmOS() &#123; mOS = \"Windows 10 家庭中文版\"; &#125; public static class Builder extends Builder2&#123; String broad; String display; @Override public Builder2 buildBroad(String broad) &#123; this.broad = broad; return this; &#125; @Override public Builder2 buildDisplay(String display) &#123; this.display = display; return this; &#125; @Override public Builder2 buildOS() &#123; return this; &#125; @Override public Computer create() &#123; return new LenovoBook(this); &#125; &#125;&#125; 测试代码 12345678910111213141516public class Test &#123; public static void main(String[] args)&#123; LenovoBook lenovoBook = (LenovoBook) new LenovoBook.Builder() .buildOS() .buildBroad(\"联想主板\") .buildDisplay(\"联想显示器\") .create(); System.out.println(\"Computer Info: \" + lenovoBook.toString()); &#125;&#125;输出结果：Computer Info: Computer &#123;mBroad = 联想主板, mDisplay = 联想显示器, mOS = Windows 10 家庭中文版&#125; 总结Builder模式在开发中很常用，通过把产品类的构造器，字段私有化，只能通过Builder来设置属性，也通常作为配置类的构造器将配置的构建与表示分离开来，同时也是将配置从目标类中独立出来，避免过多的setter方法。Builder模式常用的实现形式是链式调用。 本文源码相关位置","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"责任链模式","date":"2019-09-07T08:46:01.000Z","path":"2019/09/07/责任链模式/","text":"前言责任链模式是一种链式结构，就是由一个个节点首尾相接串起来的结构，具有很好的灵活性，将每一个节点看作是一个对象，每一个对象拥有不同的处理逻辑，将一个请求从链式的首端发出，沿着链的路径依此传递每一个节点对象，直到有对象处理这个请求为止，我们将这样一种模式称为责任链模式。 定义使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。 使用场景 1、多个对象可以处理同一请求，但具体哪个对象处理则是在运行时动态决定 2、在请求者不明确的情况下向多个对象中的一个提交一个请求 3、需要动态指定一组对象的处理请求 类图 角色介绍： AbstractHandler - 抽象处理者角色，声明一个请求处理的方法（handle（））、一个获得处理级别的方法（getHandlerLever（））和封装了一个对具体的处理转发逻辑实现的方法（handleRequest（)），并在其中保持对下一个处理节点的AbstractHandler对象的引用（nextHandler） ConcreteHandler1、2 - 具体处理者角色，对请求进行处理，如果不能处理就将请求转发给下一个节点上的处理对象 AbstractRequest - 抽象的请求类，里面声明了一个获得请求内容的方法（getContent（））和一个获得请求处理级别的方法（getRequestLever（）） ConcreteRequest - 具体的请求类 简单实现在一个公司中，员工拿到了一份合同，需要上级的签名，于是员工就把合同给组长，但是组长没有权限签名，于是组长就把合同给经理，但是经理也没有足够的权限签名，于是经理就把合同给老板，老板二话不说就把合同给签了。上面的例子就是责任链模式，员工是请求的发起者，处于链的底端，而老板是处于链条顶端的类，员工发起请求后，请求经过层层转发，直至请求被处理，员工只是和组长发生了关联，后面合同被谁处理，员工并不知道，也并不关心，他在乎的是合同签名的结果，责任链模式很好的将请求的发起者与处理者解耦，下面用代码来模拟。 抽象的员工，即AbstractHandler角色 123456789101112131415161718public abstract class Staff &#123; protected Staff nextHandler;//上一级领导处理者 //处理转发的逻辑 public final void handleRequest(Contract contract)&#123; if(contract.getContractLever() &lt; getHandlerLever())&#123; handle(contract); &#125;else &#123; if(nextHandler != null)&#123; nextHandler.handleRequest(contract); &#125; &#125; &#125; public abstract int getHandlerLever();//自身能处理请求的级别 public abstract void handle(Contract contract);//具体的处理过程&#125; 在这个抽象的处理者中，一是定义了两个接口来确定一个Staff应有的行为和属性，二是封装了一个处理请求的逻辑转发方法，确定当前Staff是否有足够的级别来处理当前合同，如果没有，就把合同转发给上一级Staff，接下来是各个实现类。 组长，即ConcreteHandler角色 12345678910111213public class CroupStaff extends Staff &#123; @Override public int getHandlerLever() &#123; return 1; &#125; @Override public void handle(Contract contract) &#123; System.out.println(\"组长签名了合同！\"); &#125;&#125; 经理，即ConcreteHandler角色 1234567891011public class ManagerStaff extends Staff &#123; @Override public int getHandlerLever() &#123; return 2; &#125; @Override public void handle(Contract contract) &#123; System.out.println(\"经理签名了合同！\"); &#125;&#125; 老板，即ConcreteHandler角色 1234567891011public class BossStaff extends Staff &#123; @Override public int getHandlerLever() &#123; return 3; &#125; @Override public void handle(Contract contract) &#123; System.out.println(\"老板签名了合同！\"); &#125;&#125; 接下来看一看请求，就是合同。 抽象的合同类，即AbstractRequest角色 1234public abstract class Contract &#123; public abstract String getContext();//获得合同具体内容 public abstract int getContractLever();//获得合同处理级别&#125; 最后员工从组长发起请求。 请求发起者，员工 12345678910111213141516171819public class Employee &#123; public static void main(String[] args)&#123; //构造各个节点对象 GroupStaff groupStaff = new GroupStaff(); ManagerStaff managerStaff = new ManagerStaff(); BossStaff bossStaff = new BossStaff(); //构成一条链 groupStaff.nextHandler = managerStaff; managerStaff.nextHandler = bossStaff; //发起请求 Contract contract = new ConcreteContract(); groupStaff.handleRequest(contract); &#125;&#125;输出结果:老板签名了合同！ 其实这里也可以直接绕过组长和经理，直接找老板签名，这也是责任链模式的灵活性，请求的发起可以从任意节点发起，同时也可以改变责任链模式内部的传递规则，如直接找老板签名。 总结对于责任链模式中的节点，有两个行为，一是处理请求，二是将请求转发给下一个节点，不允许某个节点处理者处理了请求后又把节点转发给下一个节点。对于责任链中的请求，只有俩个结果，一个是被某个节点处理，一个是所有对象均没有处理。 本文相关源码位置","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"okhttp3源码分析之拦截器","date":"2019-09-07T07:01:40.000Z","path":"2019/09/07/okhttp3源码分析之拦截器/","text":"前言 上一篇文章：okhttp3源码分析之请求流程 本篇文章继续通过源码来探讨okhttp的另外一个重要知识点：拦截器，在上一篇文章我们知道，在请求发送到服务器之前有一系列的拦截器对请求做了处理后才发送出去，在服务器返回响应之后，同样的有一系列拦截器对响应做了处理后才返回给发起请求的调用者，可见，拦截器是okhttp的一个重要的核心功能，在分析各个拦截器功能的同时又会牵扯出okhttp的缓存机制、连接机制。 本文源码基于okhttp3.14.x okhttp项目地址：okhttp 拦截器的简单使用自定义一个拦截器需要实现Interceptor接口，接口定义如下： 123456789101112131415161718192021222324252627282930public interface Interceptor &#123; //我们需要实现这个intercept(chain)方法，在里面定义我们的拦截逻辑 Response intercept(Chain chain) throws IOException; interface Chain &#123; //返回Request对象 Request request(); //调用Chain的proceed(Request)方法处理请求，最终返回Response Response proceed(Request request) throws IOException; //如果当前是网络拦截器，该方法返回Request执行后建立的连接 //如果当前是应用拦截器，该方法返回null @Nullable Connection connection(); //返回对应的Call对象 Call call(); //下面的方法见名知意，返回或写入超时 int connectTimeoutMillis(); Chain withConnectTimeout(int timeout, TimeUnit unit); int readTimeoutMillis(); Chain withReadTimeout(int timeout, TimeUnit unit); int writeTimeoutMillis(); Chain withWriteTimeout(int timeout, TimeUnit unit) &#125;&#125; 可以看到Interceptor由两部分组成：intercept(Chain)方法和内部接口Chain，下面是自定义一个拦截器的通用逻辑，如下： 1234567891011121314151617181920public class MyInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; //1、通过传进来的Chain获取Request Request request = chain.request(); //2、 处理Request，逻辑自己写 //... //3、调用Chain的proceed(Request)方法处理请求，得到Response Response response = chain.proceed(request); //4、 处理Response，逻辑自己写 //... //5、返回Response return response; &#125;&#125; 上述就是一个拦截器的通用逻辑，首先我们继承Interceptor实现intercept(Chain)方法，完成我们自己的拦截逻辑，即根据需要进行1、2、3、4、5步，不管是自定义拦截器还是后面介绍的okhttp默认的拦截器大概都是这个模板实现，定义完拦截器后，我们在构造OkhttpClient时就可以通过addInterceptor(Interceptor)或addNetworkInterceptor(Interceptor)添加自定义拦截器，如下： 123456789OkHttpClient client = new OkHttpClient.Builder() .addInterceptor(new MyInterceptor()) .build();或OkHttpClient client = new OkHttpClient.Builder() .addNetworkInterceptor(new MyInterceptor()) .build(); 这样okhttp在链式调用拦截器处理请求时就会调用到我们自定义的拦截器，那么addInterceptor(Interceptor)和addNetworkInterceptor(Interceptor)有什么不一样呢？它们一个是添加应用拦截器，一个是添加网络拦截器，主要是调用的时机不一样，更多区别可以参考官方WIKI文档Okhttp-wiki 之 Interceptors 拦截器，当我们平时做应用开发使用addInterceptor(Interceptor)就行了。 上述是我们自定义的拦截器，下面我们来看看okhttp默认的拦截器都干了什么。 RealCall :: getResponseWithInterceptorChain()在上一篇文章知道RealCall的getResponseWithInterceptorChain()是处理、发送请求并且返回响应的地方，我们再看一遍getResponseWithInterceptorChain()方法的源码，如下： 123456789101112131415161718192021222324252627282930313233343536//RealCall.javaResponse getResponseWithInterceptorChain() throws IOException &#123; //新建一个List用来保存拦截器 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); //添加我们自定义的应用拦截器 interceptors.addAll(client.interceptors()); //添加负责重试重定向的拦截器 interceptors.add(new RetryAndFollowUpInterceptor(client)); //添加负责转换请求响应的拦截器 interceptors.add(new BridgeInterceptor(client.cookieJar())); //添加负责缓存的拦截器 interceptors.add(new CacheInterceptor(client.internalCache())); //添加负责管理连接的拦截器 interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123;//没有特殊要求，不使用WebSocket协议，WebSocket是什么？自行百度 //添加我们自定义的网络拦截器 interceptors.addAll(client.networkInterceptors()); &#125; //添加负责发起请求获取响应的拦截器 interceptors.add(new CallServerInterceptor(forWebSocket)); //构造第一个Chain Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); boolean calledNoMoreExchanges = false; try &#123; //调用Chain的proceed(Request)方法处理请求 Response response = chain.proceed(originalRequest); //... //返回响应 return response; &#125; //...省略异常处理 &#125; getResponseWithInterceptorChain()干了三件事：1、添加拦截器到interceptors列表中；2、构造第一个Chain；3、调用Chain的proceed(Request)方法处理请求。下面分别介绍: 1、添加拦截器到interceptors列表中除了添加我们自定义的拦截器外，还添加了默认的拦截器，如下： 1、RetryAndFollowUpInterceptor：负责失败重试和重定向。 2、BridgeInterceptor：负责把用户构造的Request转换为发送给服务器的Request和把服务器返回的Response转换为对用户友好的Response。 3、CacheInterceptor：负责读取缓存以及更新缓存。 4、ConnectInterceptor：负责与服务器建立连接并管理连接。 5、CallServerInterceptor：负责向服务器发送请求和从服务器读取响应。 这几个默认的拦截器是本文的重点，在后面会分别介绍。 2、构造第一个ChainChain是Interceptor的一个内部接口，它的实现类是RealInterceptorChain，我们要对它的传进来的前6个构造参数有个印象，如下： 12345678910111213141516public final class RealInterceptorChain implements Interceptor.Chain &#123; //... public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, Transmitter transmitter, @Nullable Exchange exchange, int index, Request request, Call call, int connectTimeout, int readTimeout, int writeTimeout) &#123; this.interceptors = interceptors;//interceptors列表 this.transmitter = transmitter;//Transmitter对象，后面会介绍 this.exchange = exchange;//Exchange对象，后面会介绍 this.index = index;//interceptor索性，用于获取interceptors列表中的interceptor this.request = request;//请求request this.call = call;//Call对象 //... &#125; //...&#125; 在后面的拦截器中都可以通过Chain获取这些传进来的参数。我们知道，为了让每个拦截器都有机会处理请求，okhttp使用了责任链模式来把各个拦截器串联起来，拦截器就是责任链的节点，而Chain就是责任链中各个节点之间的连接点，负责把各个拦截器连接起来。那么是怎么连接的？看下面的Chain的proceed方法。 3、调用Chain的proceed(Request)方法处理请求实际是RealInterceptorChain的proceed(Request)方法，如下： 123456789101112131415161718192021222324252627282930313233public final class RealInterceptorChain implements Interceptor.Chain &#123; //... @Override public Response proceed(Request request) throws IOException &#123; return proceed(request, transmitter, exchange); &#125; public Response proceed(Request request, Transmitter transmitter, @Nullable Exchange exchange) throws IOException &#123; //index不能越界 if (index &gt;= interceptors.size()) throw new AssertionError(); //... //再新建一个Chain，这里注意index加1， RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange, index + 1, request, call, connectTimeout, readTimeout, writeTimeout); //获取interceptors列表中的下一个拦截器 Interceptor interceptor = interceptors.get(index); //调用下一个拦截器的intercept(Chain)方法，传入刚才新建的RealInterceptorChain，返回Response Response response = interceptor.intercept(next); //... //返回响应 return response; &#125;&#125; proceed方法里面首先会再新建一个Chain并且index + 1作为构造参数传了进去，然后通过index从interceptors列表中获取了一个拦截器，接着就会调用拦截器的intercept方法，并把刚刚新建的Chain作为参数传给拦截器，我们再回顾一下上面所讲的拦截器intercept方法的模板，intercept方法处理完Request逻辑后，会再次调用传入的Chain的proceed(Request)方法，这样又会重复Chain的proceed方法中的逻辑，由于index已经加1了，所以这次Chain就会通过index获取下一个拦截器，并调用下一个拦截器的intercept(Chain)方法，然后如此循环重复下去，这样就把每个拦截器通过一个个Chain连接起来，形成一条链，把Request沿着链传递下去，直到请求被处理，然后返回Response，响应同样的沿着链传递上去，如下： 从上图可知，当没有自定义拦截器时，责任链首节点就是RetryAndFollowUpInterceptor，尾节点就是CallServerInterceptor，Request按照拦截器的顺序正向处理，Response则逆向处理，每个拦截器都有机会处理Request和Response，一个完美的责任链模式的实现。 知道了getResponseWithInterceptorChain()的整体流程后，下面分别介绍各个默认拦截器的功能。 RetryAndFollowUpInterceptor在自定义拦截器的时候就讲过，Interceptor的intercept(Chain)方法就是拦截器的拦截实现，RetryAndFollowUpInterceptor的intercept(Chain)方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//RetryAndFollowUpInterceptor.java@Override public Response intercept(Chain chain) throws IOException &#123; //获取Request Request request = chain.request(); RealInterceptorChain realChain = (RealInterceptorChain) chain; //获取Transmitter Transmitter transmitter = realChain.transmitter(); //重定向次数 int followUpCount = 0; Response priorResponse = null; //一个死循环 while (true) &#123; //调用Transmitter的prepareToConnect方法，做好连接建立的准备 transmitter.prepareToConnect(request); if (transmitter.isCanceled()) &#123; throw new IOException(\"Canceled\"); &#125; Response response; boolean success = false; try &#123; //调用proceed方法，里面调用下一个拦截器BridgeInterceptor的intercept方法 response = realChain.proceed(request, transmitter, null); success = true; &#125;catch (RouteException e) &#123;//出现RouteException异常 //调用recover方法检测连接是否可以继续使用 if (!recover(e.getLastConnectException(), transmitter, false, request)) &#123; throw e.getFirstConnectException(); &#125; continue; &#125; catch (IOException e) &#123;//出现IOException异常，和服务端建立连接失败 boolean requestSendStarted = !(e instanceof ConnectionShutdownException); //调用recover方法检测连接是否可以继续使用 if (!recover(e, transmitter, requestSendStarted, request)) throw e; continue; &#125; finally &#123;//出现其他未知异常 if (!success) &#123; //调用Transmitter的exchangeDoneDueToException()方法释放连接 transmitter.exchangeDoneDueToException(); &#125; &#125; //执行到这里，没有出现任何异常，连接成功, 响应返回 //... //根据响应码来处理请求头 Request followUp = followUpRequest(response, route); //followUp为空，不需要重定向，直接返回Response if (followUp == null) &#123; //... return response; &#125; //followUp不为空，需要重定向 //... //MAX_FOLLOW_UPS值为20，重定向次数不能大于20次 if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount); &#125; //以重定向后的Request再次重试 request = followUp; priorResponse = response; &#125;&#125; RetryAndFollowUpInterceptor的intercept(Chain)方法中主要是失败重试和重定向的逻辑，该方法流程如下： 1、首先获取Transmitter类； 2、然后进入一个死循环，先调用Transmitter的prepareToConnect方法，准备建立连接；（连接真正的建立在ConnectInterceptor中） 3、接着调用Chain的proceed方法，继续执行下一个拦截器BridgeInterceptor的intercept方法： ​ 3.1、如果在请求的过程中抛出RouteException异常或IOException异常，就会调用recover方法检测连接是否可以继续使用，如果不可以继续使用就抛出异常，整个过程结束，否则就再次重试，这就是失败重试； ​ 3.2、如果在请求的过程中抛出除了3.1之外的异常，就会调用Transmitter的exchangeDoneDueToException()方法释放连接，整个过程结束。 4、没有任何异常抛出，当响应Response返回后，就会调用followUpRequest方法，里面根据返回的Response的响应码来决定是否需要重定向（构造followUp请求），如果不需要重定向，就直接返回Response，如果需要重定向，那么以重定向后的Request再次重试，重定向次数不能大于20次。 1、Transmitter在整个方法的流程中出现了一个Transmitter，这里介绍一下，它是okhttp中应用层和网络层的桥梁，管理同一个Cal的所有连接、请求、响应和IO流之间的关系，它在RealCall创建后就被创建了，如下： 12345678//RealCall.javastatic RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; //创建RealCall RealCall call = new RealCall(client, originalRequest, forWebSocket); //创建Transmitter，赋值给call的transmitter字段 call.transmitter = new Transmitter(client, call); return call;&#125; 创建后，在构造节点Chain时作为参数传了进去，在getResponseWithInterceptorChain方法中有讲到，所以在intercept方法中它可以通过chain.transmitter()获得，它的整个生命周期贯穿了所有拦截器，在接下来的ConnectInterceptor和CallServerInterceptor中你都可以见到它的身影，我们看一下它的主要成员，如下： 123456789101112131415161718192021222324252627282930313233public final class Transmitter &#123; private final OkHttpClient client;//OkHttpClient大管家 private final RealConnectionPool connectionPool;//连接池，管理着连接 public RealConnection connection;//本次连接对象 private ExchangeFinder exchangeFinder;//负责连接的创建 private @Nullable Exchange exchange;//负责连接IO流读写 private final Call call;//Call对象 //... public Transmitter(OkHttpClient client, Call call) &#123; this.client = client; this.connectionPool = Internal.instance.realConnectionPool(client.connectionPool()); this.call = call; this.eventListener = client.eventListenerFactory().create(call); this.timeout.timeout(client.callTimeoutMillis(), MILLISECONDS); &#125; public void prepareToConnect(Request request) &#123; if (this.request != null) &#123; if (sameConnection(this.request.url(), request.url()) &amp;&amp; exchangeFinder.hasRouteToTry()) &#123; return; // Already ready. &#125; //... &#125; this.request = request; //创建ExchangeFinder this.exchangeFinder = new ExchangeFinder(this, connectionPool, createAddress(request.url()), call, eventListener); &#125; &#125; 在Transmitter中client和call我们都认识，剩下的RealConnectionPool、RealConnection、ExchangeFinder、Exchange都和okhttp的连接机制有关，都会在ConnectInterceptor中介绍，Transmitter就是负责管理它们之间的关系。这里我们只要记住，Transmitter的prepareToConnect方法中主要是创建了一个ExchangeFinder，为在ConnectInterceptor中连接的建立做了一个准备。 BridgeInterceptorBridgeInterceptor的intercept(Chain)方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//BridgeInterceptor.java@Override public Response intercept(Chain chain) throws IOException &#123; //获取Request Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); //下面都是根据需要为Request的header添加或移除一些信息 RequestBody body = userRequest.body(); if (body != null) &#123; MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header(\"Content-Type\", contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header(\"Content-Length\", Long.toString(contentLength)); requestBuilder.removeHeader(\"Transfer-Encoding\"); &#125; else &#123; requestBuilder.header(\"Transfer-Encoding\", \"chunked\"); requestBuilder.removeHeader(\"Content-Length\"); &#125; &#125; if (userRequest.header(\"Host\") == null) &#123; requestBuilder.header(\"Host\", hostHeader(userRequest.url(), false)); &#125; if (userRequest.header(\"Connection\") == null) &#123; requestBuilder.header(\"Connection\", \"Keep-Alive\"); &#125; boolean transparentGzip = false; if (userRequest.header(\"Accept-Encoding\") == null &amp;&amp; userRequest.header(\"Range\") == null) &#123; transparentGzip = true; requestBuilder.header(\"Accept-Encoding\", \"gzip\"); &#125; List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header(\"Cookie\", cookieHeader(cookies)); &#125; if (userRequest.header(\"User-Agent\") == null) &#123; requestBuilder.header(\"User-Agent\", Version.userAgent()); &#125; //调用proceed方法，里面调用下一个拦截器CacheInterceptor的intercept方法 Response networkResponse = chain.proceed(requestBuilder.build()); //返回Response后 //下面都是根据需要为Response的header添加或移除一些信息 HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip &amp;&amp; \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\")) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(\"Content-Encoding\") .removeAll(\"Content-Length\") .build(); responseBuilder.headers(strippedHeaders); String contentType = networkResponse.header(\"Content-Type\"); responseBuilder.body(new RealResponseBody(contentType, -1L, Okio.buffer(responseBody))); &#125; return responseBuilder.build(); &#125; BridgeInterceptor中的逻辑是在所有默认拦截器中是最简单，它主要就是对Request或Response的header做了一些处理，把用户构造的Request转换为发送给服务器的Request，还有把服务器返回的Response转换为对用户友好的Response。例如，对于Request，当开发者没有添加Accept-Encoding时，它会自动添加Accept-Encoding : gzip，表示客户端支持使用gzip；对于Response，当Content-Encoding是gzip方式并且客户端是自动添加gzip支持时，它会移除Content-Encoding、Content-Length，然后重新解压缩响应的内容。 CacheInterceptorCacheInterceptor的intercept(Chain)方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//CacheInterceptor.java@Overridepublic Response intercept(Chain chain) throws IOException &#123; //根据Request得到Cache中缓存的Response，Cache是什么，后面介绍 Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); //创建缓存策略：网络、缓存、或两者都使用，CacheStrategy是什么，后面介绍 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); //得到networkRequest Request networkRequest = strategy.networkRequest; //得到cacheResponse，cacheResponse等于上面的cacheCandidate Response cacheResponse = strategy.cacheResponse; //... //这个Response缓存无效，close掉它 if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); &#125; //1、networkRequest为null且cacheResponse为null：表示强制使用缓存，但是没有缓存，所以构造状态码为504，body为空的Response if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504)//状态码504 .message(\"Unsatisfiable Request (only-if-cached)\") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; //2、networkRequest为null但cacheResponse不为null：表示强制使用缓存，并且有缓存，所以直接返回缓存的Response if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; //networkRequest不为null，所以可以发起网络请求，调用chain.proceed(Request)，里面调用下一个拦截器BridgeInterceptor的intercept方法，会返回网络请求得到的networkResponse networkResponse = chain.proceed(networkRequest); &#125; finally &#123; //发起网络请求出现IO异常或其他异常的处理 //... &#125; //3、networkRequest不为null且cacheResponse不为null：因为cacheResponse不为null，所以根据网络请求得到的networkResponse和缓存的cacheResponse做比较，来决定是否使用cacheResponse if (cacheResponse != null) &#123; if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;//HTTP_NOT_MODIFIED等于304，304表示服务器资源没有更新，所以客户端可以直接使用本地缓存cacheResponse //下面根据cacheResponse构造Response返回，并且更新cacheResponse的头部信息 Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); //在本地缓存更新cacheResponse cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); //返回构造的Response return response; &#125; else &#123;//服务器返回了200，服务器资源更新了，所以客户端cacheResponse无效，close掉它 closeQuietly(cacheResponse.body()); &#125; &#125; //4、networkRequest不为null但cacheResponse为null或者服务器返回了200：cacheResponse为null，没有缓存使用，服务器返回了200，本地缓存失效，这两种情况都要从networkResponse读取网络响应，构造Response准备返回 Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123;//如果Cache不为null，表示使用缓存 if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; //把Response缓存到Cache中 CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; //返回Response return response;&#125; CacheInterceptor的intercept(Chain)里面定义了okhttp的缓存机制，我们先来了解两个类：Cache和CacheStrategy，这样才能看懂intercept(Chain)里面的逻辑。 1、Cache - 缓存实现Cache是okhttp中缓存的实现，内部使用了DiskLruCache，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public final class Cache implements Closeable, Flushable &#123; //... //内部都是通过DiskLruCache实现 final DiskLruCache cache; //有一个InternalCache实现，都调用了Cache中的方法 final InternalCache internalCache = new InternalCache() &#123; @Override public @Nullable Response get(Request request) throws IOException &#123; return Cache.this.get(request); &#125; @Override public @Nullable CacheRequest put(Response response) throws IOException &#123; return Cache.this.put(response); &#125; @Override public void remove(Request request) throws IOException &#123; Cache.this.remove(request); &#125; @Override public void update(Response cached, Response network) &#123; Cache.this.update(cached, network); &#125; @Override public void trackConditionalCacheHit() &#123; Cache.this.trackConditionalCacheHit(); &#125; @Override public void trackResponse(CacheStrategy cacheStrategy) &#123; Cache.this.trackResponse(cacheStrategy); &#125; &#125; //可以通过下面两个构造函数构造一个Cache public Cache(File directory, long maxSize) &#123; this(directory, maxSize, FileSystem.SYSTEM); &#125; Cache(File directory, long maxSize, FileSystem fileSystem) &#123; this.cache = DiskLruCache.create(fileSystem, directory, VERSION, ENTRY_COUNT, maxSize); &#125; //下面是主要方法 @Nullable Response get(Request request) &#123; //... &#125; @Nullable CacheRequest put(Response response) &#123; //... &#125; void remove(Request request) throws IOException &#123; //... &#125; void update(Response cached, Response network) &#123; //... &#125; synchronized void trackConditionalCacheHit() &#123; //... &#125; synchronized void trackResponse(CacheStrategy cacheStrategy) &#123; //... &#125; @Override public void flush() throws IOException &#123; //... &#125; @Override public void close() throws IOException &#123; //... &#125;&#125; Cache中有一个内部实现类InternalCache，见名知意，它是okhttp内部使用的，它实现了InternalCache接口，接口中的方法都和Cache中的方法同名，而且这个实现类的所有方法都是调用了Cache中相应的方法，也就是说InternalCache的方法实现和Cache相应的方法一样，但Cache和InternalCache不一样的是，Cache比InternalCache多了一些方法供外部调用如flush()、 close()等，提供了更多对缓存的控制，而InternalCache中的方法都只是缓存的基本操作，如get、put、remove、update等方法，这些方法的逻辑都是基于Cache中的DiskLruCache实现，详情可以看DiskLruCache的原理实现。 要知道，okhttp默认是不使用缓存，也就是Cache为null，如果要使用缓存，我们需要自行配置，通过下面方法使用okhttp的缓存机制： 123456789//缓存的路径File cacheDir = new File(Constant.PATH_NET_CACHE);//这里通过带有两个参数的构造函数构造一个CacheCache cache = new Cache(cacheDir, 1024 * 1024 * 10);//缓存的最大尺寸10M//然后设置给OkHttpClientOkHttpClient client = new OkHttpClient.Builder() .cache(cache) .build(); 通过上面全局设置后，Cache和InternalCache都不会为null，因为在创建Cache时InternalCache也一起创建了，okhttp的缓存机制就会生效。 我们先回到CacheInterceptor的intercept方法，它首先一开始就要判断cache是否等于null，那么CacheInterceptor的cache在哪里来的呢？是在构造函数中，如下： 12345678public final class CacheInterceptor implements Interceptor &#123; final @Nullable InternalCache cache; public CacheInterceptor(@Nullable InternalCache cache) &#123; this.cache = cache; &#125; //...&#125; 可用看到它是InternalCache实例，在 getResponseWithInterceptorChain()中添加拦截器时就通过client为这个InternalCache赋值了，如下： 1234567//RealCall.javaResponse getResponseWithInterceptorChain() throws IOException &#123; //... //添加负责缓存的拦截器 interceptors.add(new CacheInterceptor(client.internalCache())); //...&#125; 注意到new CacheInterceptor(client.internalCache())，所以我们看client的internalCache方法，如下： 1234//OkHttpClient.java@Nullable InternalCache internalCache() &#123; return cache != null ? cache.internalCache : internalCache; &#125; cache就是上面全局设置的cache实例，所以不为null，返回cache中的internalCache实例，这样CacheInterceptor中就持有internalCache实例。 2、CacheStrategy - 缓存策略CacheStrategy是okhttp缓存策略的实现，okhttp缓存策略遵循了HTTP缓存策略，因此了解okhttp缓存策略前需要有HTTP缓存相关基础：HTTP 协议缓存机制详解，了解了HTTP缓存策略后，我们再来看CacheStrategy，如下： 1234567891011121314151617181920212223242526272829303132333435public final class CacheStrategy &#123; //CacheStrategy两个主要的成员变量：networkRequest、cacheResponse public final @Nullable Request networkRequest; public final @Nullable Response cacheResponse; CacheStrategy(Request networkRequest, Response cacheResponse) &#123; this.networkRequest = networkRequest; this.cacheResponse = cacheResponse; &#125; //... //通过工厂模式创建CacheStrategy public static class Factory &#123; final long nowMillis; final Request request; final Response cacheResponse; public Factory(long nowMillis, Request request, Response cacheResponse) &#123; this.nowMillis = nowMillis; this.request = request; this.cacheResponse = cacheResponse; //... &#125; public CacheStrategy get() &#123; CacheStrategy candidate = getCandidate(); //... return candidate; &#125; //... &#125;&#125; CacheStrategy是通过工厂模式创建的，它有两个主要的成员变量：networkRequest、cacheResponse，CacheInterceptor的intercept方法通过CacheStrategy的networkRequest和cacheResponse的组合来判断执行什么策略，networkRequest是否为空决定是否请求网络，cacheResponse是否为空决定是否使用缓存，networkRequest和cacheResponse的4种组合和对应的缓存策略如下： 1、networkRequest为null且cacheResponse为null：没有缓存使用，又不进行网络请求，构造状态码为504的Response。 2、networkRequest为null但cacheResponse不为null：有缓存使用，且缓存在有效期内，所以直接返回缓存的Response。 3、networkRequest不为null且cacheResponse不为null：有缓存使用，但缓存在客户端的判断中表示过期了，所以请求服务器进行决策，来决定是否使用缓存的Response。 4、networkRequest不为null但cacheResponse为null：没有缓存使用，所以直接使用服务器返回的Response networkRequest和cacheResponse在创建CacheStrategy时通过构造参数赋值，那么CacheStrategy在那里被创建呢？当调用CacheStrategy.Factory(long, Request, Response).get()时就会返回一个CacheStrategy实例，所以CacheStrategy在Factory的get方法中被创建，我们来看Factory的get方法，如下： 123456//CacheStrategy.Factorypublic CacheStrategy get() &#123; CacheStrategy candidate = getCandidate(); //... return candidate;&#125; 可以看到CacheStrategy通过Factory的getCandidate方法创建，getCandidate方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//CacheStrategy.Factoryprivate CacheStrategy getCandidate() &#123; //1、没有Response缓存，直接进行网络请求 if (cacheResponse == null) &#123; return new CacheStrategy(request, null); &#125; //2、如果TLS握手信息丢失，直接进行网络请求 if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) &#123; return new CacheStrategy(request, null); &#125; //3、根据Response状态码，Expired和Cache-Control的no-Store进行判断Response缓存是否可用 if (!isCacheable(cacheResponse, request)) &#123; //Response缓存不可用，直接进行网络请求 return new CacheStrategy(request, null); &#125; //获得Request的缓存控制字段CacheControl CacheControl requestCaching = request.cacheControl(); //4、根据Request中的Cache-Control的noCache和header是否设置If-Modified-Since或If-None-Match进行判断是否可以使用Response缓存 if (requestCaching.noCache() || hasConditions(request)) &#123; //不可以使用Response缓存，直接进行网络请求 return new CacheStrategy(request, null); &#125; //走到这里表示Response缓存可用 //获得Response的缓存控制字段CacheControl CacheControl responseCaching = cacheResponse.cacheControl(); //获得该Response已经缓存的时长 long ageMillis = cacheResponseAge(); //获得该Response可以缓存的时长 long freshMillis = computeFreshnessLifetime(); if (requestCaching.maxAgeSeconds() != -1) //一般取max-age freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds())); &#125; long minFreshMillis = 0; if (requestCaching.minFreshSeconds() != -1) &#123; //一般取0 minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds()); &#125; long maxStaleMillis = 0; if (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -1) &#123; //取max-stale， maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds()); &#125; //5、判断缓存是否过期，决定是否使用Response缓存：Response已经缓存的时长 &lt; max-stale + max-age if (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123; Response.Builder builder = cacheResponse.newBuilder(); if (ageMillis + minFreshMillis &gt;= freshMillis) &#123; builder.addHeader(\"Warning\", \"110 HttpURLConnection \\\"Response is stale\\\"\"); &#125; long oneDayMillis = 24 * 60 * 60 * 1000L; if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123; builder.addHeader(\"Warning\", \"113 HttpURLConnection \\\"Heuristic expiration\\\"\"); &#125; //5.1、缓存没有过期，直接使用该Response缓存 return new CacheStrategy(null, builder.build()); &#125; //5.2、缓存过期了，判断是否设置了Etag或Last-Modified等标记 String conditionName; String conditionValue; if (etag != null) &#123; conditionName = \"If-None-Match\"; conditionValue = etag; &#125; else if (lastModified != null) &#123; conditionName = \"If-Modified-Since\"; conditionValue = lastModifiedString; &#125; else if (servedDate != null) &#123; conditionName = \"If-Modified-Since\"; conditionValue = servedDateString; &#125; else &#123; //缓存没有设置Etag或Last-Modified等标记，所以直接进行网络请求 return new CacheStrategy(request, null); &#125; //缓存设置了Etag或Last-Modified等标记，所以添加If-None-Match或If-Modified-Since请求头，构造请求，交给服务器判断缓存是否可用 Headers.Builder conditionalRequestHeaders = request.headers().newBuilder(); Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue); Request conditionalRequest = request.newBuilder() .headers(conditionalRequestHeaders.build()) .build(); //networkRequest和cacheResponse都不为null return new CacheStrategy(conditionalRequest, cacheResponse);&#125; getCandidate()方法中根据HTTP的缓存策略决定networkRequest和cacheResponse的组合，从getCandidate()方法中我们可以看到HTTP的缓存策略分为两种： 1、强制缓存：客户端参与决策决定是否继续使用缓存，客户端第一次请求数据时，服务端返回了缓存的过期时间：Expires或Cache-Control，当客户端再次请求时，就判断缓存的过期时间，没有过期就可以继续使用缓存，否则就不使用，重新请求服务端。 2、对比缓存：服务端参与决策决定是否继续使用缓存，客户端第一次请求数据时，服务端会将缓存标识：Last-Modified/If-Modified-Since、Etag/If-None-Match和数据一起返回给客户端 ，当客户端再次请求时，客户端将缓存标识发送给服务端，服务端根据缓存标识进行判断，如果缓存还没有更新，可以使用，则返回304，表示客户端可以继续使用缓存，否则客户端不能继续使用缓存，只能使用服务器返回的新的响应。 而且强制缓存优先于对比缓存，我们再贴出来自HTTP 协议缓存机制详解的一张图，它很好的解释了getCandidate()方法中1~5步骤流程，如下： 3、缓存机制我们再回到CacheInterceptor的intercept方法，它的1~4步骤就是CacheStrategy的networkRequest和cacheResponse的4种组合情况，都有详细的注释，每一种组合对应一种缓存策略，而缓存策略又是基于getCandidate()方法中写死的HTTP缓存策略，再结合okhttp本地缓存的实现Cache，我们得出结论：okhttp的缓存机制 = Cache缓存实现 + 基于HTTP的缓存策略，整个流程图如下： 了解了okhttp的缓存机制后，我们接着下一个拦截器ConnectInterceptor。 ConnectInterceptorConnectInterceptor的intercept(Chain)方法如下： 1234567891011121314151617//ConnectInterceptor.java@Overridepublic Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); //获取Transmitter Transmitter transmitter = realChain.transmitter(); boolean doExtensiveHealthChecks = !request.method().equals(\"GET\"); //1、新建一个Exchange Exchange exchange = transmitter.newExchange(chain, doExtensiveHealthChecks); //调用proceed方法，里面调用下一个拦截器CallServerInterceptor的intercept方法 //这里调用的proceed方法是带有三个参数的，它传进了Request、Transmitter和刚刚新建的Exchange return realChain.proceed(request, transmitter, exchange);&#125; ConnectInterceptor的intercept(Chain)方法很简洁，里面定义了okhttp的连接机制，它首先获取Transmitter，然后通过Transmitter的newExchange方法创建一个Exchange，把它传到下一个拦截器CallServerInterceptor，Exchange是什么？Exchange负责从创建的连接的IO流中写入请求和读取响应，完成一次请求/响应的过程，在CallServerInterceptor中你会看到它真正的作用，这里先忽略。所以注释1的newExchange方法是连接机制的主要逻辑实现，我们继续看Transmitter的newExchange方法，如下： 123456789101112131415//Transmitter.javaExchange newExchange(Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123; //...省略异常处理 //1、通过ExchangeFinder的find方法找到一个ExchangeCodec ExchangeCodec codec = exchangeFinder.find(client, chain, doExtensiveHealthChecks); //创建Exchange，并把ExchangeCodec实例codec传进去，所以Exchange内部持有ExchangeCodec实例 Exchange result = new Exchange(this, call, eventListener, exchangeFinder, codec); //... return result;&#125; 重点是注释1，ExchangeFinder对象早在RetryAndFollowUpInterceptor中通过Transmitter的prepareToConnect方法创建，它的find方法是连接真正创建的地方，ExchangeFinder是什么？ExchangeFinder就是负责连接的创建，把创建好的连接放入连接池，如果连接池中已经有该连接，就直接取出复用，所以ExchangeFinder管理着两个重要的角色：RealConnection、RealConnectionPool，下面讲解一下RealConnectionPool和RealConnection，有助于连接机制的理解。 1、RealConnection - 连接实现连接的真正实现，实现了Connection接口，内部利用Socket建立连接，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public interface Connection &#123; //返回这个连接使用的Route Route route(); //返回这个连接使用的Socket Socket socket(); //如果是HTTPS，返回TLS握手信息用于建立连接，否则返回null @Nullable Handshake handshake(); //返回应用层使用的协议，Protocol是一个枚举，如HTTP1.1、HTTP2 Protocol protocol();&#125;public final class RealConnection extends Http2Connection.Listener implements Connection &#123; public final RealConnectionPool connectionPool; //路由 private final Route route; //内部使用这个rawSocket在TCP层建立连接 private Socket rawSocket; //如果没有使用HTTPS，那么socket == rawSocket，否则这个socket == SSLSocket private Socket socket; //TLS握手 private Handshake handshake; //应用层协议 private Protocol protocol; //HTTP2连接 private Http2Connection http2Connection; //okio库的BufferedSource和BufferedSink，相当于javaIO的输入输出流 private BufferedSource source; private BufferedSink sink; public RealConnection(RealConnectionPool connectionPool, Route route) &#123; this.connectionPool = connectionPool; this.route = route; &#125; public void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) &#123; //... &#125; //...&#125; RealConnection中有一个connect方法，外部可以调用该方法建立连接，connect方法如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//RealConnection.javapublic void connect(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, Call call, EventListener eventListener) &#123; if (protocol != null) throw new IllegalStateException(\"already connected\"); RouteException routeException = null; List&lt;ConnectionSpec&gt; connectionSpecs = route.address().connectionSpecs(); ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs); //路由选择 if (route.address().sslSocketFactory() == null) &#123; if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123; throw new RouteException(new UnknownServiceException( \"CLEARTEXT communication not enabled for client\")); &#125; String host = route.address().url().host(); if (!Platform.get().isCleartextTrafficPermitted(host)) &#123; throw new RouteException(new UnknownServiceException( \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\")); &#125; &#125; else &#123; if (route.address().protocols().contains(Protocol.H2_PRIOR_KNOWLEDGE)) &#123; throw new RouteException(new UnknownServiceException( \"H2_PRIOR_KNOWLEDGE cannot be used with HTTPS\")); &#125; &#125; //开始连接 while (true) &#123; try &#123; if (route.requiresTunnel()) &#123;//如果是通道模式，则建立通道连接 connectTunnel(connectTimeout, readTimeout, writeTimeout, call, eventListener); if (rawSocket == null) &#123; // We were unable to connect the tunnel but properly closed down our resources. break; &#125; &#125; else &#123;//1、否则进行Socket连接，大部分是这种情况 connectSocket(connectTimeout, readTimeout, call, eventListener); &#125; //建立HTTPS连接 establishProtocol(connectionSpecSelector, pingIntervalMillis, call, eventListener); break; &#125; //...省略异常处理 if (http2Connection != null) &#123; synchronized (connectionPool) &#123; allocationLimit = http2Connection.maxConcurrentStreams(); &#125; &#125; &#125; 我们关注注释1，一般会调用connectSocket方法建立Socket连接，connectSocket方法如下： 1234567891011121314151617181920212223242526//RealConnection.javaprivate void connectSocket(int connectTimeout, int readTimeout, Call call, EventListener eventListener) throws IOException &#123; Proxy proxy = route.proxy(); Address address = route.address(); //根据代理类型的不同创建Socket rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy); eventListener.connectStart(call, route.socketAddress(), proxy); rawSocket.setSoTimeout(readTimeout); try &#123; //1、建立Socket连接 Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout); &#125; //...省略异常处理 try &#123; //获得Socket的输入输出流 source = Okio.buffer(Okio.source(rawSocket)); sink = Okio.buffer(Okio.sink(rawSocket)); &#125; //...省略异常处理&#125; 我们关注注释1，Platform是okhttp中根据不同Android版本平台的差异实现的一个兼容类，这里就不细究，Platform的connectSocket方法最终会调用rawSocket的connect()方法建立其Socket连接，建立Socket连接后，就可以通过Socket连接获得输入输出流source和sink，okhttp就可以从source读取或往sink写入数据，source和sink是BufferedSource和BufferedSink类型，它们是来自于okio库，它是一个封装了java.io和java.nio的库，okhttp底层依赖这个库读写数据，Okio好在哪里？详情可以看这篇文章Okio好在哪。 2、RealConnectionPool - 连接池连接池，用来管理连接对象RealConnection，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public final class RealConnectionPool &#123; //线程池 private static final Executor executor = new ThreadPoolExecutor( 0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue&lt;&gt;(), Util.threadFactory(\"OkHttp ConnectionPool\", true)); boolean cleanupRunning; //清理连接任务，在executor中执行 private final Runnable cleanupRunnable = () -&gt; &#123; while (true) &#123; //调用cleanup方法执行清理逻辑 long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) &#123; long waitMillis = waitNanos / 1000000L; waitNanos -= (waitMillis * 1000000L); synchronized (RealConnectionPool.this) &#123; try &#123; //调用wait方法进入等待 RealConnectionPool.this.wait(waitMillis, (int) waitNanos); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125; &#125; &#125;; //双端队列，保存连接 private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;(); void put(RealConnection connection) &#123; if (!cleanupRunning) &#123; cleanupRunning = true; //使用线程池执行清理任务 executor.execute(cleanupRunnable); &#125; //将新建连接插入队列 connections.add(connection); &#125; long cleanup(long now) &#123; //... &#125; //...&#125; RealConnectionPool 在内部维护了一个线程池，用来执行清理连接任务cleanupRunnable，还维护了一个双端队列connections，用来缓存已经创建的连接。要知道创建一次连接要经历TCP握手，如果是HTTPS还要经历TLS握手，握手的过程都是耗时的，所以为了提高效率，就需要connections来对连接进行缓存，从而可以复用；还有如果连接使用完毕，长时间不释放，也会造成资源的浪费，所以就需要cleanupRunnable定时清理无用的连接，okhttp支持5个并发连接，默认每个连接keepAlive为5分钟，keepAlive就是连接空闲后，保持存活的时间。 当我们第一次调用RealConnectionPool 的put方法缓存新建连接时，如果cleanupRunnable还没执行，它首先会使用线程池执行cleanupRunnable，然后把新建连接放入双端队列，cleanupRunnable中会调用cleanup方法进行连接的清理，该方法返回现在到下次清理的时间间隔，然后调用wiat方法进入等待状态，等时间到了后，再次调用cleanup方法进行清理，就这样往复循环。我们来看一下cleanup方法的清理逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//RealConnectionPool.javalong cleanup(long now) &#123; int inUseConnectionCount = 0;//正在使用连接数 int idleConnectionCount = 0;//空闲连接数 RealConnection longestIdleConnection = null; long longestIdleDurationNs = Long.MIN_VALUE; synchronized (this) &#123; //遍历所有连接，记录空闲连接和正在使用连接各自的数量 for (Iterator&lt;RealConnection&gt; i = connections.iterator(); i.hasNext(); ) &#123; RealConnection connection = i.next(); //如果该连接还在使用，pruneAndGetAllocationCount种通过引用计数的方式判断一个连接是否空闲 if (pruneAndGetAllocationCount(connection, now) &gt; 0) &#123; //使用连接数加1 inUseConnectionCount++; continue; &#125; //该连接没有在使用 //空闲连接数加1 idleConnectionCount++; //记录keepalive时间最长的那个空闲连接 long idleDurationNs = now - connection.idleAtNanos; if (idleDurationNs &gt; longestIdleDurationNs) &#123; longestIdleDurationNs = idleDurationNs; //这个连接很可能被移除，因为空闲时间太长 longestIdleConnection = connection; &#125; &#125; //跳出循环后 //默认keepalive时间keepAliveDurationNs最长为5分钟，空闲连接数idleConnectionCount最大为5个 if (longestIdleDurationNs &gt;= this.keepAliveDurationNs || idleConnectionCount &gt; this.maxIdleConnections) &#123;//如果longestIdleConnection的keepalive时间大于5分钟 或 空闲连接数超过5个 //把longestIdleConnection连接从队列清理掉 connections.remove(longestIdleConnection); &#125; else if (idleConnectionCount &gt; 0) &#123;//如果空闲连接数小于5个 并且 longestIdleConnection连接还没到期清理 //返回该连接的到期时间，下次再清理 return keepAliveDurationNs - longestIdleDurationNs; &#125; else if (inUseConnectionCount &gt; 0) &#123;//如果没有空闲连接 且 所有连接都还在使用 //返回keepAliveDurationNs，5分钟后再清理 return keepAliveDurationNs; &#125; else &#123; // 没有任何连接，把cleanupRunning复位 cleanupRunning = false; return -1; &#125; &#125; //把longestIdleConnection连接从队列清理掉后，关闭该连接的socket，返回0，立即再次进行清理 closeQuietly(longestIdleConnection.socket()); return 0;&#125; 从cleanup方法得知，okhttp清理连接的逻辑如下： 1、首先遍历所有连接，记录空闲连接数idleConnectionCount和正在使用连接数inUseConnectionCount，在记录空闲连接数时，还要找出空闲时间最长的空闲连接longestIdleConnection，这个连接是很有可能被清理的； 2、遍历完后，根据最大空闲时长和最大空闲连接数来决定是否清理longestIdleConnection， ​ 2.1、如果longestIdleConnection的空闲时间大于最大空闲时长 或 空闲连接数大于最大空闲连接数，那么该连接就会被从队列中移除，然后关闭该连接的socket，返回0，立即再次进行清理； ​ 2.2、如果空闲连接数小于5个 并且 longestIdleConnection的空闲时间小于最大空闲时长即还没到期清理，那么返回该连接的到期时间，下次再清理； ​ 2.3、如果没有空闲连接 且 所有连接都还在使用，那么返回默认的keepAlive时间，5分钟后再清理； ​ 2.4、没有任何连接，idleConnectionCount和inUseConnectionCount都为0，把cleanupRunning复位，等待下一次put连接时，再次使用线程池执行cleanupRunnable。 了解了RealConnectionPool和RealConnection后，我们再回到ExchangeFinder的find方法，这里是连接创建的地方。 3、连接创建（连接机制）ExchangeFinder的fing方法如下： 1234567891011121314151617181920212223242526272829303132//ExchangeFinder.javapublic ExchangeCodec find( OkHttpClient client, Interceptor.Chain chain, boolean doExtensiveHealthChecks) &#123; //... try &#123; //调用findHealthyConnection方法，返回RealConnection RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, doExtensiveHealthChecks); return resultConnection.newCodec(client, chain); &#125; //...省略异常处理 &#125; private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException &#123; //一个死循环 while (true) &#123; //调用findConnection方法，返回RealConnection RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled); //... //判断连接是否可用 if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123; candidate.noNewExchanges(); continue; &#125; return candidate; &#125; ExchangeFinder的find方法会调用findHealthyConnection方法，里面会不断调用findConnection方法，直到找到一个可用的连接返回。ExchangeFinder的findConnection方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116//ExchangeFinder.javaprivate RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, int pingIntervalMillis, boolean connectionRetryEnabled) throws IOException &#123; boolean foundPooledConnection = false; RealConnection result = null;//返回结果，可用的连接 Route selectedRoute = null; RealConnection releasedConnection; Socket toClose; synchronized (connectionPool) &#123; if (transmitter.isCanceled()) throw new IOException(\"Canceled\"); hasStreamFailure = false; . //1、尝试使用已经创建过的连接，已经创建过的连接可能已经被限制创建新的流 releasedConnection = transmitter.connection; //1.1、如果已经创建过的连接已经被限制创建新的流，就释放该连接（releaseConnectionNoEvents中会把该连接置空），并返回该连接的Socket以关闭 toClose = transmitter.connection != null &amp;&amp; transmitter.connection.noNewExchanges ? transmitter.releaseConnectionNoEvents() : null; //1.2、已经创建过的连接还能使用，就直接使用它当作结果、 if (transmitter.connection != null) &#123; result = transmitter.connection; releasedConnection = null; &#125; //2、已经创建过的连接不能使用 if (result == null) &#123; //2.1、尝试从连接池中找可用的连接，如果找到，这个连接会赋值先保存在Transmitter中 if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, null, false)) &#123; //2.2、从连接池中找到可用的连接 foundPooledConnection = true; result = transmitter.connection; &#125; else if (nextRouteToTry != null) &#123; selectedRoute = nextRouteToTry; nextRouteToTry = null; &#125; else if (retryCurrentRoute()) &#123; selectedRoute = transmitter.connection.route(); &#125; &#125; &#125; closeQuietly(toClose); //... if (result != null) &#123; //3、如果在上面已经找到了可用连接，直接返回结果 return result; &#125; //走到这里没有找到可用连接 //看看是否需要路由选择，多IP操作 boolean newRouteSelection = false; if (selectedRoute == null &amp;&amp; (routeSelection == null || !routeSelection.hasNext())) &#123; newRouteSelection = true; routeSelection = routeSelector.next(); &#125; List&lt;Route&gt; routes = null; synchronized (connectionPool) &#123; if (transmitter.isCanceled()) throw new IOException(\"Canceled\"); //如果有下一个路由 if (newRouteSelection) &#123; routes = routeSelection.getAll(); //4、这里第二次尝试从连接池中找可用连接 if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, false)) &#123; //4.1、从连接池中找到可用的连接 foundPooledConnection = true; result = transmitter.connection; &#125; &#125; //在连接池中没有找到可用连接 if (!foundPooledConnection) &#123; if (selectedRoute == null) &#123; selectedRoute = routeSelection.next(); &#125; //5、所以这里新创建一个连接，后面会进行Socket连接 result = new RealConnection(connectionPool, selectedRoute); connectingConnection = result; &#125; &#125; // 4.2、如果在连接池中找到可用的连接，直接返回该连接 if (foundPooledConnection) &#123; eventListener.connectionAcquired(call, result); return result; &#125; //5.1、调用RealConnection的connect方法进行Socket连接，这个在RealConnection中讲过 result.connect(connectTimeout, readTimeout, writeTimeout, pingIntervalMillis, connectionRetryEnabled, call, eventListener); connectionPool.routeDatabase.connected(result.route()); Socket socket = null; synchronized (connectionPool) &#123; connectingConnection = null; //如果我们刚刚创建了同一地址的多路复用连接，释放这个连接并获取那个连接 if (connectionPool.transmitterAcquirePooledConnection(address, transmitter, routes, true)) &#123; result.noNewExchanges = true; socket = result.socket(); result = transmitter.connection; &#125; else &#123; //5.2、把刚刚新建的连接放入连接池 connectionPool.put(result); //5.3、把刚刚新建的连接保存到Transmitter的connection字段 transmitter.acquireConnectionNoEvents(result); &#125; &#125; closeQuietly(socket); eventListener.connectionAcquired(call, result); //5.4、返回结果 return result;&#125; 这个findConnection方法就是整个ConnectInterceptor的核心，我们忽略掉多IP操作和多路复用(HTTP2)，假设现在我们是第一次请求，连接池和Transmitter中没有该连接，所以跳过1、2、3，直接来到5，创建一个新的连接，然后把它放入连接池和Transmitter中；接着我们用同一个Call进行了第二次请求，这时连接池和Transmitter中有该连接，所以就会走1、2、3，如果Transmitter中的连接还可用就返回，否则从连接池获取一个可用连接返回，所以整个连接机制的大概过程如下： Transmitter中的连接和连接池中的连接有什么区别？我们知道每创建一个Call，就会创建一个对应的Transmitter，一个Call可以发起多次请求（同步、异步），不同的Call有不同的Transmitter，连接池是在创建OkhttpClient时创建的，所以连接池是所有Call共享的，即连接池中的连接所有Call都可以复用，而Transmitter中的那个连接只是对应它相应的Call，只能被本次Call的所有请求复用。 了解了okhttp的连接机制后，我们接着下一个拦截器CallServerInterceptor。 CallServerInterceptorCallServerInterceptor的intercept(Chain)方法如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//CallServerInterceptor.java@Overridepublic Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; //获取Exchange Exchange exchange = realChain.exchange(); //获取Request Request request = realChain.request(); //通过Exchange的writeRequestHeaders(request)方法写入请求的header exchange.writeRequestHeaders(request); boolean responseHeadersStarted = false; Response.Builder responseBuilder = null; if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; //... if (responseBuilder == null) &#123; //通过okio写入请求的body if (request.body().isDuplex()) &#123; exchange.flushRequest(); BufferedSink bufferedRequestBody = Okio.buffer( exchange.createRequestBody(request, true)); request.body().writeTo(bufferedRequestBody); &#125; else &#123; BufferedSink bufferedRequestBody = Okio.buffer( exchange.createRequestBody(request, false)); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); &#125; &#125; else &#123; //... &#125; &#125; else &#123; exchange.noRequestBody(); &#125; //... //下面开始获取网络请求返回的响应 //通过Exchange的readResponseHeaders(boolean)方法读取响应的header if (responseBuilder == null) &#123; responseBuilder = exchange.readResponseHeaders(false); &#125; //获取响应后，通过Builder模式构造Response Response response = responseBuilder .request(request) .handshake(exchange.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); //... //构造Response的body if (forWebSocket &amp;&amp; code == 101) &#123; //构造一个空的body的Response response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; //通过Exchange的openResponseBody(Response)方法读取响应的body，然后通过响应的body继续构造Response response = response.newBuilder() .body(exchange.openResponseBody(response)) .build(); &#125; //... //返回响应Response return response; &#125; 在ConnectInterceptor中我们已经建立了连接，连接到了服务器，获取了输入输出流，所以CallServerInterceptor的intercept(Chain)方法逻辑就是把请求发送到服务器，然后获取服务器的响应，如下： 1、发送请求： ​ 1.1、通过Exchange的writeRequestHeaders(request)方法写入请求的header； ​ 1.2、如果请求的body不为空，通过okio写入请求的body。 2、获取响应： ​ 2.1、通过Exchange的readResponseHeaders(boolean)方法读取响应的header； ​ 2.2、通过Exchange的openResponseBody(Response)方法读取响应的body。 这个发送获取的过程通过Exchange进行，前面已经讲过它在ConnectInterceptor中创建，在process方法中传进来，所以这里可以通过Chain获取Exchange，Exchange它是负责从IO流中写入请求和读取响应，完成一次请求/响应的过程，它内部的读写都是通过一个ExchangeCodec类型的codec来进行，而ExchangeCodec内部又是通过Okio的BufferedSource和BufferedSink进行IO读写，这个过程在上一篇文章已经分析过了，这里不在累述。 结语结合上一篇文章，我们对okhttp已经有了一个深入的了解，首先，我们会在请求的时候初始化一个Call的实例，然后执行它的execute()方法或enqueue()方法，内部最后都会执行到getResponseWithInterceptorChain()方法，这个方法里面通过拦截器组成的责任链，依次经过用户自定义普通拦截器、重试拦截器、桥接拦截器、缓存拦截器、连接拦截器和用户自定义网络拦截器和访问服务器拦截器等拦截处理过程，来获取到一个响应并交给用户。okhttp的请求流程、缓存机制和连接机制是当中的重点，在阅读源码的过程中也学习到很多东西，下一次就来分析它的搭档Retrofit。","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"okhttp","slug":"okhttp","permalink":"http://yoursite.com/tags/okhttp/"}]},{"title":"okhttp3源码分析之请求流程","date":"2019-09-03T14:49:13.000Z","path":"2019/09/03/okhttp3源码分析之请求流程/","text":"前言在Android开发中，当下最火的网络请求框架莫过于okhttp和retrofit，它们都是square公司的产品，两个都是非常优秀开源库，值得我们去阅读它们的源码，学习它们的设计理念，但其实retrofit底层还是用okhttp来发起网络请求的，所以深入理解了okhttp也就深入理解了retrofit，它们的源码阅读顺序应该是先看okhttp，我在retrofit上发现它最近的一次提交才把okhttp版本更新到3.14，okhttp目前最新的版本是4.0.x，okhttp从4.0.x开始采用kotlin编写，在这之前还是用java，而我本次分析的okhttp源码版本是基本3.14.x，看哪个版本的不重要，重要的是阅读过后的收获，我打算分2篇文章去分析okhttp，分别是： 请求流程(同步、异步) 拦截器(Interceptor) 本文是第一篇 - okhttp的请求流程，okhttp项目地址：okhttp okhttp的简单使用我们通过一个简单的GET请求来回忆一下okhttp的使用步骤，并以这个实例为例讲解okhttp的请求流程，如下： 1234567891011121314151617181920212223242526272829303132333435//1、创建OkHttpClientOkHttpClient client = new OkHttpClient.Builder() .readTimeout(5, TimeUnit.SECONDS) .build();//2、创建请求RequestRequest request = new Request.Builder() .url(\"http://www.baidu.com\") .build();//3、创建一个Call，用于发起网络请求Call call = client.newCall(request);//4、发起GET请求//4.1、同步请求，调用Call的execute()方法try &#123; //接收到回复Response Response response = call.execute(); Log.d(TAG, response.body().string());&#125; catch (IOException e) &#123; e.printStackTrace();&#125;//4.2、异步请求, 调用Call的enqueue()方法call.enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; //接收到回复Response Log.d(TAG, response.body().string()); &#125;&#125;); 可以看到，使用okhttp发起网络请求要经过4步： 1、创建OkHttpClient 2、创建请求Request 3、通过OkHttpClient和Request创建一个Call，用于发起网络请求 4、调用Call的execute()或enqueue()方法发起同步或异步请求 当服务器处理完一个请求Request后，就会返回一个响应，在okhttp中用Response代表HTTP的响应，这就是一个典型的HTTP请求/响应流程。下面简单介绍1~3步骤： 1、创建OkHttpClientOkHttpClient是okhttp中的大管家，它将具体的工作分发到各个子系统中去完成，它使用Builder模式配置网络请求的各种参数如超时、拦截器、分发器等，Builder中可配置的参数如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//OkHttpClient.Builderpublic static final class Builder &#123; Dispatcher dispatcher;//分发器 @Nullable Proxy proxy;//代理 List&lt;Protocol&gt; protocols;//应用层协议 List&lt;ConnectionSpec&gt; connectionSpecs;//传输层协议 final List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();//应用拦截器 final List&lt;Interceptor&gt; networkInterceptors = new ArrayList&lt;&gt;();//网络拦截器 EventListener.Factory eventListenerFactory;//http请求回调监听 ProxySelector proxySelector;//代理选择 CookieJar cookieJar;//cookie @Nullable Cache cache;//网络缓存 @Nullable InternalCache internalCache;//内部缓存 SocketFactory socketFactory;//socket 工厂 @Nullable SSLSocketFactory sslSocketFactory;//安全套接层socket 工厂，用于HTTPS @Nullable CertificateChainCleaner certificateChainCleaner;//验证确认响应证书，适用 HTTPS 请求连接的主机名 HostnameVerifier hostnameVerifier;//主机名字确认 CertificatePinner certificatePinner;//证书链 Authenticator proxyAuthenticator;//代理身份验证 Authenticator authenticator;//本地身份验证 ConnectionPool connectionPool;//连接池,复用连接 Dns dns;//域名 boolean followSslRedirects;//安全套接层重定向 boolean followRedirects;//本地重定向 boolean retryOnConnectionFailure;//错误重连 int callTimeout;//请求超时，它包括dns解析、connect、read、write和服务器处理的时间 int connectTimeout;//connect超时 int readTimeout;//read超时 int writeTimeout;//write超时 int pingInterval;//ping超时 //这里是配置默认的参数 public Builder() &#123; dispatcher = new Dispatcher(); protocols = DEFAULT_PROTOCOLS;//Protocol.HTTP_2和Protocol.HTTP_1_1 connectionSpecs = DEFAULT_CONNECTION_SPECS; eventListenerFactory = EventListener.factory(EventListener.NONE); proxySelector = ProxySelector.getDefault(); if (proxySelector == null) &#123; proxySelector = new NullProxySelector(); &#125; cookieJar = CookieJar.NO_COOKIES; socketFactory = SocketFactory.getDefault(); hostnameVerifier = OkHostnameVerifier.INSTANCE; certificatePinner = CertificatePinner.DEFAULT; proxyAuthenticator = Authenticator.NONE; authenticator = Authenticator.NONE; connectionPool = new ConnectionPool(); dns = Dns.SYSTEM; followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true; callTimeout = 0; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000; pingInterval = 0; &#125; //这里通过另外一个OkHttpClient配置参数 Builder(OkHttpClient okHttpClient) &#123; this.dispatcher = okHttpClient.dispatcher; this.proxy = okHttpClient.proxy; this.protocols = okHttpClient.protocols; //... &#125; //... //配置完参数后，通过Builder的参数创建一个OkHttpClient public OkHttpClient build() &#123; return new OkHttpClient(this); &#125;&#125; 2、创建请求Request在okhttp中Request代表着一个HTTP请求，它封装了请求的具体消息，如url、header、body等，它和OkHttpClient一样都是使用Budiler模式来配置自己的参数，如下： 12345678910111213141516171819202122232425262728//Request.Budilerpublic static class Builder &#123; HttpUrl url; String method; Headers.Builder headers; RequestBody body; //这里配置默认的参数 public Builder() &#123; this.method = \"GET\";//默认是GET请求 this.headers = new Headers.Builder(); &#125; //这里通过另外一个Request配置参数 Builder(Request request) &#123; this.url = request.url; this.method = request.method; //... &#125; //... //配置完参数后，通过Builder的参数创建一个Request public Request build() &#123; if (url == null) throw new IllegalStateException(\"url == null\"); return new Request(this); &#125;&#125; 3、创建用于发起网络请求的CallCall是一个接口，它的具体实现类是RealCall，Call中定义了一些enqueue(Callback)、execute()等关键方法，如下： 123456789101112131415161718192021public interface Call extends Cloneable &#123; //返回当前请求 Request request(); //同步请求方法，此方法会阻塞当前线程直到请求结果放回 Response execute() throws IOException; //异步请求方法，此方法会将请求添加到队列中，然后等待请求返回 void enqueue(Callback responseCallback); //取消请求 void cancel(); //判断请求是否在执行 boolean isExecuted(); //判断请求是否取消 boolean isCanceled(); //返回请求的超时时间 Timeout timeout(); //克隆一个新的请求 Call clone(); interface Factory &#123; Call newCall(Request request); &#125;&#125; 我们看到Call接口中有一个Factory接口，Factory中有一个newCall(Request)方法，这说明Call是通过工厂模式创建，而OkHttpClient实现了Call.Factory接口，重写了newCall(Request)方法，返回了Call的具体实现类RealCall，如下： 123456789101112131415161718public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory &#123; //... @Override public Call newCall(Request request) &#123; //调用了RealCall的newRealCall() return RealCall.newRealCall(this, request, false /* for web socket */); &#125;&#125;final class RealCall implements Call &#123; //... static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) &#123; //返回RealCall对象 RealCall call = new RealCall(client, originalRequest, forWebSocket); call.transmitter = new Transmitter(client, call); return call; &#125;&#125; 所以调用client.newCall(request)其实返回的是RealCall对象，而RealCall封装了请求的调用逻辑。 到这里也就走到了注释4，也就是第4步，okhttp通过Call的实现类RealCall的execute()或enqueue()方法发起同步或异步请求，也就是本文的重点，下面分别详细介绍: 同步请求 - RealCall :: execute()1234567891011121314//RealCall.java@Overridepublic Response execute() throws IOException &#123; //... try &#123; //1、调用Dispatcher的executed(RealCall)方法 client.dispatcher().executed(this); //2、调用getResponseWithInterceptorChain()方法 return getResponseWithInterceptorChain(); &#125; finally &#123; //3、同步请求任务执行完毕，调用Dispatcher的finished(RealCall)方法 client.dispatcher().finished(this); &#125;&#125; client就是我们上面所讲的OkHttpClient的实例，它在创建RealCall时作为构造参数传了进去，而OkHttpClient的dispatcher()方法返回的是Dispatcher实例，它在OkHttpClient构造时被创建。 我们先讲一下Dispatcher，那Dispatcher是什么呢？Dispatcher是一个任务调度器，它负责进行请求任务的调度，它的内部维护着3个任务队列(readyAsyncCalls、runningAsyncCalls、runningSyncCalls)和1个线程池(executorService)，Dispatcher主要内容如下： 123456789101112131415161718192021222324252627282930313233343536373839public final class Dispatcher &#123; private int maxRequests = 64;//最大请求数64个 private int maxRequestsPerHost = 5;//每个主机最大请求数5个 private @Nullable Runnable idleCallback;//idle任务回调，类似于Android的idlehandler, 可以在Dispatcher没有任务调度（空闲时）时执行idleCallback中的任务 //线程池，执行runningAsyncCalls队列里面的请求任务 private @Nullable ExecutorService executorService; //等待执行的异步请求任务队列 private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); //正在执行的异步请求任务队列 private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); //正在执行的同步请求任务队列 private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); synchronized void executed(RealCall call) &#123; //... &#125; void enqueue(AsyncCall call) &#123; //... &#125; void finished(RealCall call) &#123; //... &#125; void finished(AsyncCall call) &#123; //... &#125; private boolean promoteAndExecute() &#123; //... &#125; //... &#125; Dispatcher提供了executed(RealCall)和enqueue(AsyncCall)方法来进行同步和异步请求任务的入队，还提供了finished(RealCall)和finished(AsyncCalll)方法来进行同步和异步请求任务的出队，可以看到okhttp把ReadCall当作同步请求任务的代表，把AsyncCall当作异步请求任务的代表，RealCall前面已经讲过了，而AsyncCal是RealCall的一个内部类，它本质上就是一个Runnable，Dispatcher的线程池执行任务主要执行的是runningAsyncCalls队列里面的异步请求任务，也就是AsyncCall异步任务，而Dispatcher的promoteAndExecute()方法就是用来进行异步任务的调度，它的逻辑主要是按顺序把readyAsyncCalls队列中准备执行的异步任务转移到runningAsyncCalls后，再由线程池执行，对于同步任务Dispatcher只是暂时保存在runningSyncCalls队列中，并不会由线程池执行。 我们继续回到RealCall的execute()方法，根据注释1、2、3分为3部分解释同步请求流程，如下： 1、Dispatcher :: executed(RealCall)看RealCall的execute()方法的注释1，它首先调用了Dispatcher的executed(RealCall)方法，Dispatcher的executed(RealCall)方法实现如下： 1234//Dispatcher.javasynchronized void executed(RealCall call) &#123; runningSyncCalls.add(call);&#125; 可以看到没有做什么处理，只是简单的把同步请求任务放入runningSyncCalls队列。 2、RealCall :: getResponseWithInterceptorChain()看RealCall的execute()方法的注释2，调用getResponseWithInterceptorChain()方法，这里才是同步请求处理的地方，我们点进去，如下： 123456789101112131415161718192021222324252627282930313233//RealCall.java Response getResponseWithInterceptorChain() throws IOException &#123; //拦截器的添加 List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); //添加用户自定义拦截器 interceptors.addAll(client.interceptors()); //添加默认拦截器 interceptors.add(new RetryAndFollowUpInterceptor(client)); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; //添加的最后一个拦截器是CallServerInterceptor interceptors.add(new CallServerInterceptor(forWebSocket)); //创建一个RealInterceptorChain，传入了interceptors和Request Interceptor.Chain chain = new RealInterceptorChain(interceptors, transmitter, null, 0, originalRequest, this, client.connectTimeoutMillis(), client.readTimeoutMillis(), client.writeTimeoutMillis()); try &#123; //调用RealInterceptorChain的proceed(Request)方法处理请求 Response response = chain.proceed(originalRequest); //... return response; &#125; catch (IOException e) &#123; //... &#125; finally &#123; //... &#125; &#125; getResponseWithInterceptorChain()方法最终返回一个Response，也就是网络请求的响应，该方法中首先把用户自定义的拦截器和okhttp默认的拦截器封装到一个List中，然后创建RealInterceptorChain并执行proceed(Request)方法处理请求，RealInterceptorChain的proceed(Request)方法如下： 1234567891011121314151617181920//RealInterceptorChain.java@Override public Response proceed(Request request) throws IOException &#123; return proceed(request, transmitter, exchange); &#125;public Response proceed(Request request, Transmitter transmitter, @Nullable Exchange exchange) throws IOException &#123; //... //再新建一个RealInterceptorChain，这里注意index加1， RealInterceptorChain next = new RealInterceptorChain(interceptors, transmitter, exchange, index + 1, request, call, connectTimeout, readTimeout, writeTimeout); //获取interceptors列表中的下一个拦截器 Interceptor interceptor = interceptors.get(index); //调用下一个拦截器的intercept(Chain)方法，传入刚才新建的RealInterceptorChain，返回Response Response response = interceptor.intercept(next); //... return response;&#125; proceed()方法中再次新建了一个RealInterceptorChain，传入了index + 1，而获取拦截器时是通过index获取，这样每次都能获取到下一个拦截器，然后调用下一个拦截器的intercept(Chain)方法，intercept(Chain)方法中就是拦截器的主要功能实现，里面会继续调用传入的RealInterceptorChain的proceed()方法，这样又会重复上述逻辑，我们把拦截器看作一条链中的节点，这样每个拦截器就通过一个个RealInterceptorChain连接起来，形成一条链，这就是典型的责任链模式，从节点的首部开始把请求传递下去，每一个拦截器都有机会处理这个请求，这又像是一个递归的过程，直到最后一个拦截器器处理完请求后，才开始逐层返回Resquese，拦截器才是Okhttp核心功能所在，关于拦截器介绍下篇文章再讲，这里只需要知道每一个拦截器都代表了一个功能。 经过对拦截器的简单介绍后，我们知道最后一个添加的拦截器才是把请求发送出去并且返回响应的地方，我们看getResponseWithInterceptorChain()方法，最后一个拦截器的添加是CallServerInterceptor，所以我们直接看CallServerInterceptor的intercept(Chain)方法实现，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//CallServerInterceptor.java@Overridepublic Response intercept(Chain chain) throws IOException &#123; //强转成RealInterceptorChain RealInterceptorChain realChain = (RealInterceptorChain) chain; //获取Exchange Exchange exchange = realChain.exchange(); //获取Request Request request = realChain.request(); //1、通过Exchange的writeRequestHeaders(request)方法发送Request的header exchange.writeRequestHeaders(request); boolean responseHeadersStarted = false; Response.Builder responseBuilder = null; //因为前面已经讲了，默认是GET请求，而GET请求是没有body的，所以不会进入if分支 if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; //省略的是发送Request的body过程 //... &#125; else &#123; exchange.noRequestBody(); &#125; //GET请求body为空，进入这个分支，完成请求 if (request.body() == null || !request.body().isDuplex()) &#123; exchange.finishRequest(); &#125; //省略的是一些监听回调 //... //下面开始获取网络请求返回的响应 //2、通过Exchange的readResponseHeaders(boolean)方法获取响应的header if (responseBuilder == null) &#123; responseBuilder = exchange.readResponseHeaders(false); &#125; //获取响应后，通过Builder模式构造Response Response response = responseBuilder .request(request) .handshake(exchange.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); //省略的是response对状态码code的处理 //... //构造Response的body if (forWebSocket &amp;&amp; code == 101) &#123; //构造一个空的body的Response response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; //通过Exchange的openResponseBody(Response)方法获取响应的body，然后通过响应的body继续构造Response response = response.newBuilder() .body(exchange.openResponseBody(response)) .build(); &#125; //... //返回响应Response return response; &#125; intercept(Chain）方法中主要做的就是发送请求，获取响应的事情，注释中已经写的很清楚了，发送请求要把header和body分开发送，而获取响应时也要分别获取header和body，而发送请求和获取响应两个过程都是通过一个Exchange对象进行的，Exchange是在构造RealInterceptorChain时就作为构造参数传进RealInterceptorChain中，一直都为null，直到在ConnectInterceptor的intercept()中才通过Transmitter的newExchange()被赋值，而ConnectInterceptor的下一个拦截器就是CallServerInterceptor，所以CallServerInterceptor可以通过Chain获取到Exchange实例，这里不用细究这个赋值过程，Exchange它主要是用来负责完成一次网络请求和响应的过程。 这里我以intercept(Chain）方法中注释1和注释2请求header的发送(wirte)和获取(read)为例了解Exchange的工作过程，首先看Exchange的writeRequestHeaders(Request)方法，如下： 12345678910//Exchange.javapublic void writeRequestHeaders(Request request) throws IOException &#123; try &#123; //主要是调用了codec的writeRequestHeaders(request) codec.writeRequestHeaders(request); //... &#125; catch (IOException e) &#123; //... &#125;&#125; 我们再看Exchange的readResponseHeaders(boolean)方法，如下： 1234567891011//Exchange.javapublic @Nullable Response.Builder readResponseHeaders(boolean expectContinue) throws IOException &#123; try &#123; //主要是调用了codec的readResponseHeaders(boolean) Response.Builder result = codec.readResponseHeaders(expectContinue); //... return result; &#125; catch (IOException e) &#123; //... &#125; &#125; 从Exchange的两个方法可以看出，它把 wirt和read header的任务都交给了codec，codec是什么呢？codec是ExchangeCodec类型，它是一个接口，它主要用来编码http请求并解码http返回结果，所以Exchange中真正干活的是ExchangeCodec，它的有两个实现类，分别是Http2ExchangeCodec和Http1ExchangeCodec，分别对应Http2.x和Http1.x，这里我们以Http1ExchangeCodec为例，查看它的writeRequestHeaders(request)和readResponseHeaders(boolean)方法，首先看Http1ExchangeCodec的writeRequestHeaders(request)方法，如下： 12345678910111213141516171819202122//Http1ExchangeCodec.java@Override public void writeRequestHeaders(Request request) throws IOException &#123; String requestLine = RequestLine.get( request, realConnection.route().proxy().type()); //调用了writeRequest() writeRequest(request.headers(), requestLine); &#125; public void writeRequest(Headers headers, String requestLine) throws IOException &#123; if (state != STATE_IDLE) throw new IllegalStateException(\"state: \" + state); //可以看到通过sink把请求头写入IO流，发送到服务器，sink是BufferedSink类型 sink.writeUtf8(requestLine).writeUtf8(\"\\r\\n\"); for (int i = 0, size = headers.size(); i &lt; size; i++) &#123; sink.writeUtf8(headers.name(i)) .writeUtf8(\": \") .writeUtf8(headers.value(i)) .writeUtf8(\"\\r\\n\"); &#125; sink.writeUtf8(\"\\r\\n\"); state = STATE_OPEN_REQUEST_BODY; &#125; 我们再看Http1ExchangeCodec的readResponseHeaders(boolean)方法，如下： 123456789101112131415161718192021222324252627282930313233//Http1ExchangeCodec.java@Overridepublic Response.Builder readResponseHeaders(boolean expectContinue) throws IOException &#123; //... try &#123; StatusLine statusLine = StatusLine.parse(readHeaderLine()); Response.Builder responseBuilder = new Response.Builder() .protocol(statusLine.protocol) .code(statusLine.code) .message(statusLine.message) .headers(readHeaders());//调用了readHeaders() //... return responseBuilder; &#125; catch (EOFException e) &#123; //... &#125;&#125; private Headers readHeaders() throws IOException &#123; Headers.Builder headers = new Headers.Builder(); //调用了readHeaderLine()，一行一行的读取header for (String line; (line = readHeaderLine()).length() != 0; ) &#123; Internal.instance.addLenient(headers, line); &#125; return headers.build(); &#125; private String readHeaderLine() throws IOException &#123; //服务器响应返回，通过source从IO读取响应头，source是BufferedSource类型 String line = source.readUtf8LineStrict(headerLimit); headerLimit -= line.length(); return line; &#125; 从Http1ExchangeCodec的两个方法可以看出，底层是通过BufferedSink把信息写入IO流，通过BufferedSource从IO流读取信息，BufferedSink和BufferedSource都是来自okio这个开源库的，okhttp底层是通过okio来向网络中写入和读取IO的，想要了解更多可自行查看okio源码(okio也是square公司的产品)。 到此RealCall的 getResponseWithInterceptorChain()分析完，getResponseWithInterceptorChain()返回Response后，RealCall的execute() 方法就return了，我们就可以通过返回的Response获取我们想要的信息，但RealCall的execute() 方法就return后，还要继续执行finally 分支中的逻辑。 3、Dispatcher :: finished(RealCall)我们继续看RealCall的execute()方法的注释3，调用Dispatcher的finished(AsyncCall)方法，如下： 12345678910111213141516171819202122//Dispatcher.javavoid finished(RealCall call) &#123; //传进了runningSyncCalls队列 finished(runningSyncCalls, call);&#125;private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call) &#123; Runnable idleCallback; synchronized (this) &#123; //尝试移除队列中的同步请求任务 if (!calls.remove(call)) throw new AssertionError(\"Call wasn't in-flight!\"); idleCallback = this.idleCallback; &#125; //紧接着调用promoteAndExecute()方法进行异步任务的调度，如果没有异步任务要进行，promoteAndExecute()返回false boolean isRunning = promoteAndExecute(); //isRunning等于false且设置了idleCallback，会执行一遍idle任务 if (!isRunning &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; finished()方法中首先尝试从runningSyncCalls队列把刚才通过 executed()入队的同步任务RealCall移除，如果移除失败，就抛出异常，如果移除成功，就紧接着调用promoteAndExecute()方法进行异步任务的调度并尝试执行一遍idle任务，promoteAndExecute()方法在异步请求中再详细介绍。 小结至此okhttp的同步请求过程分析完毕，这里总结一下：当我们调用call.execute()时，就会发起一个同步请求，而call的实现类是RealCall，所以实际执行的是realCall.execute()，realCall.execute()中执行Dispatcher的executed(RealCall)把这个同步请求任务保存进runningSyncCalls队列中，然后RealCall执行getResponseWithInterceptorChain()处理同步请求，请求经过层层拦截器后到达最后一个拦截器CallServerInterceptor，在这个拦截器中通过Exchange把请求发送到服务器，然后同样的通过Exchange获得服务器的响应，根据响应构造Response，然后返回，最后RealCall执行Dispatcher的finished(RealCall)把之前暂时保存的同步请求任务从runningSyncCalls队列中移除。 下面是同步请求过程的调用链： 异步请求 - RealCall.enqueue(Callback)1234567//RealCall.java@Overridepublic void enqueue(Callback responseCallback) &#123; //... //1、调用Dispatcher的enqueue(AsyncCall)方法 client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; 异步请求执行的是RealCall的enqueue(Callback)方法，它比同步请求只是多了一个Callback，在Callback的 onResponse(Call, Response)回调中我们可以拿到网络响应返回的Response，RealCall的enqueue(Callback)方法中首先把Callback用AsyncCall包装起来，然后调用调用Dispatcher的enqueue(AsyncCall)方法。 1、Dispatcher :: enqueue(AsyncCall)我们看Dispatcher的enqueue(AsyncCall)方法，如下： 12345678//Dispatcher.javavoid enqueue(AsyncCall call) &#123; synchronized (this) &#123; readyAsyncCalls.add(call); //... &#125; promoteAndExecute();&#125; 该方法首先把异步请求任务AsyncCall放入readyAsyncCalls队列，然后调用promoteAndExecute()进行异步任务的调度，我们看一下Dispatcher 是如何进行异步任务的调度的。 2、Dispatcher :: promoteAndExecute()promoteAndExecute()方法如下： 123456789101112131415161718192021222324252627282930313233343536373839//Dispatcher.javaprivate boolean promoteAndExecute() &#123; //准备一个正在执行任务列表executableCalls List&lt;AsyncCall&gt; executableCalls = new ArrayList&lt;&gt;(); boolean isRunning; synchronized (this) &#123; //1、这个for循环主要把readyAsyncCalls中等待执行的异步任务转移到runningAsyncCalls队列和executableCalls列表中去 for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; //取出readyAsyncCalls中等待执行的异步任务 AsyncCall asyncCall = i.next(); //判断条件：1、正在运行的异步请求任务不能大于maxRequests；2、等待执行的异步任务的主机请求数不能大于maxRequestsPerHost if (runningAsyncCalls.size() &gt;= maxRequests) break; if (asyncCall.callsPerHost().get() &gt;= maxRequestsPerHost) continue; //满足条件，进入下面逻辑 //把这个等待执行的异步任务从readyAsyncCalls中移除 i.remove(); asyncCall.callsPerHost().incrementAndGet(); //把这个等待执行的异步任务添加进executableCalls列表 executableCalls.add(asyncCall); //把这个等待执行的异步任务添加进runningAsyncCalls队列 runningAsyncCalls.add(asyncCall); &#125; //runningCallsCount()里面的逻辑： return runningAsyncCalls.size() + runningSyncCalls.size(); isRunning = runningCallsCount() &gt; 0; &#125; //2、这个for循环主要是执行executableCalls列表中的异步任务 for (int i = 0, size = executableCalls.size(); i &lt; size; i++) &#123; AsyncCall asyncCall = executableCalls.get(i); //传进executorService，调用AsyncCall的executeOn()方法，由线程池执行这个异步任务 asyncCall.executeOn(executorService()); &#125; return isRunning;&#125; promoteAndExecute()方法中主要是2个for循环，注释1的第一个for循环是把符合条件的异步请求任务从readyAsyncCalls转移（提升）到runningAsyncCalls队列和添加到executableCalls列表中去，紧接着注释2的第二个for循环就是遍历executableCalls列表，从executableCalls列表中获取AsyncCall对象，并且调用它的executeOn()方法，executeOn()方法传进了一个Dispatcher的executorService，所以我们看AsyncCall的executeOn()方法，里面是真正执行异步请求任务的地方。 2.1、AsyncCall :: executeOn(ExecutorService)AsyncCall的executeOn()方法如下： 123456789101112131415//AsyncCall.javavoid executeOn(ExecutorService executorService) &#123; boolean success = false; try &#123; //传进this，执行AsyncCall异步任务，AsyncCall本质是Runnable executorService.execute(this); success = true; &#125; catch (RejectedExecutionException e) &#123; //... &#125; finally &#123; if (!success) &#123; //异步任务执行失败，调用Dispatcher的finished(AsyncCall)方法 client.dispatcher().finished(this); &#125; &#125; 可以看到，里面的主要逻辑就是调用 executorService.execute(this)执行当前的AsyncCall异步任务，前面已经说过AsyncCall实现了NamedRunnable，本质是Runnable，如下： 1234567891011121314151617181920final class AsyncCall extends NamedRunnable &#123; //...&#125;public abstract class NamedRunnable implements Runnable &#123; //... @Override public final void run() &#123; String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try &#123; //run方法中执行execute()方法 execute(); &#125; finally &#123; Thread.currentThread().setName(oldName); &#125; &#125; protected abstract void execute();&#125; 线程池执行到此异步任务时，它的run方法就会被执行，而run方法主要调用execute()方法，而execute()方法是一个抽象方法，AsyncCall实现了NamedRunnable，所以AsyncCall重写了execute()实现了执行逻辑，所以我们直接看AsyncCal的execute()方法。 2.2、AsyncCal :: execute()AsyncCal的execute()方法如下： 1234567891011121314151617//AsyncCall.java@Override protected void execute() &#123; //... try &#123; //调用RealCall的getResponseWithInterceptorChain()方法处理请求 Response response = getResponseWithInterceptorChain(); signalledCallback = true; //请求处理完毕，返回响应，回调Callback的onResponse()方法 responseCallback.onResponse(RealCall.this, response); &#125; catch (IOException e) &#123; //... &#125; finally &#123; //异步请求任务执行完毕，调用Dispatcher的finished(AsyncCall)方法 client.dispatcher().finished(this); &#125;&#125; AsyncCal的execute()方法的逻辑和前面介绍的同步请求过程殊途同归，首先调用RealCall的getResponseWithInterceptorChain()方法处理请求，请求处理完毕后，返回响应Response，这时回调我们调用Call.enqueue(Callback)时传进来的Callback的onResponse()方法，最后在finally语句中调用Dispatcher的finished(AsyncCall)方法来把异步请求任务从runningAsyncCalls队列中移除出去，这个移除逻辑和上面同步请求任务的移除逻辑一样，只是这次是从runningAsyncCalls移除而不是runningSyncCalls，如下： 12345//Dispatcher.javavoid finished(AsyncCal call) &#123; //传进runningAsyncCalls，而不是runningSyncCalls finished(runningSyncCalls, call);&#125; 小结至此okhttp的异步请求过程分析完毕，这里再次总结一下，当我们调用call.enqueue(Callback)时，就会发起一个异步请求，实际执行的是realCall.enqueue(Callback)，它比同步请求只是多了一个Callback参数，然后realCall.execute()中先把传进来的Callback包装成一个AsyncCall，然后执行Dispatcher的enqueue(AsyncCall)把这个异步请求任务保存进readyAsyncCalls队列中，保存后开始执行 promoteAndExecute()进行异步任务的调度，它会先把符合条件的异步请求任务从readyAsyncCalls转移到runningAsyncCalls队列和添加到executableCalls列表中去，然后遍历executableCalls列表，逐个执行AsyncCall 的executeOn(ExecutorService)，然后在这个方法中AsyncCall会把自己放进Dispatcher 的线程池，等待线程池的调度，当线程池执行到这个AsyncCall时，它的run方法就会被执行，从而执行重写的execute()方法，execute()方法中的流程和同步请求流程大致相同。 下面是异步请求过程的调用链： 结语okhttp通过Builder模式创建OkHttpClient、Request和Response，通过client.newCall(Resquest)创建一个Call，用于发起异步或同步请求，请求会经过Dispatcher、一系列拦截器，最后通过okio与服务器建立连接、发送数据并解析返回结果，这个过程如图： 以上就是对okhttp的请求流程的分析，如有错误，欢迎指出。 参考文章： OkHttp 3.x 源码解析之Dispather分发器","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"okhttp","slug":"okhttp","permalink":"http://yoursite.com/tags/okhttp/"}]},{"title":"自定义View实践-使用贝塞尔曲线实现一个loading控件","date":"2019-08-23T10:19:46.000Z","path":"2019/08/23/自定义View实践-使用贝塞尔曲线实现WaveLoadingView/","text":"前言上一篇文章：仿微信滑动按钮 本文是自定义View实践第二篇，上一篇实现了一个简单的滑动按钮，知道了一些自定义View的基本步骤，本文是使用贝塞尔曲线实现的一个加载中控件，接下来进入正文讲解。 地址：WaveLoadingView 效果图 可以看到，WaveLoadingView除了用于loading外，还可以用于显示进度的场景。 实现方式在效果图中，波浪是曲线的形式的，所以我们需要想办法把曲线画出来，在数学领域中，用于实现曲线的函数有很多种，但在开发中，比较常用的就是正弦曲线和贝塞尔曲线了，下面简单介绍一下: 1、正弦曲线正弦曲线是我们非常熟悉的曲线，它的函数如下： y = Asin(ωx + φ) + h A表示振幅，用于表示曲线的波峰和波谷的距离; ω表示角速度，用于控制正弦曲线的周期; φ表示初相，用于控制正弦曲线的左右移动; h表示偏距，用于控制曲线的上下移动. 当A、ω、h取一定的值，φ取不同的值时，就可以让曲线在水平方向移动起来，如下： 上面是A = 2，ω = 0.8， h = 0， φ不断变化的正弦曲线。 2、贝塞尔曲线贝塞尔曲线有一阶、二阶、… 、n阶，一阶的贝塞尔曲线是一条直线，从第2阶开始才是曲线，n阶的贝塞尔曲线可以由(n - 1)阶贝塞尔曲线推导出来，关于贝塞尔曲线的推导可以阅读深入理解贝塞尔曲线。 这里我使用二阶贝塞尔曲线，它的函数如下： f(t) = (1- t)^2 * P0 + 2t(1- t)P1 + t^2 * P2 (0&lt;= t &lt;= 1) P0、P1、P2都是已知的点，称为控制点, t是一个变量，范围为0到1，函数值随着t的变化而变化. 下面我们取P0 = (x0, y0) = (-20, 0)，P1 = (x1, y1) = (-10, 20)，P2 = (x2, y2) = (0, 0)，然后把这3个点的值代入二阶贝塞尔曲线函数，形成的曲线如下： 图一 这样就画出了一条曲线（那两条直线是用于辅助的），接下来我们继续取P3 = (x3, y3) = (10, -20)，P4 = (x4, y4) = (20, 0)，然后把P2、P3、P4再次代入二阶贝塞尔曲线函数，形成的曲线如下： 图二 这样就有点接近正弦曲线了，只要我们不断的取控制点，不断的代入二阶贝塞尔曲线函数，就可以形成一条周期的曲线，到这里我们也发现了二阶贝塞尔曲线函数不是一个周期函数，所以它不像正向曲线那样连绵不绝，一个二阶贝塞尔曲线函数一次只能通过3个控制点画出一条曲线。 3、如何选择？我们也发现了贝塞尔曲线相对正弦曲线的实现有点复杂，但是，在Android中，贝塞尔曲线已经有了封装好的api供我们使用，使用起来非常简单，不需要我们去用代码实现那个函数，相反正弦曲线就需要我们从零做起，要用代码去实现正弦函数，还要进行大量计算、范围检查等，所以从使用的复杂来看，选用贝塞尔曲线的工作量更小一点。 在Android中，贝塞尔曲线是通过Path来实现的，在Path中，与二阶贝塞尔曲线有关的函数是： 12path.quadTo(x1, y1, x2, y2)//绝对坐标path.rQuadTo(x1, y1, x2, y2)//相对坐标 再贴一次图一的贝塞尔曲线： 图一 假设坐标系参考图一的xy轴，即x轴向右，y轴向上，原点是(0, 0)， 通过以下代码就可以画出上图的曲线，如下： 123456789101112131415var path = Path()path.moveTo(-20f, 0f)//(x0, y0) = (-20, 0)path.quadTo( -10f, 20f, //(x1, y1) = (-10, 20) 0f, 0f //(x2, y2) = (0, 0))//上面是绝对坐标，下面代码使用相对坐标的方式画出var path = Path()path.moveTo(-20f, 0f)//(x0, y0) = (-20, 0)path.rQuadTo( 10f, 20f, //(x1, y1)相对(x0, y0)为(10, 20) 20f, 0f //(x2, y2)相对(x0, y0)为(20, 0)) 如果想要画出图二的贝塞尔曲线，只需要在前面曲线的基础上再加一句quadTo或rQuadTo，如下： 123456789101112131415161718192021222324var path = Path()path.moveTo(-20f, 0f)//(x0, y0) = (-20, 0)path.quadTo( -10f, 20f, //(x1, y1) = (-10, 20) 0f, 0f //(x2, y2) = (0, 0))path.quadTo( 10f, -20f, //(x3, y3) = (10, -20) 20f, 0f //(x4, y4) = (20, 0))//上面是绝对坐标，下面代码使用相对坐标的方式画出var path = Path()path.moveTo(-20f, 0f)//(x0, y0) = (-20, 0)path.rQuadTo( 10f, 20f, //(x1, y1)相对(x0, y0)为(10, 20) 20f, 0f //(x2, y2)相对(x0, y0)为(20, 0))path.rQuadTo( 10f, -20f, //(x3, y3)相对(x2, y2)为(10, -20) 20f, 0f //(x4, y4)相对(x2, y2)为(20, 0)) 绝对坐标的每个点都是以坐标系的原点为参考；而相对坐标是以moveTo方法那个点为原点作为参考，如果只调用了一次moveTo方法，而调用了多次rQuadTo方法，那么从第二次rQuadTo方法开始，它参考上一次rQuadTo方法的最后一个坐标值，例如上面相对坐标计算中，第二次rQuadTo方法的(x3, y3)，(x4, y4)是参考(x2, y2)计算出来的，而不是参考(x0, y0)。 上面是为了讲解方便把坐标系说成x轴向右，y轴向上，但是在android中，坐标系是x轴向右，y轴向下，原点是View的左上角，这一点要注意。 实现步骤下面开始讲主要的实现步骤： 1、测量控件大小我使用一个Shape枚举表示控件的4种形状，如下： 123456enum class Shape&#123; CIRCLE,//圆形，默认形状 SQUARE, //正方形 RECT, //矩形 NONE//没有形状约束&#125; 对于圆形和正方形，控件的测量宽和高应该保持一样的，而对于矩形和NONE，控件的测量宽和高可以不一样，如下： 1234567891011121314override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) &#123; val measureWidth = MeasureSpec.getSize(widthMeasureSpec) val measureHeight = MeasureSpec.getSize(heightMeasureSpec) when(shape)&#123; Shape.CIRCLE, Shape.SQUARE -&gt; &#123;//圆形或正方形 val measureSpec = if(measureHeight &lt; measureWidth) heightMeasureSpec else widthMeasureSpec //传入的measureSpec一样 super.onMeasure(measureSpec, measureSpec) &#125;else -&gt; &#123;//矩形或NONE //传入的measureSpec不一样 super.onMeasure(widthMeasureSpec, heightMeasureSpec) &#125; &#125;&#125; 所以如果用户使用圆形或正方形，但是输入的宽高不一样，我就取宽和高的最小值的测量模式去测量控件，这样就保证了控件的测量宽高一样；而用户如果使用矩形或NONE，就保持原来的测量就行了。 一个控件有可能经过多次measure后才确定测量宽高，在多次onMeasure()方法调用后，接下来会调用onSizeChanged()方法，且只会调用一次，这个方法调用后接下来就会调用onLayout()方法确定控件的最终宽高，我在onSizeChanged()里面获取测量宽高确定了控件作画的范围大小和暂时的控件大小，如下： 123456789override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) &#123; //控件作画的范围大小 canvasWidth = measuredWidth canvasHeight = measuredHeight //控件大小，暂时等于canvas大小，后面在onlayout()中会改变 viewWidth = canvasWidth viewHeight = canvasHeight //...&#125; 控件作画的范围大小和控件大小关系如下： 绿色框就是控件作画的范围大小，红色框就是控件大小，也就是说每次控件大小确定之后，我只取中间的部分绘制，很多人会有疑问？为什么只取中间的部分绘制，而不在整个控件范围绘制？这是因为当控件的父布局是ConstraintLayout，控件宽或高取match_parent时，会出现以下情况： 图1 ：控件大小：layout_width = “match_parent” ， layout_height = “200dp” 图2：控件大小：layout_width = “200dp” ， layout_height = “match_parent” 蓝色框就是手机屏幕，黑色背景就是控件大小，你还记得我上面在onMeasure()方法讲过，如果控件的形状是圆形，那么控件的测量宽高应该相等的，并取最小值为基准，所以如果控件大小输入是layout_width = “match_parent” ，layout_height = “200dp” 或 layout_width = “200dp” ，layout_height = “match_parent”，经过测量后控件大小应该是宽 = 高 = 200dp，效果应该都是如下图： 图3 可实际情况却不是图3，而是图1或图2，这是因为ConstraintLayout布局会让子控件的setMeasuredDimension()失效，所以导致 measuredHeight 和 height 不一样，宽同理，所以在遇到父布局是ConstraintLayout时，并且控件的宽或高设置了“match_parent”，并且你自定义了测量过程，就会导致自定义View过程中测量出来大小不等于View最终大小，即getMeasureHeigth()或getMeasureWidth() != getWidth()或getHeigth()，为什么ConstraintLayout就会有这种情况而其他如Linearlayout就没有？我也不知道，可能需要大家通过源码了解了，而我的解决办法就是让每次作画的范围在控件的中心，就像图1和图2一样，这样就不会那么难看。 2、裁剪画布形状怎么把控件弄成圆形、正方形、矩形这些形状，如果控件形状是正方形或矩形，还可以设置圆角，一个方法是通过BitmapShader实现，使用BitmapShader要经过3步： 1、新建Bitmap； 2、以1新建的Bitmap创建一个Canvas，在Canvas上画出波浪； 3、最后新建一个BitmapShader与1的Bitmap关联，然后设置给画笔，用画笔在onDraw方法传进来的Canvas上画一个形状出来，然后这个形状就会含有波浪. 但我没有使用BitmapShader，因为波浪的移动需要开启一个无限循环动画，就会不断的调用onDraw()方法，而在onDraw()方法不断的新建对象是一个不推荐的做法，虽然Bitmap可以通过recycler()复用，但是还是避免不了每次都要新建Canvas对象, 所以为了减少对象分配，我使用了Canvas的clipPathAPI来把画布裁剪成我想要的形状，然后把波浪画在裁剪后的画布上，这样也能实现与BitmapShader同样的效果，如下： 12345678910111213141516171819202122232425262728private fun preDrawShapePath(w: Int, h: Int) &#123; clipPath.reset() when (shape) &#123; Shape.CIRCLE -&gt; &#123; //... //path路径为圆形 clipPath.addCircle( shapeCircle.centerX, shapeCircle.centerY, shapeCircle.circleRadius, Path.Direction.CCW ) &#125; Shape.SQUARE -&gt; &#123; //... //path路径为正方形或圆角正方形 if (shapeCorner == 0f) clipPath?.addRect(shapeRect, Path.Direction.CCW) else clipPath.addRoundRect( shapeRect, shapeCorner, shapeCorner, Path.Direction.CCW ) &#125; Shape.RECT -&gt; &#123; //... &#125; &#125; &#125; preDrawShapePath()中根据Shape来add不同的形状给Path来把这些路径信息预先保存下来，前面已经讲过每次作画的范围都在控件的中心，//…省略的都是居中计算，保存好形状的Path将在onDraw方法中使用，如下： 12345678910override fun onDraw(canvas: Canvas?) &#123; clipCanvasShape(canvas) //... &#125; private fun clipCanvasShape(canvas: Canvas?) &#123; //调用canvas的clipPath方法裁剪画布 if (shape != Shape.NONE) canvas?.clipPath(clipPath) //... &#125; 在onDraw方法中使用canvas.clipPath()方法传入Path裁剪画布，这样以后作画的范围都被限定在这个画布形状之内。 3、画波浪使用贝塞尔曲线画波浪，如下： 12345678910111213141516171819202122232425262728private fun preDrawWavePath() &#123; wavePath.reset() //波长等于画布的宽度 val waveLen = canvasWidth //波峰 val waveHeight = (waveAmplitude * canvasHeight).toInt() //波浪的起始y坐标 waveStartY = calculateWaveStartYbyProcess() //把path移到起始位置，这里使用了path.moveTo（）方法 wavePath.moveTo(-canvasWidth * 2f, waveStartY) //下面就是画波浪的过程，都使用了path.rXX（）方法，表示把上一次结束点的坐标作为原点，从而简化计算量 val rang = -canvasWidth * 2..canvasWidth for (i in rang step waveLen) &#123; wavePath.rQuadTo( waveLen / 4f, waveHeight / 2f, waveLen / 2f, 0f ) wavePath.rQuadTo( waveLen / 4f, -waveHeight / 2f, waveLen / 2f, 0f ) &#125; //波浪的深度就是画布的高度 wavePath.rLineTo(0f, canvasHeight.toFloat()) wavePath.rLineTo(-canvasWidth * 3f, 0f) //最后使用path.close()把波浪的路径关闭，使整个波浪围起来 wavePath.close()&#125; preDrawWavePath() 中把波浪路径的信息保存在path中，下面一张图很好的说明波浪的整个路径，如下： 我把控件大小充满了父容器，所以控件的作画范围就是绿色框的大小，波浪的波长就是一个画布的宽度即绿色框的宽度，我把波浪的起始点移到屏幕范围外，从起始点开始，画了三个波长，把波浪画出屏幕的范围，从而方便的待会的波浪的上下移动，最后记得使用path.close()把波浪的路径关闭，使整个波浪围起来。 保存好波浪路径的信息的Path在onDraw方法中使用，如下： 12345678910111213override fun onDraw(canvas: Canvas?) &#123; clipCanvasShape(canvas) drawWave(canvas) //...&#125;private fun drawWave(canvas: Canvas?) &#123; wavePaint.style = Paint.Style.FILL_AND_STROKE wavePaint.color = waveColor //... //使用canvas的drawPath()方法把波浪画在画布上 canvas?.drawPath(wavePath, wavePaint)&#125; 使用canvas的drawPath()方法直接把波浪画在画布上，这时在屏幕上显示的效果如下： 这样就画出了一条波浪了，第二条波浪呢？可以再用另外一个Path按照上述preDrawWavePath()方法的流程再画一条，只要波浪的起始点坐标不同就行，但我没有用这种办法，我是通过Canvas的translate()方法平移画布，利用两次平移的偏移量不一样，画出了第二条，如下： 1234567891011121314151617181920212223242526272829private fun drawWave(canvas: Canvas?) &#123; wavePaint.style = Paint.Style.FILL_AND_STROKE //首先保存两次画布状态，记为画布1、2 canvas?.save()//画布1 canvas?.save()//画布2 //记当前画布为画布3 //调用canvas的translate（）方法水平平移一下画布3 canvas?.translate(canvasSlowOffsetX, 0) wavePaint.color = adjustAlpha(waveColor, 0.7f) //首先在画布3画出第一条波浪 canvas?.drawPath(wavePath, wavePaint) //恢复保存的画布2状态 canvas?.restore() //下面是在画布2上作画 //调用canvas的translate（）方法水平平移一下画布2 canvas?.translate(canvasFastOffsetX, 0) wavePaint.color = waveColor //然后在画布2上画出第二条波浪 canvas?.drawPath(wavePath, wavePaint) //恢复保存的画布1状态 canvas?.restore() //后面都是在画布1上作画&#125; 熟悉Canvas的save()、restore()方法都知道，每调用一次save()，可以理解为画布的一次入栈（保存），每调用一次restore()，可以理解为画布的出栈（恢复），画布3是默认就有的，画布1、2是我保存生成的，所以上述画布1，2，3之间是独立的，互不影响的，而canvasSlowOffsetX和canvasFastOffsetX两个值是不一样的，这样就造成了画布2和3平移时偏移量不一样，所以用同一个Path画在两个偏移量不一样的画布上就可以形成两条波浪，效果图如下： 4、让波浪动起来 让波浪移动起来很简单，使用一个无限循环动画，在动画的进度回调中计算画布的偏移量，然后调用invalidate()就行，如下： 1234567891011waveValueAnim.apply &#123; duration = ANIM_TIME repeatCount = ValueAnimator.INFINITE//无限循环 repeatMode = ValueAnimator.RESTART addUpdateListener&#123; animation -&gt; //... canvasFastOffsetX = (canvasFastOffsetX + fastWaveOffsetX) % canvasWidth canvasSlowOffsetX = (canvasSlowOffsetX + slowWaveOffsetX) % canvasWidth invalidate() &#125;&#125; 在适当的时机启动动画，如下： 1234567891011override fun onDraw(canvas: Canvas?) &#123; clipCanvasShape(canvas) drawWave(canvas) //... //启动动画 startLoading()&#125;fun startLoading()&#123; if(!waveValueAnim.isStarted) waveValueAnim.start()&#125; 到这里整个控件就完成了。 5、优化大家都知道手机的资源都是非常有限的，我在做自定义View时，特别是涉及到无限循环的动画时，要注意优化我们的代码，因为一般的屏幕刷新周期是16ms，这意味着在这16ms内你要把有关动画的所有计算和流程完成，不然就会造成掉帧，从而卡顿，在自定义View时我想到可以从下面几点做一些优化，提高效率： 5.1、减少对象的内存分配，尽可能做到对象复用每次系统GC的时候都会暂停系统ms级别的时间，而无限循环的动画的逻辑代码会在短时间内被循环往复的调用, 这样如果在逻辑代码中在堆上创建过多的临时变量，会导致内存的使用量在短时间内上升，从而频繁的引发系统的GC行为，这样无疑会拖累动画的效率，让动画变得卡顿。 在自定义View涉及到无限循环动画时，我们不能忽略对象的内存分配，不要经常在onDraw()方法中new对象：如果这些临时变量每次的使用都是固定，完全不需要每次循环执行的时候重复创建，我们可以考虑将它们从临时变量转为成员变量，在动画初始化或View初始化时将这些成员变量初始化好，需要的时候直接调用即可；对于不规则图形的绘制我们会需要到Path，并且对于越复杂的 Path，Canvas 在绘制的时候，也会更加的耗时，因此我们需要做的就是尽量优化 Path 的创建过程， 还有Path 类中本身提供reset()和rewind()方法用于复用Path对象， reset()方法是用于对象的复位，rewind()方法在对象的复位基础上还可以让Path对象不释放之前已经分配的内存就，重用之前分配的内存。 5.2、抽取重复运算，尽可能减少浮点运算在自定义View的时候不难免遇到大量的运算，特别在做无限循环动画时，其逻辑代码会在短时间内被循环往复的调用, 这样如果在逻辑代码中在做过多的重复运算无疑会降低动画的效率，特别是在做浮点运算时，CPU 在处理浮点运算时候、会变的特别的慢，要多个指令周期才能完成。 因此我们还应该努力减少浮点运算，在不考虑精度的情况下，可以将浮点运算转成整型来运算，同时我们还应该把重复的运算从逻辑代码中抽取出来，不用每次都运算，例如在WaveLoadingView中， 我创建Path的过程的计算大部分都是在onLayout()中成，把重复运算的结果提前用Path保存好，然后在onDraw()中使用，因为onDraw()在做动画时会被频繁的被调用。 5.3、考虑使用SurfaceView传统的View的测量、布局、绘制都是在UI线程中完成的，而Android 的UI线程除了View的绘制之外，还需要进行额外的用户处理逻辑、轮询消息事件等，这样当View的绘制和动画比较复杂，计算量比较大的情况，就不再适合使用 View 这种方式来绘制了。这时候我们可以考虑使用SurfaceView ，SurfaceView 能够在非 UI 线程中进行图形绘制，释放了 UI 线程的压力。当然WaveLoadingView也可以使用SurfaceView 来实现。 结语WaveLoadingView的实现就讲解完毕，本次自定义View的过程都使用了kotlin进行编写，整体的代码量的确比java的减少了许多，但语言毕竟只是一个工具，我们主要是学习自定义View的实践过程，当你经常动手实践后，你会发现自定义View没有想象那么难，来来去去就那几个方法，大部分时间都是花在实现的细节和运算上，更多实现请查看文末地址。 地址：WaveLoadingView","tags":[{"name":"自定义view","slug":"自定义view","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89view/"}]},{"title":"自定义View实践-仿微信的滑动按钮","date":"2019-08-06T10:30:02.000Z","path":"2019/08/06/自定义View实践-仿微信的滑动按钮/","text":"前言前几天写过一篇文章View的工作原理，有原理不行，还要有实践，刚好把以前项目写过的仿微信滑动按钮控件封装一下，所以本文记录一下我实现这个控件的细节。 地址：SwitchButton 效果图控件使用效果如下： 除了颜色，看起来和微信的还是挺像的。 准备1、选择自定义View的方式自定义View有3种途径实现：1、组合控件；2、继承现有控件(如Button)；3、继承View。下面分别介绍一下： 1、组合控件：我们并不需要自己去绘制视图上显示的内容，而是将几个系统原生的控件组合到一起，这样创建出的控件就被称为组合控件，比如标题栏就是个很常见的组合控件。 2、继承现有控件：我们并不需要自己重新去实现一个控件，只需要去继承一个现有的控件，然后在这个控件上增加一些新的功能。它的优点就是不仅能够按照我们的需求加入相应的功能，并且还可以继承现有控件已经封装好的属性，同时不用自己定义测量流程。 3、继承View：我们继承View，重写相应的方法，重新去实现一个控件。它的优点就是灵活性高，它给你一张白纸，你用画笔尽情发挥。 现实情况使用什么方式根据实际情况考虑，我这个控件的选择是方式3: 继承View，重写onMeasure方法定义它的测量流程，重写onDraw()方法定义它的绘制流程。 2、选择让控件内容滑动的方式既然是滑动按钮，肯定有滑动，当我点击按钮时，如果是打开，按钮的小圆会滑向右边，如果是关闭，按钮的小圆会滑向左边。让控件的内容滑动起来我想到的有3种方式： 1、通过Scroller：调用Scroller的startScroll()方法，传入起始点坐标和终点坐标，然后重写View的computeScroll()方法，在这个方法里面调用Scroller的computeScrollOffset()方法开始滑动计算，然后调用View的scrollTo()或scrollBy()方法完成View的滑动距离的更新，然后调用View的invalidate()或postInvalidate()方法重绘View。 2、通过Handler不断的发送延时消息：通过Handler的 sendMessageDelayed(Message msg, long delayMillis)方法不断的发送延时消息，在Handler的handlerMessage()中收到消息后，完成滑动距离的更新，然后调用View的invalidate()或postInvalidate()方法重绘View。 3、通过动画：利用补间动画或属性动画的平移动画可以让View动起来，或者通过ValueAnimator，设定一个初始值和结点值，当调用ValueAnimator的start()方法后，就可以在回调中获取动画的进度，然后根据动画的进度更新滑动距离，然后调用View的invalidate()或postInvalidate()方法重绘View。 对于方法1，它更适用于自定义ViewGroup的情景，如果自定义ViewGroup中有许多子View需要滑动起来，就可以考虑使用Scroller，例如Android的ViewPager内部就是使用了Scroller；而对于自定义View，可能方法2和3更适用，我这个控件的选择是方式3: 通过ValueAnimator动画，在构造ValueAnimator时传入起点和终点，然后开启动画，根据动画进度计算滑动距离，让按钮的小圆滑动起来。 3、要不要考虑padding属性如果你在自定义控件中没有考虑padding属性，那么用户定义控件的padding值就会失效，我的选择是不考虑用户的padding值，因为滑动按钮中的内容只有一个小圆，且只在一边，padding的意义不大，考虑padding会让很多地方的坐标计算复杂，我还不如让用户直接控制小圆的半径，这样也类似于padding的效果，也简化了计算。 所以现实情况要不要考虑padding属性需要根据实际情况考虑。而margin值是由父ViewGroup决定，不是由View控制的，我们不用考虑margin值。 实现1、定义控件属性在自定义滑动按钮之前，我们先思考可以让用户自定义这个控件的什么属性，如按钮颜色，打开状态和关闭状态的颜色等，在 res -&gt; values 中，右键新建一个名为attrs的xml文件，在这个文件中定义控件属性，如下： 12345678910111213141516171819202122&lt;resources&gt; &lt;declare-styleable name=\"SwitchButton\" &gt; &lt;attr name=\"sb_openBackground\" format=\"color\"/&gt; &lt;attr name=\"sb_closeBackground\" format=\"color\"/&gt; &lt;attr name=\"sb_circleColor\" format=\"color\"/&gt; &lt;attr name=\"sb_circleRadius\" format=\"dimension\"/&gt; &lt;attr name=\"sb_status\"&gt; &lt;enum name=\"close\" value=\"0\"/&gt; &lt;enum name=\"open\" value=\"1\"/&gt; &lt;/attr&gt; &lt;attr name=\"sb_interpolator\"&gt; &lt;enum name=\"Linear\" value=\"0\"/&gt; &lt;enum name=\"Overshoot\" value=\"1\"/&gt; &lt;enum name=\"Accelerate\" value=\"2\"/&gt; &lt;enum name=\"Decelerate\" value=\"3\"/&gt; &lt;enum name=\"AccelerateDecelerate\" value=\"4\"/&gt; &lt;enum name=\"LinearOutSlowIn\" value=\"5\"/&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 这样用户在引用这个控件时就能使用这些属性，如下： 12345678910&lt;com.example.library.SwitchButton android:id=\"@+id/sb_button2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:sb_interpolator=\"Accelerate\" app:sb_status=\"open\" app:sb_circleRadius=\"10dp\" app:sb_closeBackground=\"@android:color/black\" app:sb_openBackground=\"@android:color/holo_blue_bright\" app:sb_circleColor=\"@android:color/white\" /&gt; 属性的名称要做到见名知意，app只是一个命名空间，取什么名字都可以，不要和系统android相同就行。关于这些属性什么意思可以看SwitchButton。 2、初始化控件属性重写View的3个构造方法，分别在3个构造函数中调用init()方法获取控件属性并初始化控件，如下： 1234567891011121314151617181920212223242526public class SwitchButton extends View &#123; public SwitchButton(Context context) &#123; super(context); init(context, null); &#125; public SwitchButton(Context context, AttributeSet attrs) &#123; super(context, attrs); init(context, attrs); &#125; public SwitchButton(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context, attrs); &#125; private void init(Context context, @Nullable AttributeSet attrs) &#123; TypedArray typedValue = context.obtainStyledAttributes(attrs, R.styleable.SwitchButton); mOpenBackground = typedValue.getColor(R.styleable.SwitchButton_sb_openBackground, DEFAULT_OPEN_BACKGROUND); mCloseBackground = typedValue.getColor(R.styleable.SwitchButton_sb_closeBackground, DEFAULT_CLOSE_BACKGROUND); //... typedValue.recycle(); //... //初始画笔，动画等 &#125;&#125; 我们在attrs中定义的控件属性都在AttributeSet这个集合中，然后通过TypedArray这个类帮助我们把值获取出来，最后一定要记得调用 typedValue.recycle() 方法回收资源。 为什么要重写3个构造函数呢？因为你的控件有可能在代码中引用或者在xml布局中引用，如果你的控件在xml布局中被引用，那么系统就会调用含有两个参数的构造函数来初始化控件；如果你直接在代码中 new 一个控件然后 add 到容器中，那么大多数情况你会使用含有一个参数的构造函数来初始化控件，如：SwitchButton button = new SwitchButton(this)，而不管一个参数的还是两个参数的系统最终都会调用含有三个参数的构造函数，以防万一，3个构造函数都要重写。 3、重写onMeasure方法，设定按钮的测量宽高重写onMeasure方法在这个方法设定滑动控件的测量宽高，如下： 12345678910111213141516171819202122232425262728293031323334353637383940@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int measuredWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measuredHeightMode = MeasureSpec.getMode(heightMeasureSpec); //取出系统测量宽高 int measuredWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int defaultWidth = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 60, getResources().getDisplayMetrics());//控件的默认宽 int defaultHeight = (int) (defaultWidth * 0.5f);//控件的默认高是默认宽的一半 //OFFSET == 6 int offset = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, OFFSET * 2 * 1.0f, getResources().getDisplayMetrics());//控件宽和高的差距不能小于12dp, 否则按钮就不好看了 //考虑wrap_content情况 if(measuredWidthMode == MeasureSpec.AT_MOST &amp;&amp; measuredHeightMode == MeasureSpec.AT_MOST)&#123; measuredWidth = defaultWidth; measureHeight = defaultHeight; &#125;else if(measuredHeightMode == MeasureSpec.AT_MOST)&#123; measureHeight = defaultHeight; if(measuredWidth - measureHeight &lt; offset) measuredWidth = defaultWidth; &#125;else if(measuredWidthMode == MeasureSpec.AT_MOST)&#123; measuredWidth = defaultWidth; if(measuredWidth - measureHeight &lt; offset) measureHeight = defaultHeight; &#125;else &#123; //处理输入非法的宽高情况，即高度大于宽度，把它们交换就行 if(measuredWidth &lt; measureHeight)&#123; int temp = measuredWidth; measuredWidth = measureHeight; measureHeight = temp; &#125; &#125; if(Math.abs(measureHeight - measuredWidth) &lt; offset) throw new IllegalArgumentException(\"layout_width cannot close to layout_height nearly, the diff must less than 12dp!\"); setMeasuredDimension(measuredWidth, measureHeight); &#125; 如果知道View的工作原理，那么理解上面的代码就很简单，主要是考虑wrap_content情况，我们要给滑动按钮设置一个默认的宽或高，默认的宽是60dp，默认高是30dp即宽的一半，如果不是wrap_content情况就让View直接使用系统测量的宽或高，最后一定要记得调用setMeasuredDimension()设定View的测量宽高。 同时我们还要考虑理输入非法的宽高情况，一定要保证宽 &gt; 高，如果用户输入的宽高是 宽 &lt; 高，这样会导致按钮竖起来，这种情况，我直接让高度与宽度交换；如果用户输入的宽高是 宽 &gt; 高，但是如果高很接近宽甚至相等，那么导致滑动控件就是一个圆形，按钮就不好看了，所以我们还要控制宽高不能相差得太近，为了美观，我设定阈值是12dp，如果宽高相差小于12dp，我就抛个异常提示用户。 4、在onLayout()方法中根据View的宽高计算坐标滑动控件被分为4个部分：左圆、矩形、右圆、小圆，如下： 在onDraw()方法中也会按顺序绘制滑动按钮的4个部分，在View的工作原理中讲到，onMeasure()有可能会被系统调用多次，所以最好在onLayout()方法中通过getHeight()和getWidth()方法获得View的真实宽高，所以在onLayout()方法中首先根据View的宽高计算出左圆的半径，小圆的半径，矩形左边界的x坐标，矩形右边界的x坐标，还有小圆圆心的x坐标，如下： 1234567891011121314@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); //得出左圆的半径 mLeftSemiCircleRadius = getHeight() / 2; //小圆的半径 = 大圆半径减OFFER，OFFER = 6 if(!checkCircleRaduis(mCircleRadius)) mCircleRadius = mLeftSemiCircleRadius - OFFSET; //矩形左边的x坐标 mLeftRectangleBolder = mLeftSemiCircleRadius; //矩形右边的x坐标 mRightRectangleBolder = getWidth() - mLeftSemiCircleRadius; //小圆的圆心x坐标一直在变化 mCircleCenter = isOpen ? mRightRectangleBolder : mLeftRectangleBolder;&#125; 可以看到左圆的半径等于View高的一半，然后基于左圆的半径得出其他坐标，小圆与左圆之间会有一些空隙，所以左圆半径减去offset值得出小圆半径，矩形左边的x坐标直接等于左圆的半径，矩形右边的x坐标View的宽度减左圆的半径，小圆圆心的x坐标根据初始状态是开启还是关闭，决定它的圆心的初始坐标是在矩形的右边界还是左边界。 在接下来只要你不断的改变小圆圆心的x坐标并重绘View，就可以让滑动按钮滑动起来。 5、重写onDraw()方法，绘制按钮内容View的工作原理中我们知道，View会在onDraw()方法中绘制自己，所以我们重写onDraw()方法，绘制滑动按钮的四个部分，如下： 1234567891011@Overrideprotected void onDraw(Canvas canvas) &#123; //左圆 canvas.drawCircle(mLeftRectangleBolder, mLeftSemiCircleRadius, mLeftSemiCircleRadius, mPathWayPaint); //矩形 canvas.drawRect(mLeftRectangleBolder, 0, mRightRectangleBolder, getMeasuredHeight(), mPathWayPaint); //右圆 canvas.drawCircle(mRightRectangleBolder, mLeftSemiCircleRadius, mLeftSemiCircleRadius, mPathWayPaint); //小圆 canvas.drawCircle(mCircleCenter, mLeftSemiCircleRadius, mCircleRadius, mCirclePaint);&#125; canvas是系统提供给我们的画布，在canvas绘制的东西就是View显示的内容，根据在onLayout中的计算，我们用画笔Paint在canvas中绘制出滑动按钮的4个部分，绘制后显示如下： 接下来就是让它滑动起来，这样就能达到效果图的效果。 6、重写onTouchEvent()方法，让按钮滑动起来在View的事件分发机制讲到，触摸事件如果不被拦截，最终会分发到View的onTouchEvent()方法中，在这个方法中我们可以根据事件的类型做出滑动按钮的不同行为，我们知道当手指按下按钮然后抬起，滑动按钮的小圆就会滑动到另一边；当手指按下按钮然后移动，滑动按钮的小圆也会跟随手指移动，知道了这两个行为后，我们看onTouchEvent()方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; //不在动画的时候可以点击 if(isAnim) return false; switch(event.getAction())&#123; case MotionEvent.ACTION_DOWN: //开始的x坐标 startX = event.getX(); break; case MotionEvent.ACTION_MOVE: float distance = event.getX() - startX; //更新小圆圆心坐标 mCircleCenter += distance / 10; //控制范围 if (mCircleCenter &gt; mRightRectangleBolder) &#123;//最右 mCircleCenter = mRightRectangleBolder; &#125; else if (mCircleCenter &lt; mLeftRectangleBolder) &#123;//最左 mCircleCenter = mLeftRectangleBolder; &#125; invalidate(); break; case MotionEvent.ACTION_UP: float offset = Math.abs(event.getX() - Math.abs(startX)); float diff; //分2种情况 if (offset &lt; mMinDistance) &#123; //1.点击, 按下和抬起的距离小于mMinDistance确定是点击了 if(isOpen)&#123; diff = mLeftRectangleBolder - mCircleCenter; &#125;else&#123; diff = mRightRectangleBolder - mCircleCenter; &#125; &#125; else &#123;//2.滑动 if (mCircleCenter &gt; getWidth() / 2) &#123;//滑过中点，滑到最右 this.isOpen = false; diff = mRightRectangleBolder - mCircleCenter; &#125; else&#123;//没滑过中点,回归原点 this.isOpen = true; diff = mLeftRectangleBolder - mCircleCenter; &#125; &#125; mValueAnimator.setFloatValues(0, diff); mValueAnimator.start(); startX = 0; break; default: break; &#125; return true;&#125; 我们先看ACTION_DOWN，当手指按下，我们记录手指按下的x坐标。 接着看ACTION_MOVE，如果按下后移动，我们就让小圆跟随手指移动即可，所以ACTION_MOVE中先计算出手指移动的距离distance，往右移distance是正数，往左移distance是负数，然后加到小圆的圆心坐标，还要控制小圆的圆心坐标的范围，不要超出矩形左右边界，最后调用 invalidate()重绘View，这样onDraw()方法就会重新执行，更新小圆的位置，就会让小圆慢慢滑动起来。 最后看ACTION_UP，mMinDistance = new ViewConfiguration().getScaledTouchSlop()，它是系统定义的临界值，当抬起手指时，如果移动的距离offset大于mMinDistance ，就认为抬起手指前，手指在移动，否则就认为在点击。如果手指在移动后抬起，这时就判断小圆圆心是否滑过中点算出滑动距离，如果滑过中点(getWidth() / 2)，就让小圆滑到最右，如果没有滑过中点，就让小圆滑到最左；如果手指只是在点击控件，这时就根据控件目前处于开启还是关闭状态算出滑动距离，如果目前处于开启状态，就让小圆滑到最左，如果目前处于关闭状态就让小圆滑到最右；而这个滑动距离diff就是小圆圆心到矩形边界的距离，至于是距离左边界还是右边界，就看上述情况了，计算出滑动距离后设置给ValueAnimator，最后开启动画，在ValueAnimator的updateListener中接收动画进度，如下： 12345678mValueAnimator.addUpdateListener(animation -&gt; &#123; float value = (float)animation.getAnimatedValue(); mCircleCenter -= mPreAnimatedValue; //更新小圆圆心坐标 mCircleCenter += value; mPreAnimatedValue = value; invalidate();&#125;); 在里面根据动画进度更新小圆圆心坐标，然后调用 invalidate()重绘View，这样onDraw()方法就会重新执行，更新小圆的位置，这样重复执行直到动画结束，就会让小圆慢慢滑动起来。 结语到最后就已经实现了效果图的效果，整个过程的原理还是挺简单，使用到了动画还有自定义View的基础知识，赶快动手实践一下。 地址：SwitchButton","tags":[{"name":"自定义view","slug":"自定义view","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89view/"}]},{"title":"View的事件分发机制","date":"2019-07-29T15:14:42.000Z","path":"2019/07/29/View的事件分发机制/","text":"前言前几天写过一篇文章View的工作原理，讲述的View工作的三大流程，其实与View的工作流程同样重要还有View的事件分发机制，平时我们经常通过setOnClickListener()方法来设置一个View的点击监听，那你有没有想过这个点击事件底层是怎么样传递到这个View的呢？当你自定义控件时，如果要处理滑动事件，那么到底返回true还是false？还有当你遇到了滑动嵌套的情景，你要怎么解决滑动嵌套引起的冲突？所以，本文通过 源码 + 流程图 来深入了解一个事件分发机制，当你掌握了它之后，当你遇到与滑动相关的问题时就更加的游刃有余。 本文源码基于Android8.0 准备知识1、什么是触摸事件触摸事件事件就是当你的手触摸到手机屏幕时所产生的最小单元事件，所谓最小单元，就是不可再拆分的，它一般有4种类型：按下（down)、移动（move）、抬起（up）、取消(cancel)。然后由若干个不可再拆分的最小单元事件就组成了点击事件、长按事件、滑动事件等。 2、什么是MotionEventMotionEvent就是Android对上面触摸事件相关信息的封装，View的事件分发中的事件就是这个MotionEvent，当这个MotionEvent产生后，那么系统就会将这个MotionEvent传递给View的层级，MotionEvent在View的层级传递的过程就是事件分发。MotionEvent封装了事件类型和坐标两类信息。 事件类型可以通过 motionEvent.getAction() 方法获得，它返回一个常量，对应着一个事件类型，事件类型主要有以下4种： 12345678910111213//MotionEvent.javapublic final class MotionEvent extends InputEvent implements Parcelable &#123; //按下（down) public static final int ACTION_DOWN = 0; //抬起（up） public static final int ACTION_UP = 1; //移动（move） public static final int ACTION_MOVE = 2; //取消(cancel) public static final int ACTION_CANCEL = 3; //还有很多就不一 一列举 //...&#125; 坐标信息也是通过MotionEvent获取，motionEvent.getRawX()、motionEvent.getRawY() 可以获得以屏幕作为参考系的坐标值，motionEvent.getX()、motionEvent.getY() 可以获得以被触摸的 View 作为参考系的坐标值。参考下面的视图坐标： 蓝色点想象成手指触摸屏幕的位置。 3、一个事件序列从手指按下屏幕到抬起，在这个过程中所产生的一系列事件，就是一个事件序列，这个事件序列以down事件开始，中间含有数量不定的move事件，最终以up事件结束。所以可能会有下面两种事件序列： ACTION_DOWN -&gt; ACTION_UP：手指按下屏幕后又抬起 ACTION_DOWN -&gt; ACTION_MOVE -&gt; … -&gt; ACTION_MOVE -&gt; ACTION_UP：手指按下屏幕，滑动一会，然后抬起 在分析事件分发的过程时，会有事件序列这个概念。 4、事件分发的起点，事件从何而来我想大家都知道View的事件分发机制的起点是View的dispatchTouchEvent()方法，但是如果从View的dispatchTouchEvent()继续追溯上去，事件是从哪里来的呢？ Android的输入设备有很多种，如屏幕、键盘、鼠标、轨迹球等，而屏幕是我们接触最多的设备，当用户手指触摸屏幕时就会产生触摸事件，这时Android的输入系统就会为这个触摸事件在/dev/input/路径下写入以event[NUMBER]为名的输入设备节点，这时输入系统中的EventHub就会监听到这个输入事件，然后InputReader就会把这个原始输入事件读取并经过加工后交给输入系统中的InputDispatcher，InputDispatcher会在mWindowHandles列表（mWindowHandles列表在IMS中代表所有窗口）中会找到合适的WindowHandle(InputWindowHandle类型)，然后把输入事件经过WindowHandle中的InputChannel通过Socket发送给应用进程所在的ViewRootImp中的InputChannel，这时ViewRootImp会把接收到的事件通过内部类InputEventReceiver分发给ViewRootImp持有的顶级View，然后顶级View的dispatchTouchEvent方法就会回调，在该方法中会获取Window.Callback(Activity或Dialog等实现了这个接口)，然后把事件分发给Callback，这时Callback的dispatchTouchEvent方法回调，不同的实现类由不同的实现，在Activity的实现中，它会把事件交给PhoneWindow来分发，然后PhoneWindow又会把这个事件分发给顶级View，然后顶级View就调用super.dispatchTouchEvent方法，把这个输入事件在View树中层层分发下去，直到找到合适的View来处理这个事件，这来到了我们熟悉的View的事件分发机制。 这个事件传输的大概过程：IMS -&gt; ViewRootImp -&gt; 顶级View -&gt; 实现Window.Callback的类 -&gt; Window -&gt; 顶级View。（更多细节可以查看原来Android触控机制竟是这样的？） 上面的一些名词如EventHub、InputReader、InputReader都是属于Android的输入系统，这部分是一个很复杂的知识，我只是概括了一下，所以我们只要知道，输入系统监听到输入事件后，就会先交给Window，然后Window再交给顶级View，然后顶级View在把它分发下去。(关于Window和View的关系可以看这篇文章Window, WindowManager和WindowManagerService之间的关系) 这个顶级View可能是View，也有可能是ViewGroup，具体情况看你添加Window到WMS时你的addView(View view, ViewGroup.LayoutParams params)方法中的View是View实例还是ViewGroup实例，所以本文接下来就分别分析View的事件分发和ViewGroup的事件分发。 View的事件分发1、View::dispatchTouchEvent()View的事件分发比ViewGroup的简单，因为它只是一个单独的元素，所以它只需要处理自己的事件，View的事件分发从View的dispatchTouchEvent()方法开始，所以我们看它的dispatchTouchEvent方法，如下： 1234567891011121314151617181920212223242526272829303132//View.javapublic boolean dispatchTouchEvent(MotionEvent event) &#123; //... //result默认为false boolean result = false; //... ListenerInfo li = mListenerInfo; if ( li != null//如果ListenerInfo不为空 &amp;&amp; li.mOnTouchListener != null//如果触摸事件的监听不为空 &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED//如果该控件是ENABLED状态 &amp;&amp; li.mOnTouchListener.onTouch(this, event)//如果onTouch方法返回了true )&#123; result = true; &#125; if ( !result//如果上面四个条件都不满足，result默认为false &amp;&amp; onTouchEvent(event)//如果onTouchEvent()方法返回了true ) &#123; result = true; &#125; //... return result;&#125;//View.javastatic class ListenerInfo &#123; public OnClickListener mOnClickListener;//点击事件的监听 protected OnLongClickListener mOnLongClickListener;//长按事件的监听 private OnTouchListener mOnTouchListener;//触摸事件的监听 //...&#125; 从View的dispatchTouchEvent()方法的伪代码可以看出，dispatchTouchEvent()方法首先会根据4个条件来决定是否调用View的onTouchEvent方法，如下： 1、如果ListenerInfo不为空：ListenerInfo里面有View的各种监听，那么mListenerInfo是什么时候被赋值的呢？答案是给View设置监听的时候，在我们给View设置任何监听的时候，如果这个mListenerInfo还没初始化就会先初始化，比如设置触摸事件的监听，我们看setOnTouchListener()方法，如下： 1234567891011121314//View.javapublic void setOnTouchListener(OnTouchListener l) &#123; //先调用getListenerInfo方法初始化mListenerInfo，然后把触摸事件的监听赋值给mOnTouchListener getListenerInfo().mOnTouchListener = l;&#125;//View.javaListenerInfo getListenerInfo() &#123; if (mListenerInfo != null) &#123; return mListenerInfo; &#125; mListenerInfo = new ListenerInfo(); return mListenerInfo; &#125; 2、如果触摸事件的监听不为空：即ListenerInfo的mOnTouchListener不为空，从1可以看出，当你给View设置OnTouchListener时，就已经满足了1、2条件了。 3、如果该控件是ENABLED状态：即该Vew处于enable状态，如果你没有手动调用过View的setEnable(false)设置控件为不可用的话，这个条件就为true，控件默认为enable状态。 4、如果onTouch方法返回了true：当你给View设置OnTouchListener，并且在onTouch方法中返回了true，表示消费了这次事件，那么这个条件就为true。所以到这里，如果4个条件都满足的话，result就会等于true，就会导致下面无法调用View的onTouchEvent()方法。 但是如果你没有给你给View设置OnTouchListener或者你给View设置了OnTouchListener，但是onTouch方法返回了false，只要满足这两个条件之一，就会让result保持默认值false，从而满足下面的条件调用View的onTouchEvent()方法。这里得出一个结论：OnTouchListener的onTouch方法的优先级高于onTouchEvent()方法。 假设现在不满足上面4个条件，从而调用View的onTouchEvent()方法，我们来看View的onTouchEvent()方法。 2、View::onTouchEvent()onTouchEvent()方法里面会处理View点击事件、长按事件，即回调你设置的OnClickListener的onClick()方法和OnLongClickListener的OnLongClick()方法，在你设置OnClickListener或OnLongClickListener回调时会同时把你的View设置为可点击状态即clickable状态，有些控件默认可点击如Button，而有些控件需要设置点击回调或setClickable(true)才可以点击如TextView。 接下来我们看View的onTouchEvent()方法的主要源码，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//View.javapublic boolean onTouchEvent(MotionEvent event) &#123; final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); //该View是否可点击，可以看到这里点击包含3种点击：CLICKABLE、LONG_CLICKABLE和CONTEXT_CLICKABLE(回调OnContextClickListener) //这里我们关注CLICKABLE和LONG_CLICKABLE就行，即点击和长按 final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; //1、如果View处于disabled状态，即不可用状态 if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; setPressed(false); &#125; mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN; //这里说明了即使View处于不可用状态，但是如果它可以点击，它还是会消费点击事件 return clickable; &#125; //2、如果View设置有代理机制，那么就会执行TouchDelegate的onTouchEvent()方法 if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; //3、下面是onTouchEvent()对点击事件和长按事件的处理 //如果控件可以点击 if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123; switch (action) &#123; case MotionEvent.ACTION_UP: //... break; case MotionEvent.ACTION_DOWN: //... break; case MotionEvent.ACTION_CANCEL: //... break; case MotionEvent.ACTION_MOVE: //... break; &#125; //从这里看出，如果我们的View是可以点击的，最终一定返回true，表示消费了此事件 return true; &#125; //4、最终虽然控件可用，但是不可点击，返回false，不消费此事件 return false;&#125; 这个onTouchEvent()方法有点长，这里我截取了整体框架，这里我们先明确一点的是onTochEvent()中返回true就表示这个事件由这个View消费，返回false就表示这个View不消费这个事件然后它的父容器会继续找合适的View消费。首先我们看注释1，它说明了即使View处于不可用状态，但是如果它可以点击即clickable = true，它会返回true，表明不可用状态下的View它还是会消费事件，即使这个View会没有响应，反之返回false；接着注释2，如果设置了mTouchDelegate，则会将事件交给代理者处理，直接return true，如果大家希望自己的View增加它的touch范围，可以尝试使用TouchDelegate；接着注释3，如果控件可以点击，就判断事件类型：ACTION_UP、ACTION_DOWN、ACTION_CANCEL、ACTION_MOVE，然后根据不同的事件类型做出不同的行为，然后都返回了true，表示消费了此事件；最后注释4如果控件不可点击，就返回false，不消费此事件。 接下来我们重点看注释3，看onTouchEvent()是如何在ACTION_UP、ACTION_DOWN、ACTION_CANCEL、ACTION_MOVE中触发onClick()和onLingClick()回调的。 2.1、case ACTION_DOWN:1234567891011121314 switch (action) &#123; case MotionEvent.ACTION_DOWN: //... //1、设置mHasPerformedLongPress为false mHasPerformedLongPress = false; //... //2、给mPrivateFlags设置一个PREPRESSED标识 mPrivateFlags |= PFLAG_PREPRESSED; //3、通过postDelayed发送一个延时100毫秒后执行的任务mPendingCheckForTap postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); //... break; &#125;return true; 我们想象一下，我们的手指按下这个View，这时进入ACTION_DOWN分支，在这个分支里，在注释1中它首先设置mHasPerformedLongPress为false，表示长按事件还没有触发，然后在注释2给mPrivateFlags设置一个PREPRESSED的标识，表示开始检查长按事件，然后在注释3通过postDelayed发送了一个延时消息，ViewConfiguration.getTapTimeout()返回100毫秒，即100毫秒后会执行任务mPendingCheckForTap，它一个CheckForTap类型任务，它是用来检测长按事件的。我们看这个任务是什么，如下： 1234567891011121314151617181920212223242526272829303132333435//View.java //用来检测长按事件private final class CheckForTap implements Runnable &#123; public float x; public float y; @Override public void run() &#123; //1、mPrivateFlags清除PFLAG_PREPRESSED标识 mPrivateFlags &amp;= ~PFLAG_PREPRESSED; //2、见下面调用链，这里传入true，即给mPrivateFlags设置一个PFLAG_PRESSED标识 setPressed(true, x, y); //3、调用checkForLongClick()方法，传入100毫秒 checkForLongClick(ViewConfiguration.getTapTimeout(), x, y); &#125; &#125;private void setPressed(boolean pressed, float x, float y) &#123; //... //主要调用了带一个参数的setPressed(pressed)方法 setPressed(pressed); &#125;//设置控件是否处于按下状态public void setPressed(boolean pressed) &#123; //... if (pressed) &#123;//如果pressed为true //给mPrivateFlags设置一个PFLAG_PRESSED标识 mPrivateFlags |= PFLAG_PRESSED; &#125; else &#123;//如果pressed为false //清除mPrivateFlags之前设置的PFLAG_PRESSED标识 mPrivateFlags &amp;= ~PFLAG_PRESSED; &#125; //...&#125; mPendingCheckForTap的run方法里面在注释1首先会先清除mPrivateFlags中PFLAG_PREPRESSED标识，然后在注释2设置PFLAG_PRESSED标识，表示准备执行长按事件，最主要的是注释3，我们看checkForLongClick方法里面干了什么，如下： 1234567891011121314151617//View.javaprivate void checkForLongClick(int delayOffset, float x, float y) &#123; //1、检查mViewFlags，如果可以进行长按事件LONG_CLICKABLE if ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE || (mViewFlags &amp; TOOLTIP) == TOOLTIP) &#123; //此时mHasPerformedLongPress标志位还是false mHasPerformedLongPress = false; if (mPendingCheckForLongPress == null) &#123; //2、创建了一个CheckForLongPress类型的任务 mPendingCheckForLongPress = new CheckForLongPress(); &#125; //... //3、ViewConfiguration.getLongPressTimeout()返回500毫秒，再减100毫秒等于400毫秒 //通过postDelayed()发送延时400毫秒后执行的任务mPendingCheckForLongPress postDelayed(mPendingCheckForLongPress, ViewConfiguration.getLongPressTimeout() - delayOffset); &#125;&#125; 这个方法在注释1首先检测该View是否可以进行长按事件，View的LONG_CLICKABLE属性默认为false，但是在setOnLongClickListener（）时就会把它设置为true，然后在注释2创建了一个CheckForLongPress类型的任务，然后在注释3通过postDelayed()发送了一个延时消息，即400毫秒后执行mPendingCheckForLongPress任务，它是用来执行长按事件的，我们看这个任务的具体实现，如下： 1234567891011121314151617181920212223242526272829//View.java//用来执行长按事件private final class CheckForLongPress implements Runnable &#123; private float mX; private float mY; @Override public void run() &#123; if ((mOriginalPressedState == isPressed())//1、首先检查mPrivateFlags中是否清除了PFLAG_PRESSED标识，如果清除了表示长按事件取消 &amp;&amp; (mParent != null) &amp;&amp; mOriginalWindowAttachCount == mWindowAttachCount) &#123; //2、调用performLongClick()方法 if (performLongClick(mX, mY)) &#123; //3、设置mHasPerformedLongPress为true mHasPerformedLongPress = true; &#125; &#125; //... if (performLongClick(mX, mY)) &#123; mHasPerformedLongPress = true; &#125; &#125; //...&#125;public boolean isPressed() &#123; //返回true表示检测mPrivateFlags中清除了PFLAG_PRESSED标识，false反之 return (mPrivateFlags &amp; PFLAG_PRESSED) == PFLAG_PRESSED;&#125; CheckForLongPress就是用于执行长按事件的，它的run方法里面会先检查mPrivateFlags中是否清除了PFLAG_PRESSED标识，如果清除了就表示长按事件取消，否则就调用performLongClick()方法，里面会最终回调onLongClick()方法回调，如果performLongClick()返回true，就会设置mHasPerformedLongPress为true，否则mHasPerformedLongPress还是为false，即mHasPerformedLongPress是否为true取决performLongClick(float x, float y)是否返回true，接下来我们看performLongClick(float x, float y)方法，如下： 1234567891011121314151617181920212223//View.javapublic boolean performLongClick(float x, float y) &#123; //... final boolean handled = performLongClick(); //... return handled; &#125;public boolean performLongClick() &#123; return performLongClickInternal(mLongClickX, mLongClickY);&#125;private boolean performLongClickInternal(float x, float y) &#123; boolean handled = false; final ListenerInfo li = mListenerInfo; //如果设置了OnLongClickListener回调 if (li != null &amp;&amp; li.mOnLongClickListener != null) &#123; //回调OnLongClickListener的onLongClick方法 handled = li.mOnLongClickListener.onLongClick(View.this); &#125; //... return handled;&#125; 在这个方法中一路跟进，最终来到了performLongClickInternal(float x, float y)方法中，在performLongClickInternal()方法中，如果我们通过setOnLongClickListener()设置了OnLongClickListener回调，这里就会回调我们熟悉的onLongClick()方法，而performLongClickInternal()是否返回true取决于我们在onLongClick()方法中是否返回true，performLongClick()是否返回true取决于performLongClickInternal()是否返回true，然后这里结合上面的黑体字得出一个结论：如果你设置了onLongClickListener，mHasPerformedLongPress是否为true取决我们在onLongClick()方法中是否返回true，如果没有设置，mHasPerformedLongPress就一直为false，这个mHasPerformedLongPress是否为true会影响我们在ACTION_UP是否能够回调onClick()方法的关键。 现在我们通过case ACTION_DOWN知道：如果我们按下手指在500毫秒内没有抬起，就会触发长按事件。下面分析ACTION_UP。 2.2、case ACTION_UP:12345678910111213141516171819202122232425262728293031323334353637383940414243switch (action) &#123; case MotionEvent.ACTION_UP: //... boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; //1、如果mPrivateFlags中包含PFLAG_PRESSED或PFLAG_PREPRESSED标识，都会进入if分支 if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; //... if (prepressed) &#123;//如果mPrivateFlags中只包含PFLAG_PREPRESSED标识，表示用户在100毫秒内抬起了手指，还没执行CheckForTap任务 //2、这里传入为true，即给mPrivateFlags设置一个PFLAG_PRESSED标识 //这里主要让用户看到控件还是按下状态 setPressed(true, x, y); &#125; //3、这个mHasPerformedLongPress为false就进入if分支，mIgnoreNextUpEvent默认为false if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; //4、移除长按事件CheckForLongPress任务消息，即取消长按事件 removeLongPressCallback(); //... if (mPerformClick == null) &#123; //5、如果mPerformClick为null，初始化一个实例 mPerformClick = new PerformClick(); &#125; //6、通过Handler把mPerformClick添加到消息队列，但其实PerformClick中的run方法还是执行performClick()方法，所以我们只要看performClick()方法就行 if (!post(mPerformClick)) &#123; //如果post一个PerformClick失败就执行performClick()方法 performClick(); &#125; &#125; //... //7、移除检测长按事件CheckForTap任务消息，即取消检测长按事件 removeTapCallback(); &#125; break;&#125;return true;//View.java//PerformClick中的run方法还是执行performClick()方法 private final class PerformClick implements Runnable &#123; @Override public void run() &#123; performClick(); &#125; &#125; 我们想象一下，现在我们抬起了手指，分三个时间段抬起： 1、如果你在100毫秒内抬起手指，那么mPrivateFlags肯定只有PFLAG_PREPRESSED标识，且mHasPerformedLongPress为false，根据注释1和3，这样就会执行PerformClick()方法，在执行PerformClick()方法前，在注释4调用removeLongPressCallback()移除长按事件CheckForLongPress任务，即不会触发onLongClick()回调。 2、如果你在100毫秒后到500毫秒才抬起，那么mPrivateFlags肯定只有PFLAG_PRESSED标识，且mHasPerformedLongPress为false，接下来的逻辑和1一样。 3、如果你在500毫秒后才抬起，那么mPrivateFlags肯定只有PFLAG_PRESSED标识，而mHasPerformedLongPress是否为true取决我们是否设置onLongClickListener并在onLongClick()方法中是否返回true。如果你设置了onLongClickListener回调并在onLongClick()方法中返回了false或者你没有设置onLongClickListener回调，那么你还是可以走到注释6执行performClick()方法；但是如果你设置了onLongClickListener回调并在onLongClick()方法中返回了true，那么你就不能执行performClick()方法了。 对照ACTION_DOWN的流程和ACTION_UP的流程就能更好的理解上面3个时间段，所以从这里我们知道：如果你在500毫秒内抬起手指，那么你就只能执行点击事件，不能执行长按事件；如果你在500毫秒后抬起，并且你设置了onLongClickListener并在onLongClick()方法中返回了false 或者 你没有设置onLongClickListener回调，那么你执行完长按事件后还可以执行点击事件，但是如果你设置了onLongClickListener回调并在onLongClick()方法中返回了true，那么你就不能执行点击事件。performClick()和 performLongClick()方法类似，它里面最终回调onClick()方法，如下： 1234567891011121314//View.javapublic boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; //1、执行了OnClickListener的onClick()方法 li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; //... return result; &#125; performClick()方法中的逻辑是，如果你设置了OnClickListener回调，那么就会执行onClick(）方法，大家也注意到performClick()会返回一个true或者false，但是这个返回值对于onTouchEvent()方法没有任何意义，因为上面提到switch语句块的后面一定返回true。这里我们再得出一个结论：OnLongClickListener的onLongClick()方法的优先级高于onClickListener的onClick()方法。 好了现在我们的手指从按下到抬起，就已经分析完onTouchEvent()中的ACTION_DOWN和ACTION_UP分支，如果你的手指在抬起前，不小心移动了一下，就会触发ACTION_CANCEL或ACTION_MOVE，这个时候它就会根据条件(手指是否移出View的范围)通过调用 removeLongPressCallback()或 removeTapCallback()方法移除CheckForLongPress或CheckForTap任务，即取消长按或点击，这里限于篇幅就不再展开分析，大家可自行分析。 3、小结1、View没有子View，所以它的的分发比较简单，从View的dispatchTouchEvent()方法开始进入View的事件分发流程，该方法只负责事件的分发，没有进行实际事件的处理，进行实际事件的处理有两处地方：1、通过外部设置的onTouchListener的onTouch()方法，2、View的onTouchEvent()方法。 2、当一个View要处理点击事件时，如果它设置了onTouchListener，那么onTouch方法就会回调，这时事件如何处理还要看onTouch()方法的返回值，如果返回true，那么onTouchEvent()方法将不会被调用，dispatchTouchEvent()方法直接返回true；如果返回false，onTouchEvent()方法会被调用，这时事件如何处理就要看onTouchEvent()的返回值，在onTouchEvent()中，不管控件可用还是不可用，返回值取决于控件是否可点击，如果控件可点击(clickabale或longClickabale，只要有一个为true)，onTouchEvent()返回true，如果控件不可点击(clickabale和longClickabale都为false)，onTouchEvent()返回false。 3、如果我们同时设置了OnTouchListener、OnLongClickListener和OnClickListener回调，根据优先级，事件的传递顺序是：onTouch() -&gt; onLongClick() -&gt; onClick()，其中除了onClick()都有boolean返回值，返回值能决定下一个方法是否被调用，onClick()优先级最低，连返回值都没有。 4、 对于ViewGroup（也就是当前 View 的父容器）而言，它只认识子 View的dispatchTouchEvent()方法，不认识另外两个处理事件的方法。子View的 onTouch() 和 onTouchEvent() 都是在自己的 dispatchTouchEvent() 里面调用的，他们两个会影响 dispatchTouchEvent() 的返回值，但是对于上级 ViewGroup 而言，它只认识 dispatchTouchEvent() 的返回值。 流程图： ViewGroup的事件分发1、ViewGroup::dispatchTouchEvent()ViewGroup是View的子类，它是一组View的集合，它包含很多子View和子ViewGroup，所以ViewGroup的事件分发比View的复杂，但是ViewGroup的事件分发才是整个事件分发机制的精髓，和View一样ViewGroup的事件分发的起点也是dispatchTouchEvent()，虽然这个方法在View中，但是ViewGroup重写了它，因为它们的分发逻辑不一样。所以我们看ViewGroup的dispatchTouchEvent()方法，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//ViewGroup.java@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; //... //本次事件处理结果 boolean handled = false; if (onFilterTouchEventForSecurity(ev)) &#123; final int action = ev.getAction(); final int actionMasked = action &amp; MotionEvent.ACTION_MASK; //1、如果本次事件是ACTION_DOWN if (actionMasked == MotionEvent.ACTION_DOWN) &#123; //置空mFirstTouchTarget，mFirstTouchTarget是TouchTarget类型，是一个单链表结构 cancelAndClearTouchTargets(ev); //清除mGroupFlags中的FLAG_DISALLOW_INTERCEPT标志位，这个标志等同于下面的disallowIntercept resetTouchState(); &#125; //ViewGroup是否拦截本次事件标志 final boolean intercepted; //2、如果本次事件是ACTION_DOWN 或者 mFirstTouchTarget为空 if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; //子View是否禁止ViewGroup拦截事件标志 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123;//如果子View允许ViewGroup拦截事件 //调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent(ev)决定 intercepted = onInterceptTouchEvent(ev); //... &#125; else &#123;//如果子View禁止ViewGroup拦截事件 intercepted = false;//intercepted值为false &#125; &#125; else &#123;//如果本次事件不是ACTION_DOWN又没有target //intercepted值为true，在此之后，当前事件序列中的所有事件序列都由ViewGroup处理，不会再传递给子View intercepted = true; &#125; //... //检查本次事件是否是ACTION_CANCEL final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; //split默认为true final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; //newTouchTarget用于记录本次事件的target TouchTarget newTouchTarget = null; //表示事件是否已经分发给target对应的子View，默认为false boolean alreadyDispatchedToNewTouchTarget = false; //3、如果本次事件不取消并且不拦截，就寻找合适的子View处理 if (!canceled &amp;&amp; !intercepted) &#123; //取出按下手指的index final int actionIndex = ev.getActionIndex(); // always 0 for down //getPointerId表示根据index取出按下手指的id，第一根手指为0，第二根手指为1，以此类推 //idBitsToAssign与多点触控相关，本文不重点讨论 final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; //... //如果本次事件是ACTION_DOWN 或 ACTION_POINTER_DOWN 或ACTION_HOVER_MOVE //本文重点关注ACTION_DOWN事件，ACTION_POINTER_DOWN与多点触控相关 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE ) &#123; final int childrenCount = mChildrenCount; //如果target是null并且ViewGroup有子View，就寻找某个子View当target if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); final View[] children = mChildren; //从后往前逐个取出子View for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); //判断子View能否接受点击事件：子View可见或在播放动画，并且触摸点在子View范围内 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; //走到这里表示子View满足处理事件的条件 //... //dispatchTransformedTouchEvent()里面会调用子View的dispatchTouchEvent()方法，在这个方法里把事件分发给子View if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; //... //如果dispatchTransformedTouchEvent()返回true，表示找到子View消费本次事件了，就会走到这里, 所以这个子View就被当作target，这里会调用addTouchTarget()方法为这个子View创建一个TouchTarget，并把这个target插入mFirstTouchTarget链表的表头，并把表头返回赋值给newTouchTarget newTouchTarget = addTouchTarget(child, idBitsToAssign); //alreadyDispatchedToNewTouchTarget赋值为true，表示事件已经分发给target对应的子View alreadyDispatchedToNewTouchTarget = true; break; &#125; //... &#125;//end...for（） //... &#125;//end...if(newTouchTarget == null &amp;&amp; childrenCount != 0) &#125;//end...if(actionMasked == MotionEvent.ACTION_DOWN...) &#125;///end...if(!canceled &amp;&amp; !intercepted) //4、根据mFirstTouchTarget是否为null做出不同行为 if (mFirstTouchTarget == null) &#123;//这一般有三种情况导致mFirstTouchTarget为空： //1、ViewGroup没有子View； //2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false； //3、ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true //在这三种情况下ViewGroup就会自己处理事件 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123; //有两种情况mFirstTouchTarget不为空，表示找到合适的子View为target： //1、本次事件是ACTION_DOWN，遍历完ViewGroup所有的子View后找到了合适的子View为target； //2、本次事件是除了ACTION_DOWN以外的其他事件，但是在ACTION_DOWN时已经找到了合适的子View为target，所以接下来就直接把事件分发给mFirstTouchTarget的child处理处理就行 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; //mFirstTouchTarget是一个单链表结构，下面是链表的遍历 while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;//情况1的处理 //因为在找到target时已经调用过dispatchTransformedTouchEvent()了，表示该target的View已经消费了该事件，handle直接等于true handled = true; &#125; else &#123;//情况2的处理 //注意这个intercepted，如果为true，cancelChild就会为true，会导致子View收到一个ACTION_CANCEL, 表示子View的本次事件取消 final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; //调用dispatchTransformedTouchEvent()方法把事件分发给target对应的子View if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; //handle的是否为true取决于子View的dispatchTouchEvent()返回值 handled = true; &#125; //如果需要取消本次事件，清空这个子View对应的target，并把这个tareget从链表中取消，导致该事件序列的后序事件该子View都无法再收到 if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; //继续分发给下一个target target = next; &#125;//end...while (target != null) &#125;//end...if (mFirstTouchTarget == null) //... &#125;//end...if (onFilterTouchEventForSecurity(ev)) //... return handled;&#125; 这个方法特别长，里面就是整个ViewGroup的事件分发逻辑，我知道大家也没有想看的欲望了，这个方法对应的流程图如下： 可以看到，在同一个事件序列内（从down开始，到up结束），ViewGroup的dispatchTouchEvent()方法可以分为两大过程：1、ACTION_DOWN事件的处理流程；2、除了ACTION_DOWN以外的事件处理流程。下面跟着这两个流程分别走一遍。 2、ViewGroup处理ACTION_DOWN事件的流程ACTION_DOWN事件的处理流程又可以分为两个流程即：ViewGroup拦截事件(intercepted = true)与不拦截事件（intercepted = false）。 看流程图，在dispatchTouchEvent()方法注释2中的if语句会决定 intercepted 的值，如下： 12345678910111213141516//ViewGroup是否拦截本次事件标志final boolean intercepted;//2、如果本次事件是ACTION_DOWN 或者 mFirstTouchTarget为空if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; //2.1、子View是否禁止ViewGroup拦截事件标志 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123;//如果子View允许ViewGroup拦截事件 //调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent(ev)决定 intercepted = onInterceptTouchEvent(ev); //... &#125; else &#123;//如果子View禁止ViewGroup拦截事件 intercepted = false;//intercepted值为false &#125;&#125; else &#123; //...&#125; 如果本次事件是ACTION_DOWN也会进入这个if分支，看注释2.1检查 mGroupFlags 中是否包含FLAG_DISALLOW_INTERCEPT标识，默认没有，即默认disallowIntercept为false，所以就会调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent()决定，onInterceptTouchEvent()默认返回false，所以intercepted = false。 2.1、intercepted = false当DOWN事件没有被ViewGroup拦截，intercepted = false，它就会进入dispatchTouchEvent()方法注释3的if语句，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 //检查本次事件是否是ACTION_CANCELfinal boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;//...//newTouchTarget用于记录本次事件的targetTouchTarget newTouchTarget = null;//表示事件是否已经分发给target对应的子View，默认为falseboolean alreadyDispatchedToNewTouchTarget = false;//3、如果本次事件不取消并且不拦截，就寻找合适的子View处理if (!canceled &amp;&amp; !intercepted) &#123; //... //如果本次事件是ACTION_DOWN 或 ACTION_POINTER_DOWN 或ACTION_HOVER_MOVE //本文重点关注ACTION_DOWN事件，ACTION_POINTER_DOWN与多点触控相关 if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123; final int childrenCount = mChildrenCount; //如果target是null并且ViewGroup有子View，就寻找某个子View当target if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); final View[] children = mChildren; //从后往前逐个取出子View for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); //3.1、判断子View能否接受点击事件：子View可见或在播放动画，并且触摸点在子View范围内 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; //走到这里表示子View满足处理事件的条件 //... //3.2、dispatchTransformedTouchEvent()里面会调用子View的dispatchTouchEvent()方法，在这个方法里把事件分发给子View if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; //... //3.3、如果dispatchTransformedTouchEvent()返回true，表示找到子View消费本次事件了，就会走到这里, 所以这个子View就被当作target，这里会调用addTouchTarget()方法为这个子View创建一个TouchTarget，并把这个target插入mFirstTouchTarget链表的表头，并把表头返回赋值给newTouchTarget newTouchTarget = addTouchTarget(child, idBitsToAssign); //alreadyDispatchedToNewTouchTarget赋值为true，表示事件已经分发给target对应的子View alreadyDispatchedToNewTouchTarget = true; break; &#125; //... &#125;//end...for（） //... &#125;//end...if(newTouchTarget == null &amp;&amp; childrenCount != 0) &#125;//end...if(actionMasked == MotionEvent.ACTION_DOWN...)&#125;///end...if(!canceled &amp;&amp; !intercepted) 如果是DOWN事件，假设ViewGroup有子View，就会进入for循环，ViewGroup就会遍历所有子View，先在注释3.1中判断这个子View是否满足接收事件的条件，如果不满足，就再找下一个子View，如果满足，就来到了注释3.2，然后调用dispatchTransformedTouchEvent()方法看这个子View是否消费DOWN事件。 dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)方法如下： 123456789101112131415161718192021222324252627282930313233//ViewGroup.java//dispatchTransformedTouchEvent（）只需要关注两个参数：//@params cancel 是否取消本次事件//@params child 准备接收分发事件的子Viewprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; final int oldAction = event.getAction(); //1、如果cancel为true，进入这个if分支 if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; //设置ACTION_CANCEL事件 event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; //...省略的是多点触控的处理 //2、如果cancel为false，进入这个if分支 if (child == null) &#123;//如果child为空 //调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件 handled = super.dispatchTouchEvent(event); &#125; else &#123;//如果child不为空 //... //调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件 handled = child.dispatchTouchEvent(event); &#125; return handled;&#125; 因为传入cancel为false，所以来带注释2的if分支，因为传入的child不为空，所以调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件，到这里DOWN事件就传递给子View，如果子View是一个View，那么它的处理流程就像前面介绍的View的事件分发一样，如果子View是一个ViewGroup，那么它的处理流程就又是ViewGroup的事件分发。 好了，假设子View消费这个事件，返回true，则dispatchTransformedTouchEvent()返回true，ViewGrou找到了要消费这个DOWN事件的子View，这时到了dispatchTouchEvent方法的注释3.3，调用addTouchTarget(child, idBitsToAssign)方法，如下： 123456789101112131415161718//ViewGroup.javaprivate TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123; //首先为传进来的View获取一个target关联 final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); //然后把这个target插入mFirstTouchTarget链表的表头 target.next = mFirstTouchTarget; mFirstTouchTarget = target;//mFirstTouchTarget重新移动到链表表头 //返回链表表头的target return target;&#125;//ViewGroup::TouchTargetpublic static TouchTarget obtain(@NonNull View child, int pointerIdBits) &#123; //... target.child = child; target.pointerIdBits = pointerIdBits; return target;&#125; 如果找到了要消费这个DOWN事件的子View，就会为这个子View创建一个target关联，同时这个子View会赋值给target的child字段，最后这个target就会插入链表的表头并返回，addTouchTarget方法返回后赋值给newTouchTarget字段。target的作用就是：做了一个记录，当下一个事件到来时，如果发现mFirstTouchTarget不为空，就会遍历链表找到对应的target，直接把事件分发给target中记录的View，就不用再去遍历ViewGroup中子View了。 那么我们上面所谈到的target、mFirstTouchTarget、newTouchTarget是什么？它们都是TouchTarget类型，如下： 1234567891011///ViewGroup::TouchTargetprivate static final class TouchTarget &#123; //当前消费事件的View public View child; //它的下一个结点 public TouchTarget next; //通过二进制位记录按在child上的手指数量，有多少个1就表示有多少根手指 //例如pointerIdBits = 001表示有一根手指，pointerIdBits = 011表示有两根手指， public int pointerIdBits; //...&#125; 它是一个链表结构，其中child表示本次需要消费事件的View，next表示下一个结点，pointerIdBits表示按在child上的手指数量，mFirstTouchTarget就是这个链表的表头，链表由很多的target串联起来，newTouchTarget就是代表最新插入的target，为什么mFirstTouchTarget是一个链表？我的猜测是由于多点触控的存在，例如我5个手指可以同时触摸到列表的5个子View，如果5个子View都是要消费这个DOWN事件的话，那么就要用链表把它们记录起来，当下一个事件到来时，5个子View都能分发到事件，所以后面遇到target的字眼，时刻记住它是一个链表结构。 多点触控在事件分发中又是另外一个知识点，在多点触控中:1、如果多个手指依此按在同一个View中，那么这个View会先收到第一个手指的ACTION_DOWN事件，接着会收到其他手指的ACTION_POINTER_DOWN事件;2、如果多个手指依此按在不同的View中，那么每个View都会收到相应手指的ACTION_DOWN事件；在Android中，通过idBitsToAssign、mFirstTouchTarget 和 mFirstTouchTarget中的pointerIdBits配合实现多点触控的事件分发，有兴趣的可以自行了解“事件分发只有一次 ACTION_DOWN，一次 ACTION_UP”严谨吗？。 好了，现在已经找到了可以消费事件的子View，并通过addTouchTarget方法为这个子View关联了一个target插入了mFirstTouchTarget，并且mFirstTouchTarget在链表插入时也被移动到链表表头了，不为null了，接着就一个break跳出for循环，直接来到dispatchTouchEvent()方法的注释4，如下： 1234567891011121314151617181920212223//4、根据mFirstTouchTarget是否为null做出不同行为if (mFirstTouchTarget == null) &#123; //...&#125; else &#123;//有两种情况mFirstTouchTarget不为空，表示找到合适的子View为target： //1、本次事件是ACTION_DOWN，遍历完ViewGroup所有的子View后找到了合适的子View为target； //2、本次事件是除了ACTION_DOWN以外的其他事件，但是在ACTION_DOWN时已经找到了合适的子View为target，所以接下来就直接把事件分发给target的child处理就行 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; //mFirstTouchTarget是一个单链表结构，下面是链表的遍历 while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;//情况1的处理 //因为在找到target时已经调用过dispatchTransformedTouchEvent()了，表示该target的View已经消费了该事件，handle直接等于true handled = true; &#125; else &#123;//情况2的处理 //... &#125; predecessor = target; //继续分发给下一个target target = next; &#125;//end...while (target != null) &#125;//end...if (mFirstTouchTarget == null) mFirstTouchTarget不为空，就来到else分支，else分支中是一个链表的遍历，遍历所有的target，找到在上面的for循环消费了DOWN事件的子View对应的target，对应情况1的if分支，在上面的for循环中找到子View后，这个子View已经消费了DOWN事件，alreadyDispatchedToNewTouchTarget已经赋值为true，所以handle直接等于true。 到这里在DOWN事件下ViewGroup不拦截的情况下分析完毕。上面是假设找到了子View并且子View消费了事件，这样当下一次事件到来时mFirstTouchTarget不为空，就直接把这个事件给子View；但是如果上面是找到子View而这个子View不消费这个DOWN事件，即子View的dispatchTouchEvent()方法返回false，那么dispatchTransformedTouchEvent()返回false，就导致无法为mFirstTouchTarget赋值，mFirstTouchTarget为空，当下一次事件序列到来时，ViewGroup会直接处理，而不再转发给子View。这里得出一个结论：子View如果不消费ACTION_DOWN事件，那么同一事件序列的其他事件都不会再交给它来处理，而是交给它的父ViewGroup处理；子View一旦消费ACTION_DOWN事件，那么同一事件序列的其他事件都会交给它处理。 所以如果此时子View没有消费ACTION_DOWN事件，或者我重写了ViewGroup的onInterceptTouchEvent()并返回了true，那么ViewGroup就会开始拦截事件，接下来看在DOWN事件下ViewGroup拦截的情况，即intercepted = true。 2.2、intercepted = true如果ViewGroup拦截DOWN事件，那么intercepted = true，就不会进入dispatchTouchEvent()方法的注释3的if语句，这样在DOWN事件下ViewGroup就不会遍历它的子View，也就无法调用dispatchTransformedTouchEvent()找到要消费事件的子View，同理无法调用addTouchTarget()方法为mFirstTouchTarget赋值，就会导致在DOWN事件下mFirstTouchTarget为空，这样就直接来到了dispatchTouchEvent()方法的注释4的if语句，如下： 123456789101112131415 //检查本次事件是否是ACTION_CANCEL final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;//... //4、根据mFirstTouchTarget是否为null做出不同行为if (mFirstTouchTarget == null) &#123;//这一般有三种情况导致mFirstTouchTarget为空： //1、ViewGroup没有子View； //2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false； //3、ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true //在这三种情况下ViewGroup就会自己处理事件 //注意第三个参数传入null，表示ViewGroup自己处理事件 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; else &#123; //... &#125;//end...if (mFirstTouchTarget == null) 很明显这里是情况3，因为没有找到子View，dispatchTransformedTouchEvent()方法的第三个参数为空，而第二个参数为false，因为不是ACTION_CANCEL事件，我们参考上面的dispatchTransformedTouchEvent()方法分析，如下： 123456789101112131415161718//ViewGroup.java//dispatchTransformedTouchEvent（）只需要关注两个参数：//@params cancel 是否取消本次事件//@params child 准备接收分发事件的子Viewprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; //... //2、如果cancel为false，进入这个if分支 if (child == null) &#123;//如果child为空 //调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件 handled = super.dispatchTouchEvent(event); &#125; else &#123;//如果child不为空 //... //调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件 handled = child.dispatchTouchEvent(event); &#125; return handled;&#125; 里面就会调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件，ViewGroup的父类是View，所以super.dispatchTouchEvent(event)里面的处理逻辑就是View的事件分发的处理逻辑，见前面分析的View的事件分发。 到这里在DOWN事件下ViewGroup拦截的情况分析完毕。这里得出一个结论：ViewGroup如果在onInterceptTouchEvent()方法的ACTION_DOWN事件中返回true，那么整个事件序列都会交给ViewGroup处理，不再交给子View。 我们回到dispatchTouchEvent()方法，还有一点要注意的是在ACTION_DOWN下不管拦截还是不拦截都会进入dispatchTouchEvent()方法中注释1的if语句，如下： 1234567 //1、如果本次事件是ACTION_DOWNif (actionMasked == MotionEvent.ACTION_DOWN) &#123; //置空mFirstTouchTarget，mFirstTouchTarget是TouchTarget类型，是一个单链表结构 cancelAndClearTouchTargets(ev); //清除mGroupFlags中的FLAG_DISALLOW_INTERCEPT标志位，这个标志等同于下面的disallowIntercept resetTouchState();&#125; 这个if语句的作用就是防止前一次事件序列对本次事件序列造成影响，所以它会向先调用 cancelAndClearTouchTargets(ev)清空mFirstTouchTarget，然后调用resetTouchState()清除FLAG_DISALLOW_INTERCEPT标志位，因为ACTION_DOWN事件是一个新的事件序列的开始，所以dispatchTouchEvent()方法首先要做的就是判断是不是迎来了一个新的事件序列，所以要判断该事件是否是ACTION_DOWN 事件，如果是 ACTION_DOWN 事件，作为一个事件序列的开头，应当要消除前面的事件序列可能留下的影响。关于FLAG_DISALLOW_INTERCEPT标志位后面会讲。 到这里ViewGroup处理ACTION_DOWN事件的流程分析完毕，下面我们来看除了ACTION_DOWN以外的事件的处理流程。 3、ViewGroup处理除了ACTION_DOWN以外的事件的流程ACTION_DOWN事件的处理流程又可以分为两个流程即：mFirstTouchTarget != null与mFirstTouchTarget == null。你会发现intercepted这个标记位似乎已经没有多大作用， 它如果是true，它根本不会进入dispatchTouchEvent()方法的注释3，就算是false进入了dispatchTouchEvent()方法的注释3，它也不会满足注释3.1的条件。所以我们就直接来到注释4。 3.1、mFirstTouchTarget == null123456789101112131415//检查本次事件是否是ACTION_CANCELfinal boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;//... //4、根据mFirstTouchTarget是否为null做出不同行为if (mFirstTouchTarget == null) &#123;//这一般有三种情况导致mFirstTouchTarget为空： //1、ViewGroup没有子View； //2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false； //3、ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true //在这三种情况下ViewGroup就会自己处理事件 //注意第三个参数传入null，表示ViewGroup自己处理事件 handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);&#125; else &#123; //... &#125;//end...if (mFirstTouchTarget == null) 这里1、2、3情况都有可能发生，从ACTION_DOWN的处理流程我们知道为mFirstTouchTarget赋值的过程只会在处理ACTION_DOWN事件的时候出现，所以如果在处理ACTION_DOWN事件的时候ViewGroup没有子View，不会进入for循环，导致mFirstTouchTarget为空；如果ViewGroup有子View，进入了for循环，但是View不消费DOWN事件，即在dispatchTouchEvent()返回了false，导致无法调用addTouchTarget()方法为mFirstTouchTarget赋值，导致mFirstTouchTarget为空；ViewGroup在DOWN事件中的onInterceptTouchEvent(ev)返回了true，不会进入注释3的if语句，导致mFirstTouchTarget为空；所以在处理ACTION_DOWN事件的时候没有找到mFirstTouchTarget，就会导致在除了ACTION_DOWN其他事件到来时mFirstTouchTarget == null，这里就直接让ViewGroup自己处理事件了。 3.2、mFirstTouchTarget != null12345678910111213141516171819202122232425262728293031323334353637383940414243//4、根据mFirstTouchTarget是否为null做出不同行为if (mFirstTouchTarget == null) &#123; //...&#125; else &#123;//有两种情况mFirstTouchTarget不为空，表示找到合适的子View为target： //1、本次事件是ACTION_DOWN，遍历完ViewGroup所有的子View后找到了合适的子View为target； //2、本次事件是除了ACTION_DOWN以外的其他事件，但是在ACTION_DOWN时已经找到了合适的子View为target，所以接下来就直接把事件分发给target的child处理就行 TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; //mFirstTouchTarget是一个单链表结构，下面是链表的遍历 while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;//情况1的处理 //... &#125; else &#123;//情况2的处理 //4.1、注意这个intercepted，如果为true，cancelChild就会为true，会导致子View收到一个ACTION_CANCEL, 表示子View的本次事件取消 final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; //4.2、调用dispatchTransformedTouchEvent()方法把事件分发给target if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; //handle的是否为true取决于子View的dispatchTouchEvent()返回值 handled = true; &#125; //4.3、如果需要取消本次事件，清空这个子View对应的target，并把这个tareget从链表中取消，导致该事件序列的后序事件该子View都无法再收到 if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; //继续分发给下一个target target = next; &#125; predecessor = target; target = next;&#125;//end...while (target != null) &#125;//end...if (mFirstTouchTarget == null) mFirstTouchTarget != null，表示在处理ACTION_DOWN事件的时候已经找到mFirstTouchTarget，就会进入注释4的else分支，这里是情况2，就会进入情况2的处理的else分支，注释4.1的cancelChild这个值会决定子View是收到ACTION_CANCEL事件还是其他事件，而cancelChild的值取决于intercepted的值，所以如果ViewGroup在除了ACTION_DOWN以外的其他事件中的onInterceptTouchEvent(ev)方法返回了true，导致intercepted = true，从而cancelChild = true，而如果ViewGroup一直保持默认状态，intercepted = false，从而cancelChild = false，紧接着在注释4.2把cancelChild和target.child传进了dispatchTransformedTouchEvent()方法中。 我再贴一下dispatchTransformedTouchEvent()方法的代码，如下： 12345678910111213141516171819202122232425262728293031//ViewGroup.javaprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; final boolean handled; final int oldAction = event.getAction(); //1、如果cancel为true，进入这个if分支 if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123; //设置ACTION_CANCEL事件 event.setAction(MotionEvent.ACTION_CANCEL); //分发ACTION_CANCEL事件 if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; event.setAction(oldAction); return handled; &#125; //...省略多点触控处理 //2、如果cancel为false，进入这个if分支 if (child == null) &#123; //调用 super.dispatchTouchEvent(event)，表示ViewGroup自己决定是否处理本次事件 handled = super.dispatchTouchEvent(event); &#125; else &#123; //... //调用child.dispatchTouchEvent(event)，表示让子View决定是否处理本次事件 handled = child.dispatchTouchEvent(event); &#125; return handled;&#125; 可以看到如果cancel为true，进入注释1这个if分支，里面会set一个ACTION_CANCEL事件，然后传递给target记录的子View；如果cancel为false，进入注释2这个else分支，调用child.dispatchTouchEvent(event)，表示让target记录的子View决定是否处理本次事件，前面已经讲过了。 好，现在我们走出dispatchTransformedTouchEvent()方法，来到注释4.3，如果cancelChild为true，就会调用TouchTarget的recycler()方法回收这个target，这样做的后果是什么呢？这样相当于清空了这个子View对应的target，并把这个tareget从链表中取消，导致该事件序列的后序事件该子View都无法再收到。 到这里ViewGroup处理除了ACTION_DOWN以外事件的流程分析完毕。 4、子View如何禁止ViewGroup拦截事件前面的分析都是默认子View不禁止ViewGroup拦截事件，所以ViewGroup可以通过onInterceptTouchEvent()返回true从而拦截下子View的事件，但此时子View希望依然能够响应这些事件该怎么办呢？Android给我们提供了一个方法：requestDisallowInterceptTouchEvent(boolean) 用于设置是否允许拦截，如下： 1234567891011121314//ViewGroup.java@Overridepublic void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; //... if (disallowIntercept) &#123; mGroupFlags |= FLAG_DISALLOW_INTERCEPT; &#125; else &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; // Pass it up to our parent if (mParent != null) &#123; mParent.requestDisallowInterceptTouchEvent(disallowIntercept); &#125;&#125; 当子View调用getParent.requestDisallowInterceptTouchEvent(true)，mGroupFlags就会有FLAG_DISALLOW_INTERCEPT标识，当子View调用getParent.requestDisallowInterceptTouchEvent(false)，mGroupFlags就会清除FLAG_DISALLOW_INTERCEPT标识，那么FLAG_DISALLOW_INTERCEPT标识又是怎么控制ViewGroup的拦截的呢？如下： 12345678final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;if (!disallowIntercept) &#123;//如果子View允许ViewGroup拦截事件 //调用onInterceptTouchEvent()方法询问ViewGroup是否拦截事件，intercepted的值由onInterceptTouchEvent(ev)决定 intercepted = onInterceptTouchEvent(ev); //...&#125; else &#123;//如果子View禁止ViewGroup拦截事件 intercepted = false;//intercepted值为false&#125; 子View通过调用getParent.requestDisallowInterceptTouchEvent(true)，来禁止ViewGroup拦截除了ACTION_DOWN以外的其他事件，这样当下一个事件到来时就会交给这个子View， 为什么是除了ACTION_DOWN以外的其他事件？因为ACTION_DOWN事件是事件序列的开始，ACTION_DOWN事件会先经过ViewGroup的onInterceptTouchEvent()方法，从ACTION_DOWN事件的处理流程 - intercepted = true我们知道，如果ViewGroup一开始在onInterceptTouchEvent()的ACTION_DOWN返回true，它就不会进入dispatchTouchEvent()方法的注释3的if语句，这样在DOWN事件下就无法找到mFirstTouchTarget，这样当同一个事件序列的其他事件到来时，mFirstTouchTarget == null，这样ViewGroup只能把事件交给自己处理，无法传递给子View，也就无法调用子View的dispatchTouchEvent()方法，这样子View在dispatchTouchEvent()方法中调用getParent.requestDisallowInterceptTouchEvent(true)就没有意义了。 5、小结从ViewGroup的事件分发中得出几个结论： 1、ViewGroup如果在onInterceptTouchEvent()方法的ACTION_DOWN事件中返回true，那么整个事件序列都会交给ViewGroup处理，不再交给子View，从而导致无法调用子View的dispatchTouchEvent()方法，导致子View调用getParent.requestDisallowInterceptTouchEvent(true)失效。 2、ViewGroup如果在onInterceptTouchEvent()方法中一旦拦截除了ACTION_DOWN的事件，那么子View将会收到一个ACTION_CANCEL事件，并且接下来的事件都是交给ViewGroup处理。 3、1、2点的含义都是ViewGroup决定拦截事件，那么一旦ViewGroup决定拦截事件，那么接下来的事件都是交给ViewGroup处理，并且ViewGroup的onInterceptTouchEvent()方法在这个事件序列内不会再调用，这说明ViewGroup的onInterceptTouchEvent()方法不是每次都调用,只有ViewGroup的dispatchTouchEvent()才能保证每次调用。 3、在ViewGroup中ACTION_DOWN 事件负责寻找 target，即寻找能够消费ACTION_DOWN事件的子View，如果找到，那么接下来同一事件序列内的所有事件都会交给这个子View处理，不再交给ViewGroup；如果没有找到，有两种情况：1、ViewGroup没有子View，2、子View处理了ACTION_DOWN事件，但是在dispatchTouchEvent()返回了false，那么接下来同一事件序列下的所有事件都是ViewGroup自己处理。 4、子View如果不消费ACTION_DOWN事件，那么同一事件序列的其他事件都不会再交给它来处理，而是交给它的父ViewGroup处理；子View一旦消费ACTION_DOWN事件，如果ViewGroup不拦截，那么同一事件序列的其他事件都会交给子View处理。 5、当调用super.dispatchTouchEvent(event)就代表ViewGroup开始自己处理事件，里面会执行ViewGroup的onTouchEvent(), 逻辑和View的事件分发一样。 结语当点击事件到达ViewGroup时，它的dispatchTouchEvent()方法就会被调用，如果这个ViewGroup的onInterceptTouchEvent()方法返回true，就表示它要拦截当前事件，接下来这个事件序列内的事件都会交给它处理，即super.dispatchTouchEvent()方法得到调用；如果这个ViewGroup的onInterceptTouchEvent()方法返回false，就表示它不拦截当前事件，这时当前事件就会传递给它的子View，接着子View的dispatchTouchEvent()方法就会被调用，如果子View是一个View，那么它的处理流程就像前面介绍的View的事件分发一样，如果子View是一个ViewGroup，那么它的处理流程就又是ViewGroup的事件分发，如此递归，从上到下，直到整颗View树都收到事件，接下来递归返回，从下到上，每一层的返回值都决定是否消费本次事件，如果消费，返回true，它的上一层就无法处理这个事件，如果不消费，返回false，它的上一层又继续传给上一层，直到根视图。 View的事件分发小结和ViewGroup的事件分发小结都可以在源码中找到证明，可以自行验证一下，本文通过源码 + 流程图 说明了整个View的事件分发体制，在看的过程最好要结合上下文来看，始终记住这是在同一个事件序列内，跟着流程图的每一个分支在源码中走一遍，那样你就会有更深刻的理解。 参考资料： Android事件分发完全解析之事件从何而来 通过流程图来分析Android事件分发 十分钟了解Android触摸事件原理（InputManagerService）","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"view","slug":"view","permalink":"http://yoursite.com/tags/view/"}]},{"title":"View的工作原理","date":"2019-07-22T11:57:11.000Z","path":"2019/07/22/View的工作原理/","text":"前言在Android中View一直扮演着一个很重要的角色，它是我们开发中视觉的呈现，我平常也使用着Android提供的丰富且功能强大的控件，有时候遇到一个很炫酷的自定义View的开源库，我们也是拿来主义，时间长了你就会发现你只是一个只会使用控件和依赖被人开源库的程序员，这并不是一个开发者，所以我们并不能只满足于使用，我们要理解它背后的工作原理和流程，这样才能自己做出一个属于自己的控件，一直都说自定View是Android进阶中的一道门槛，当其实自定义View当你理解了它的原理后，你就会发现它也不过如此。本文将从源码的角度探讨View工作的三大流程，对View做进一步的认识。俗话说的好：源码才是最好的老师。 本文代码基于Android8.0，相关源码位置如下： frameworks/base/core/java/android/*.java(*代表View, ViewGroup, ViewRootImpl) frameworks/base/core/java/android/FrameLayout.javaView何时开始绘制？- requestLayout()提到View，就不得不讲起Window，在Window,WindowManager和WindowManagerService之间的关系文章中讲过，Widnow是View得载体，在ViewRootImpl的setView方法中添加Winodw到WMS之前，会先调用requestLayout绘制整颗View Hierarchy的绘制，如下： 所以我们先从requestLayout()中看起，该方法如下： 123456789101112131415161718//ViewRootImpl.javapublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; //检查是否在主线程，在子线程绘制UI会抛出异常，见下方 checkThread(); //是否measure和layout布局的开关 mLayoutRequested = true; //1、准备开始遍历View Hierarchy绘制 scheduleTraversals(); &#125;&#125;void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\"); &#125;&#125; requestLayout()中首先会检查线程的合法性，Android规定必须在主线程中操作UI，那么为什么不能在子线程中访问UI呢？这是因为Android的UI控件都不是线程安全的，如果在多线程环境下并发访问控件会导致控件处于不可预测状态。接着我们来看注释1，调用了ViewRootImpl的scheduleTraversals方法，如下： 123456789101112//ViewRootImpl.javavoid scheduleTraversals() &#123; if (!mTraversalScheduled) &#123;//防止同一帧绘制多次 mTraversalScheduled = true; //拦截同步Message，优先处理异步Message mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); //1、Choreographer回调，里面执行最终会执行mTraversalRunnable中的绘制任务 mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); //... &#125; &#125; 在Android4.1之前Android的UI流畅性很差，所以在Android4.1之后引入了Choreographer机制和Vsync机制用来解决这个问题，Choreographer管理者动画、输入和绘制的时机，Vsync叫Vertical Synchronization（垂直同步）信号，每隔 16ms Choreographer就会收到来自native层的Vsync信号，这时Choreographer就会根据事件类型进行相应的回调操作，Choreographer支持4种事件类型回调：输入(CALLBACK_INPUT)、绘制(CALLBACK_TRAVERSAL)、动画(CALLBACK_ANIMATION)、提交(CALLBACK_COMMIT)，并通过postCallback方法在对应需要同步Vsync刷新处进行注册，等待回调，关于这个细节和原理可以看Android图形系统-Choreographer和Android垂直同步和三重缓存，这里我们并不深究Choreographer机制和Vsync机制，我们看到注释1中的Choreographer的postCallback方法提交了CALLBACK_TRAVERSAL类型的回调，它对应着mTraversalRunnable绘制操作，而mTraversalRunnable是一个TraversalRunnable类型的绘制任务，最终回调会执行这个任务，mTraversalRunnable的run方法源码如下： 12345678//ViewRootImpl.javafinal class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; //1、里面会执行performTraversals() doTraversal(); &#125;&#125; doTraversal()里面会执行performTraversals方法，点开doTraversal方法看一下，如下： 1234567891011//ViewRootImpl.javavoid doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; //移除拦截同步Message屏障 mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); //1、今天的主角，performTraversals()方法 performTraversals(); //... &#125;&#125; 在doTraversal() 方法里面我们终于看到我们熟悉的方法：performTraversals()。 View树绘制的起点 - performTraversals()performTraversals()它是整个View Hierarchy绘制的起点，它里面会执行View绘制的三大工作流程，我们先看一下精简版的performTraversals方法，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243//ViewRootImpl.javaprivate void performTraversals() &#123; //mView是在View与ViewRootImpl建立关联的时候被赋值的，即调用ViewRootImpl的setView方法时，它代表着View Hierarchy的根节点，即根视图 final View host = mView; //... WindowManager.LayoutParams lp = mWindowAttributes; //desiredWindowWidth和desiredWindowHeight分别代表着屏幕的宽度和高度 int desiredWindowWidth; int desiredWindowHeight; //... if (mLayoutRequested) &#123; final Resources res = mView.getContext().getResources(); //... //1、这里调用了measureHierarchy方法，里面会调用performMeasure方法，执行View Hierarchy的measure流程，见下方 windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight); //... &#125; //... if(didLayout)&#123; //2、这里调用了performLayout方法，执行View Hierarchy的layout流程 performLayout(lp, mWidth, mHeight); //... &#125; //... if (!cancelDraw &amp;&amp; !newSurface) &#123; //... //3、这里调用了performDraw方法，执行View Hierarchy的draw流程 performDraw(); &#125; //...&#125; private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) &#123; int childWidthMeasureSpec; int childHeightMeasureSpec; //... //1.1、顶级View在调用performMeasure方法之前，会先调用getRootMeasureSpec方法来生成自身宽和高的MeasureSpec childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width); childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); //1.2、这里调用performMeasure方法，执行View Hierarchy的measure流程 performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; performTraversals方法里面非常复杂，我们看的时候千万不要深究其中的细节，不然就走火入魔了，我们找出个整体框架就行，我们先看注释1、2、3，可以看到依此调用measureHierarchy() -&gt; performLayout() -&gt; performDraw()，而measureHierarchy()里面最终调用performMeasure()，所以performTraversals()可以看作依此调用了performMeasure() -&gt; performLayout() -&gt; performDraw()，分别对应顶级View的measure、layout和draw流程，顶级View可以理解为View Hierarchy的根节点，它一般是一个ViewGroup，就像Activity的DecorView一样。 ps： 1、在performTraversals()方法中，performMeasure()可能会执行多次，而performLayout()和performDraw()最多执行一次。 2、本文讨论的顶级View你可以把它类比成Activity的DecorView，但是它其实就是View树的根结点，DecorView也是Activity中View树的根结点。 接下来我们就照着performTraversals() 中的整体框架来讲解View工作的三大流程。 View的测量流程 - performMeasure()1、MeasureSpec讲解View的measure流程前，不得不先讲解一下MeasureSpec的含义，MeasureSpec是一个32位的int值，它是View的一个内部类，它的高2位代表着SpecMode，表示测量模式，它的低30位表示SpecSize，表示测量大小，系统通过位运算把SpecMode和SpecSize合二为一组成一个32位int值的MeasureSpec。 下面看一下MeasureSpec的里面组成，如下： 123456789101112131415161718192021222324252627282930//View.javapublic static class MeasureSpec &#123; //左移位数 private static final int MODE_SHIFT = 30; //位掩码 private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; //代表着三种SpecMode public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; //makeMeasureSpec方法是把SpecMode和SpecSize通过位运算组成一个MeasureSpec并返回 public static int makeMeasureSpec(int size,int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; //getMode方法是从给定的MeasureSpec中取出SpecMode public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; //getSize方法是从给定的MeasureSpec中取出SpecSize public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125;&#125; 可以看到MeasureSpec提供了三个工具方法分别用来组合MeasureSpec、从MeasureSpec中取出SpecMode、从MeasureSpec中取出SpecSize，其中SpecMode有三种取值，如下： UNSPECIFIED：它表示父容器对子View的绘制的大小没有任何限制，要多大给多大，这种情况一般适用于系统内部，表示一种测量状态。 EXACTLY：它表示父容器已经测量出子View需要的精确大小SpecSize，这个时候View的最终大小就是SpecSize的值，它对应于LayoutParams中match_parcent和具体的数值这两种模式。 AT_MOST：它表示父容器为子View的大小指定了一个最大值SpecSize，这个时候View的大小不能大于这个值，它对应于LayoutParams中的wrap_content这种模式。 1.1 如何确定View的MeasureSpec？除了顶级View，其他View的MeasureSpec都是由父容器的MeasureSpec和自身的LayoutParams共同决定的，LayoutParams就是你平时在编写View的xml属性时那些带有layout_XX前缀开头的布局属性，对于顶级View和在View树中子View的MeasureSpec的生成规则有点不一样，见下面分析： 1.1.1、顶级View的MeasureSpec的创建 - getRootMeasureSpec()由于顶级View是View树的根结点，所以它没有父容器，所以它的MeasureSpec是由屏幕窗口的尺寸和自身的LayoutParams来共同决定，上面注释1.1我们讲到顶级View在调用performMeasure方法之前，会先调用ViewRootImpl的getRootMeasureSpec方法来生成自身宽和高的MeasureSpec，我们来看一下getRootMeasureSpec方法，如下： 12345678910111213141516//ViewRootImpl.javaprivate static int getRootMeasureSpec(int windowSize, int rootDimension) &#123; int measureSpec; switch (rootDimension) &#123; case ViewGroup.LayoutParams.MATCH_PARENT://如果是MATCH_PARENT,那么就是EXACTLY measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT://如果是WRAP_CONTENT,就是AT_MOST measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default://如果是固定的值,也是EXACTLY measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; &#125; return measureSpec;&#125; windowSize就是是传入的desiredWindowWidth或desiredWindowHeight，它表示屏幕的大小，rootDimension就是传入的屏幕窗口的LayoutParams的大小模式，对应我们平时写的layout_width或layout_height属性，该属性无非就三个值：match_parent、wrap_content和固定的数值，所以从getRootMeasureSpec方法可以看到，顶级View的MeasureSpec的创建规则如下： 其中rootSize表示顶级View大小。 1.1.2、子View的MeasureSpec的创建 - getChildMeasureSpec()在1中，顶级View的MeasureSpec已经创建好了，这时候就要根据这个MeasureSpec去生成子View的MeasureSpec，子View的MeasureSpec的创建是从ViewGroup的measureChildWithMargins方法开始，如下： 1234567891011//ViewGroup.javarotected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; //得到子View的margin final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); //1、这里调用了getChildMeasureSpec方法，里面就是创建子View的MeasureSpec，这里创建子View宽的MeasureSpec final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); //同理，这里创建子View高的MeasureSpec final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); //如果子View是一个ViewGroup，递归measure下去 child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 上述方法会对子View进行measure，由注释1得知，在调用子View的measure方法前，会先调用getChildMeasureSpec方法获得子View的MeasureSpec，从getChildMeasureSpec方法的参数可以看出，子View的MeasureSpec的创建与父容器的MeasureSpec和子View本身的LayoutParams有关，此外还和View的margin及padding有关，下面我们来看ViewGroup的getChildMeasureSpec方法，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//ViewGroup.javapublic static int getChildMeasureSpec(int spec, int padding, int childDimension) &#123; //取出父容器的测量模式specMode int specMode = MeasureSpec.getMode(spec); //取出父容器的测量大小specSize int specSize = MeasureSpec.getSize(spec); // padding是指父容器中已占用的空间大小，因此子View最大可用大小size == 父容器剩余大小 == 父容器的尺寸减去padding int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) &#123; case MeasureSpec.EXACTLY://如果父容器是EXACTLY if (childDimension &gt;= 0) &#123;//如果子View的LayoutParams是固定大小 resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123;//如果子View的LayoutParams是MATCH_PARENT //子View的MeasureSpec为父容器剩余大小 + EXACTLY resultSize = size; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123;//如果子View的LayoutParams是WRAP_CONTENT //子View的MeasureSpec为父容器剩余大小 + AT_MOST resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; case MeasureSpec.AT_MOST://如果父容器是AT_MOST if (childDimension &gt;= 0) &#123; //子View的MeasureSpec为子View大小 + EXACTLY resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; //子View的MeasureSpec为父容器剩余大小 + AT_MOST resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; //子View的MeasureSpec为父容器剩余大小 + AT_MOST resultSize = size; resultMode = MeasureSpec.AT_MOST; &#125; break; case MeasureSpec.UNSPECIFIED://如果父容器是UNSPECIFIED，这个平时开发用不到 if (childDimension &gt;= 0) &#123; resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; &#125; else if (childDimension == LayoutParams.MATCH_PARENT) &#123; resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; else if (childDimension == LayoutParams.WRAP_CONTENT) &#123; resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; &#125; break; &#125; return MeasureSpec.makeMeasureSpec(resultSize, resultMode);&#125; 可以看到getChildMeasureSpec方法里面的逻辑还是很清楚的，首先根据父容器的测量模式specMode分为三大类：EXACTLY、AT_MOST和UNSPECIFIED，每一类又和子View的LayoutParams的的三种大小模式：固定大小、MATCH_PARENT和WRAP_CONTENT组合，所以总共有3 X 3 = 9种组合，所以根据getChildMeasureSpec方法可以得出子View的MeasureSpec的创建规则如下： 其中childSize表示子View的大小，parentSize表示父容器剩余大小。 2、View和ViewGroup的measure流程分析完View的MeasureSpec的创建后，我们继续回到View的measure流程，大家都知道ViewGroup是继承自View的，所以View的measure流程，分为两种情况，一种是View的measure流程，一种是ViewGroup的measure流程，但是不管是View的measure流程还是ViewGroup的measure流程都是从ViewRootImpl的performMeasure()开始，并且都会先调用View的measure方法，如下： 123456//ViewRootImpl.java private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; //... //1、调用了View的measure方法 mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; 我们继续看View的measure方法，如下： 1234567//View.java public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; //... //1、调用了onMeasure方法 onMeasure(widthMeasureSpec, heightMeasureSpec); //... &#125; 可以看到measure方法是一个final方法，说明这个方法不能够被子类重写，这个方法把measure的具体过程交给了onMeasure方法去实现，所以View和ViewGroup的measure流程的差异就从这个onMeasure方法开始，见下面分析。 2.1、View的measure流程从上述知道View的measure起点在View的measure方法中，并且View的measure方法会调用View的onMeasure方法，View::measure() -&gt; View::onMeasure()，所以我们直接看onMeasure方法在View中的实现，如下： 12345678//View.javaprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //1、 如果View没有重写onMeasure方法，则会调用setMeasuredDimension方法设置宽高，在设置之前先调用getDefaultSize方法获取默认宽高 setMeasuredDimension( getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec) );&#125; View中的onMeasure方法的默认实现是先调用getDefaultSize方法获取默认宽高，然后再调用调用setMeasuredDimension方法设置View的宽高，当调用setMeasuredDimension方法设置View的宽高后，就可以通过getMeasureWidth()或getMeasureHeight()获得View测量的宽高，所以我们先看一下 getDefaultSize()方法是如何获取默认的宽高，该方法源码如下： 123456789101112131415161718//View.javapublic static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; //如果specMode是UNSPECIFIED，返回的大小就是传进来的size，而这个size就是通过getSuggestedMinimumWidth()或getSuggestedMinimumHeight()方法获得的 case MeasureSpec.UNSPECIFIED: result = size; break; //如果specMode是AT_MOST或EXACTLY，返回的大小就是MeasureSpec中的specSize case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result; &#125; getDefaultSize方法的逻辑很简单，除了UNSPECIFIED这种模式，其他测量模式都返回MeasureSpec中的specSize，而这个specSize就等于父容器给View测量后的大小，所以我们可以得出一个结论：直接继承View写自定义控件时需要重写onMeasure方法并设置wrap_content时自定义View自身的大小，这是因为如果自定义View在xml文件写了layout_XX = wrap_content这个属性，那么在创建它的MeasureSpec时，它的specMode就会等于AT_MOST，而从getDefaultSize方法看出，如果specMode是AT_MOST或EXACTLY，它们两个返回的值是一样的，都是MeasureSpec中的specSize，通过上面所讲的子View的MeasureSpec的创建规则可知specSize是等于parentSize即父容器剩余的大小，这样就会造成这个自定义View会填充满整个父容器，效果和match_parent一样，并不按你想象那样的大小。所以以后在自定义View时，如果有wrap_content这个场景，就要重写onMeasure方法，可以参考下面的模板，如下： 12345678910111213141516//View.javaprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int measureWidth = MeasureSpec.getSize(widthMeasureSpec); int measureHeight = MeasureSpec.getSize(heightMeasureSpec); int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec); int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec); int width, height; //经过计算，控件所占的宽和高分别对应width和height // ………… //我们只需要在View为wrap_content时设置我们经过计算得出的View的默认宽高width和height即可 //其他模式如EXACTLY，就直接设置父容器给我们测量出来的宽高即可 setMeasuredDimension( (measureWidthMode == MeasureSpec.AT_MOST) ? width : measureWidth , (measureHeightMode == MeasureSpec.AT_MOST) ? height : measureHeight );&#125; 讲完了getDefaultSize()中AT_MOST和EXACTLY模式情况，接着讲UNSPECIFIED这种模式的情况，从getDefaultSize方法中可以看出如果specMode是UNSPECIFIED，返回的大小就是传进来的size，而这个size就是通过getSuggestedMinimumWidth()或getSuggestedMinimumHeight()方法获得的，所以我们以getSuggestedMinimumWidth方法为例子，看一些如果获取在UNSPECIFIED模式下的宽，getSuggestedMinimumHeight()方法同理，getSuggestedMinimumWidth方法源码如下： 123456789101112//View.java protected int getSuggestedMinimumWidth() &#123; //根据View有无背景返回大小，getMinimumWidth()见下方 return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125;//Drawable.javapublic int getMinimumWidth() &#123; //getIntrinsicWidth()返回Drawable的宽，默认返回-1 final int intrinsicWidth = getIntrinsicWidth(); return intrinsicWidth &gt; 0 ? intrinsicWidth : 0;&#125; mBackground就等于View的背景，即android:background属性，mMinWidth就等于你在View的xml布局中写了“android:minWidth”这个属性，mBackground.getMinimumWidth()就是获取View的背景的宽度，所以我们得出结论：在UNSPECIFIED模式下，如果View没有设置背景，那么View的宽就等于android:minWidth，如果View设置了背景，那么View的宽就等于View的背景background的宽和android:minWidth的最大值，高度同理。 View的onMeasure方法执行完后，就可以通过getMeasureWidth()或getMeasureHeight()获得View测量的宽高，但是有可能会不准确，因为有时候系统会进行多次measure，才能确定最终测量宽高，所以最好是在onLayout方法中去获取View的宽高。 2.2、ViewGroup的measure流程 (以FrameLayout为例)从上述知道ViewGroup的measure起点也在View的measure方法中，而View的measure方法会调用View的onMeasure方法，ViewGroup继承自View，但是它是一个抽象类并没有重写View的onMeasure方法，而是由ViewGroup的子类如LinearLayout、FrameLayout等重写onMeasure方法以实现不同的measure流程，这里以FrameLayout为例，*View::measure() -&gt; FrameLayout::onMeasure() *，我们来看FrameLayout的onMeasure方法，如下： 12345678910111213141516171819202122//FrameLayout.javaprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //获取子View的个数 int count = getChildCount(); //... //遍历所有子View，测量每个子View的大小 for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); if (mMeasureAllChildren || child.getVisibility() != GONE) &#123;//如果子View可见 //1、调用ViewGroup的measureChildWithMargins方法，测量子View的大小 measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); //子View测量完后，FrameLayout就可以通过View的getMeasuredWidth或getMeasuredHeight获得子View的宽高，从而得出自己的宽高 //根据FrameLayout的叠加特性，它自身的测量宽高就是所有子View宽高中的最大值 maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); &#125; &#125; //...&#125; 可以看到与View的onMeasure方法不同的是，FrameLayout的onMeasure方法是遍历它所有的子View，然后逐个测量子View的大小，这个测量子View是通过注释1的measureChildWithMargins方法来完成，这个方法已经在上面子View的MeasureSpec的创建中讲过一点，measureChildWithMargins方法是在FrameLayout的父类ViewGroup中，如下： 123456protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; //省略的这部分在上面已经讲过，主要是创建子View的MeasureSpec（childWidthMeasureSpec, childHeightMeasureSpec） //... //1、调用子View的measure方法，叫子View自己测量自己 child.measure(childWidthMeasureSpec, childHeightMeasureSpec);&#125; measureChildWithMargins方法中首先会根据父容器传进来的parenXXMeasureSpec来创建子View的childXXMeasureSpec，然后调用子View的measure方法，把测量子View的任务又推给了子View，这个过程又回到了2.1所讲的View的measure流程，就不再赘述，所有子View测量完后，ViewGroup就可以得出自己的测量宽高。 3、小结measure流程是三大流程中最复杂的一个，它的整体流程是：从ViewRootImp的performTraversals()方法进入performMeasure()方法，开始整颗View树的测量流程，在performMeasure方法里面会调用View的measure方法，然后measure方法会调用onMeasure方法，如果是View就直接开始测量，设置View的宽高，如果是ViewGroup，则在onMeasure方法中则会对所有的子View进行measure过程，如果子View是一个ViewGroup，那么继续向下传递，直到所有的View都已测量完成。如图： measure过后就可以通过getMeasureWidth()或getMeasureHeight()获得View测量的宽高。 View的布局流程 - performLayout()前面讲解了View的measure过程，如果你理解了，那么View的布局过程也很容易理解的，和measure相似，View的布局过程是从ViewRootImpl的performLayout()开始的，如下： 123456789//ViewRootImpl.javaprivate void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; //... final View host = mView; //... //1、调用了顶级View的layout方法 host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); //...&#125; 在performLayout中主要调用了顶级View的layout方法，顶级View的实例有可能是View也有可能是ViewGroup，但是这个layout方法是在View中，它不像measure方法那样，它不是final修饰，所以它可以被重写，并且ViewGroup重写了layout方法，我们先看一下ViewGroup中的layout方法，如下： 1234567891011//ViewGroup.java@Overridepublic final void layout(int l, int t, int r, int b) &#123; if (...) &#123; //... //1、ViewGroup中的重写的layout方法还是调用了父类即View的layout方法 super.layout(l, t, r, b); &#125; else &#123; //... &#125;&#125; 可以看到ViewGroup重写的layout方法只是做了一些判断，然后最终还是还是调用了父类即View的layout方法，所以我们直接看View的layout方法即可。 1、View和ViewGroup的layout流程View的layout方法如下： 123456789101112131415161718192021//View.javapublic void layout(int l, int t, int r, int b) &#123; // 注意传进来的四个参数： // l 表示子View的左边缘相对于父容器的上边缘的距离 // t 表示子View的上边缘相对于父容器的上边缘的距离 // r 表示子View的右边缘相对于父容器的右边缘的距离 // b 表示子View的下边缘相对于父容器的下边缘的距离 //... int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //1、调用setFrame方法设定View的四个顶点的位置 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; //2、调用onlayout方法 onLayout(changed, l, t, r, b); //... &#125; //...&#125; layout方法传进来的l、t、r、b分别代表着View的上下左右四个点的坐标，这个四个点的坐标是相对于它的父容器来说的，这个layout方法主要干了两件事： 1、注释1：调用View的setFrame方法设定View的四个顶点的位置，我们先看View的setFrame()方法，如下： 1234567891011121314//View.javaprotected boolean setFrame(int left, int top, int right, int bottom) &#123; boolean changed = false; if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123; changed = true; //... mLeft = left; mTop = top; mRight = right; mBottom = bottom; //... &#125; return changed;&#125; 可以看到，setFrame方法主要把l、t、r、b分别赋值给mLeft、mTop、mBottom、mRight，即更新View的四个顶点的位置，这个四个顶点一旦确定，那么View在父容器中的位置也就确定了。 2、我们继续看注释2：调用了onLayout方法，这个方法在View中是一个空实现，如下： 123//View.java protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;&#125; 但是在ViewGroup中是一个抽象方法，如下： 123//ViewGroup.java@Overrideprotected abstract void onLayout(boolean changed, int l, int t, int r, int b); 这是因为onLayout方法主要用途是给父容器确定子View的位置，所以如果本身就是一个View，就无需实现这个方法，但是如果是ViewGroup，它还要布局子View，所以是ViewGroup的子类就要强制实现这个方法，不同的ViewGroup具有不同的布局方式，所以不同的ViewGroup的onLayout方法的实现就不一样，我们还是以FrameLayout为例，看一下FrameLayout的onLayout方法的实现，如下： 1234//FrameLayout.javaprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; layoutChildren(left, top, right, bottom, false /* no force left gravity */);&#125; FrameLayout的onLayout方法只调用了layoutChildren方法，该方法如下： 12345678910111213141516171819202122232425262728293031void layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) &#123; final int count = getChildCount(); //获取padding值 final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); //遍历所有子View，布局每个子View for (int i = 0; i &lt; count; i++) &#123; final View child = getChildAt(i); //如果子View可见 if (child.getVisibility() != GONE) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); //获得measue流程测量出来的子View的宽高 final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); //子View的左边缘位置 int childLeft; //子View的上边缘位置 int childTop; //下面是获取布局方向 //... //下面根据布局方向计算出childLeft和childTop //... //1、根据上面的计算，就算出了一个子View的左边缘位置childLeft和上边缘位置childTop //从而根据childLeft和childTop得出子View的右边缘位置childRight = childLeft + width，下边缘位置childButtom = childTop + height //然后调用子View的layout方法 child.layout(childLeft, childTop, childLeft + width, childTop + height); &#125; &#125; &#125; 可以发现layoutChildren里面过程和onMeasure里面的过程很像，只是注释1中调用的是子View的layout方法而不是measure方法，如果这个子View是一个View，那么layout方法里面就可以通过setFrame方法直接确定自身的位置，如果这个子View是一个ViewGroup，除了调用setFrame方法确定自身的位置外，还要重复onLayout方法中确定子View位置的过程，最后一层一层的往下，直到全部都子View的layout完成。 2、小结我们再来看一下layout的整体流程：从ViewRootImp的performTraversals()方法进入performLayout()方法，开始整颗View树的布局流程，在performLayout方法里面会调用layout方法，我们发现，View的布局过程其实也可想测量过程那样分为View的layout流程和ViewGroup的layout流程，对于View来说，执行layout方法时只需要直接确定自身四个顶点的位置即可，而onLayout方法是一个空实现；对于ViewGroup来说，执行layout方法时除了要确定自身的四个顶点的位置外，那么它在onLayout方法中还要对自己所有的子View进行layout，最后一层一层的往下，直到全部都layout完成。如下： layout过后就可以通过View的getWidth()和getHeight()来获取最终的宽高的，这个两个方法的实现如下： 12345678//View.javapublic final int getWidth() &#123; return mRight - mLeft;&#125;public final int getHeight() &#123; return mBottom - mTop;&#125; 可以发现就是通过View的四个顶点的差值来得到View的准确宽高。 View的绘制流程 - performDraw()和上面两步相似，View的绘制从ViewRootImpl的performDraw()开始的，如下： 123456789//ViewRootImpl.javaprivate void performDraw() &#123; //... final boolean fullRedrawNeeded = mFullRedrawNeeded; //... //1、调用ViewRootImpl的draw方法 draw(fullRedrawNeeded); //...&#125; performDraw()方法中并不是先调用View的draw方法，而是先调用ViewRootImpl的draw方法，如下： 12345678910111213141516171819202122//ViewRootImpl.javaprivate void draw(boolean fullRedrawNeeded) &#123; //获取surface绘制表面 Surface surface = mSurface; //... //如果surface表面需要更新 if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123; //判断是否启用硬件加速，即是否使用GPU绘制 if (mAttachInfo.mThreadedRenderer != null &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123; //... //使用GPU绘制 mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this); &#125;else &#123; //... //1、调用drawSoftware方法，使用CPU绘制 if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123; return; &#125; &#125; &#125; //...&#125; 在ViewRootImpl的draw方法中首先获取需要绘制的区域，然后判断是否使用GPU进行绘制，使用硬件加速是为提高了Android系统显示和刷新的速度，是在在API 11之后引入GPU加速的支持，关于这部分知识可自行查阅资料，不是本文重点，这里我们只关心注释1，通常情况下我们使用的是CPU绘制，也就是调用ViewRootImpl的drawSoftware方法来绘制，ViewRootImpl的drawSoftware()方法如下： 1234567891011121314151617181920212223242526272829303132//ViewRootImpl.javaprivate boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; final Canvas canvas; //... try &#123; final int left = dirty.left; final int top = dirty.top; final int right = dirty.right; final int bottom = dirty.bottom; //1、获取指定区域的Canvas对象，即画布，用于绘制 canvas = mSurface.lockCanvas(dirty); //... &#125;//省略catch try &#123; //... try &#123; //... //2、从View树的根节点开始绘制，触发整颗View树的绘制 mView.draw(canvas); &#125; finally &#123; //... &#125; &#125; finally &#123; try &#123; //3、释放Canvas锁，然后通知SurfaceFlinger更新这块区域 surface.unlockCanvasAndPost(canvas); &#125; catch (IllegalArgumentException e) &#123; //... &#125; &#125; return true;&#125; drawSoftware方法中主要做了3件事： 1、获取Surface对象并锁住Canvas绘图对象 2、从View树的根视图开始绘制整颗视图树 3、释放Surface对象并解锁Canvas，通知SurfaceFlinger更新视图 1、View和ViewGroup的draw流程第1和第3点都是操作Surface的基本流程，我们主要看第二点即注释2，调用了View的draw方法，它就是一个模板方法，定义了几个固定的绘制步骤，如下： 1234567891011121314151617181920212223242526272829303132333435//View.javapublic void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ //1、绘制背景 if (!dirtyOpaque) &#123; drawBackground(canvas); &#125; //... //2、保存Canvas图层，为fadin做准备 saveCount = canvas.getSaveCount(); //... //3、 绘制自身内容，setWillNotDraw()可以控制dirtyOpaque这个标志位 if(!dirtyOpaque) onDraw(canvas); //4、如果是ViewGroup，绘制子View dispatchDraw(canvas); //... //5、如果需要的话，绘制View的fading边缘并恢复图层 canvas.drawRect(left, top, right, top + length, p); //... //6、绘制装饰，如滚动条 onDrawForeground(canvas);&#125; 你看那英文注释，它已经替我们把draw方法中的6大步骤写出来了，其中最重要的就是注释3和4，我们分别来介绍一下： onDraw(canvas)：onDraw方法是用来绘制自身内容，如果你的自定义View或ViewGroup需要绘制内容，就要重写这个方法在Canvas上绘制自身内容。 dispatchDraw(canvas)：如果是ViewGroup，除了绘制自身内容外，还需要绘制子View的内容，所以dispatchDraw就是把View的绘制一层一层的传递下去，直到整颗View树绘制完毕，ViewGroup重写了该方法，我们看一下它的主要源码如下： 123456789101112131415161718192021//ViewGroup.java@Overrideprotected void dispatchDraw(Canvas canvas) &#123; final int childrenCount = mChildrenCount; final View[] children = mChildren; //... for (int i = 0; i &lt; childrenCount; i++) &#123; //... //如果子View可见 if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; //调用drawChild方法，见下面 more |= drawChild(canvas, child, drawingTime); &#125; &#125;&#125;//ViewGroup.java protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; //还是调用了View的draw方法 return child.draw(canvas, this, drawingTime); &#125; 可以看到，dispatchDraw方法把绘制子View的任务通过drawChild方法分发给它的子View，如果是一个ViewGroup，又会重复dispatchDraw()过程。 2、onDraw()绘制开关 - setWillNotDraw()1234//View.javapublic void setWillNotDraw(boolean willNotDraw) &#123; setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);&#125; 但是如果你不需要绘制任何内容，你可以通过View的setWillNotDraw(true)方法关闭绘制，在默认情况下，View没有启用这个优化标志位，但是ViewGroup会启用，所以当你的自定义ViewGroup需要通过onDraw来绘制内容时，需要显式的打开这个开关setWillNotDraw(false)，当你的自定义View不需要onDraw来绘制内容时，需要显式的关闭这个开关setWillNotDraw(true)。 3、小结到这里，我们走完了View的绘制过程，我们再来看一下draw的整体流程：从ViewRootImp的performTraversals()方法进入performDraw()方法，开始整颗View树的绘制流程，在performDraw()方法中经过层层调用：ViewRootImpl :: draw() -&gt; ViewRootImpl :: drawSoftware() -&gt; View :: draw()，来到View的draw()方法，它里面定义了View绘制的6大步骤，其中对于View来说，直接调用onDraw()方法绘制自身，对于ViewGroup来说，还要通过dispatchDraw()把绘制子View的流程分发下去，一层层传递，直到所有View都绘制完毕。如图： 总结我们一直讲View的工作原理，但有没有发现ViewRootImpl也出现的很频繁，它虽然不是一个View，但它是连接View和Window之间的纽带，View三大工作流程的起点就是ViewRootImpl的performTraversals()方法，performTraversals()中依此调用了performMeasure() -&gt; performLayout() -&gt; performDraw()，分别对应顶级View的measure、layout和draw流程，然后顶级View的measure流程和layout流程又会分别调用我们熟悉的onMeasure()、onLayout()方法 ，draw流程有点特别，它是通过dispatchDraw()方法来进行draw流程的传递, 而onDraw()方法只是单纯的绘制自身内容，在onMeasure()方法中会对所有child进行measure过程，同理onLayout()方法中会对所有child进行layout过程，dispatchDraw()方法中会对所有child进行draw过程，如此递归直到完成整颗View Hierarchy的遍历。 该过程如图: 在阅读Android源码时，如果你只是在追踪方法的调用链，这种过程是毫无意义的，但是如果你在这个阅读过程加入了自己的思考，把它的知识点用自己的语言整理，这样才会有所收获。以上就是我对View的工作原理的理解，希望大家有所收获。 参考资料： 《Android开发艺术探索》","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"view","slug":"view","permalink":"http://yoursite.com/tags/view/"}]},{"title":"java学习总结之面向对象","date":"2019-07-19T04:29:50.000Z","path":"2019/07/19/java面向对象/","text":"前言 上一篇文章java基础本篇文章继续Java知识点的归纳，梳理一下关于面向对象的知识点，涉及到封装、继承、多态，还有接口，类之间的关系。 接口和抽象类1、抽象类抽象类和抽象方法都用abstract关键字进行声明，抽象类不能被实例化，不能直接创建，抽象方法必须放在抽象类中，类中如果有抽象方法，这个类继续声明为抽象类，如下： 123456789101112public abstract class Hero&#123; public abstract void fight();&#125;//子类实现抽象方法，完成实际操作public class Warrior extends Hero&#123; @Override public void fight()&#123;&#125;&#125;//子类继续声明为抽象类public abstract class LongRange extends Hero&#123;&#125; 2、接口接口被认为是一种特殊的抽象类，同样不能使用new实例化，接口的字段和方法都默认为public，且不能声明为private或protected，接口只能包含常量(static final)和待实现的方法，java8以后接口中可以有方法的实现，如下： 123456interface Eat&#123; //... default public void eating()&#123; System.out.println(\"eating\"); &#125;&#125; 在接口中，也可以定义内部类，但是只能是public static修饰的内部类，所以接口中只能定义静态内部类，但是在接口中定义内部类的用处不大，很少使用。 3、接口和抽象类的比较 变量 成员方法 构造方法 使用场合 抽象类 无限制 无限制 可以有 强的“is a”关系（是一种） 接口 所有变量必须是public static final 所有方法必须是public abstract 无 弱的“is a”关系（is kind of，是一类） 在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低，而且接口可以实现多继承。 外部类和内部类把一个类放在另外一个类的内部，处于类内部的类就叫做内部类，包含内部类的类就叫做外部类，一个外部类不一定有内部类，但是一个内部类就一定有一个”依附“的外部类，内部类比外部类多使用3个修饰符：private、protected、static，外部类不能使用这3个修饰符，虽然外部类和内部类整体是一个类文件，但是编译之后，它会分别生成外部类的class文件和内部类的class文件，这说明在运行时外部类和内部类其实是两个独立的类，内部类可以分为：非静态内部类、静态内部类、局部内部类、匿名内部类。 1、非静态内部类123456789101112131415161718public class OuterClass &#123; private String outer = \"外部类私有变量\"; private void outerMethod()&#123; System.out.println(\"外部类私有方法\" ); &#125; public class InnerClass&#123; public void innerMethod()&#123; //非静态内部类调用外部类的私有方法 outerMethod(); //非静态内部类访问外部类的私有变量 System.out.println(outer); &#125; &#125;&#125; 没有使用static修饰的就是非静态内部类，它依赖于外部类实例，要创建非静态内部类实例，必须先创建外部类实例，如下： 123456public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); //通过 外部类实例 调用非静态内部类的构造器 OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.innerMethod();&#125; 总的来说，非静态内部类有以下几个特点： 1、非静态内部类属于外部类实例，必须依赖外部类实例才能够创建； 2、非静态内部类编译之后，会保留一个外部类对象的引用(在构造方法中传入)； 3、非静态内部类不能含有静态成员、静态方法和static语句块； 4、非静态内部类中可以直接访问外部类的所有成员和方法(包括private的)，但是在外部类中不能直接访问内部类的任何成员和方法，必须先创建实例后才能访问(包括private的)。 如果外部类和内部类的成员变量重名，可以通过this和外部类.this区分。 2、静态内部类12345678910111213141516171819public class OuterClass &#123; private static String outer = \"外部类私有变量\"; private static void outerMethod()&#123; System.out.println(\"外部类私有方法\" ); &#125; public static class InnerClass&#123; public void innerMethod()&#123; //静态内部类调用外部类的私有静态方法 outerMethod(); //静态内部类访问外部类的私有静态变量 System.out.println(outer); &#125; &#125;&#125; 使用static修饰的就是静态内部类，它依赖于外部类，创建静态内部类实例时，不需要先创建外部类实例，因为静态内部类依赖的是类而不是类实例，如下： 12345public static void main(String[] args) &#123; //通过 外部类 调用静态内部类的构造器 OuterClass.InnerClass innerClass = new OuterClass.InnerClass(); innerClass.innerMethod();&#125; 总的来说，静态内部类有以下几个特点： 1、静态内部类属于类，而不属于类实例； 2、静态内部类编译之后，不会含有外部类对象的引用； 3、静态内部类可以包含静态成员、静态方法和static语句块，也能包含非静态的； 4、静态内部类不能直接访问外部类的实例成员或方法，只能访问静态成员或方法(包括private的)，外部类可以直接通过类名访问静态内部类的静态成员或方法(包括private的)，如果要访问实例成员或方法，必须先创建实例后才能访问(包括private的)。 外部类和内部类之间要访问对方的private/protected成员时，编译器会自动生成合适的“access method”静态方法来提供合适的可访问性，这样就绕开了原本的成员的可访问性不足的问题。 3、局部内部类123456789101112131415161718public class OuterClass &#123; public static void main(String[] args) &#123; //局部内部类 class InnerClass&#123; private String inner = \"内部类私有变量\"; private void innerMethod()&#123; System.out.println(\"内部类私有方法\"); &#125; &#125; InnerClass innerClass = new InnerClass(); //访问局部内部类的私有变量 System.out.println(innerClass.inner); //调用局部内部类的私有方法 innerClass.innerMethod(); &#125;&#125; 把一个类在方法里定义，这个类就是局部内部类，局部内部类只能在方法里面使用，它的作用域在方法之内，由于局部内部类不能在方法之外使用，所以它不能使用static和任何访问修饰符修饰，局部内部类在开发中很少用到，因为它的作用域太小了，不能被其他方法复用。 4、匿名内部类12345678910111213141516171819public class OuterClass &#123; private void outerMethod()&#123; //创建匿名内部类 InnerClass innerClass = new InnerClass()&#123; @Override public void innerMethod() &#123; System.out.println(\"内部类私有方法\"); &#125; &#125;; //调用匿名内部类的方法 innerClass.innerMethod(); &#125; public abstract class InnerClass&#123; int num = 1; abstract void innerMethod(); &#125;&#125; 匿名内部类就是没有名字的内部类，它没有使用class关键字来定义类，而是在使用时直接创建接口或抽象父类的实现类来使用，匿名内部类一般在只使用一次的场景下使用，总的来说，匿名内部类有以下几个特点： 1、匿名内部类不能继续声明为抽象类，它必须实现接口或抽象父类的所有抽象方法； 2、匿名内部类不能定义构造器，因为它没有名字，但是它可以使用实例语句块来完成初始化； 3、匿名内部类必须实现一个接口或抽象父类，但最多只能实现一个接口或抽象父类； 4、匿名内部类编译之后，会保留一个外部类对象的引用。 在java8之前，局部内部类或匿名内部类访问方法的局部变量时，这个局部变量必须使用final修饰，在java8之后，被局部内部类或匿名内部类访问的局部变量编译器会自动加上final，无需显式声明，但是如果局部变量在内部类中被修改，那么它还是要显式声明final，总之，在局部内部类或匿名内部类中使用局部变量时，必须按照有final修饰的方式来用(一次赋值，以后不能重复赋值)。 面向对象三大特性面向对象是一种程序设计方法，它的基本思想是封装、继承、多态，根据现实世界中各种事物的本质特点，把它们抽象成类，作为系统的基本构成单元，然后这些类可以生成系统中的多个对象，而这些对象则是映射成客观世界的各种事物的实例。 1、封装封装就是尽可能地隐藏对象内部的实现细节，只保留一些对外接口使之与外部发生联系。用户无需知道对象内部的细节，但可以通过对象对外提供的接口来访问该对象。 2、继承继承是面向对象实现复用的手段，继承是一种“is a”关系，父类和子类之间必须存在“is a”关系，通过继承，子类可以获得父类的所有非 private 属性和方法，父类的私有属性在子类中不能直接访问，例如Cat 和 Animal 就是一种 “is a” 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。 2.1、父类构造和子类构造 构造方法不可继承，使用super关键字调用父类构造 默认会先调用父类构造，再调用子类构造 2.2、子类调用父类信息 使用super关键字 可以调用父类的公有属性和方法 可以调用父类的protected属性和方法 下面一张表给出java中访问权限修饰符的访问范围： 修饰符 在同一类中可访问 在同一包内可访问 在子类内可访问 在不同包可访问 public 可以 可以 可以 可以 protected 可以 可以 可以 – default 可以 可以 – – private 可以 – – – 2.3、方法重写在子类中提供一个对方法的新的实现。 方法重写发生在通过继承而相关的不同类中； 方法重写具有相同的方法签名和返回值； 子类重写方法时子类方法访问权限大于父类的； 子类重写方法时子类抛出的异常类型是父类抛出异常的子类； @Overiide称为重写标注，用来保证重写的方法和原方法的签名和返回值一致。 方法重载：方法重载是指在于同一个类中，一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。应该注意的是，返回值不同，其它都相同不算是重载。 3、多态多态是指子类对象可以直接赋值给父类变量，但是运行时依然表现出子类的行为特征，这表示同一个类型的对象在运行时可以具有多种形态，多态分为以下两种： 编译时多态：主要指方法的重载 运行时多态：指程序中定义的对象引用所指向的具体类型在运行期间才确定（运行时多态有三个条件：继承，方法重写，向上转型） 例如下面的代码中，子类Warrior继承父类Hero，它重写了父类的fight方法，并且在main函数中父类Hero引用子类Warrior（父类引用指向子类对象称为向上转型），在Hero引用调用fight方法时，会执行实际对象所在类的fight方法，即Warrior类的fight方法，而不是Hero的fight方法。 12345678910111213141516171819public class Hero&#123; public void fight()&#123; System.out.println(\"hero\"); &#125;&#125;public class Warrior extends Hero&#123; @Override public void fight()&#123; System.out.println(\"Warrior\"); &#125;&#125;public static void main(String[] args) &#123; Hero warrior = new Warrior(); warrior.fight();&#125;输出：Warrior 类图了解下面6种关系有助于看懂UML图。 1、泛化关系（Generalization）泛化关系用一条带空心箭头的直线表示，在类图中表示为类的继承关系（“is a”关系），在java中用extends关键字表示，最终代码中，泛化关系表现为继承非抽象类。例如下面ASUS继承自Laptop，ASUS是一台笔记本，ASUS与Laptop之间是泛化关系。 2、实现关系（Realization）实现关系用一条带空心箭头的虚线表示，在类图中表示实现了一个接口（在java中用implements 关键字表示），或继承抽象类，实现了抽象类中的方法。例如下面Laptop实现了IO接口，同时它继承Computer这个抽象类，Laptop是它们的具体实现。 3、聚合关系（Aggregation）聚合关系用一条带空心菱形箭头的直线表示，表示整体是由部分组成的，但是整体和部分之间并不是强依赖的，整体不存在了，部分还是会存在。例如下面表示Staff聚合到Department，或者说部门是由员工组成的，部门不存在了，员工还是会存在的。 4、组合关系 ( Composition )组合关系是用一条带实心菱形箭头的直线表示，和聚合关系不同，组合关系中整体和部分是强依赖的，即整体不存在了部分也不存在，组合关系是一种强依赖的特殊聚合关系。例如下面表示Department组合到Company中，或者说Company是由Department组成的，但是公司不存在了，部门也将不存在。 5、关联关系（Association）关联关系用一条直线表示，表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示.。例如下面学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。 关联关系默认不强调方向，表示对象之间相互知道，如果要特别强调方向，如下图，表示A知道B，但是B不知道A，这又叫DirectedAssociation。 1ps: 在最终代码中，关联对象通常以成员变量的形式存在。 6、依赖关系（Dependency）依赖关系用一条带箭头的虚线表示，与关联关系不同的是，他描述一个对象在运行期间会用到另一个对象的关系，是一种动态关系，并且随着运行时的变化， 依赖关系也可能发生变化。依赖也有方向，但是我们总是应该保持单向依赖，避免双向依赖的产生。例如下面表示A依赖于B，A的一个方法中使用到了B作为参数。 1234ps: 在最终代码中，依赖关系主要表现为：1、A 类是 B 类方法的局部变量；2、A 类是 B 类方法或构造的传入参数；3、A 类向 B 类发送消息，从而影响 B 类发生变化; 箭头的指向为调用关系。 结语本文都是关于面向对象的一些知识，虽然简单，但是也挺繁琐的，积少成多，希望大家阅读过后有所收获。 参考资料： 看懂UML类图和时序图 为什么内部类的private变量可被外部类直接访问？","tags":[{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"java学习总结之线程池","date":"2019-07-19T04:26:00.000Z","path":"2019/07/19/java线程池/","text":"前言 上一篇文章：java学习总结之线程 当我们需要频繁的创建多个线程时，每次都通过new一个Thread是一种不好的操作，创建一个线程是要消耗资源，频繁的创建会导致性能较差，而且我们还要管理多个线程的状态，管理不好还可能会出现死锁，浪费资源。这时就需要java提供的线程池，它能够有效的管理、调度线程，避免过多资源的消耗，通过线程池的统一调度、管理，使得多线程开发变得更简单。本文讲解一下有关线程池的知识点。 一、Executor框架线程池属于Executor框架的一部分，Executor框架包括任务，任务的执行、任务执行的结果三部分，其中线程池属于任务的执行那一部分，线程池的主要类和接口如下： 主要角色介绍： Executor：它是一个接口，里面只有一个方法execute(Runnable command)，用来提交任务到线程池执行； ExecutorService：它继承Executor，同样是一个接口，里面提供了更多的方法用于操作线程池，如Future&lt;?&gt; submit(Runnable task)可以提交有返回值的任务到线程池执行、shutdown和shutdownNow方法可以用来关闭线程池； ThreadPoolExecutor：它是真正的线程池的实现，它实现了上面接口的方法，还提供了一系列参数来配置线程池； ScheduleThreadPoolExecutor：它继承自ThreadPoolExecutor，实现了ScheduledExecutorService接口，也是线程池的实现，它在ThreadPoolExecutor的基础上提供了用于执行定时或延迟任务的方法，如scheduleAtFixedRate和scheduleWithFixedDelay方法，它可以用来取代java中的Timer； Executors：它是一个工厂类，通过它提供的工厂方法可以创建不同的线程池，即返回不同配置参数的ThreadPoolExecutor或ScheduleThreadPoolExecutor实例. 而线程池是用来执行任务的，在java中，任务被分为两种，一种是没有返回值的任务，它用Runnable接口表示，一种是有返回值的任务，它用Callable接口表示；而在线程池中，任务的执行结果用Future接口表示，只要实现了Furure接口的类都可以作为线程池的任务返回结果，在java中，Furure接口的一个主要实现类是FutureTask，任务和任务执行结果它们之间的关系如下： 主要角色介绍： Runnable：一个接口，代表没有返回值的任务，通过Executor的execute(Runnable)方法执行其中的run方法； Callable：一个接口，代表有返回值的任务，可以使用ExecutorService的submit(Callable)方法执行，还可以通过FutureTask包装后，使用ExecutorService的submit(Runnable)方法执行，任务完成后，返回V类型的结果，V是一个泛型； Future：一个接口，代表着异步任务的返回结果，只要实现了Furure接口的类都可以作为线程池的任务返回结果，通过get方法(阻塞)可以获取返回结果，通过cancel可以取消任务的执行； FutureTask：它实现了Runnable和Future接口，所以它里面会有run方法用来执行任务和get、cancel等方法用来操作任务，这说明FutureTask即可以被当作任务提交到线程池执行，又可以被当作线程池的任务返回结果，它的内部是通过AQS(AbstractQueuedSynchronizer)来实现同步管理，AQS是java5之后加入的一个同步框架. FutureTask它有两个构造器： FutureTask(Callable )和FutureTask(Runnable, V) ，第一个构造器可以用来包装一个Callable对象；第二个构造器可以用来包装一个Runnable对象，里面会通过Executors的callable方法把Runnable对象适配成Callable对象，并以第二个参数的V类型作为返回值类型，如果没有返回值，传入null就可以. 所以FutureTask的run方法中最终执行的是Callable的call方法，返回V类型的结果，更多细节可以查看FutureTask内部实现。 线程池使用的大概流程如下： 首先程序创建实现了Runnable或者Callable接口的任务，然后通过Executors相应方法返回或自己配置一个ThreadPoolExecutor，然后把任务通过ThreadPoolExecutor的相应方法提交，如果提交的是Callable任务，ThreadPoolExecutor还会把它包装成FutureTask任务，由于FutureTask也实现了Runnable接口，所以不管提交的是Runnable还是Callable任务，ThreadPoolExecutor最终执行的还是Runnable类型的任务； 如果你使用的是ThreadPoolExecutor的submit(XX)来提交任务，它会返回一个实现了Future接口的对象，在java中，默认返回的是FutureTask，然后程序就可以通过FutureTask.get()来等待任务执行完成，也可以通过FutureTask.cancel(boolean)来取消任务的执行； 如果你使用的是ThreadPoolExecutor的execute(XX)来提交任务，任务就会等待ThreadPoolExecutor调度执行直到完成或抛出异常，你无法操作它的执行过程。 二、线程池的配置参数ThreadPoolExecutor是线程池的真正实现，它的构造方法提供了一系列的参数来配置线程池，如下： 1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 下面对这几个参数进行说明： 1、int corePoolSize含义：线程池中的核心线程数。 线程池启动后默认是空的，只有任务到来时才会创建线程以处理请求，如果调用了ThreadPoolExecutor的prestartAllCoreThreads方法，可以在线程池启动后立即创建所有的核心线程以等待任务。 还有在默认情况下，核心线程一旦创建后就会在线程池中一直存活，即使它们处于空闲状态，如果设置ThreadPoolExecutor的allowCoreThreadTimeOut(boolean value)方法为true，那么空闲的核心线程在等待新任务到来时就会有超时策略，这个超时时间由keepAliveTime指定，当等待时间超过keepAliveTime后，核心线程就会被终止。 2、int maximumPoolSize含义：线程池所能创建的最大线程数，它与corePoolSize、workQueue共同调整线程池中实际运行的线程数量。 当线程池中的工作线程数小于corePoolSize时，每次来任务的时候都会创建一个新的工作线程。不管工作线程集合中有没有线程是处于空闲状态；当池中工作线程数大于等于 corePoolSize 的时候，每次任务来的时候都会首先尝试将线程放入队列，而不是直接去创建线程。 如果放入队列失败，说明队列满了，且当线程中线程数小于 maximumPoolSize 的时候，则会创建一个工作线程（非核心线程）来执行这个任务，如果线程池中的线程数大于maximumPoolSize，调用给定的拒绝策略；如果任务成功放入队列，就等待线程取出执行。 如图，线程池的工作流程如下: 工作线程：执行任务的线程;空闲线程：已经执行完任务，并且还在存活着的线程. 3、 long keepAliveTime含义：非核心线程空闲时的超时时长，超过这个时长，非核心线程就会被回收。 默认情况下只对非核心线程有作用，我们可以通过调用allowCoreThreadTimeout(true)来将这种策略应用给核心线程，这样核心线程也会有超时机制。 4、TimeUnit unit含义：指定keepAliveTime的单位，可选值有毫秒、秒、分等。 5、 BlockingQueue workQueue含义：线程池中的任务队列，用来保存等待执行任务的阻塞队列。 首先 BlockingQueue 是一个接口，这是一个很特殊的队列，如果 BlockQueue 是空的，从 BlockingQueue 取东西的操作将会被阻断进入等待状态，直到 BlockingQueue 进了东西才会被唤醒。同样，如果 BlockingQueue 是满的，任何试图往里存东西的操作也会被阻断进入等待状态，直到 BlockingQueue 里有空间才会被唤醒继续操作。 BlockingQueue 大致有四个实现类，如下： ArrayBlockingQueue：规定大小的基于数组结构的 BlockingQueue，即有界队列，其构造函数必须带一个 int 参数来指明其大小，其所含的对象是以 FIFO(先入先出)顺序排序的，如果队列满了调用给定的拒绝策略； LinkedBlockingQueue： 大小不定的基于链表结构的 BlockingQueue，既可以有界也可以无界，若其构造函数带一个规定大小的参数，生成的 BlockingQueue 有大小限制，若不带大小参数，所生成的 BlockingQueue 的大小由 Integer.MAX_VALUE 来决定，其所含的对象是以 FIFO(先入先出)顺序排序的；所以如果该队列是无界的，则可以忽略给定的拒绝策略，因为它永远都不会满，同时还可以忽略maximumPoolSize 参数，因为起当核心线程都在忙的时候，新的任务被放在队列上，永远不会有大于 corePoolSize 的线程被创建； PriorityBlockingQueue：优先级队列，类似于 LinkedBlockQueue，可以有界也可以无界，但其所含对象的排序不是 FIFO，而是依据对象的自然排序顺序或者是构造函数的 Comparator 决定的顺序； SynchronousQueue：特殊的 BlockingQueue，对其的操作必须是放和取交替完成的，因为其特殊的操作，所以如果有一个任务要插入队列，那么它必须要等到另一个移除任务的操作，所以使用该队列会直接把任务提交给线程池，而不会将任务加入队列，如果线程池没有任何可用的线程处理，就调用给定的拒绝策略。 BlockingQueue 的常用方法： add(object)：把 object 加到 BlockingQueue 里，如果 BlockingQueue 可以容纳，则返回 true，否则报异常； offer(object)：把 object 加到 BlockingQueue 里，如果 BlockingQueue 可以容纳，则返回 true，否则返回 false； put(object)：把 object 加到 BlockingQueue 里，如果 BlockQueue 没有空间，则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续； take()：取走 BlockingQueue 里排在首位的对象，若 BlockingQueue 为空，阻断进入等待状态直到 Blocking 有新的对象被加入为止； poll(time)：取走 BlockingQueue 里排在首位的对象，若不能立即取出，则可以等 time 参数规定的时间，取不到时返回 null。 6、ThreadFactory threadFactory含义：线程工厂，让用户可以定制创建线程的过程。 ThreadFactory 是一个接口，它只有一个Thread newThread(Runnable)方法，如果没有指定threadFactory，默认调用Executors的defaultThreadFactory方法返回一个DefaultThreadFactory，DefaultThreadFactory创建的线程都属于同一个线程组和拥有同样的优先级。 除了默认的ThreadFactory，我们可以实现ThreadFactory 接口自定义自己的ThreadFactory，这样就可以自定义线程的名字、线程组合等状态，如果newThread方法返回null，线程池将不会执行任何任务。 7、RejectedExecutionHandler handler含义：当新任务到来时，线程池被关闭或线程数maximumPoolSize和任务队列大小已经达到上限的时候，对新任务采取的拒绝策略。 RejectedExecutionHandler 同样是一个接口，里面只有一个rejectedExecution(Runnable, ThreadPoolExecutor)方法，下面介绍一下几个默认的实现，都定义在ThreadPoolExecutor中，都实现了RejectedExecutionHandler 接口： AbortPolicy：直接抛出 RejectedExecutionException 异常，线程池的默认实现； CallerRunsPolicy：这个策略将会使用 Caller 线程来执行这个新任务，可以降低任务提交的速度； DiscardPolicy：这个策略将会直接丢弃新任务； DiscardOldestPolicy：这个策略将会把任务队列头部的任务丢弃，然后重新尝试执行新任务，如果还是失败则继续实施该策略（这样的结果是最后加入的任务反而更有可能先被执行）. 和ThreadFactory 一样，我们也可以实现RejectedExecutionHandler 接口自定义自己的拒绝策略。 三、线程池的生命周期线程池的生命周期包含5种状态，如下： 1、RUNNING线程池创建后就进入RUNNING状态，这个时候可以向线程池提交任务，可以通过ThreadPoolExecutor的execute方法或submit方法，只有处于RUNNING的状态的线程池才能提交任务。 execute方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功；而submit方法用于提交需要返回值的任务，这时线程池会返回一个Future类型的对象，通过这个Future对象可以判断任务是否执行成功，并且可以通过Future的get方法来获取返回值，get方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程timeout时间后立即返回，这时候有可能任务没有执行完，当线程池的任务还没有执行完时，会报超时异常。 2、SHUTDOWN当调用ThreadPoolExecutor的shutdown方法后，便会进入SHUTDOWN状态，这时意味线程池不再接受新的任务，isShutdown方法会返回true，但此时线程池会把阻塞队列中保存的所有任务执行完毕后，再中断所有线程。 3、STOP如果调用的是ThreadPoolExecutor的shutdownNow方法，便会进入STOP状态，这时线程池也不能再接受新的任务，isShutdown方法也会返回true，它会中断线程池中的所有线程，不管你是空闲线程还是正在执行任务的线程，同时也不会处理阻塞队列中保存的任务。 shutdown方法和shutdownNow方法方法中断线程的原理都是通过调用线程的interrupt方法，所以如果你的没有正确处理中断事件，你的线程还是不会马上停止，而是等到线程执行完毕或抛出异常后才停止，如何正确中断一个线程? 可以查看我的上一篇文章java学习总结之线程。 可以看到，线程池SHUTDOWN或STOP的时候最终都会把所有线程中断，并关闭线程池，这时你的线程池就无法再次提交任何任务了，所以如果你只是想中断线程池中的一个或几个任务，可以通过使用 submit方法来提交任务，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断这个任务。 4、TIDYING处于SHUTDOWN或STOP状态的线程池的工作线程数为0时，线程池便会进入TIDYING状态，这是一个过渡状态，很快就会进入TERMINATED状态。 5、TERMINATED在TIDYING状态的线程池调用terminated方法后，就变为TERMINATED状态，这时调用isTerminated方法会返回true。 线程池的生命周期转换如下： 四、线程池的分类通过配置ThreadPoolExecutor的构造函数的参数就可以实现不同类型的线程池，但是配置一个ThreadPoolExecutor会很繁琐，需要了解那么多参数，所以我们可以使用工厂类来Executors创建线程池，Executors已经为我们配置好了四种类型的线程池，它们分别是：FixedThreadPool、CachedThreadPool、ScheduleThreadPool和SingleThreadExecutor，我们通过调用Executors的newXX方法就可以得到这些线程池的实例，下面分别介绍： 1、FixedThreadPoolThreadPoolExecutor类型，通过传入的参数大小，创建一种固定线程数量的线程池，如下： 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; 可以看到核心线程数和最大线程数相同，没有超时机制，队列为无界队列，每当新任务到来时，如果线程池中的线程数还没有到达核心线程数，就会立即创建一个工作线程来处理这个任务，如果线程数达到核心线程数，那么新任务就会被放入任务队列等待，并且这个队列能够容纳无限个任务，这样做的后果是导致最大线程数和超时机制无效，只要线程池没有被关闭，那么对于新任务的到来，只有两种处理：被核心线程执行或放入任务队列，永远不会创建一个非核心线程。 FixedThreadPool适用于资源有限，需要限制当前线程数量的场景。 2、CachedThreadPool ThreadPoolExecutor类型，与FixedThreadPool相反，它是一种线程数量不固定的线程池，如下： 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 它的核心线程数为0，最大线程数为Integer.MAX_VALUE，相当于无限大，这说明线程池中的线程足够多，每个线程的超时时间为60秒，超过60秒空闲的线程就会被回收，它的任务队列是SynchronousQueue，它是一种特殊的队列，它不会保存任务，每当有新任务插入队列，它都会把新任务立即提交给线程池处理，如果线程池没有空闲线程，它会立即创建一个线程处理，如果有空闲线程就交给空闲线程处理，所以只要线程池没有被关闭，对于每个新任务，它都来者不拒。 CachedThreadPool适用于任务执行时间短、并发量比较大的场景。 在极端情况下，任务数量非常多，任务执行时间非常长，CachedThreadPool会因为创建过多线程而导致耗尽CPU资源和内存资源。 3、SingleThreadExecutorThreadPoolExecutor，它是只有一个核心线程的线程池。如下： 123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; 它相当于大小为一的FixedThreadPool，因为只有一个线程用来执行任务，所以使得这些任务之间不需要处理线程同步的问题，任务都按顺序的排队执行。 SingleThreadExecutor适用于需要按顺序执行任务的场景。 4、ScheduleThreadPool它和前面3个线程池不一样，它是ScheduledThreadPoolExecutor类型的，ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，实现了ScheduledExecutorService接口，ScheduledExecutorService接口提供了一些用于用于执行定时任务和周期任务的方法，如scheduleAtFixedRate和scheduleWithFixedDelay方法。 我们看一下Executors的newScheduledThreadPool方法，如下： 12345678910111213 private static final long DEFAULT_KEEPALIVE_MILLIS = 10L; MILLISECONDS(TimeUnit.MILLI_SCALE),public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125; public ScheduledThreadPoolExecutor(int corePoolSize) &#123; //super就是ThreadPoolExecutor的构造函数 super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,//DEFAULT_KEEPALIVE_MILLIS为10L，单位为毫秒 new DelayedWorkQueue()); &#125; 可以看到它是一个核心线程数大小为corePoolSize，最大线程数大小为 Integer.MAX_VALUE的线程池，它的空闲线程的超时时间为10毫秒，并且使用DelayedWorkQueue作为任务队列，DelayedWorkQueue是一个延时队列，它也是实现了BlockingQueue接口的队列，并且是一个无界队列，所以最大线程数和超时机制无效，当一个新任务到来时，它会把新任务放入任务队列中，因为任务队列是一个DelayedQueue，所以任务会按照它的执行时间排序，越先执行的排在越前面，队列中的任务等时间到了，会被线程池中的线程取出执行，任务执行后，修改时间为下次执行时间，再放入队列，等待下次再次执行。 下面演示一下如何使用： 12345678910111213141516171819202122232425public class ScheduledThreadPoolDemo &#123; public void doWork()&#123; //创建定时执行的线程池 ScheduledExecutorService executor = Executors.newScheduledThreadPool(3); //参数1是执行的任务 //参数2是第一次运行任务延迟的时间 //参数3是定时任务的周期 //参数4是单位 executor.scheduleAtFixedRate(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"工作线程： \" + Thread.currentThread().getName() + \", 结果：\" + fibc(10)); &#125; &#125;, 1, 2, TimeUnit.SECONDS); &#125; private int fibc(int n)&#123; if(n == 0) return 0; if(n == 1) return 1; return fibc(n - 1) + fibc(n - 2); &#125;&#125; 上面设计了一个定时任务，计算10的斐波那契数，它会延时1秒后开始执行，然后每隔2秒重复执行一次。 使用： 123 public static void main(String[] args) throws InterruptedException &#123; new ScheduledThreadPoolDemo().doWork();&#125; 输出结果： 12345工作线程： pool-1-thread-1, 结果：55工作线程： pool-1-thread-1, 结果：55工作线程： pool-1-thread-2, 结果：55工作线程： pool-1-thread-2, 结果：55... ScheduleThreadPool适用于资源有限，需要有限个线程执行周期任务的场景. Executors中还有一个newSingleThreadScheduledExecutor方法，用于创建大小为1的ScheduleThreadPool，适用于需要单个线程执行周期任务，并且任务需要排队处理的场景。 结语本文简单的介绍了Executor框架和介绍了线程池ThreadPoolExecutor的配置参数，还介绍了Executors工厂类提供的四种类型线程池，分别是：FixedThreadPool、CachedThreadPool、ScheduleThreadPool和SingleThreadExecutor，它们都有着各自的应用场景，在开发中，如果Executors中提供的线程池无法满足我们，就需要我们自己手动去配置，所以一定要熟悉线程池的各种配置参数，不然会导致你配置出一个错误的线程池，最简单的办法就是参考Executors中的配置，我们只需要合理的修改一下参数的大小和队列类型就能为我们所用。 有关线程池的基础知识先介绍到这里了，希望大家有所收获！ 参考资料： Java线程池实现原理及其在美团业务中的实践","tags":[{"name":"线程池","slug":"线程池","permalink":"http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}]},{"title":"java学习总结之线程","date":"2019-07-19T04:25:50.000Z","path":"2019/07/19/java线程/","text":"前言在java中，线程非常重要，我们要分清楚进程和线程的区别：进程是操作系统中资源分配的基本单位，进程是指一个内存中运行的应用程序，每个进程都拥有自己的一块独立的内存空间，进程之间的资源不共享；而线程是CPU调度的最小单元，一个进程可以有多个线程，线程之间的堆空间是共享的，但栈空间是独立的，java程序的进程至少包含主线程和后台线程(垃圾回收线程)。了解这些知识后，来看下文有关线程的知识。 一、并发和并行我们先来看一下概念： 并行：指两个或多个事件在同一时刻点发生 并发：指两个或多个事件在同一时间段内发生 对于单核CPU的计算机来说，它是不能并行的处理多个任务，它的每一时刻只能有一个程序执行时间片（时间片是指CPU分配给各个程序的运行时间），故在微观上这些程序只是分时交替的运行，所以在宏观看来在一段时间内有多个程序在同时运行，看起来像是并行运行。 对于多核CPU的计算机来说，它就可以并行的处理多个任务，可以做到多个程序在同一时刻同时运行。 同理对线程也一样，但系统只有一个CPU时，线程会以某种顺序执行，我们把这种情况称为线程调度，所以从宏观角度上看线程是并行运行的，但是从微观角度来看，却是串行运行，即一个线程一个线程的运行。 一般来说，JVM的进程和线程都是与操作系统的进程和线程一 一对应的，这样做的好处是可以使操作系统来调度进程和线程，进程和线程调度是操作系统的核心模块，它的实现是非常复杂的，特别是考虑到多核的情况，因此，就完全没有必要在JVM中再提供一个进程和线程调度机制。 二、线程的创建与启动有3种方式使用线程。 方式1：继承Thread类定义一个类继承java.lang.Thread类，重写Thread类中的run方法，如下： 1234567891011public class MyThread extends Thread &#123; public void run() &#123; // ... &#125;&#125;//使用线程public static void main(String[] args) &#123; Thread thread = new MyThread(); thread.start();&#125; 方式2：实现Runnable接口2.1：定义一个类实现Runnable接口实现 Runnable只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用，如下： 123456789101112public class MyRunnable implements Runnable &#123; public void run() &#123; // ... &#125;&#125;//使用线程public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; 2.2、使用匿名内部类这种方式只适用于这个线程只使用一次的情况，如下： 12345678910public class MyRunnable implements Runnable &#123;//使用线程public static void main(String[] args) &#123; new Thread(new Runnable()&#123; public void run()&#123; // ... &#125; &#125;).start();&#125; 方式3：实现Callable接口与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装，所以在创建Thread时，要把FutureTask 传进去，如下： 1234567891011121314public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125;//使用线程public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyCallable mc = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get());&#125; 继承与实现的区别1、继承方式： （1）java中类是单继承的，如果继承了Thread，该类就不能有其他父类了，但是可以实现多个接口 （2）从操作上分析，继承方式更简单，获取线程名字也简单 2、实现方式： （1）java中类可以实现多接口，此时该类还可以继承其他类，并且还可以实现其他接口 （2）从操作上分析，实现方式稍复杂，获取线程名字也比较复杂，得通过Thread.currentThread来获取当前线程得引用 综上所述，实现接口会更好一些。 三、线程的中断与终止1、interrupt()、isInterrupted()、interrupted()的作用中断就是线程的一个标识位，它表示一个运行中的线程是否被其他线程调用了中断操作，其他线程可以通过调用线程的interrupt()方法对其进行中断操作，线程可以通过调用isInterrupted()方法判断是否被中断，线程也可以通过调用Thread的interrupted()静态方法对当前线程的中断标识位进行复位。 大家不要认为调用了线程的interrupt()方法，该线程就会停止，它只是做了一个标志位，如下： 1234567891011121314151617181920212223public class InterruptThread extends Thread&#123; @Override public void run() &#123; //一个死循环 while (true)&#123; System.out.println(\"InterruptThread正在执行\"); &#125; &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; InterruptThread interruptThread = new InterruptThread(); interruptThread.start(); interruptThread.interrupt();//调用线程的interrupt() System.out.println(\"interruptThread是否被中断，interrupt = \" + interruptThread.isInterrupted());//此时isInterrupted()方法返回true&#125;输出结果：interruptThread是否被中断，interrupt = trueInterruptThread正在执行InterruptThread正在执行InterruptThread正在执行//... 可以看到当你调用了线程的interrupt()方法后，此时调用isInterrupted()方法会返回true，但是该线程还是会继续执行下去。所以怎么样才能终止一个线程的运行呢？ 2、终止线程的运行一个线程正常执行完run方法之后会自动结束，如果在运行过程中发生异常也会提前结束；所以利用这两种情况，我们还可以通过以下三种种方式安全的终止运行中的线程： 2.1、利用中断标志位前面讲到的中断操作就可以用来取消线程任务，如下： 12345678public class InterruptThread extends Thread&#123; @Override public void run() &#123; while (!isInterrupted())&#123;//利用中断标记位 System.out.println(\"InterruptThread正在执行\"); &#125; &#125;&#125; 当不需要运行InterruptThread线程时，通过调用InterruptThread.interrupt()使得isInterrupted()返回true，就可以让线程退出循环，正常执行完毕之后自动结束。 2.2、利用一个boolean变量利用一个boolean变量和上述方法同理，如下： 123456789101112131415public class InterruptThread extends Thread&#123; private volatile boolean isCancel; @Override public void run() &#123; while (!isCancel)&#123;//利用boolean变量 System.out.println(\"InterruptThread正在执行\"); &#125; &#125; public void cancel()&#123; isCancel = true; &#125;&#125; 当不需要运行InterruptThread线程时，通过调用InterruptThread.cancel()使isCancel等于true，就可以让线程退出循环，正常执行完毕之后自动结束，这里要注意boolean变量要用volatile修饰保证内存的可见性。 2.3、响应InterruptedException通过调用一个线程的 interrupt() 来中断该线程时，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程，例如当你调用Thread.sleep()方法时，通常会让你捕获一个InterruptedException异常，如下: 12345678910111213public class InterruptThread extends Thread&#123; @Override public void run() &#123; try&#123; while (true)&#123; Thread.sleep(100);//Thread.sleep会抛出InterruptedException System.out.println(\"InterruptThread正在执行\"); &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 当不需要运行InterruptThread线程时，通过调用InterruptThread.interrupt()使得 Thread.sleep() 抛出InterruptedException，就可以让线程退出循环，提前结束。在抛出InterruptedException异常之前，JVM会把中断标识位复位，此时调用线程的isInterrupted()方法将会返回false。 四、线程的生命周期1、线程的6种状态线程也是有生命周期，也就是存在不同的状态，状态之间相互转换，线程可以处于以下的状态之一： 1.1、NEW(新建状态)使用new创建一个线程对象，但还没有调用线程的start方法，Thread t = new Thread()，此时属于新建状态。 1.2、RUNNABLE(可运行状态)但在新建状态下线程调用了start方法，t.start()，此时进入了可运行状态。可运行状态又分为两种状态： ready(就绪状态)：线程对象调用stat方法后，等待JVM的调度，此时线程并没有运行。 running(运行状态)：线程对象获得JVM调度，此时线程开始运行，如果存在多个CPU，那么允许多个线程并行运行。 线程的start方法只能调用一次，否则报错（IllegalThreadStateException）。 1.3、BLOCKED(阻塞状态)正在运行的线程因为某些原因放弃CPU，暂时停止运行，就会进入阻塞状态，此时JVM不会给该线程分配CPU，直到线程重新进入就绪状态，才有机会转到运行状态，阻塞状态只能先进入就绪状态，不能跳过就绪状态直接进入运行状态。线程进入阻塞状态常见的情况有： 1、当A线程处于运行状态时，试图获取同步锁，却被B线程获取，此时JVM把当前A线程放到对象的锁池(同步队列)中，A线程进入阻塞状态，等待获取对象的同步锁。 2、当线程处于运行状态时，发出了IO请求，此时进入阻塞状态。 1ps: 如果是使用Synchronize关键字，那么尝试获取锁的线程会进入BLOCKED状态；如果是使用java.util.concurrent 类库中的Lock，那么尝试获取锁的线程则会进入WAITING或TIMED WAITING状态，因为java.util.concurrent 类库中的Lock是使用LockSupport来进行同步的。 1.4、WAITING(等待状态)正在运行的线程调用了无参数的wait方法，此时JVM把该线程放入对象的等待池（等待队列）中，此时线程进入等待状态，等待状态的线程只能被其他线程唤醒，否则不会被分配 CPU 时间片。下面是让线程进入等待状态的方法： 进入方法 退出方法 无Timeout参数的Object.wait() Object.notify() / Object.notifyAll() 无Timeout参数的Thread.join() 方法 被调用的线程执行完毕 LockSupport.park() 方法 LockSupport.unpark(Thread) 1.5、TIMED WAITING(计时等待状态)正在运行的线程调用了有参数的wait方法，此时JVM把该线程放入对象的等待池中，此时线程进入计时等待状态，计时等待状态的线程被其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。下面是让线程进入等待状态的方法： 进入方法 退出方法 调用Thread.sleep(int timeout) 方法 时间结束 有Timeout 参数的 Object.wait() 方法 时间结束 / Object.notify() / Object.notifyAll() 有Timeout 参数的 Thread.join() 方法 时间结束 / 被调用的线程执行完毕 LockSupport.parkNanos() 方法 LockSupport.unpark(Thread) LockSupport.parkUntil() 方法 LockSupport.unpark(Thread) 1ps：阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。 1. 6、TREMINATED(终止状态)又称死亡状态，表示线程的终止。线程进入终止状态的情况有： 1、正常执行完run方法，线程正常退出。 2、遇到异常而退出 线程一旦终止了，就不能再次启动，否则报错（IllegalThreadStateException） 2、线程的状态转换图 六、线程之间的通信如果一个线程从头到尾的执行完一个任务，不需要和其他线程打交道的话，那么就不会存在安全性问题了，由于java内存模式的存在，如下： 每一个java线程都有自己的工作内存，线程之间要想协作完成一个任务，就必须通过主内存来通信，所以这里就涉及到对共享资源的竞争，在主内存中的东西都是线程之间共享，所以这里就必须通过一些手段来让线程之间完成正常通信。主要有以下两种方法： 1、wait() / notify() notifyAll() 机制它们都是Object类中的方法，它们的主要作用如下： wait()：执行该方法的线程对象释放同步锁（这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁），然后JVM把该线程存放在等待池中，等待其他线程唤醒该线程 notify()：执行该方法的线程唤醒在等待池中等待的任意一个线程，把线程转到锁池中等待 notifyAll()：执行该方法的线程唤醒在等待池中等待的所有线程，把线程转到锁池中等待 注意：上述方法只能在同步方法或者同步代码中使用，否则会报IllegalMonitorStateException异常，还有上述方法只能被同步监听锁对象来调用，不能使用其他对象调用，否则会报IllegalMonitorStateException异常。 假设A线程和B线程共同操作一个X对象，A、B线程可以通过X对象的wait方法和notify方法进行通信，流程如下： 1、当A线程执行X对象的同步方法时，A线程持有X对象的锁，则B线程没有执行同步方法的机会，B线程在X对象的锁池中等待。 2、A线程在同步方法中执行X.wait()时，A线程释放X对象的锁，进入X对象的等待池中。 3、在X对象的锁池中等待获取锁的B线程在这时获取X对象的锁，执行X对象的另一个同步方法。 4、B线程在同步方法中执行X.notify()或notifyAll()时，JVM把A线程从X对象的等待池中移到X对象的锁池中，等待获取锁。 5、B线程执行完同步方法，释放锁，A线程获取锁，从上次停下来的地方继续执行同步方法。 下面以一个ATM机存钱取钱的例子说明，ATM机要在银行把钱存进去后，其他人才能取钱，如果没钱取，只能先回家等待，等银行通知你有钱取了，再来取，如果有钱取，就直接取钱。 ATM机，存钱和取钱方法都是同步方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class ATM &#123; private int money; private boolean isEmpty = true;//标志ATM是否有钱的状态 /** * 往ATM机中存钱 */ public synchronized void push(int money)&#123; try&#123; //ATM中有钱，等待被人把钱取走 while (!isEmpty)&#123; this.wait(); &#125; //ATM中没钱了，开始存钱 System.out.println(Thread.currentThread().getName() + \":\" + \"发现ATM机没钱了，存钱中...\"); Thread.sleep(2000); this.money = money; System.out.println(Thread.currentThread().getName() + \":\" + \"存钱完毕，存了\" + money + \"元\"); //存钱完毕，把标志置为false isEmpty = false; //ATM中有钱了，通知别人取钱 this.notify(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; /** * 从ATM机中取钱 */ public synchronized void pop()&#123; try &#123; //ATM中没钱取，等待通知 while (isEmpty)&#123; System.out.println(Thread.currentThread().getName() + \":\" + \"ATM机没钱，等待中...\"); this.wait(); &#125; //ATM中有钱了，开始取钱 System.out.println(Thread.currentThread().getName() + \":\" + \"收到通知，取钱中...\"); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + \":\"+ \"取出完毕，取出了\" + this.money + \"钱\"); //取钱完毕，把标志置为true isEmpty = true; //ATM没钱了，通知银行存钱 this.notify(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 银行， 需要传入同一个ATM示例： 12345678910111213141516public class Blank implements Runnable &#123; private ATM mAtm;//共享资源 public Blank(ATM atm)&#123; this.mAtm = atm; &#125; @Override public void run() &#123; //银行来存钱 for(int i = 0; i &lt; 2; i++)&#123; mAtm.push(100); &#125; &#125;&#125; 小明， 需要传入同一个ATM示例： 1234567891011121314public class Person implements Runnable&#123; private ATM mAtm;//共享资源 public Person(ATM atm)&#123; this.mAtm = atm; &#125; @Override public void run() &#123; //这个人来取钱 mAtm.pop(); &#125;&#125; 客户端操作，我特地让小明提前来取钱，此时ATM机中是没钱的，小明要等待： 12345678910111213141516public static void main(String[] args)&#123; //创建一个ATM机 ATM atm = new ATM(); //小明来取钱 Thread tPerson = new Thread(new Person(atm), \"XiaoMing\"); tPerson.start(); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //银行来存钱 Thread tBlank = new Thread(new Blank(atm), \"Blank\"); tBlank.start(); &#125; 输出结果： 1234567XiaoMing:ATM机没钱，等待中...Blank:发现ATM机没钱了，存钱中...Blank:存钱完毕，存了100元XiaoMing:收到通知，取钱中...XiaoMing:取出完毕，取出了100钱Blank:发现ATM机没钱了，存钱中...Blank:存钱完毕，存了100元 可以看到，小明总是在收到ATM的通知后才来取钱，如果通过这个存钱取钱的例子还不了解wait/notify机制的话，可以看看这个修厕所的例子。 1ps: wait() 和 sleep() 的区别是什么，首先wait()是Object的方法，而sleep()是Thread的静态方法，其次调用wait()会释放同步锁，而sleep()不会，最后一点不同的是调用&#96;wait&#96;方法需要先获得锁，而调用&#96;sleep&#96;方法是不需要的。 2、await() / signal() signalAll()机制从java5开始，可以使用Lock机制取代synchronized代码块和synchronized方法，使用java.util.concurrent 类库中提供的Condition 接口的await / signal() signalAll()方法取代Object的wait() / notify() notifyAll() 方法。 下面使用Lock机制和Condition 提供的方法改写上面的那个例子，如下： ATM2： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class ATM2 &#123; private int money; private boolean isEmpty = true;//标志ATM是否有钱的状态 private Lock mLock = new ReentrantLock();//新建一个lock private Condition mCondition = mLock.newCondition();//通过lock的newCondition方法获得一个Condition对象 /** * 往ATM机中存钱 */ public void push(int money)&#123; mLock.lock();//获取锁 try&#123; //ATM中有钱，等待被人把钱取走 while (!isEmpty)&#123; mCondition.await(); &#125; //ATM中没钱了，开始存钱 System.out.println(Thread.currentThread().getName() + \":\" + \"发现ATM机没钱了，存钱中...\"); Thread.sleep(2000); this.money = money; System.out.println(Thread.currentThread().getName() + \":\" + \"存钱完毕，存了\" + money + \"元\"); //存钱完毕，把标志置为false isEmpty = false; //ATM中有钱了，通知别人取钱 mCondition.signal(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125;finally &#123; mLock.unlock();//释放锁 &#125; &#125; /** * 从ATM机中取钱 */ public void pop()&#123; mLock.lock();//获取锁 try &#123; //ATM中没钱取，等待通知 while (isEmpty)&#123; System.out.println(Thread.currentThread().getName() + \":\" + \"ATM机没钱，等待中...\"); mCondition.await(); &#125; //ATM中有钱了，开始取钱 System.out.println(Thread.currentThread().getName() + \":\" + \"收到通知，取钱中...\"); Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + \":\"+ \"取出完毕，取出了\" + this.money + \"钱\"); //取钱完毕，把标志置为true isEmpty = true; //ATM没钱了，通知银行存钱 mCondition.signal(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; mLock.unlock();//释放锁 &#125; &#125;&#125; 可以看到ATM2改写ATM后，把方法的synchronized去掉，因为Lock机制没有同步锁的概念，然后获取lock锁，在finally里释放lock锁，还把原本Object.wait()用Condition.await()代替，原本Object.notify()用Condition.signal()代替。 客户端操作只是把ATM换成ATM2，输出结果和上面的一样，就不在累述。 3、死锁多线程通信的时候很容易造成死锁，死锁一旦发生，只能通过外力解决。 死锁是什么？ 当A线程等待获取由B线程持有的锁，而B线程正在等待获取由A线程持有的锁，发生死锁现象，JVM既不检测也不会避免这种情况，所以程序员必须保证不导致死锁。 官方定义：如果一组进程中的每一个进程都在等待仅由该进程组中的其他进程才能引发的事件，那么该组进程就是死锁。 产生死锁的原因？ 多个线程对不可抢占性资源或可消耗性资源的进行争夺时，可能会产生死锁。 产生死锁的必要条件？ 同时满足以下4个条件，就会产生死锁： 1、 互斥条件：线程对分配到的资源进行排他性使用； 2、 请求和保持条件：线程已经保持了至少一个资源，又提出了新的资源请求; 3、 不可抢占条件: 线程已获得的资源在未使用完之前不能被抢占； 4、 循环等待条件：发生死锁时，一定存在一个线程-资源的循环链。 如何预防死锁？ 在程序运行之前，可以通过以下3点来预防死锁： 1、破坏必要条件中的一个或几个就行； 2、当多个线程都要访问共享资源A、B、C时，保证每一个线程都按照相同的顺序去访问去访问他们，比如先访问A，接着访问B，最后访问C； 3、不要使用Thread类中过时的方法，因为容易导致死锁，所以被废弃，例如A线程获得对象锁，正在执行一个同步方法，如果B线程调用A线程的suspend()，此时A线程暂停运行，放弃CPU，但是不会放弃锁，所以B就永远不会得到A持有的锁。 在操作系统中，还可以在程序运行时，通过银行家算法来避免死锁。 解决死锁的办法？ 1、从一个或多个线程中，抢占足够数量的资源分配给死锁线程，解决死锁状态； 2、终止或撤销系统中一个或多个线程，直到打破死锁状态。 上面对死锁讨论的所有情况，同样适用于进程，线程就是””轻量级进程””。 4、 Thread类中过时的方法由于线程安全问题，被弃用，如下： void suspend()：暂停当前线程。 void resume()：恢复当前线程。 void stop()：结束当前线程 suspend()方法在调用之后不会释放已经占有的资源(锁)，然后进入睡眠状态，这样很容易导致死锁； stop()方法直接终止线程，不会保证线程资源的正常释放，导致程序处于不确定状态。对于suspend()和 resume()可以用上面提到的等待/通知机制代替，而 stop()方法可以用上面提到的终止线程运行的3种方式代替。 七、线程的控制操作下面来看一些可以控制线程的操作。 1、线程休眠让执行的线程暂停等待一段时间，进入计时等待状态，使用如下： 123public static void main(String[] args)&#123; Thread.sleep(1000);&#125; 调用sleep()后，当前线程放弃CPU，在指定的时间段内，sleep所在的线程不会获得执行的机会，在此状态下该线程不会释放同步锁。 2、联合线程在线程中调用另一个线程的 join() 方法，会将当前线程置于阻塞状态，等待另一个线程完成后才继续执行，原理就是等待/通知机制，使用如下： 12345678910111213141516171819202122232425public class JoinThread extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"JoinThread执行完毕！\"); &#125;&#125; public static void main(String[] args) throws InterruptedException &#123; JoinThread joinThread = new JoinThread(); joinThread.start(); System.out.println(\"主线程等待...\"); joinThread.join();//主线程等join线程执行完毕后才继续执行 System.out.println(\"主线程执行完毕\"); &#125;输出结果：主线程等待...JoinThread执行完毕！主线程执行完毕 对于以上代码，主线程会等join线程执行完毕后才继续执行，因此最后的结果能保证join线程的输出先于主线程的输出。 3、后台线程顾名思义，在后台运行的线程，其目的是为其他线程提供服务，也称“守护线程”，JVM的垃圾回收线程就是典型的后台线程，通过t.setDaemon(true)把一个线程设置为后台线程，如下： 1234567891011121314151617public class DeamonThread extends Thread &#123; @Override public void run() &#123; System.out.println(getName()); &#125;&#125; public static void main(String[] args) throws InterruptedException &#123; //主线程不是后台线程，是前台线程 DeamonThread deamonThread = new DeamonThread(); deamonThread.setDaemon(true);//设置子线程为后台线程 deamonThread.start(); //通过deamonThread.isDaemon()判断是否是后台线程 System.out.println(deamonThread.isDaemon()); &#125;输出结果：true 后台线程有以下几个特点： 1、若所有的前台线程死亡，后台线程自动死亡，若前台线程没有结束，后台线程是不会结束的。 2、前台线程创建的线程默认是前台线程，可以通过setDaemon(true)设置为后台线程，在后台线程创建的新线程，新线程是后台线程。 注意：t.setDaemon(true)方法必须在start方法前调用，否则会报IllegalMonitorStateException异常 4、线程优先级当线程的时间片用完时就会发生线程调度，而线程优先级就是决定线程需要多或少分配一些CPU时间片的线程属性，在java中，通过一个成员变量priority来控制优先级，在线程构建时可以通过setPriority(int)方法来修改线程的优先级，如下： 123456789101112public class PriorityThread extends Thread&#123; @Override public void run() &#123; super.run(); &#125; &#125;public static void main(String[] args) throws InterruptedException &#123; PriorityThread priorityThread = new PriorityThread(); priorityThread.setPriority(Thread.MAX_PRIORITY);//10 priorityThread.start();&#125; 优先级范围从1到10，默认是5，优先级高的线程分配的时间片数量要多于优先级低的线程。 1ps: 在不同的JVM以及操作系统上，线程优先级规划会有差异，有些操作系统会忽略对线程优先级的设定，所以线程优先级不能作为程序正确性的依赖保证，因为操作系统可以完全不用理会线程优先级的设定 5、线程礼让对静态方法 Thread.yield() 的调用，声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。如下： 1234567public class YieldThread extends Thread &#123; @Override public void run() &#123; System.out.println(\"已经完成重要部分，可以让其他线程获取CPU时间片\"); Thread.yield(); &#125;&#125; 该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。也就是说，就算你执行了这个方法，该线程还是有可能继续运行下去。 6、线程组java.lang.ThreadGroup类表示线程组，可以对一组线程进行集中管理，当用户在创建线程对象时，可以通过构造器指定其所属的线程组：Thread(ThreadGroup group, String name)。 如果A线程创建B线程，如果没有设置B线程的分组，那么B线程加入到A线程的线程组，一旦线程加入某个线程组，该线程就一直存在于该线程组中直到线程死亡，不能在中途修改线程的分组。 当java程序运行时，JVM会创建名为main的线程组，在默认情况下，所以的线程都属于该线程组。 结语本文到这里就结束了，在平时开发中我们一般都只会使用线程，但却很少去了解线程的生命周期、通信机制等，但我们不要忽略掉这些知识点，它们都是面试常客，也是非常的重要，在java中，一般不推荐你直接new一个线程使用，如果你需要创建的线程数量非常多的话，这时就需要使用线程池来帮助你管理线程的创建，在线程的内部中，还有一个用于存储数据的Map集合，java提供了一个ThreadLocal类来操作这些集合，ThreadLocal在多线程环境下可以很好的保证了这些数据只能为本线程使用，从而避免了并发问题。 以上就是我对线程的总结，希望对大家有所帮助。","tags":[{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"java学习总结之基础","date":"2019-07-19T04:24:58.000Z","path":"2019/07/19/java基础/","text":"前言万事开头难，准备从零把java相关知识点捡起来，把自己所学的Java知识点归纳，下面是关于java的一些基本知识点。 java代码的运行过程 创建java源程序，扩展名为.java 使用javac命令编译源程序为字节码文件，扩展名为.class 使用java命令运行字节码文件，在不同平台执行 数据类型下面用一张表概括： 数据类型 类型说明符 位数 字节 整形 int 32 4 短整型 short 16 2 长整形 long 64 8 字节型 byte 8 1 单精度浮点型 float 32 4 双精度浮点型 double 64 8 字符类型 char 16 2 布尔类型 boolean - - 字符串类型 String - - 自定义类型 public class … - - 其中java的数据类型又分为： * 基本类型/原始类型（primitive type）：用来保存简单的单个数据，如：int、short、long、byte、float、double、boolean、char共8种。 类类型/引用类型（class type or reference types）：用来保存复杂的组合数据，如String和自定义类型。 在java中，char类型实际是一个16位的无符号整数（&lt;=65535），可以保存中文和转义字符(\\b,\\t,\\n等)。 而在java中并没有明确的表示boolean类型应该占多少位，其大小与JVM实现相关，JVM的建议如下： 1、boolean 类型应该被编译成 int 类型来使用，占 4 个字节； 2、boolean 数组应该被编译成 byte 数组类型，每个 boolean 数组成员占 1 个 字节. 可以肯定的是，boolean 类型不会只占 1 个位，boolean 类型的大小与JVM实现相关。 成员变量和局部变量1234567891011public class 类名&#123; 数据类型 变量1；//成员变量 返回值类型 方法名()&#123; 数据类型 变量2；//局部变量 &#125; &#125; 1、成员变量的作用域在整个类都是可见的。2、局部变量的作用域仅在定义它们的方法中可见。3、成员变量有默认的初始值（数字为0，对象为null）。4、局部变量没有默认的初始值，需要赋初值再使用。5、成员变量和局部变量重名时，局部变量的优先级更高。 字符串1、String类型在java中String是引用类型，它的构造器如下： 除了用以上new的方法创建一个字符串，还可以用以下方式： 12String name1 = \"rain\";String name2 = \"rain\"; 那么用new和用=有什么不同的呢? new出来字符串是一个String对象，它被放在堆中，地址不一样。用=赋值的字符串是从字符串池（String Pool，保存着所有字符串字面量，这些字面量在编译时期就确定）中拿的，如果这个字符串在池中没有，就会先放进池，所以上面两个name1和name2是同一个字符串。 String中常用的方法： String的比较： 获取String的字串的方法： 在 Java 8 中，String 内部使用 char 数组存储数据，在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，这些数组在都用final修饰，所以才保证String是不可变的，不可变就是每次意图修改String，都会产生一个新的String对象。 1、在字符串的比较中==是用来比较地址的，String的equals方法才是用来比较两个字符串是否相等 ；2、在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代，而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。 2、StringBuffer和StringBuilder与String类不同的是，StringBuffer和StringBuilder是可变的，它们的对象可以被多次修改，因为它里面的数组并没有使用final修饰，所以每次意图修改StringBuffer或StringBuilder对象时，都会在原始对象上进行修改，不会产生新的对象，StringBuilder是在JDK5中被提出来的，它和StringBuffer之间最大的不同是StringBuilder的方法都不是线程安全的，而StringBuffer的方法都是线程安全的。 StringBuffer的构造方法（StringBuilder类似）： StringBuffer的常用方法： 3、字符串的拼接在java中，可以通过+、String的concat方法、StringBuilder的append方法和StringBuffer的append方法来拼接字符串，如下： 使用+拼接： 12345public static void main(String[] args) &#123; String str1 = \"Hello\"; String str2 = \"World!\"; String str = str1 + \" \" + str2;&#125; 反编译后，如下： 12345public static void main(String[] args) &#123; String str1 = \"Hello\"; String str2 = \"World!\"; String str = (new StringBuilder()).append(str1).append(\" \").append(str2).toString();&#125; 可以看到使用+拼接字符串时，底层会new一个StringBuilder对象，调用StringBuilder的append方法来拼接。 使用String的concat方法拼接： 12345public static void main(String[] args) &#123; String str1 = \"Hello\"; String str2 = \"World!\"; String str = str1.concat(\" \").concat(str2);&#125; 查看String的concat方法的源码，如下： 12345678910111213141516public String concat(String str) &#123; int olen = str.length(); if (olen == 0) &#123; return this; &#125; //... int len = length(); //创建一个新的长度的字节数组，新长度 = 原始字符串长度len + 要拼接字符串长度olen byte[] buf = StringUTF16.newBytesFor(len + olen); //把原始字符串的字节数组复制到buf中 getBytes(buf, 0, UTF16); //把要拼接的字符串的字节数组复制到buf中 str.getBytes(buf, len, UTF16); //通过buf创建一个String返回 return new String(buf, UTF16);&#125; 可以看到concat方法底层是新创建一个字节数组，长度为原始字符串长度和要拼接字符串长度之和，然后把原始字符串和要拼接字符串的字节数组复制到新的字节数组中，最后通过新的字节数组创建一个新的String对象返回，所以String的concat方法最终会返回一个新的String对象，这也说明了String的不可变性，不会修改原始字符串的字节数组到达拼接字符串的目的。 使用StringBuilder和StringBuffer的append方法拼接： 1234567//以StringBuilder举例，StringBuffer类似public static void main(String[] args) &#123; String str1 = \"Hello\"; String str2 = \"World!\"; StringBuilder str = new StringBuilder(); str.append(str1).append(\" \").append(str2).toString();&#125; 查看StringBuilder的append方法的源码，如下： 123456789101112131415161718public StringBuilder append(String str) &#123; super.append(str); return this;&#125;//StringBuilder的父类AbstractStringBuilder中的append方法public AbstractStringBuilder append(String str) &#123; if (str == null) &#123; return appendNull(); &#125; int len = str.length(); //扩容内部的字节数组，扩容后长度 = 原始字符串长度count + 要拼接的字符串长度len ensureCapacityInternal(count + len); //把要拼接的字符串追加到内部的字节数组 putStringAt(count, str); count += len; return this;&#125; 可以看到，StringBuilder的append方法会直接拷贝待拼接的字符串字节数组到内部的字节数组中，如果内部的字节数组长度不够，就会先扩容后再拷贝，所以append方法并不会产生新的StringBuilder对象，对于StringBuffer的append方法，它和StringBuilder的append方法的逻辑一样，只是多了一个synchronized关键字。 效率比较： 分别使用+、concat方法、StringBuffer和StringBuilder的append方法来拼接字符串，各自的效率怎么样？在单线程环境下的一个for循环中拼接大量字符串，经过测试，它们的效率高低如下： StringBuilder &gt; StringBuffer &gt; concat &gt; + +效率最低，这是因为每次拼接字符串时，都会new一个StringBuilder对象来拼接，频繁的新建对象是很耗时的，而StringBuffer每次append都需要进行同步，所以它的效率比StringBuilder低。 阿里巴巴Java开发手册建议：在循环体内，使用 StringBuilder 的 append 方法进行字符串的拼接，而不要使用+，因为+会频繁的创建新的StringBuilder对象导致耗费更多的时间和造成内存资源的浪费。 包装类包装类就是将java的基本数据类型打包成对象处理，包装类都在java.lang包中，下面用一个表显示： 基本数据类型 包装类 int Interger short Short long Long char Character byte Byte float Float double Double boolean Boolean 它涉及到以下两种操作： ### 1、装箱(boxing) 以double装箱为例： 1234double num = 3.14；Double dnum1 = new Double(num);//1Double dnum2 = Double.valueOf(num);//2Double dnum3 = num;//3 注释1、2都是手动装箱，注释3是自动装箱。 ### 2、拆箱(unboxing) 同样上述double拆箱为例： 12num = dnum1;//1num = dnum2.doubleValue();//2 注释1是自动拆箱，注释2是手动拆箱。 除了Double和Float，每个包装类都会有一个默认大小的缓存池，例如Integer，缓存池默认大小是-128-127，缓存池中都是缓存了一些经常使用的值，而对于Double和Float，都是浮点型，它们没有经常使用的值，编译器会在自动装箱过程中会调用 valueOf() 方法，因此多个值相同，且值在缓存池范围内的包装类实例使用自动装箱来创建，那么就会引用相同的对象。 ps:1、包装类没有无参构造，所有包装类的实例都是不可变的，一旦创建对象后，它们的内部值就不能再改变。2、每个基本类型包装类都有常量MAX_VALUE和MIN_VALUE。 关键字1、final防止扩展和重写。 修饰成员变量：常量（可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量），不可更改（对于基本数据类型，final使数值不能改变，对于引用类型，final使引用不能改变，即不能引用其他对象，但引用本身可以更改） 修饰方法：不可被重写 修饰类：不可被继承 2、static可以通过类名直接访问它修饰的属性，静态属性和方法都是优先于类的实例存在。 修饰变量：称为静态变量（区别于实例变量）、类变量，类的所有实例都共享静态变量，静态变量在内存中只存在一份 修饰方法：称为静态方法，静态方法必须有实现，它不依赖于任何实例，静态方法中只能调用类的静态属性和静态方法，方法中不能有 this 和 super 关键字 修饰语句块：称为静态语句块，在类初始化时运行一次 修饰内部类：称为静态内部类，非静态内部类依赖于外部类的实例，而静态内部类不需要 存在继承的情况下，初始化顺序为： 父类(静态变量、静态语句块) -&gt; 子类（静态变量、静态语句块） -&gt; 父类（实例变量、普通语句块）-&gt; 父类（构造函数）-&gt; 子类（实例变量、普通语句块） -&gt; 子类（构造函数） 关于==、equal()和hashCode()1、====是一个关系操作符，所以： 如果左右两边的操作数是基本数据类型，那么X==Y，就是判断左右两边的操作数的值是否相等. 如果左右两边的操作数是引用数据类型，那么X==Y，就是判断左右两边的操作数的内存地址是否相等. 2、equal()equal()是用来判断两个对象是否等价，即两个对象是否相等，所以如果要重写一个equal方法，需要做到以下3步： 先使用==判断两个对象的引用是否相等.（地址相同） 然后使用*instanceof *判断两个对象是否是同一个类型.（类型相同） 最后比较两个对象的内容是否一致.(内容相同) 按照上面3步重写的equal方法，满足自反性、对称性、传递性，如下： 自反性：对于非null的x，x.equal(x)返回true； 对称性：对于非null的x，y，x.equal(y)返回true当且仅当y.equal(x)返回true； 传递性：对于非null的x，y，z，如果x.equal(y)返回true，并且y.equal(z)返回true，那么x.equal(z)返回true。 3、hashCode()hashCode()用来返回一个对象的hash值，它是一个native方法，它主要使用于哈希表中的hash算法，用于定位一个元素的位置，所以当你的对象要作为哈希表中的元素时，你要保证以下几个原则： 要比较两个对象是否相等，必须使用equal方法，如果相等，那么调用两个对象的 hashCode 方法必须返回相同的结果，即相等的两个对象返回的hashCode必须是相等的. 如果两个对象根据 equals方法比较是不相等的，则 hashCode 方法不一定得返回不同的整数. 对同一个对象调用多次hashcode方法必须返回相同的hash值. 两个不同对象的hashcode可能相等. 两个不同hashcode的对象一定不相等. 在使用hashXX集合添加对象时，集合先调用该对象的hashCode方法，根据哈希函数得到对象在哈希表中的位置，如果该位置没有元素，就直接把它存储在该位置上；如果该位置已经有元素了，就调用对象的equal方法与该位置的每个元素逐个比较，如果相等，就更新该元素，如果都不相等，就把该对象的映射添加到这个位置对应的链表中。 因此在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象hash值也相等，不然会导致集合中出现重复的元素，一个好的习惯是equals方法中用到的成员变量也必定会在hashcode方法中用到，这样就能保证两个相等的对象hash值也相等。 当你没有重写hashCode方法时，它可能返回以下的值：1、随机生成数字；2、对象的内存地址，强制转换为int；3、根据对象的内存地址生成；4、1硬编码（用于敏感性测试）；5、一个序列；6、使用线程状态结合xorshift算法生成。具体返回什么需要看不同JDK版本的实现。 异常异常就是一种对象(Exception), 表示阻止程序正常执行的错误。异常类的层次结构如下： 1、RuntimeException和Error以及它们的子类都称为免检异常, 这种异常一般是由程序逻辑错误引起的，对于这种异常，可以选择捕获处理，也可以不处理； 2、除了免检异常，其他异常都称为必检异常，这种异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发，所以Java强制要求我们必须对这些异常进行处理. 由于免检异常可能在程序的任何一个地方出现，为了避免过多的使用try-catch块，java语言不强制要求编写代码捕获免检异常，也不要求在方法头显示声明免检异常。 1、常见的异常类型 2、java中的异常处理机制异常处理机制就是可以使程序处理非预期的情景，并继续正常执行，异常处理机制的主要组成如下： try：监控有可能产生异常的语句块 catch：以合理的方式捕获异常 finally：不管有没有异常，一定会执行的语句块（一般用来释放资源），除了遇到System.exit(0)语句 throw：手动引发异常 throws: 指定由方法引发的异常 所以一个异常捕获处理语句可以如下形式： 123456789try&#123; //监控可能产生异常的语句块&#125;catch(Exception1 e)&#123; //捕获异常，处理异常，如打印异常信息，日志纪录&#125;catch(Exception2 e)&#123; //JDK7后简化写法catch(Exception1|Exception2|Exception3|... e)&#125;finally&#123; //不管有无异常，一定会执行的语句，用来释放资源&#125; try块中的代码可能会引发多种类型的异常，当引发异常时，会按照catch的顺序进行匹配异常类型，并执行第一个匹配的catch语句。 泛型1、为什么使用泛型在java5之前，任何类型的元素都可以“丢进“集合中，元素一旦进入集合中，元素的类型就会被集合忘记，导致从集合中取出的元素都是Object类型，需要进行强制类型转换后才能变成我们”丢进“集合前的元素类型，这样就导致了以下两个缺点： 1、编程的复杂度增加：任何从集合中取出的元素都要进行强制类型转换，增加编程的工作量； 2、运行时容易引发ClassCastException：由于任何类型的元素都可以放进集合中，导致集合中的元素的类型不一致，在取出元素强制类型转换时，就有可能人为地转换错误，引发ClassCastException异常，导致程序崩溃. 所以为了解决集合编译时不检查类型的问题，就出现了泛型，泛型(GenericType)是从java5开始支持的新语法，它又被称为参数化类型ParameterizedType，ParameterizedType是java5新增的Type，泛型它表示广泛通用的类型，可以在代码编译期就进行类型检查，在创建集合的时候可以动态地指明元素的类型是什么，从而约束所有放进集合的元素类型一致，这样从集合中取出元素时就不需要进行强制类型转换，从而避免了在运行时出现ClassCastException异常，如果把错误类型元素放入集合，编译器就会提出错误，所以在java中使用泛型时它保证只要程序在编译期没有提示“UnChecked”未经检查警告，那么运行时就不会产生ClassCastException。 所以从java5之后，集合框架中的全部类和接口都增加了泛型支持，从而在创建集合时可以动态地指明元素的类型是什么，如：List&lt;String&gt; list = new ArrayList&lt;String&gt;()，其中List&lt;String&gt;、ArrayList&lt;String&gt;就统称为泛型，而&lt;&gt;括号中的类型就称为类型形参。 java7的时候出现了菱形语法简化了泛型的写法，java7开始允许使用泛型时构造器后面的&lt;&gt;括号内不带类型形参，只需要给出&lt;&gt;括号就行，如：List&lt;String&gt; list = new ArrayList&lt;&gt;()。 泛型可以分为泛型类(包括类和接口)和泛型方法。 2、泛型类泛型类就是直接在类或接口上定义的泛型，上面所讲的集合也是属于泛型类，如下创建一个泛型类： 1234567891011public class Bean&lt;T&gt; &#123; private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125;&#125; 如果有多个类型形参，在&lt;&gt;括号中就用 , 隔开，在创建Bean实例的时候就可以动态的指明T(类型形参)的类型，如下： 1Bean&lt;String&gt; bean = new Bean&lt;String&gt;(); 泛型类中的T(类型形参)不存在继承的关系，如下是错误的： 1Bean&lt;Object&gt; bean = new Bean&lt;String&gt;();//错误，Bean&lt;String&gt;并不是Bean&lt;Object&gt;的子类。 同时需要注意静态变量不能使用类型形参修饰，还有静态方法不能使用泛型类声明的类型形参，如下是错误的： 12345public class Bean&lt;T&gt; &#123; private T t; private static T t2; //错误，类型形参在编译后会被擦除 public static void doWork(Bean&lt;T&gt; bean)&#123;&#125;//错误，类型形参在编译后会被擦除，如果静态方法需要使用泛型，只能使用泛型方法&#125; 还有instanceof运算符后面不能使用泛型类，如下是错误的： 123if(XX instanceof Bean&lt;String&gt;)&#123;//错误，不存在Bean&lt;String&gt;对应的Class&lt;String&gt;对象 //...&#125; 以上错误的原因都可以归结为泛型擦除，不管传入的类型形参是什么类型，在运行时它们总是具有相同的类(Class)。 如果从泛型类派生子类时，必须为作为父类的泛型类的类型形参指明类型或者不写&lt;&gt;括号，不写&lt;&gt;括号时泛型类的类型形参默认为上限类型，如果没有上限，默认为Object类型。 3、泛型方法泛型方法就是直接在方法上定义的泛型，如下创建一个泛型方法： 123public static &lt;T&gt; T doWork(Bean&lt;T&gt; bean)&#123; return bean.get();&#125; 如果有多个类型形参，在&lt;&gt;括号中就用 , 隔开，在调用doWork方法时，java会自动推断方法形参的类型，从而推断出类型形参的类型，如下： 12Bean&lt;String&gt; bean = new Bean&lt;String&gt;();doWork(bean); 上面doWork方法传入形参为bean实例，它的类型形参为String类型，从而推断出doWork方法的类型形参T为String类型。 泛型方法允许类型形参被用来表示方法的一个或多个参数之间的类型依赖关系，或者返回值与参数之间的类型依赖关系，如果没有这样的类型依赖关系，就不应该使用泛型方法，可以考虑使用类型通配符。 4、类型通配符、上限和下限类型通配符使用?表示，它表示未知的元素类型，当不知道使用什么类型接收时，此时可以使用?，如下： 123456//此时可以往doWork传入List&lt;String&gt;、List&lt;Integer&gt;等实例public static void doWork(List&lt;?&gt; list)&#123; for(Object o : list)&#123; System.out.println(o); &#125;&#125; 不管往doWork方法中传入任何类型的List&lt;XX&gt;实例，当用?接收后，此时List集合中的所有元素类型都是Object，不能往元素类型是?的集合中增加、修改元素，只能查询、删除。 类型通配符?一般代表所有类型的父类，即Object，可以为?添加上限或下限，如下： 123456//上限：此时的类型形参必须为Number或Number的子类public static void doWork(List&lt;? extends Number&gt; list)&#123; for(Number o : list)&#123; System.out.println(o); &#125;&#125; 123456//下限：此时的类型形参必须为Number或Number的父类public static void doWork(List&lt;? super Number&gt; list)&#123; for(Object o : list)&#123; System.out.println(o); &#125;&#125; 在&lt;&gt;中加入extends，就是 &lt;= 的关系，在&lt;&gt;中加入super，就是 &gt;= 的关系。 extends和super也可以用于限制泛型的类型形参的上限和下限。 5、泛型擦除泛型其实是一个语法糖，系统并不会为每个泛型生成一个Class对象，它们在运行时始终具有相同的Class对象，例如List&lt;String&gt;、List&lt;Integer&gt;等泛型类在编译之后，&lt;&gt;括号内的类型信息都会被擦除，在运行时都是使用List的Class对象，并且在反编译后，还是使用强制类型来获取元素，如下： 123456789101112131415161718192021222324public static void main(String[] args)&#123; //类型形参为Integer的泛型 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); Integer num = list.get(0); //类型形参为String的泛型 List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); list2.add(\"1\"); String str = list2.get(0);&#125;//反编译后public static void main(String args[]) &#123; //Integer类型被擦除 List list = new ArrayList(); list.add(Integer.valueOf(1)); Integer num = (Integer)list.get(0); //String类型被擦除 List list2 = new ArrayList(); list2.add(\"1\"); String str = (String)list2.get(0);&#125; 还有当把一个具有泛型信息的变量赋值给另一个没有泛型信息的变量时，所有&lt;&gt;括号之间的类型信息都会被擦除，如下： 1234567891011121314//类型形参为Integer的泛型List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);//把具有Integer类型信息的泛型list赋值给没有泛型信息的list2List list2 = list;//此时list的所有类型信息被擦除，变成了Object类型，这是可以往里面添加任何类型的元素//添加元素时会提示\"UnChecked\"警告，所以在访问list2中的元素时，如果访问不当就会在运行时引发ClassCastExceptionlist2.add(\"123\");//这里尝试把\"123\"转化为Integer，将会引发ClassCastExceptionInteger num = (Integer) list2.get(1);//这里访问正确Object o = list2.get(1);//或者String num = (String)list2.get(1) 同时系统支持把没有泛型信息的变量赋值给具有泛型信息的变量，而不会提示任何警告或错误，如下： 12345678910111213//类型形参为Integer的泛型List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);//list的Integer类型信息被擦除List list2 = list;//把擦除后的list赋值给类型形参为String的泛型list3List&lt;String&gt; list3 = list2;//下面的访问将会引起ClassCastException//等价于String num = 1；String num = list3.get(0); 上述代码将会引发ClassCastException，因为list3的类型信息是String，编译器会把list3中的元素类型当作是String，而此时list3实际引用的变量泛型擦除后的list，泛型擦除后的list中的元素类型在编译时是Object，但在运行时却是Integer，所以在运行时，从list3中取出的元素是Integer类型，Integer是不可以强转成String的，从而引起ClassCastException。 所以总的来说，泛型擦除主要在以下两个方面： 1、编译之后，泛型会被擦除；(自动擦除) 2、把泛型变量赋值给原始变量时，泛型会被擦除。(手动擦除) 结语本文简单整理了一下java语言的基本知识点，希望大家有所收获！ 参考资料： java 中的 ==, equals 与 hashCode 的区别与联系 Java 自动装箱与拆箱的实现原理 为什么阿里不建议在for循环中使用”+”进行字符串拼接","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"搞定两种场景下的Fragment懒加载","date":"2019-07-14T10:33:57.000Z","path":"2019/07/14/搞定两种场景下的Fragment懒加载/","text":"前言我对懒加载的定义是：数据的加载要等到页面对用户可见时才加载，否则的话会浪费用户流量。网上实现懒加载的方案非常多，但大多数都是解决了我下面说到的场景一的懒加载，本文还解决场景二的懒加载方式。 如果不想看下面的分析，直接这个类导入你的项目中，需要懒加载的Fragment继承这个类，并重写相应的方法就行：传送门。 场景一： Viewpager + Tablayout + Fragment什么？不会用Viewpager，可以看一下这个入门系列：ViewPager 详解（一）—基本入门。 场景一应该是很多人都遇到过的情况，界面整体使用Viewpager + Tablayout + Fragment组合，左右滑动界面以展示数据给用户，当你滑动到下一页的时候，Fragment已经有数据了，因为Viewpager默认会预加载好相邻的Fragment页面，这个预加载数量可以通过如下设置： 1viewPager.setOffscreenPageLimit(0); 那么上面这句代码不是把预加载数量设置为0了吗？这样Fragment就不会预先加载了，这样想你就太天真，通过看setOffscreenPageLimit的源码得知，如果你传入的数值小于1，那么ViewPager就会把预加载数量设置成默认值，而默认值就是1，所以说就算你传入了0，ViewPager还是会预先加载好当前页面的左右两个Fragment页面。 懒加载原理那么怎么解决呢？这时要认识Fragment中的一个函数：setUserVisibleHint(boolean isVisibleToUser)： setUserVisibleHint方法是Fragment中的一个回调函数。当前Fragment可见对用户可见时，setUserVisibleHint()回调，其中参数isVisibleToUser=true，当前Fragment由可见到不可见或实例化时，setUserVisibleHint()回调，其中参数isVisibleToUser=false。 下面看一下这个方法在Fragment生命周期中的调用时机： 1、当Fragment被实例化时，即Fragment被装载进ViewPager适配器中，并：setUserVisibleHint() -&gt;onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onViewCreated() -&gt; onActivityCreate() -&gt; onStart() -&gt; onResume()。此时setUserVisibleHint() 中的参数为false。 2、在Fragmente可见时，即ViewPager滑动到当前页面时：setUserVisibleHint()。只会调用setUserVisibleHint方法，因为已经预加载过了，Fragment在之前生命周期已经走到onResume() 了。此时setUserVisibleHint() 中的参数为true。 3、在Fragment由可见变为不可见，即ViewPager由当前页面滑动到另一个页面：setUserVisibleHint()。只会调用setUserVisibleHint方法，因为还要保持当前页面的预加载过程，此时setUserVisibleHint() 中的参数为false。 4、点击由TabLayout直接跳转到一个未预加载的页面，此时生命周期的回调过程：setUserVisibleHint() -&gt; setUserVisibleHint() -&gt; onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onViewCreated() -&gt; onActivityCreate() -&gt; onStart() -&gt; onResume()。回调了两次setUserVisibleHint() ，一次代表初始化时，传入参数是false，一次代表可见时，传入参数是true。 可以看到此时setUserVisibleHint的调用时机总是在初始化时调用，可见时调用，由可见转换成不可见时调用。 实现思路下面讲讲场景一的懒加载实现思路：我们一般在Fragment的onActivityCreated中加载数据，这个时候我们可以判断此时的Fragment是否对用户可见，调用fragment.getUserVisibleHint()可以获得isVisibleToUser的值，如果为true，表示可见，就加载数据，如果不可见，就不加载数据了，代码如下： 1234567891011@Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); if(isFragmentVisible(this) &amp;&amp; this.isAdded())&#123; if (this.getParentFragment() == null || isFragmentVisible(this.getParentFragment())) &#123; onLazyLoadData(); isLoadData = true; //... &#125; &#125; &#125; 判读Fragment是否对用户可见封装在isFragmentVisible方法中， onLazyLoadData()是子类需要重写的方法，用来加载数据，加载完数据后把isLoadData设置为true，表示已经加载过数据。 上面就控制了当Fragment不可见时就不加载数据，而且此时Fragment的生命周期也走到onResume了，那么当我滑到这个Fragment时，只会调用它的setUserVisibleHint方法，那么就要在setUserVisibleHint方法中加载数据，代码如下： 12345678@Override public void setUserVisibleHint(boolean isVisibleToUser) &#123; super.setUserVisibleHint(isVisibleToUser); if(isFragmentVisible(this) &amp;&amp; !isLoadData &amp;&amp; isViewCreated &amp;&amp; this.isAdded())&#123; onLazyLoadData(); isLoadData = true; &#125; &#125; isViewCreated字段表示布局是否被初始化，它在onViewCreated方法中被赋值为true，如下： 1234@Override public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) &#123; isViewCreated = true; &#125; onViewCreated方法的回调在onCreateView方法后，当调用onViewCreated方法时，Fragment的View布局一定创建好了。 我们再回到setUserVisibleHint方法中，在if中它会依此判断当前Fragment可见、还没有加载数据、布局已经创建好等这些条件满足后才加载数据，并把isLoadData赋值为true。 应用示例下面是我在项目中使用的情况： 可以看到，当我滑倒这个Fragment时才加载数据。 场景二：FragmentManager + FragmentTransaction+ Fragment这个场景就是你把几个Fragment通过FragmentTransaction的add方法add到FragmentManager 中，切换Fragment的时候通过FragmentTransaction的hide和show方法配合使用，类似于微信的主界面，底部有一个tab，然后点击tab，切换页面。 当Fragment被add进manager中时，Fragment生命周期已经执行到onResume了，所以在后续的hide和show方法切换Fragment时，Fragment已经有数据了，在我的项目中，我想要的效果是，当我点到这个tab时，该tab对于的Fragment才加载数据，所以我对这种情况实现了懒加载。 懒加载原理那么要怎么实现呢？照搬场景2的实现方式？可惜了，不行，因为这种情况下setUserVisibleHint方法不会被调用。这个时候我们又重新认识一个方法onHiddenChanged（boolean hidden）： onHiddenChanged方法是当Fragment的隐藏状态变化示被调用，当Fragment没有被隐藏时即调用show方法，当前onHiddenChanged回调，其中参数hidde=false，当Fragment被隐藏时即调用hide了方法，onHiddenChanged()回调，其中参数hidde=true。还有一点注意的是使用hide和show时，fragment的所有生命周期方法都不会调用，除了onHiddenChanged（）。 下面看一下这个方法在Fragment生命周期中的调用时机： 1、当Fragment被add进manager时：onAttach() -&gt; onCreate() -&gt; onCreateView() -&gt; onViewCreated() -&gt; onActivityCreate() -&gt; onHiddenChanged() -&gt; onStart() -&gt; onResume()。此时onHiddenChanged() 中的参数为false。 2、当用hide方法隐藏Fragment时：onHiddenChanged()，只会调用onHiddenChanged方法，此时setUserVisibleHint() 中的参数为true。 3、当用show方法显示Fragment时：onHiddenChanged()，只会调用onHiddenChanged方法，此时setUserVisibleHint() 中的参数为false。 可以看到此时onHiddenChanged的调用时机总是在初始化时调用，hide时调用，show时调用。 实现思路场景二是在setUserVisibleHint方法中做文章，而这次是在onHiddenChanged方法中做文章，如下： 123456789101112@Override public void onHiddenChanged(boolean hidden) &#123; super.onHiddenChanged(hidden); //1、onHiddenChanged调用在Resumed之前，所以此时可能fragment被add, 但还没resumed if(!hidden &amp;&amp; !this.isResumed()) return; //2、使用hide和show时，fragment的所有生命周期方法都不会调用，除了onHiddenChanged（） if(!hidden &amp;&amp; isFirstVisible &amp;&amp; this.isAdded())&#123; onLazyLoadData(); isFirstVisible = false; &#125; &#125; 首先看注释1，因为当add的时候，onHiddenChanged调用在onResumed之前，此时还没有执行onResume方法，用户还看不见这个Fragment，如果此时加载数据就没有什么用，等于用户看到这个Fragmen时它就已经执行完数据了，如果这里要加一个判断，如果Fragment还没有Resume，就直接return，不做操作。 接下来看注释2，执行到注释2表示此时Fragment已经可见了，就可以通过hidden字段控制懒加载，hidden为false表示调用了show方法，通过isFirstVisible控制只加载一次，为什么要用isFirstVisible呢，因为在onActivityCreate方法中就有可能已经加载过数据，如果加载过就不用再加载了，在onActivityCreate中会把这个字段赋值为true，如下： 123456789101112@Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); if(isFragmentVisible(this) &amp;&amp; this.isAdded())&#123; if (this.getParentFragment() == null || isFragmentVisible(this.getParentFragment())) &#123; onLazyLoadData(); isLoadData = true; if(isFirstVisible) isFirstVisible = false; &#125; &#125; &#125; 应用示例下面是我在项目中使用的情况： 可以看到，当我点击到这个tab时，对应的Fragment才加载数据。 结语以上就是我的懒加载历程，虽然现在也有一些Fragment库可以实现这个效果，但是它的原理也是这个，我们要知其所以然，该懒加载类整合场景一和场景二，只有简单的几句代码，只要继承就能在两种场景下使用。 参考文章： Fragment 知识梳理(3) FragmentPagerAdapter与FragmentStatePagerAdapter区别","tags":[{"name":"fragment","slug":"fragment","permalink":"http://yoursite.com/tags/fragment/"}]},{"title":"如何获取Android应用和系统信息","date":"2019-07-12T14:36:32.000Z","path":"2019/07/12/如何获取Android应用与系统信息/","text":"前言本主要了解一下Android系统信息的获取，apk应用信息的获取。 本文相关源码在文末给出Android系统信息的获取有时我们想要获取手机系统的配置信息，通常可以从以下俩方面获取： android.os.Build SystemProperty 1、android.os.Buildandroid.os.Build包含了系统编译时的大量设备，配置信息，它里面的字段含义如下： Build.BOARD; //主板 Build.BRAND; //Android系统指定商 supported_abis = null;//CPU指令集 Build.DEVICE;//设备参数 Build.DISPLAY;//显示屏参数 Build.FINGERPRINT;//唯一编号 Build.SERIAL;//硬件序列号 Build.ID;//修订版本列表 Build.MANUFACTURER;//硬件制造商 Build.MODEL;//版本 Build.HARDWARE;//硬件名 Build.PRODUCT;//手机产品名 Build.TAGS;//描述Build的标签 Build.TYPE;//Builder类型 Build.VERSION.CODENAME;//当前开发号 Build.VERSION.INCREMENTAL;//源码版本控制号 Build.VERSION.RELEASE;//版本字符串 Build.VERSION.SDK_INT;//版本号 Build.HOST;//Host值 Build.USER;//User名 Build.TIME;//编译时间2、SystemPropertySystemProperty包含许多系统，配置属性值和参数，很多与上面通过android.os.Build获取的相同,下面给出常用的信息： System.getProperty(“os.version”);//os 版本 System.getProperty(“os.name”);//os 名称 System.getProperty(“os.arch”);//os 架构 System.getProperty(“user.home”);//Home 属性 System.getProperty(“user.name”);//Name 属性 System.getProperty(“user.dir”);//Dir 属性 System.getProperty(“user.timezone”);//时区 System.getProperty(“path.separator”);//路径分隔符 System.getProperty(“line.separator”);//行分隔符 System.getProperty(“file.separator”);//文件分隔符 System.getProperty(“java.vendor.url”);//java vender URL 属性 System.getProperty(“java.class.path”);//java Class 路径 System.getProperty(“java.class.version”);//java Class 版本 System.getProperty(“java.vendor”);//java Vender 属性 System.getProperty(“java.version”);//java 版本 System.getProperty(“java_home”);//java HOME属性3、实例 通过一个简单的示例查看如何使用（更多细节查看文末源码），如下： 12345678910/* 通过android.os.Build，可以直接获得一些Build提供的系统信息 */String board = Build.BOARD;String brand = Build.BRAND;Log.d(TAG, \"android.os.Build，board：\" + board);Log.d(TAG, \"android.os.Build，brand： \" + brand);/* 通过SystemProperty，要使用System.getProperty(\"XXX\") */String os_version = System.getProperty(\"os.version\");String os_name = System.getProperty(\"os.name\");Log.d(TAG, \"SystemProperty，os_version: \" + os_version);Log.d(TAG, \"SystemProperty, os_name: \" + os_name); 可以看到，获取系统信息还是很简单的。 Apk应用信息的获取Apk应用信息的获取无非分为，apk包信息的获取与应用进程信息的获取。 1、PackageManager通过PackageManager可以获得应用的apk包信息，先看下面一张图： 最里面的框代表了整个Activity的信息，系统提供了ActivityInfo类来进行封装，以此类推。 1.1、下面列举一些常用的系统封装信息下面这些封装信息与PackageManager在同一个包内。 ActivityInfoActivityInfo 封装了在Manifest文件中&lt;activity&gt;&lt;/activity&gt;和&lt;receiver&gt;&lt;/receiver&gt;之间的所有信息，包括name，icon，label，launchmod等 。 ServiceInfo和ActivityInfo类似，它封装了&lt;service&gt;&lt;/service&gt;之间的所有信息 。 ApplicationInfo它封装了&lt;application&gt;&lt;/application&gt;之间的信息，特别的是，Application包含很多Flag，FLAG_SYSTEM表示为系统应用，FLAG_EXTERNAL_STORAGE表示为安装在sd卡上的应用等，通过这些FLAG可以很方便的判断应用类型 。 PackageInfo它用于封装Manifest文件相关节点的信息，包含了所有Activity、Service等信息 。 ResolveInfo这个比较特殊，它封装的是包含&lt;intent&gt;信息的上一级信息，所以它可以返回ActivityInfo，ServiceInfo等包含的信息，它经常用来帮助我们找到那些包含特定intent条件的信息，如带分享，播放功能的应用。 通过上面的对象，PackageManager 就可以通过调用各种方法来返回不同类型的Bean 1.2、PackageManager常用方法 getPackagerManager: 通过调用这个方法返回一个PackageManager对象 getApplicationInfo: 以ApplicationInfo形式返回指定包名的Application getApplicationIcon：返回指定包名的icon getInstalledApplications： 以ApplicationInfo形式返回安装的应用 getInstalledPackages：以PackageInfo的形式返回安装的应用 queryIntentActivities: 返回指定intent的ResolveInfo对象、Activity集合 queryIntentServices：返回指定intent的ResolveInfo对象、service集合 resolveActivity：返回指定intent的Activity resolveService：返回指定的intentService1.3、实例 下面通过一个例子来了解如何通过PackageManager来选出不同类型的app，判断app类型的依据，就是利用Applicationinfo中的FLAG_SYSTEM来进行判断，如下： 1app.flags &amp; Applicationinfo.FLAG_SYSTEM 如果flags &amp; Applicationinfo.FLAG_SYSTEM ！= 0，则为系统应用 如果flags &amp; Applicationinfo.FLAG_SYSTEM &lt;= 0, 则为第三方应用 如果flags &amp; Applicationinfo.FLAG_EXTERNAL_STORAGE != 0, 则为SD卡上的应用 特殊的，当系统应用经过升级后，也将成为第三方应用：flags &amp; Applicationinfo.FLAG_UPDATED_SYSTEM_APP != 0 首先封装一个Bean保存我所需要的app信息： 12345678910111213141516171819202122232425262728293031323334353637public class PMAppInfo &#123; private String appName;//app名称 private Drawable appIcon;//图标 private String pkgName;//所在包名 public PMAppInfo(String appLabel, Drawable appIcon, String pkgName) &#123; this.appName = appLabel; this.appIcon = appIcon; this.pkgName = pkgName; &#125; public String getAppLabel() &#123; return appName; &#125; public void setAppLabel(String appName) &#123; this.appName = appName; &#125; public Drawable getAppIcon() &#123; return appIcon; &#125; public void setAppIcon(Drawable appIcon) &#123; this.appIcon = appIcon; &#125; public String getPkgName() &#123; return pkgName; &#125; public void setPkgName(String pkgName) &#123; this.pkgName = pkgName; &#125;&#125; 接下来，通过上面所说的方法判断各种类型的app： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private List&lt;PMAppInfo&gt; getAppInfoList(int flag)&#123; pm = this.getPackageManager(); //获取应用信息 List&lt;ApplicationInfo&gt; applicationInfoList = pm.getInstalledApplications(PackageManager.GET_UNINSTALLED_PACKAGES); List&lt;PMAppInfo&gt; appInfoList = new ArrayList&lt;&gt;(); //判断应用类型 switch (flag)&#123; case ALL_APP: appInfoList.clear(); for (ApplicationInfo app : applicationInfoList) &#123; appInfoList.add(new PMAppInfo( ((String) app.loadLabel(pm)), app.loadIcon(pm), app.packageName)); &#125; break; case SYSTEM_APP: appInfoList.clear(); for (ApplicationInfo app : applicationInfoList) &#123; if ((app.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) &#123; appInfoList.add(new PMAppInfo( ((String) app.loadLabel(pm)), app.loadIcon(pm), app.packageName)); &#125; &#125; break; case THIRD_APP: appInfoList.clear(); for (ApplicationInfo app : applicationInfoList) &#123; if ((app.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= 0) &#123; appInfoList.add(new PMAppInfo( ((String) app.loadLabel(pm)), app.loadIcon(pm), app.packageName)); &#125; else if ((app.flags &amp; ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) &#123; appInfoList.add(new PMAppInfo( ((String) app.loadLabel(pm)), app.loadIcon(pm), app.packageName)); &#125; &#125; break; case SDCARD_APP: appInfoList.clear(); for (ApplicationInfo app : applicationInfoList) &#123; if ((app.flags &amp; ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) &#123; appInfoList.add(new PMAppInfo( ((String) app.loadLabel(pm)), app.loadIcon(pm), app.packageName)); &#125; &#125; break; default: return null; &#125; return appInfoList; &#125; 运行效果图： 如上图所示，通过点击不同的按钮，在下方显示出不同类型的apk信息。 2、ActivityManager前面使用了PackageManager获得了应用包的信息，PackageMessager重点在于获得应用的包信息，而ActivityManager重点在于获得在运行时的应用程序的进程信息。 2.1、同PackageManager一样， ActivityManager也封装了很多Bean对象下面的封装类都在ActivityManager的类中。 ActivityManager.MemoryInfo它封装了内存信息，MemoryInfo中有几个重要的字段：availMem - 系统可用内存，totalMen - 总内存，threshold - 低内存的阈值，即区分是否是低内存，lowMemory - 是否处于低内存。 Debug.MemoryInfoandroid中还有一个MemoryInfo，它来自Debug.MemoryInfo,前面的MemoryInfo通常用于获取全局的内存使用信息，而它用于统计进程下的内存信息。 RunningAppProcessInfo顾名思义，就是运行间进程信息，储存的字段自然进程相关的信息，processName - 进程名， pid - 进程pid, uid - 进程uid，pkgList - 该进程下所有的包 。 RunningServiceInfoRunningServiceInfo与RunningAppProcessInfo类似，用于封装运行时的服务信息，它包含了进程信息的同时还包含了其他的信息，activeSince - 第一次被激活的时间，方式，foreground - 服务是否在后台运行。 2.2、实例下面同样通过一个例子来使用ActivityManager，先封装一个Bean来保存一个我们需要的字段： 123456789101112131415161718192021222324252627282930313233343536373839404142public class AMProcessInfo &#123; private String uid; private String pid; private String memorySize; private String processName; public AMProcessInfo() &#123; &#125; public String getPid() &#123; return pid; &#125; public void setPid(String pid) &#123; this.pid = pid; &#125; public String getUid() &#123; return uid; &#125; public void setUid(String uid) &#123; this.uid = uid; &#125; public String getMemorySize() &#123; return memorySize; &#125; public void setMemorySize(String memorySize) &#123; this.memorySize = memorySize; &#125; public String getProcessName() &#123; return processName; &#125; public void setProcessName(String processName) &#123; this.processName = processName; &#125;&#125; 通过调用getRunningAppProcesses（）返回当前运行时的进程信息集合： 1234567891011121314151617181920212223private List&lt;AMProcessInfo&gt; getRunningProcessesInfo() &#123; amProcessInfoList = new ArrayList&lt;&gt;(); //获取正在运行的进程集合 List&lt;ActivityManager.RunningAppProcessInfo&gt; appProcessList = am.getRunningAppProcesses(); for (int i = 0; i &lt; appProcessList.size(); i++) &#123; ActivityManager.RunningAppProcessInfo info = appProcessList.get(i); int pid = info.pid; int uid = info.uid; String processName = info.processName; //获取该进程下的内存 int[] memoryPid = new int[]&#123;pid&#125;; Debug.MemoryInfo[] memoryInfo = am.getProcessMemoryInfo(memoryPid); int memorySize = memoryInfo[0].getTotalPss(); AMProcessInfo processInfo = new AMProcessInfo(); // processInfo.setPid(\"\" + pid); processInfo.setUid(\"\" + uid); processInfo.setMemorySize(\"\" + memorySize); processInfo.setProcessName(processName); amProcessInfoList.add(processInfo); &#125; return amProcessInfoList; &#125; 运行效果图： 上图运行给出了当前运行的一个进程的pid，uid，占用内存，进程名的信息。 结语PackageManager是用来获取apk包信息的，ActivityManager是用来获取运行时进程信息的，如果想要获取手机系统信息，可以通过SystemProperty和android.os.Build，本文同样是一篇学习记录，希望大家读完后和我一样有所收获。 本文相关源码位置 参考资料： 《android群英传》","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"ActivityManager","slug":"ActivityManager","permalink":"http://yoursite.com/tags/ActivityManager/"},{"name":"PackageManager","slug":"PackageManager","permalink":"http://yoursite.com/tags/PackageManager/"}]},{"title":"基于P2P的局域网即时通信应用","date":"2019-07-12T11:25:30.000Z","path":"2019/07/12/基于P2P的局域网即时通信应用/","text":"前言这是一个使用java语言开发的基于P2P的局域网即时通信Android应用，界面是高仿微信的聊天界面，在里面你将会学到java多线程并发编程、Socket编程、UDP广播、TCP连接、还有图片加载相关知识等。 项目地址：P2P 设计思路P2P不同于C/S方式，它没有集中式的服务器，在P2P中，程序既是服务器又是客户端，在同一个局域网内，每个用户发送的消息不会经过路由器转发到其他局域网，那么如何保证大家都在同一个局域网内呢？答案是只要大家都连上同一个WIFI就行，这样就保证大家在同一个局域网内，这时你手机或电脑就会被路由器分配一个ip地址。 如下图： 下面是设计思路： 1、用户登陆阶段（1）用户A打开P2P程序的，选择一个名字和头像后，点击登陆，就开始登陆上局域网，用户A登陆时程序同时会启动两个线程，一个线程里面启动UDP服务端(端口号9156)，用来等待其他用户的登陆，另一个线程里面启动TCP服务端(端口号9155)，用来等待其他用户的Socket连接，在登陆同时用户A还会使用UDP广播一个UDP包出去。这个UDP包包含了用户姓名和ip地址等信息，UDP包会发送给同一局域网内所有具有相同端口的UDP服务端程序，包括本程序。 （2）这时如果有其他在线的用户，那么每个在线的用户程序中的UDP服务端就会收下这个UDP包，然后把用户信息取出来并把用户A加入在线列表，因为UDP包中包含用户A ip地址，所以每个在线的用户使用用户A的ip地址向用户A发一个回复。 （3）用户A等待一段时间后，就会收到所有在线用户的回复，然后把所有的在线用户加入自己的在线列表。 登陆阶段如图： 2、 用户聊天阶段（1）用户A选择自己的在线列表中的用户B聊天，这时用户A就会向用户B发起TCP连接，与此同时用户B的TCP服务端中就会收到一个Socket请求，用户B把这个Socket请求缓存起来，同理用户A发起连接时也会产生一个Socket，用户A也把这个Socket保存缓存起来，这样下一次就不用重复建立连接。 （2）这样双方都拥有一个Socket，双方基于Socket与Socket之间建立的连接上聊天（传输文件，文字等）。 聊天阶段如图： 3、用户退出阶段（1）当用户A离开程序，退出局域网时，用户A就像登陆一样使用广播地址广播一个UDP包出去，UDP中包含了要退出登陆的信息，那么在局域网内的在线用户收到这个UDP后，就把用户A移除出在线用户列表，如果有用户A的Socket连接，就把Socket连接关闭掉。 （2）用户A发出退出广播后，也把自己缓存的所有Socket连接关闭掉。 程序运行截图首先用户A和用户B登陆，分别选择一个头像和姓名，如下 登陆后，双方正常来讲，是只有一个在线用户的，但是考虑到平时测试两台手机不方便，就没有把自己过滤掉，所以现在双方都有两个在线用户，用户A的在线用户是用户B和自己，用户B的在线用户是用户A和自己，如下： 下面是双方聊天的过程，现在可以发文字、图片、语音、文件(支持发送大文件，发送大文件有进度显示)。 关键性的代码下面红色方框内的是关键性类，如下： 下面讲解一些关键性代码： 1、初始化TCP服务端初始化TCP服务端，在ConnectManager类中，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445 /** * 初始化ServerSocket监听，绑定端口号, 等待客户端连接 */public void initListener()&#123; mExecutor.execute(() -&gt; &#123; try &#123; //创建ServerSocket监听，并绑定端口号 mServerSocket = new ServerSocket(PORT); LogUtil.d(TAG, \"开启服务端监听，端口号 = \" + PORT); &#125; catch (IOException e) &#123; e.printStackTrace(); LogUtil.e(TAG, \"绑定端口号失败，e = \" + e.getMessage()); &#125; while (true)&#123; try &#123; //调用accept()开始监听，等待客户端的连接 Socket socket = mServerSocket.accept(); String ipAddress = socket.getInetAddress().getHostAddress(); if(isClose(ipAddress))&#123; LogUtil.d(TAG, \"一个用户加入聊天，socket = \" + socket); //每个客户端连接用一个线程不断的读 ReceiveThread receiveThread = new ReceiveThread(socket); //缓存客户端的连接 mClients.put(ipAddress, socket); //放到线程池中执行 mExecutor.execute(receiveThread); LogUtil.d(TAG, \"已连接的客户端数量：\" + mClients.size()); //简单的心跳机制 heartBeat(ipAddress); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); LogUtil.e(TAG, \"调用accept()监听失败， e = \" + e.getMessage()); break; &#125; &#125; try &#123; //释放掉ServerSocket占用的端口号 mServerSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); LogUtil.e(TAG, \"关闭端口号失败， e = \" + e.getMessage()); &#125; &#125;);&#125; ConnectManager是用来管理每个用户的连接，ConnectManager的initListener()方法里面会绑定一个端口号，然后调用accept()方法等待其他客户端的连接，如果有客户端的连接请求，就会为每一个客户端的连接创建一个Thread，这个Thread会不停等待接收客户端的消息。如下： 1234567891011121314151617181920212223public class ReceiveThread implements Runnable&#123; //... @Override public void run() &#123; while (true)&#123; Mes mes; try&#123; InputStream in = mSocket.getInputStream(); mes = receiveMessageByType(in); //... &#125; catch (Exception e) &#123; e.printStackTrace(); LogUtil.e(TAG, \"获取客户端消息失败，e = \" + e.getMessage()); //两端的Socker连接都要关闭 ConnectManager.getInstance().removeConnect(mClientIp); ConnectManager.getInstance().removeReceiveCallback(mClientIp); ConnectManager.getInstance().cancelScheduledTask(mClientIp); break; &#125; &#125; &#125;//...&#125; 2、初始化UDP服务端初始化UDP服务端，在OnlineUserManager类中，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 /** * 初始化监听，绑定指定端口, 等待接受广播 */public void initListener()&#123; mExecutor.execute(() -&gt; &#123; try &#123; mDatagramSocket = new DatagramSocket(PORT); LogUtil.d(TAG, \"开启广播监听，端口号 = \" + PORT); &#125; catch (SocketException e) &#123; e.printStackTrace(); LogUtil.e(TAG, \"创建DatagramSocket监听失败， e = \" + e.getMessage()); &#125; while (true)&#123; try &#123; byte[] buffer = new byte[MAX_RECEIVE_DATA]; DatagramPacket datagramPacket = new DatagramPacket(buffer, buffer.length); mDatagramSocket.receive(datagramPacket); byte[] data = datagramPacket.getData(); //获得发送方的ip地址 String receiveIp = datagramPacket.getAddress().getHostAddress(); //解析数据 Data datas = resolveData(data); if(datas != null)&#123; //用户数据 int code = datas.getCode(); User user = datas.getUser(); user.setIp(receiveIp); if(code == 0)&#123; //把它加入在线用户列表 if(!mOnlineUsers.containsKey(receiveIp))&#123; mOnlineUsers.put(receiveIp, user); //通知主活动用用户加入 if(mUserCallback != null)&#123; mHandler.obtainMessage(TYPE_JOIN_USER, mOnlineUsers.get(receiveIp)).sendToTarget(); &#125; LogUtil.d(TAG, \"一个用户加入，地址 = \" + receiveIp); &#125; //回复它 reply(receiveIp); &#125;else if(code == 1)&#123; //用户退出在线用户列表 if(mOnlineUsers.containsKey(receiveIp))&#123; User exitUser = mOnlineUsers.remove(receiveIp); if(mUserCallback != null)&#123; mHandler.obtainMessage(TYPE_EXIT_USER, exitUser).sendToTarget(); &#125; LogUtil.d(TAG, \"一个用户退出，地址 = \" + receiveIp); &#125; &#125;else &#123; //得到所有在线用户列表 if(!mOnlineUsers.containsKey(receiveIp)) &#123; mOnlineUsers.put(receiveIp, user); //通知主活动用用户加入 if(mUserCallback != null)&#123; mHandler.obtainMessage(TYPE_JOIN_USER, mOnlineUsers.get(receiveIp)).sendToTarget(); &#125; LogUtil.d(TAG, \"获得一个用户信息，地址 = \" + receiveIp); &#125; &#125; &#125; LogUtil.d(TAG, \"当前在线用户，count = \" + mOnlineUsers.size()); &#125; catch (IOException e) &#123; e.printStackTrace(); LogUtil.e(TAG, \"接受广播失败， e = \" + e.getMessage()); break; &#125; &#125; if(mDatagramSocket != null)&#123; mDatagramSocket.close(); &#125; &#125;);&#125; OnlineUserManager是用来管理在线用户的，OnlineUserManager的initListener()方法里面也是会绑定一个端口号，然后调用receive()方法等待用户的广播信息，如果有用户的广播信息，就根据用户的广播信息类型做出不同的动作，如把用户加入在线用户列表。 3、Mes类的设计Mes类是用户之间建立连接后传输消息的实体类，如下： 12345678public class Mes&lt;T&gt;&#123; public ItemType itemType;//Mes的Item类型 public MesType mesType;//Mes的类型 public String userIp;//发送Mes的用户的ip public T data;//具体消息 //...&#125; 其中T是一个泛型，它可以代表着文本、音频、文件、图片的类型，所以在构造一个Mes时，就要确定它是属于什么类型，然后文本、音频、文件、图片分别在对应一个实体类。 4、User类的设计User就代表着用户，如下： 1234567public class User implements Serializable &#123; private String mName;//名字 private String mIp;//ip private String mImagePath;//头像路径 private int mImageLen;//头像长度 //...&#125; 它在传输前中会转成一个Json字符串，收到后再把它转成User类，这样就很容易的把它里面的数据解析出来也方便了传输。 5、关于心跳机制的实现心跳机制是什么？它就每隔一段事件发一个探测，探测在线的用户是否存活。有些在线用户由于手机关机，不正常退出应用等会导致它无法正常退出登陆，这时就需要每隔一段时间探测它是否存活。 P2P中实现了一个简单的心跳机制，其实它就是一个定时任务，线程池中可以提交周期执行的任务，如下： 12345678910111213141516/** * 简单心跳机制 */private void heartBeat(String ipAddress) &#123; if(!mScheduledTasks.containsKey(ipAddress))&#123; ScheduledFuture task = mScheduledExecutor.scheduleAtFixedRate(() -&gt; &#123; int result = PingManager.getInstance().ping(ipAddress); Log.d(TAG, \"探测对方是否在线, result = \" + result + \", ipAddress = \" + ipAddress); if(result != 0)&#123; removeConnect(ipAddress); cancelScheduledTask(ipAddress); &#125; &#125;, 10, 10, TimeUnit.SECONDS); mScheduledTasks.put(ipAddress, task); &#125;&#125; 它每隔10秒就会执行一次，然后会ping一下用户的ip地址，如果它不连通了，就要把它从在线用户中移除。 开发过程中遇到的问题及解决办法 问题1：获取获得在线用户列表和如果告诉别人我上线了？ 因为第一次开发P2P应用，所以不知道用户体系建立的逻辑，尝试的第一种方法是：使用Ping命令把ip地址的最后三位用循环从0~255不断的ping，如果ping通，就说明这个ip地址的用户连接着局域网的同一个WIFI，把它记录下来，但是这有一个缺点，能ping通的ip地址只是说明这个用户连着WIFI，并没有说明这个用户打开了P2P应用，也并不代表这个用户上线了，所以这种方法不行；后来想到了一种改进办法：就是把ping通的ip地址列表逐个建立Socket连接，如果能够连接上，就说明这个用户打开了P2P应用并且上线了，这个办法可以，但是逐个建立连接有很麻烦，耗时。 解决办法：就是使用UDP的广播，UDP广播能够告诉同一局域网内的所有打开了同一端口的在线用户我上线了，并且收到他们的回复。 问题2：用户头像的发送？ 因为使用UDP广播，但是UDP广播每次最大只能发送64Kb数据，一个头像就算压缩了，也有几百Kb，所以如何把头像发送出去是一个问题，尝试的第一种方法是：把头像转化成字节数组和用户信息一起转化为json数据，json数据再转化为字节数组，然后把json数据的字节数组分段发送出去，但是这有一个缺点，就是会额外增大发送时UDP的字节数组的长度导致发送额外多的字节，耗时，这种方法不行；尝试的第二种方法是：把头像和用户信息分开发送，先发送用户信息，然后再把头像转化为字节数组分段发送，但是有一个无法解决的问题，就是UDP是不可靠，很难保证分段后的字节再重新组合成一个完整的头像字节数组，会有顺序问题，所以这种办法不行。 解决办法：用户信息用UDP广播发送，因为用户信息短，不用分段，然后等获取到在线用户列表后再逐一建立TCP连接把用户头像发送给在线用户列表，TCP可靠。","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"},{"name":"p2p","slug":"p2p","permalink":"http://yoursite.com/tags/p2p/"}]},{"title":"SVG入门学习","date":"2019-07-12T09:39:00.000Z","path":"2019/07/12/SVG入门学习/","text":"前言SVG对于android开发者听起来是陌生的东西，因为它是属于前端的产物，其实Android中也是支持SVG的，语法也很简单易懂，本文就通过我自己学习的经历，和大家一起学习一下SVG。 什么是SVG?Google 在Android5.X中增加了对SVG矢量图形的支持，可以用来创建高效率的动画, 所以我们先来了解一下SVG的定义： 可伸缩矢量图形（Scalable Vector Graphics） 使用XML格式定义图形 图像在放大或改变尺寸的情况下图片质量不会有所损失 android中使用vector标签表示SVG 与bitmap相比，SVG最大的优点是放大不会失真，而bitmap需要为不同的分辨率准备很多套图标，而SVG则不需要，前面说了SVG要用vector表示，我们先来看看vector标签中属性的含义。 vector的各个属性是什么意义？12345678910111213141516171819202122232425262728293031323334&lt;vector xmlns:android=\"http://schemas.android.com/apk/res/android\" //命名空间 android:height=\"200dp\" //这个是图片的intrinsic高度 android:width=\"200dp\" //这个是图片的intrinsic宽度 android:viewportHeight=\"100\" //这个是为这个图片设置的纵坐标,表示将图片分为100等份,主要下面的pathData需要依赖这个坐标的划分 android:viewportWidth=\"100\" //同上,只不过这个是横坐标, heigh，width的比例和viewportHeight，viewportWidth的比例必须保持一致，不然图形就会发生形变 android:alpha=\"0.2\" //这个是整个图像的透明度,取值范围0到1 &gt; &lt;group //这个标签中可以放入若干个&lt;path/&gt;标签,并给它们设置一些共同的属性 android:name=\"group_name\" //这个name很有用,在设置objectAnimator的时候用来区分给那个部分施加动画 android:pivotY=\"50\" //这个设置这个group的中心点的X坐标,取值范围为0到100,在做rotation时有用 android:pivotX=\"50\" //这个设置这个group的中心点的Y坐标,取值范围为0到100,在做rotation时有用 android:translateX=\"20\" //将整个group在X轴方向平移多少像素 android:translateY=\"30\" //将整个group在Y轴方向平移多少像素 android:rotation=\"90\" //将整个group以中心点左边旋转的角度,360为一圈 android:scaleX=\"0.5\" //横坐标的缩放比例 , 取值1表示100% android:scaleY=\"0.3\"&gt; //纵坐标的缩放比例,取值0.5表示50%,取值1.5表示150% &lt;path //这个标签是重头戏,矢量图绘制的路径 android:name=\"path_name\" //为这个path标记的名字,在使用objectAnimator的时候用来区分给哪个部分施加动画 android:pathData=\"m 0,0 L50,0 L100,100 L0,100 z\" //这个是SVG的语法,下面讲 android:fillColor=\"@color/red\" //定义填充图形的颜色，如果没有定义则不填充路径 android:fillAlpha=\"1\" //定义填充图形的透明度，取值范围0到1 android:strokeAlpha=\"0.5\" //定义路径的透明度,取值范围0到1 android:strokeColor=\"#ff0000ff\" //定义如何绘制路径，如果没有定义则不显示路径 android:strokeWidth=\"20\" //线段的宽度 android:strokeLineCap=\"butt|round|square\" //线的末端形状,butt严格到指定的坐标就截至,round是圆角,square是方形，到指定的坐标后还会再冒出一点来 android:strokeLineJoin=\"round|bevel|miter\" //线的连接处形状,round是圆角的,bevel和miter貌似看不出来有什么区别.... android:trimPathStart=\"0.5\" //顾名思义,从path开始的地方(0%)去除path,去除到指定的百分比位置,取值范围0到1 android:trimPathEnd=\"0.5\" //顾名思义,从path结束的地方(100%的地方)去除path,去除到指定的百分比位置,取值范围0到1 android:trimPathOffset=\"0.5\" //这个属性是和上面两个属性共同使用的,单独使用没有用,这个属性的意思是,在去除path的时候设置path原点的位置,按百分比设置,取值范围0到1 /&gt; &lt;/group&gt;&lt;/vector&gt; 下面就来重点讲解path标签，path标签是用来创建SVG的，就像用指令控制一只画笔，path标签所支持的指令有以下几种。 path 标签中的绘图指令12345678910M &#x3D; moveto(M X, Y): 将画笔移动到指定的位置，但未发生绘制L &#x3D; lineto(L X, Y): 画直线到指定位置H &#x3D; horizontal(H X): 画水平线到指定X坐标V &#x3D; vertical lineto(V Y): 画垂直线到指定Y坐标C &#x3D; curveto(C X1,Y1,X1,Y2,ENDX,ENDY): 画三次贝塞尔曲线S &#x3D; smooth curveto(S X2,Y2,ENDX,ENDY): 画三次贝塞尔曲线Q &#x3D; quadratic Belzier curve(Q X,Y,ENDX,ENDY): 二次贝塞尔曲线T &#x3D; smooth quadratic Belzier curveto(T ENDX,ENDY): 映射前面路径后的终点A &#x3D; elliptical Arc(A RX,RY,XROTATION,FLAG1,FLAG2,X,Y): 画弧线Z &#x3D; closepath(): 关闭路径，把前面的路径连起来 在使用以上指令时，需要注意： 坐标轴以（0，0）为中心，X轴水平向右，Y轴水平向下 所有指令大小写均可。大写绝对定位，参考全局坐标系；小写相对定位，参考父容器坐标系 指令和数据间的空格可以省略，可以用逗号隔开，也可以用空格 同一指令出现多次可以只用一个 SVG的指令参数非常复杂，但是在android中，不需要太多太复杂的SVG图形，所以我们先来掌握几个常用的指令，在以后的学习中，读者将会慢慢掌握更多的SVG绘制技巧和方法。 常用指令讲解 M ：类似Android绘图中path类的moveTo方法，即将画笔移动到某一点但并没有发生绘制动作，下面配合L进行讲解 L ：画一条直线 123&lt;path ...省略一些代码 android:pathData=\"M 20 50 L 80 50\"/&gt; 如图： 上面表示把画笔放在（20,50）位置，连直线到80，50点 。 同时L后面还可以跟H或V指令来绘制水平、竖直线，后面的参数是x坐标（H指令）或y坐标（V指令）,如下： 123&lt;path ...省略一些代码 android:pathData=\"M 20 50 L 80 50 V 80 H 20\"/&gt; 如图： A ：绘制一段弧线，且弧线不允许闭合，可以把弧线想象成椭圆的某一段，A指令有以下7个参数： RX，RY 指所在椭圆的半轴大小 XROTATION 指椭圆的X轴与水平方向的顺时针方向夹角，可以想象成一个水平的椭圆绕中心点顺时针旋转XRORATION的额角度 FLAG1 只有俩个值，1表示大角度弧线，0表示小角度弧线 FLAG2 只有俩个值，1为顺时针，0反之 X，Y 为终点坐标 看代码： 12345&lt;path ...省略一些代码 android:pathData=\" M 50 50 a 30 15 0 1 0 1 0\"/&gt; 再看图： 图一 上面表示把画笔放在（50,50）位置；30, 15分别表示椭圆的x，y半轴大小；0表示x轴不旋转；1表示用大角度弧线绘制；0表示顺时针：1，0表示相对与以（50，50）为起始点的坐标轴的坐标，因为a是小写。再看一段代码： 12345&lt;path ...省略一些代码 android:pathData=\" M 25 50 a 25 25 0 1 0 50 0\" /&gt; 再看图： 图二 可以看到这里显示了一个半圆，因为这里的X，Y轴大小相等 。 再看一段代码： 1234&lt;path ...省略一些代码 android:pathData=\"M 25 50 a 25 25 0 1 0 40 0\" /&gt; 再看图： 图三 这里把终点x轴坐标改为40，图中显示了圆的大部分 。 看一段代码： 1234&lt;path ...省略一些代码 android:pathData=\"M 25 50 a 25 25 0 0 0 40 0\" /&gt; 再看图： 图四 这里把FLAG1改为0，与图三相比，发现弧度变小了，因为用小弧度画。 看一段代码： 1234&lt;path ...省略一些代码 android:pathData=\"M 25 50 a 25 25 0 0 1 40 0\" /&gt; 再看图： 图五 这里把FLAG2改为1，与图四相比，图形翻转了，因为画的方向不一样了 , 把A指令的几个图结合看一下，就能弄懂A这个指令了。 关于贝塞尔指令的，这里就不过多介绍了，放出几个链接供大家学习：贝塞尔曲线初探SVG讲解 VectorDrawable和AnimatedVectorDrawableCoogle在Android5.0X中提供了俩个API来帮助支持SVG： VectorDrawable AnimatedVectorDrawable 其中VectorDrawable用于创建XML文件的SVG图形，即前面的vector标签，并结合AnimatedVectorDrawable来完成动画效果。 1、 VectorDrawable在XML中创建一个静态的XMLSVG图形，通常会形成如下的树形结构： 树形结构 path是树形结构中最小的单位，而通过Group可以将不同的path进行组合，接下来我们使用vector标签创建SVG图形，代码如下： 12345678910111213141516171819202122232425&lt;vector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:width=\"200dp\" android:height=\"200dp\" android:viewportWidth=\"100\" android:viewportHeight=\"100\"&gt; &lt;group android:name=\"line\"&gt; &lt;path android:name=\"path1\" android:strokeColor=\"@android:color/holo_green_dark\" android:strokeWidth=\"5\" android:strokeLineCap=\"round\" android:pathData=\" M 20 20 L 50 20 80 20\"/&gt; &lt;path android:name=\"path2\" android:strokeLineCap=\"round\" android:strokeWidth=\"5\" android:strokeColor=\"@android:color/holo_green_dark\" android:pathData=\" M 20 80 L 50 80 80 80\"/&gt; &lt;/group&gt;&lt;/vector&gt; 上面的代码画了俩条线，每条线由三个点控制，形成初始状态，下面立马通过AnimatedVectorDrawable来实现动画效果。 源码文末给出2、 AnimatedVectorDrawableAnimatedVectorDrawable就是通过连接静态的VectorDrawable和动态的objectAninmator来为VectorDrawable提供动画效果，分几个步骤来使用： 1、在XML中通过animated-vector标签来声明对AnimatedVectorDrawable的使用，并指定它的drawable属性，target标签中的name属性和animation属性 代码如下： 123456789&lt;animated-vector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:drawable=\"@drawable/svg_path\"&gt; &lt;target android:animation=\"@animator/anim_path1\" android:name=\"path1\"/&gt; &lt;target android:animation=\"@animator/anim_path2\" android:name=\"path2\"/&gt;&lt;/animated-vector&gt; android:drawable=”@drawable/svg_path”指定了上面创建的VectorDrawable即画的俩条线；target标签中的name指定了要作用动画的path或Group的name, 即俩者的name要保持一致，这样系统才能找到要实现动画的元素;taret标签中的animation指定了要作用的都动画。 在本例中，path1的动画代码如下: 123456789101112&lt;objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"500\" android:propertyName=\"pathData\" android:valueType=\"pathType\" android:valueFrom= \"M 20 20 L 50 20 80 20\" android:valueTo= \"M 20 20 L 50 50 80 20\" android:interpolator=\"@android:anim/bounce_interpolator\"&gt;&lt;/objectAnimator&gt; path2的动画代码如下： 123456789101112&lt;objectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"500\" android:propertyName=\"pathData\" android:valueType=\"pathType\" android:valueFrom= \"M 20 80 L 50 80 80 80\" android:valueTo= \"M 20 80 L 50 50 80 80\" android:interpolator=\"@android:anim/bounce_interpolator\"&gt;&lt;/objectAnimator&gt; 以上的俩个动画代码中都定义了一个pathType的属性动画，并指定了变换的初始值分别为： 12345678//path1 android:valueFrom= \"M 20 20 L 50 20 80 20\"//path2 android:valueFrom= \"M 20 80 L 50 80 80 80\" 结束值为: 12345678//path1 android:valueTo= \"M 20 20 L 50 50 80 20\"//path2 android:valueTo= \"M 20 80 L 50 50 80 80\" 这里要注意的是，SVG的路径变换属性动画中，变换前后的节点数必须相同，这也是为什么前面需要使用三个点来绘制一条直线，因为后面需要中点进行动画变换 。 2、把AnimatedVectorDrawable的XML文件设置给ImageView 1234&lt;ImageView android:id=\"@+id/iv_path\" android:src=\"@drawable/svg_path_anim\" .../&gt; 3、代码中启动AnimatedVectorDrawable动画 123456789101112ImageView ivPath;...ivPath = findViewById(R.id.iv_path); ivPath.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Drawable drawable = ivPath.getDrawable(); if(drawable instanceof Animatable)&#123; ((Animatable)drawable).start(); &#125; &#125; &#125;); 这样俩个path就实现了动画效果，如图： 结语了解了上面SVG知识，也就基本入门了，可以用SVG来实现简单的图标，当然现在也有一些工具来生成SVG图片，不用我们手动去写xml，但是了解它背后的实现也是很重要的，在以后的深入学习中，你会发现SVG结合动画会产生非常好看的动态效果。希望大家阅读完有所收获。 本文相关源码 参考资料： 《Android群英传》 SVG教程","tags":[{"name":"svg","slug":"svg","permalink":"http://yoursite.com/tags/svg/"}]},{"title":"Activity应用窗口的添加过程","date":"2019-07-10T07:20:32.000Z","path":"2019/07/10/Activity应用窗口的添加过程/","text":"前言 上一篇文章Window, WindowManager和WindowManagerService之间的关系 从上一篇文章中，我们了解到了Window的体系机制，也知道了window分为三种类型，分别是应用窗口(Application Window)、子窗口(Sub Window)、系统窗口(System Window），本文通过源码以Activity为例讲解一下应用窗口的添加过程，如果没看过上一篇文章建议先看，对于不同类型的窗口的添加，它们在WindowManager中的处理过程会有一点不一样，但是对于在WMS的处理过程中，基本上都是一样的。所以本文深入讲解一下Activity窗口的添加过程，知道了这个过程，对于其他类型的窗口添加也就能举一反三了。 本文基于Android8.0, 相关源码位置如下: frameworks/base/core/java/android/view/*.java（*代表Window, WindowManager, WindowManagerImpl，WindowManagerGlobal, ViewRootImpl） frameworks/base/core/java/android/app/*.java（*代表Activity，ActivityThread） frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java frameworks/base/services/core/java/com/android/server/wm/Session.javaActivity的Window创建 - Activity :: attach()熟悉Activity启动流程的都知道Window的创建过程是在activity的attach方法中，它在调用Activity的onCreate方法前完成一些重要数据的初始化，如下： 123456789101112131415161718192021222324252627282930313233//Activity.javafinal void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback) &#123; //... //1、关注这里，创建PhoneWindow mWindow = new PhoneWindow(this, window, activityConfigCallback); //下面都是设置window的一些属性，如回调、软键盘模式 mWindow.setWindowControllerCallback(this); //这个设置Window的Callback回调 mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions); &#125; //... //2、关注这里，把Window与WindowManager进行关联 mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); //把WindowManager与Activity进行关联 mWindowManager = mWindow.getWindowManager(); //...&#125; 在attach里。跟Window无关的我都省略掉了，我们看到attach方法里，在注释1中，首先new 了一个PhoneWindow赋值mWinow，mWindow是Window类型，它是一个抽象类，所以从这里可以看出Activity的Window的具体实现类是PhoneWindow，接下来，给mWindow设置回调，传入的参数是this，说明Activity实现了这些回调接口，这样当Window接收到外界的状态变化或输入事件时就会回调Activity的方法，其中我们比较熟悉的接口回调是Window的Callback接口，它里面有我们熟悉的回调方法如：dispatchTouchEvent()、onWindowFocusChanged()、onAttachedToWindow()和onDetachedFromWindow()。 接着我们来看注释2，这里通过Window的setWindowManager方法把WanagerManger与Window进行关联，然后通过Window的getWindowManager()把WanagerManger与Activity进行关联。 Window与WanagerManager的关联 - Window :: setWindowManager()我们知道Window的添加、更新和删除都是要通过WanagerManager的，接下来我们看看Window与WanagerManager是如何关联的，从上面知道该过程是在Window的setWindowManager方法中，如下： 12345678910111213141516//Window.javapublic void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) &#123; //token是Window的重要属性之一，是IBinder类型，它这里等于Activity中的mToken mAppToken = appToken; //应用名 mAppName = appName; //是否硬件加速 mHardwareAccelerated = hardwareAccelerated || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false); //获得系统级服务WMS在本地进程的代理 if (wm == null) &#123; wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE); &#125; //1、关注这里，调用WindowManagerImpl的createLocalWindowManager方法，创建WindowManager mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); &#125; 在setWindowManager方法中，是有关window的一些属性的赋值，其中mAppToken是Activity中的token，它在Activity启动的过程中从AMS中传递过来的，这里你只要记住Activity应用窗口的token值是Activity中的token值，接下来如果wm为空就获取WMS并转成WindowManager赋值给wm，wm是WindowManager，它是一个接口，它的具体实现类是WindowManagerImpl，所以接下来的注释1中wm转成WindowManagerImpl，并调用WindowManagerImpl的createLocalWindowManager方法，我们来看看WindowManagerImpl的createLocalWindowManager方法，如下： 123456789//WindowManagerImpl.javapublic WindowManagerImpl createLocalWindowManager(Window parentWindow) &#123; return new WindowManagerImpl(mContext, parentWindow);&#125; private WindowManagerImpl(Context context, Window parentWindow) &#123; mContext = context; mParentWindow = parentWindow;&#125; 这个方法很简单，只是简单的返回一个WindowManagerImpl对象，注意它传入了一个parentWindow参数，它是Window类型，说明此时构建的WindowManagerImpl是与具体的Window关联的，至此，在java层上Window就已经与WindowManager建立起联系。 Activity的Window的视图创建 - Window :: setContentView()从上一篇文章我们知道，View是依附在Window上的，在Activity的启动过程中的attach方法里已经完成了Activity的Window的创建和与WindowManager的关联，那么Activity的视图即View是在哪里创建的呢？答案是在我们熟悉的setContentView方法中，我们先来看一张图： 如图所示每一个Activity都有一个顶级View叫做DecorView，一般情况下它会包含一个竖直方向的LinearLayout，在这个LinearLayout中包含两部分(具体情况与Android的版本与主题有关)，上面是标题栏，下面是内容布局，内容布局其实是一个FrameLayout，我们平时setContentView指定的布局其实是set到了这个FrameLayout中，所以这个方法叫setContentView也是也是很贴和实际的，因为FrameLayout的id就是android.R.id.content，理解了这些知识后，我们来看Activity中的setContentView方法，如下： 1234567//Activity.javapublic void setContentView(@LayoutRes int layoutResID) &#123; //1、关注这里，其实调用的是PhoneWindow的setContentView，setContentView里面会加载内容布局并添加进DecorView中 getWindow().setContentView(layoutResID); //如果Activity主题是带ActionBar的话，这里面就会创建ActionBar并添加进DecorView中 initWindowDecorActionBar();&#125; 我们看注释1，前面已经讲过Activity的Window的创建，所以这里的getWindow其实返回的是Window，而Window的实现类是PhoneWindow，所以这里调用的是PhoneWindow的setContentView，并传入了我们的内容布局id，PhoneWindow的setContentView方法的相应源码如下： 12345678910111213141516171819202122232425262728//PhoneWindow.java@Overridepublic void setContentView(int layoutResID) &#123; //1，根据mContentParent是否为空做出不同动作，mContentParent就是上面所讲的id为android.R.id.content的布局，用来set我们id为layoutResID的内容布局 if (mContentParent == null) &#123; //1.1、mContentParent为空，创建DecorView，并加载mContentParent installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; //1.2、mContentParent不为空，并且没有转场动画，就把mContentParent中的View视图清空，下面会重新加载 mContentParent.removeAllViews(); &#125; //2、根据是否有转场动画，做出不同的动作 if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; //2.1、有转场动画，创建Scene完成转场动画 final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID， getContext()); transitionTo(newScene); &#125; else &#123; //2.2、没有转场动画，直接把我们的layoutResID的布局加载进mContentParent mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; //触发Activity的onContentChanged方法, 因为Activity实现了这些回调接口 cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; 从注释中可以看出这个方法如果忽略转场动画的处理的话，可以分为两部分，第一部分是注释1.1的DecorView的创建和加载mContentParent，第二部分是注释2.2的把我们的layoutResID的布局加载进mContentParent，其中重点是第一部分，下面我们来分析PhoneWindow的setContentView方法的第一部分。 1、PhoneWindow :: installDecor()我们来看PhoneWindow的installDecor方法，如下： 123456789101112131415161718//PhoneWindow.javaprivate void installDecor() &#123; //... //1、根据mDecor是否为空，做出不同动作，mDecor就是DecorView，它是继承自FrameLayout if (mDecor == null) &#123; //1.1、mDecor为空，就创建mDecor mDecor = generateDecor(-1); //... &#125; else &#123; //1.2、、mDecor不为空，不用重复创建，把Window设置给DecorView mDecor.setWindow(this); &#125; if (mContentParent == null) &#123; //2、如果mContentParent为空，就加载mContentParent mContentParent = generateLayout(mDecor); //... &#125;&#125; installDecor()有一百多行代码，但是重点就是上面几句，因为这里我们是第一次创建mDecor，所以mDecor就为空，那么上面就分为两部分，第一部分是注释1.1的创建mDecor，第二部分是注释2的加载加载mContentParent，我们先看installDecor方法的第一部分。 1.1 PhoneWindow :: generateDecor()PhoneWindow的generateDecor()方法如下： 123456789101112//PhoneWindow.javaprotected DecorView generateDecor(int featureId) &#123; Context context; if (mUseDecorContext) &#123; Context applicationContext = getContext().getApplicationContext(); //... &#125; else &#123; context = getContext(); &#125; //1、关注这里，new了一个DecorView return new DecorView(context, featureId, this, getAttributes());&#125; 可以看到generateDecor就是简单的创建了一个DecorView并返回，其中this是Window实例，DecorView的构造方法中会把Window设置给DecorView中的mWindow。我们看一下DecorView是什么，如下： 1234//DecorView.javapublic class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks &#123; //...&#125; 可以看到DecorView就是一个FrameLayout。 我们回到installDecor方法中，接下来我们来看installDecor方法的第二部分。 1.2 PhoneWindow :: generateLayout(mDecor)PhoneWindow的generateLayout()方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//PhoneWindow.javaprotected ViewGroup generateLayout(DecorView decor) &#123; //这里获取到当前的Activity的主题theme的属性，下面忽略的，都是根据theme的属性设置Activity的Window TypedArray a = getWindowStyle(); //... //这个layoutResource是一个布局id int layoutResource; //获得theme的features int features = getLocalFeatures(); //下面根据features获得不同的layoutResource if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; layoutResource = R.layout.screen_swipe_dismiss; setCloseOnSwipeEnabled(true); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_LEFT_ICON) | (1 &lt;&lt; FEATURE_RIGHT_ICON))) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleIconsDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_title_icons; &#125; removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; ((1 &lt;&lt; FEATURE_PROGRESS) | (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS))) != 0 &amp;&amp; (features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) == 0) &#123; layoutResource = R.layout.screen_progress; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_CUSTOM_TITLE)) != 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogCustomTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else &#123; layoutResource = R.layout.screen_custom_title; &#125; removeFeature(FEATURE_ACTION_BAR); &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) == 0) &#123; if (mIsFloating) &#123; TypedValue res = new TypedValue(); getContext().getTheme().resolveAttribute( R.attr.dialogTitleDecorLayout, res, true); layoutResource = res.resourceId; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_BAR)) != 0) &#123; layoutResource = a.getResourceId( R.styleable.Window_windowActionBarFullscreenDecorLayout, R.layout.screen_action_bar); &#125; else &#123; layoutResource = R.layout.screen_title; &#125; &#125; else if ((features &amp; (1 &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != 0) &#123; layoutResource = R.layout.screen_simple_overlay_action_mode; &#125; else &#123; //1、我们选取这个 R.layout.screen_simple 布局作为例子看一下 layoutResource = R.layout.screen_simple; &#125; mDecor.startChanging(); //2、将上面获取到的layoutResource对应的布局加载进DecorView中 mDecor.onResourcesLoaded(mLayoutInflater, layoutResource); // //3、因为layoutResource对应的布局已经加载进DecorView中了，所以这里可以通过findViewById获取android.R.id.content的布局 ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); //... mDecor.finishChanging(); //返回id为android.R.id.content的布局，赋值给mContentParent return contentParent;&#125; generateLayout()这个方法非常长，但是它里面的逻辑很简单，这个方法的主要作用是根据当前的Activity的theme的属性设置Activity的Window，并把根据features获取到的布局加载进传进来的DecorView，并从DecorView中获取android.R.id.content的布局返回给mContentParent，我们只要看懂注释1~3就清楚了。 首先我们看注释1，因为if…else…的语句非常多，所以我就选了最后一个else语句的layoutResource对应的布局文件讲解，它的位置在：/frameworks/base/core/res/res/layout/screen_simple.xml，如下： 12345678910111213141516171819202122&lt;!-- 还记得上面那张图吗，DecorView一般情况下它会包含一个竖直方向的LinearLayout --&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\" android:orientation=\"vertical\"&gt; &lt;!-- ViewStub是一个按需加载的View，它在用到时才会加载，而且只能加载一次，这里它的layout指向的是一个ActionBar的布局文件，所以这里把ViewStub看作一个ActionBar就行 --&gt; &lt;ViewStub android:id=\"@+id/action_mode_bar_stub\" android:inflatedId=\"@+id/action_mode_bar\" android:layout=\"@layout/action_mode_bar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:theme=\"?attr/actionBarTheme\" /&gt; &lt;!-- 这个就是id为android.R.id.content得布局，用来放置我们平时setContentView时set得内存布局 --&gt; &lt;FrameLayout android:id=\"@android:id/content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:foregroundInsidePadding=\"false\" android:foregroundGravity=\"fill_horizontal|top\" android:foreground=\"?android:attr/windowContentOverlay\" /&gt;&lt;/LinearLayout&gt; screen_simple.xml文件就是一个布局文件，大家把这个布局对应一下上面得那张图，就会有一种恍然大悟得感觉了，所以我们紧接着来看注释2，它就是把上面这个screen_simple.xml布局文件加载进DecorView中。 我们再看注释3，ID_ANDROID_CONTENT就是android.R.id.content的常量，看一下findViewById方法的源码，如下： 123456//PhoneWindow.java @Nullable public &lt;T extends View&gt; T findViewById(@IdRes int id) &#123; //getDecorView()就是获得到Window中的DecorView return getDecorView().findViewById(id); &#125; 可以看到findViewById方法中获取到DecorView，然后调用DecorView的findViewById方法，因为在注释2中我们已经把layoutResource对应的布局加载进DecorView中了，所以这时就获取到android.R.id.content的布局。在generateLayout方法的最后，把android.R.id.content的布局返回给mContentParent。 我们再回到installDecor方法中，至此我们已经创建好DecorView，也通过DecorView获取到mContentParent, 即android.R.id.content的布局。 我们来分析PhoneWindow的setContentView方法的第二部分。 2、mLayoutInflater.inflate(layoutResID, mContentParent)layoutResID就是我们setContentView传进来的内容布局id，所以这里就把内容布局加载进mContentParent中了。至此Window的setContentView分析完毕。 这个过程如下图： 我们回到Activity的setContentView方法，其实到这里Activity的视图，也可以是说Activity的Window的视图DecorView就创建好了，接下来就是把这个DecorView显示到屏幕上。 Activity的Window的视图添加 - WindowManager :: addView()熟悉Activity的启动流程的都知道，Activity会在handleResumeActivity方法中把DecorView显示出来，而添加一个Winow是通过WindowManager的addView方法实现的，但是Window只是View的载体，并不是真实存在的，所以addView其实就是添加一个View，这个View是依附在Window上，并且这个View是 View Hierarchy 最顶端的根 View，而Activity的的顶级View是DecorView, 所以添加Activity的Window就是添加DecorView。我们来看一下handleResumeActivity方法，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//ActivityThread.javafinal void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; //ActivityClientRecord里面保存了Activity的信息 ActivityClientRecord r = mActivities.get(token); //... //这个方法里面最终会回调Activity的onResume方法 r = performResumeActivity(token, clearHide, reason); //所以下面都是在执行onResume方法后的行为 if (r != null) &#123; //得到Activity final Activity a = r.activity; //... //面if（r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible）&#123;&#125;分支里面的逻辑主要是把Activity的Window的DecorView添加到WMS中 if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; //获取前面Activit创建的Window r.window = r.activity.getWindow(); //获取前面Window创建的DecorView View decor = r.window.getDecorView(); //先把DecorView设为不可见 decor.setVisibility(View.INVISIBLE); //Activity关联的WindowManager ViewManager wm = a.getWindowManager(); //下面设置Window的布局参数 WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; //窗口的类型是TYPE_BASE_APPLICATION，应用类型窗口 l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; //... if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; //1、关注这里，调用WindowManager的addView方法 wm.addView(decor, l); &#125; else &#123; //... &#125; &#125; &#125;else if (!willBeVisible) &#123; //... &#125; //... //面if（r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible）&#123;&#125;分支里面的逻辑主要是把DecorView显示出来 if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; //... if (r.activity.mVisibleFromClient) &#123; //2、关注这里，上面已经把Window添加到WMS中了，所以里面会把DecorView显示出来, 见下面Activity.java r.activity.makeVisible(); &#125; &#125; //... &#125; //...&#125;//Activity.javavoid makeVisible() &#123; //... //把DecorView设为可见 mDecor.setVisibility(View.VISIBLE);&#125; 上面的注释已经写的很清楚了，重点就是一句话：获取Activity的Window中的DecorView并调用WindowManager的addView方法添加DecorView，然后把DecorView设置为可见。到这里视图的添加已经转移到WindowManager中，阅读过上一篇文章的知道，WindowManager的实现类是WindowManagerImp，WindowManagerImp会把大部分操作转发给WindowManagerGlobal。 1、WindowManagerGlobal :: addView()所以我们直接看方法WindowManagerGlobal的addView()就行，如下： 123456789101112131415161718192021222324252627282930313233343536//WindowManagerGlobal.javapublic void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; //... //获取Window的LayoutParams final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; //这里的parentWindow不为空，因为从上面的Window与WanagerManager的关联可知，会调用createLocalWindowManager(this)来创建一个WanagerManagerImpl，这个this代表的PhoneWindow实例会传进WanagerManagerImpl构造中赋值给mParentWindow //1、调整窗口布局参数 if (parentWindow != null) &#123; //如果有设置父窗口，会通过adjustLayoutParamsForSubWindow()来调整params parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; //... &#125; ViewRootImpl root; synchronized (mLock) &#123; //... //2、构建ViewRootimpl root = new ViewRootImpl(view.getContext(), display); //3、把View、ViewRootimpl、LayoutParams保存 //把上面调整好的params设置给待添加的View view.setLayoutParams(wparams); //把待添加的View添加到View列表中 mViews.add(view); //把ViewRootimpl对象root添加到ViewRootimpl列表中 mRoots.add(root); //把params添加到params列表中 mParams.add(wparams); try &#123; //4、调用ViewRootImpl的setView将View显示到手机窗口上 root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; //... &#125; &#125;&#125; 上述方法主要分为4个部分，我们先来看WindowManagerGlobal的addView传进来的4个参数，其中view、params和display三者是必不可少的，view就代表待添加的View，这里是DecorView，params就代表窗口布局参数，diaplay代表的是表示要输出的显示设备，而parentWindow表示父窗口，这里的父窗口并不一定是真正意义上的父窗口，有可能就是描述一个窗口的对象本身。在上述分析Activity的 WindowManager创建时就提到parentWindow就是PhoneWindow本身。 1.1、adjustLayoutParamsForSubWindow(wparams)接下来我们来看这个方法，这个方法被分为4部分，其中第一部分是注释1，重点是Window的adjustLayoutParamsForSubWindow方法，用来调整params，该方法主要源码如下： 12345678910111213141516171819202122//Window.javavoid adjustLayoutParamsForSubWindow(WindowManager.LayoutParams wp) &#123; //... if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wp.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;//如果它是子窗口 if (wp.token == null) &#123; View decor = peekDecorView(); if (decor != null) &#123; //可以看到子窗口的token为顶级View的WindowToken wp.token = decor.getWindowToken(); &#125; &#125; //... &#125; else if (wp.type &gt;= WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW &amp;&amp; wp.type &lt;= WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) &#123;//如果它是系统窗口 //系统窗口没有为token赋值，因为系统窗口的生命周期不依赖于app，当app退出了，系统窗口不会受到影响，它还是能显示和接收外界的输入事件 //... &#125; else &#123;//如果它是应用窗口 if (wp.token == null) &#123; //可以看到应用窗口的token为Activity的mAppToken wp.token = mContainer == null ? mAppToken : mContainer.mAppToken; &#125; //...&#125; 这个方法主要是为Window的token赋值，如果是应用窗口且wp.token==null，就会给它赋值mAppToken，而这个mAppToken就是我们上面在Activity的attach()方法中传入的mToken，而系统窗口的token为null，原因注释中说了，我们再分析子窗口的token，接上面的decor.getWindowToken()，该方法如下: 1234//View.javapublic IBinder getWindowToken() &#123; return mAttachInfo != null ? mAttachInfo.mWindowToken : null;&#125; 可以看到子窗口的token就是View中mAttachInfo的mWindowToken，那么mAttachInfo是什么？它在哪里被赋值？我们先留一个疑问。 1.2、创建ViewRootImpl我们回到addView()方法继续看注释2，注释2构建了一个ViewRootimpl，WindowManagerGlobal会为每一个待添加的View创建一个ViewRootImpl，我们看ViewRootImpl的构造方法，如下： 1234567891011121314151617181920212223242526//ViewRootImpl.javapublic ViewRootImpl(Context context, Display display) &#123; mContext = context; //1、记住这个mWindowSession，待会用到 mWindowSession = WindowManagerGlobal.getWindowSession(); mDisplay = display; //... //2、创建了一个W对象，继承自IWindow.Stub，是一个IBinder类型，用来接收WMS的通知 mWindow = new W(this); //... //3、创建了一个mAttachInfo，这个mAttachInfo就是上面View中mAttachInfo，它在这里被创建，见下面View.AttachInfo的构造方法 mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this, context); //...&#125;//View.java AttachInfo(IWindowSession session, IWindow window, Display display, ViewRootImpl viewRootImpl, Handler handler, Callbacks effectPlayer) &#123; mSession = session; mWindow = window; //mWindowToken本质就是ViewRootImpl中的W类，只是调用asBinder转化了一下 mWindowToken = window.asBinder(); mDisplay = display; mViewRootImpl = viewRootImpl; //... &#125; ViewRootImpl的构造方法中，关键的就是上面三个注释，注释1下面会解释，注释2创建了一个W类对象，它是一个IBinder类型，它在后面会通过Binder IPC传送到WMS中，WMS就是通过这个W类对象和Activity所在进程交互，注释3创建了一个AttachInfo类对象，ViewRootImpl为每一个待添加的View创建一个AttachInfo类对象mAttachInfo，当这个待添加的View与ViewRootImpl建立联系(mView被赋值)后，ViewRootImpl就会调用performTraversal()方法遍历这颗View Hierarchy 把其mAttachInfo赋值给这颗View Hierarchy 中的每一个View的mAttachInfo，所以上面的decor.getWindowToken()中的mAttachInfo就不为空，这样子窗口的token就是mAttachInfo中的mWindowToken，从AttachInfo构造可以看出，传入的W类通过asBinder转化了一下赋值给mWindowToken，所以现在可以得出结论：子窗口的token就是ViewRootImpl中的W类。 1.3、 把View、ViewRootimpl、LayoutParams保存到列表我们回到addView()方法继续看注释3，第三部分就是把待添加的View、新创建ViewRootimpl、待添加的View的LayoutParams分别保存到3个列表，这三个列表在WindowManagerGlobal中，这三个列表的含义如下： 1234567//WindowManagerGlobal.javapublic final class WindowManagerGlobal &#123; private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();//mViews存储的是所有Window所对应的顶级View（即View Hierarchy最顶端的View） private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();//mRoots存储着所有Window所对应的ViewRootImpl private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams = new ArrayList&lt;WindowManager.LayoutParams&gt;();//mParams存储着所有Window所对应的布局参数 //...&#125; 1.4、通过ViewRootImpl 的setView()方法把DecorView显示到窗口上我们回到addView()方法继续看注释4，注释4就是调用ViewRootImpl的setView方法，它里面会请求View Hierarchy的绘制，并请求WMS显示待添加的View，我们看一下该方法，如下： 12345678910111213141516171819202122232425262728293031323334353637383940public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; //ViewRootImpl与待添加的View建立联系 mView = view; //... //接收WMS添加后的返回结果 int res； //1、请求绘制View Hierarchy requestLayout(); //... try &#123; //... //2、向通过mWindowSession向WMS发起显示当前Window的请求 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; catch (RemoteException e) &#123; //... &#125; //下面这些异常都是由于添加Window错误而抛出 if (res &lt; WindowManagerGlobal.ADD_OKAY) &#123; //... switch (res) &#123; case WindowManagerGlobal.ADD_BAD_APP_TOKEN: case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN: throw new WindowManager.BadTokenException( \"Unable to add window -- token \" + attrs.token + \" is not valid; is your activity running?\"); case WindowManagerGlobal.ADD_NOT_APP_TOKEN: throw new WindowManager.BadTokenException( \"Unable to add window -- token \" + attrs.token + \" is not for an application\"); //... &#125; //... &#125; &#125;&#125; 在setView方法中，我们先看注释1，在向WMS发起将View显示到手机窗口上前，先调用requestLayout绘制整颗View Hierarchy，这个方法里面会通过Choreographer的postCallback方法注册对应的绘制回调(CALLBACK_TRAVERSAL)，等待vsync信号，然后会触发整个View树的绘制操作，也就是performTraversal()方法的执行。我们来看注释2，到这里Activity的Window的添加就交给了mWindowSession，它是一个IWindowSession类型，IWindowSession是一个AIDL接口文件，需要编译后才生成IWindowSession.java接口，mWindowSession是在上面的ViewRootImpl的构造中被赋值的：mWindowSession = WindowManagerGlobal.getWindowSession();，关于这部分的已经在上一篇文章讲解过了，所以注释2其实最终调用的Session的addToDisplay()方法，在addToDisplay()中返回了WMS的addWindow()的返回结果,所以从这里开始添加Window的过程转移到WMS进程中去。 2、WMS :: addWindow()我们就简单的过一遍WMS的addWindow()方法，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; int[] appOp = new int[1]; //如果窗口时系统窗口，还要进行权限检查 int res = mPolicy.checkAddPermission(attrs, appOp); if (res != WindowManagerGlobal.ADD_OKAY) &#123; return res; &#125; //... final int type = attrs.type; synchronized(mWindowMap) &#123; //省略的是检查Display显示信息, //... //如果是子窗口 if (type &gt;= FIRST_SUB_WINDOW &amp;&amp; type &lt;= LAST_SUB_WINDOW) &#123; //通过windowForClientLocked()方法还要检查其父窗口是否存在 parentWindow = windowForClientLocked(null, attrs.token, false); //如果父窗口不存在，返回错误 if (parentWindow == null) &#123; //... return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN; &#125; //如果父窗口还是子窗口，返回错误 if (parentWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; parentWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) &#123; //... return WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN; &#125; &#125; //... //检查token AppWindowToken atoken = null; ////是否有父窗口 final boolean hasParent = parentWindow != null; //如果它有父窗口，就使用父窗口的token，如果没有，就是使用自己的token WindowToken token = displayContent.getWindowToken( hasParent ? parentWindow.mAttrs.token : attrs.token); //如果它有父窗口，就使用父窗口的type，如果没有，就是使用自己的type final int rootType = hasParent ? parentWindow.mAttrs.type : type; if (token == null) &#123; if (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;//如果是应用窗口，但是它的token为空，返回错误 //... return WindowManagerGlobal.ADD_BAD_APP_TOKEN; &#125; //... &#125; else if (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) &#123;//如果是应用窗口，但是它的token不是mAppToken（mApptoken是从AMS传过来的），返回错误 atoken = token.asAppWindowToken(); if (atoken == null) &#123; //... return WindowManagerGlobal.ADD_NOT_APP_TOKEN; &#125; else if (atoken.removed) &#123; //... return WindowManagerGlobal.ADD_APP_EXITING; &#125; &#125; //这里省略的是，一些系统窗口的token 不能为空，并且通过token检索到的WindowToken的类型不能是其本身对应的类型 //... else if (token.asAppWindowToken() != null) &#123; //某些系统窗口的token应该为空，但是却不为空，所以这里把token清空 attrs.token = null; token = new WindowToken(this, client.asBinder(), type, false, displayContent, session.mCanAddInternalSystemWindow); &#125; //... //经过一系列的检查后，会创建一个WindowState final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], seq, attrs, viewVisibility, session.mUid, session.mCanAddInternalSystemWindow); //... //走到这里证明没有任何错误发生，res = ADD_OKAY res = WindowManagerGlobal.ADD_OKAY; //... //WindowState的attach方法创建了一个SurfaceSession对象用于与SurfaceFlinger服务通信 win.attach(); //client就是Activity进程那边传过来的ViewRootImpl中的W类，这里用asBinder转化了一下，所以这里以W类为Key，WindowState为Value建立映射存放进mWindowMap中，它是一个WindowHashMap类型 mWindowMap.put(client.asBinder(), win); &#125;&#125; 这个方法很长，但是里面的逻辑还是很有规律，建议对照着注释跟源码看一遍，这里总结一下这个方法的过程： 1、首先如果是系统窗口要进行权限检查，mPolicy是一个PolicyWindowManager类型，如果想知道哪些系统窗口是需要权限的可以查看这个PolicyWindowManager的checkAddPermission()方法，这个方法检查如果不是系统类型的窗口就会返回一个ADD_OKAY表示检查通过，否则表示检查不通过，代表着这个系统窗口没有在Manifest.xml文件中声明权限。 2、如果是子窗口类型，就通过windowForClientLocked()方法还要检查其父窗口是否存在，子窗口一定要有父窗口。 3、根据类型type检查token是否有效，应用窗口和子窗口的token是一定要赋值的，否则创建窗口会抛异常，且应用窗口中的token必须是某个有效的 Activity 的 mToken。而子窗口中的token必须是父窗口的 ViewRootImpl 中的 W 对象。对于部分系统窗口其token也要赋值，有些系统窗口的token不需要赋值。这个token赋值规则可以对照上面的adjustLayoutParamsForSubWindow(wparams)的方法解说。 4、通过WindowState的attach方法，WMS把渲染Window视图的任务交给了SurfaceFlinger。 5、一系列的检查后，WMS会为每一个Window会创建一个WindowState，并以传过来的W类为Key，新创建的WindowState为Value建立映射存放进WindowHashMap中，这个WindowState维护着窗口的状态以及根据适当的机制来调整窗口的状态。 这个添加过程如下图： 总结以上就是Activity的Window的添加过程，我们发现添加一个Window最重要的是View、type和token，至于其他类型窗口的添加相似的，一图总结本文，如下： 从图中可以看到，添加一个Window，会涉及到两个进程的交互，一个是Activity所在的应用进程，一个是WMS所在的系统服务进程，所以绿色的那部分就代表着IPC，ViewRootImpl通过WindonManagerGlobal的静态变量sWindowSession负责与WMS通信，它是Session类型，在ViewRootImpl构造中被赋值，WMS中的每个Window的WindowState的mClient负责与Activity所在的应用进程通信，它是W类型，在创建WindowState构造中被赋值，在Activity所在的应用进程的WindonManagerGlobal中会为每一个添加的Window中的View创建一个ViewRootImpl，所以多个Window就对应多个ViewRootImpl，而在WMS中，Window对应着一个View，它会为每一个Window创建一个WindowState以维护Window的状态，所以多个Window就多个WindowState。 从应用窗口的添加过程中，对Window的机制也有了一些了解，以后如果遇到有关于Window的添加的异常也懂得去哪里找原因。 参考资料： Android Window 机制探索 浅析 Android 的窗口","tags":[{"name":"window","slug":"window","permalink":"http://yoursite.com/tags/window/"},{"name":"windowManager","slug":"windowManager","permalink":"http://yoursite.com/tags/windowManager/"},{"name":"WMS","slug":"WMS","permalink":"http://yoursite.com/tags/WMS/"},{"name":"activity","slug":"activity","permalink":"http://yoursite.com/tags/activity/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"发布开源库到jitpack","date":"2019-06-10T10:47:41.000Z","path":"2019/06/10/发布开源库到jitpack/","text":"前言最近几天准备发布一个开源库，方便自己使用，一开始了解到的是发布到jcenter仓库中，它是目前世界上最大的java和Android开源软件构件仓库，而且 JCenter 是 Android Studio 默认使用的服务器仓库，只需要一句话就可以搞定整个包的导入过程，但是它的发布过程繁琐，而且对于新手来说特别不友好，就算你跟着网上教程来发布，运气好的话你就会发布成功，如果运气不好，你就会遇到很多构建失败、上传失败、翻墙等问题，而且在网上还找不到答案。我就属于运气不好的一类，我发布的时候几乎是使用了所有方法，但还是失败，就在我心灰意冷的时刻，我发现了jitpack，几步操作就把开源库发布成功，真的是简单了许多，有种相见恨晚的感觉，下面就把我发布的过程分享给大家。 JitPack是什么？在讲解发布流程之前先简单介绍一下jitpack是什么，JitPack是一个网站，它允许你把git托管的java或android项目（貌似目前仅支持github和码云），轻松发布到jitpack的maven仓库上，它所有内容都通过内容分发网络（CDN）使用加密https连接获取。 发布步骤下面开始讲解发布步骤。以我的开源库Loading为例。 1、准备好你要发布的librarylibrary不同于app工程，library是没有applicationId的，还有build.gradle中apply的的插件也不一样，在AS中按如下操作新建一个library：File -&gt; new -&gt; New Moudle -&gt; Android Library -&gt; next -&gt; 填写好信息后 -&gt; finish。 2、给你要发布libaray添加配置2.1、首先在项目的根目录的build.gradle下添加maven插件，如下： 可以去这里查看插件的最新版本android-maven-gradle-plugin。 2.2、然后再library目录的build.gradle下apply插件和添加group，如下： group填com.github.你的github账号名，这里我的是rain9155。 3、执行gradlew命令，排错再命令行下输入gradlew install命令，这个命令会构建你的library到你的本地 maven 仓库($HOME/.m2/repository)中，如下： 如果出现BUILD SUCCESS，说明构建成功，如果出现BUILD FAIL，说明构建失败，这时候你就要按照失败提示去排错，排错完后在执行一遍gradlew install命令，直到出现BUILD SUCCESS。 4、本地打tag，上传到github中4.1、在打tag前，你要先执行git add .和git commit -m “XX”命令，把代码提交到本地git仓库 4.2、然后开始在本地git仓库打tag，如下： 打tag本质就是提交一个commit，-a后面写版本号，一般是v1.0或v1.0.0，-m后面写描述信息，这里写了第一版，然后把tag push到github上面。 5、github上面发布release打开你的libary的github界面，点击release，如下： 然后点击Draft a new release，新建一个release，如下： 然后填信息，如下： 填好信息后，点击publich release，如下： 其实relese就是一个加了描述信息的tag。 6、用GitHub账号登陆、注册jitpack，Look Up -&gt; Get it登陆jitpack后，在jitpack的地址栏中输入你的library的的github项目地址，然后点击Look Up，如下： 点击Look Up后，下面会出现项目在github上发布的release版本，你有多少个release，下面就会显示多少个，然后点击Get it，如下： 点击Get it后，它会滚到下面去，你要滚回上面去，先等一会，等jitpack那里构建完，会出现一个绿色的log，如下： 如果出现红色的log，说明构建失败，你可以点击进去看一下失败原因，出现绿色的代表成功，然后再点Get it，它会滚到下面去，如下： 可以看到，它提示了你如何用gradle方式引用你的开源库，maven { url &quot;https://jitpack.io&quot; }就是指定私有Maven库为JitPack，implementation com.github.rain9155:Loading:Tag则是指定具体的包。然后你就可以愉快的在项目中按照它的提示引用你的开源库。 更多请查看示例Loading。 其他jitpack也是有勋章的，如下： 点击那个jitpack，把它的链接复制到你的REMAED中去，如下： 结语JitPack是基于GitHub Releases的发布。当你打完tag，生成一个Release时，源文件会自动打包成zip。在JitPack上点击【Get it】，就可以编译这个tag的源文件，把版本发布到这个私有Maven库中，并且可以提供给其他人使用。比起Bintray的JCenter，或者Maven Central这个官方中央仓库来说，JitPack背靠GitHub，少了一大堆流程。","tags":[{"name":"jitpack","slug":"jitpack","permalink":"http://yoursite.com/tags/jitpack/"}]},{"title":"android6.0动态权限申请的正确流程","date":"2019-06-06T10:13:59.000Z","path":"2019/06/06/android6-0动态权限申请的正确流程/","text":"前言从 Android 6.0（API 级别 23）开始，用户开始在应用运行时向其授予权限，而不是在应用安装时授予。所以如果你的应用使用到了一些危险权限，就必须在AndroidManifest.xml 中静态地声明需要用到的权限，并在使用到该功能时要动态的申请，否则在调用到相应权限功能时候，会抛出 SecurityException异常。所以本文探讨一下动态权限的申请的正确流程，并把它封装成一个库，简化了申请过程。 PermissionHelper 权限的分类在讲解之前，先看一下android权限的分类，android权限分为四类，如下： 1、普通权限普通权限也叫正常权限，它不需要动态申请，你只需要在用到它的时候在AndroidManifest.xml 中静态地声明，然后系统在app运行时就会自动的授予该app相应的权限。这类权限主要在你的app想要接触app沙盒外的数据或资源的时用到，它不会涉及到系统的操作，也不会泄漏或篡改用户的隐私数据。如下： 123456789101112131415161718192021222324252627282930313233343536ACCESS_LOCATION_EXTRA_COMMANDS ACCESS_NETWORK_STATE ACCESS_NOTIFICATION_POLICY ACCESS_WIFI_STATE BLUETOOTH BLUETOOTH_ADMIN BROADCAST_STICKY CHANGE_NETWORK_STATE CHANGE_WIFI_MULTICAST_STATE CHANGE_WIFI_STATE DISABLE_KEYGUARD EXPAND_STATUS_BAR FOREGROUND_SERVICE GET_PACKAGE_SIZE INSTALL_SHORTCUT INTERNET KILL_BACKGROUND_PROCESSES MANAGE_OWN_CALLS MODIFY_AUDIO_SETTINGS NFC READ_SYNC_SETTINGS READ_SYNC_STATS RECEIVE_BOOT_COMPLETED REORDER_TASKS REQUEST_COMPANION_RUN_IN_BACKGROUND REQUEST_COMPANION_USE_DATA_IN_BACKGROUND REQUEST_DELETE_PACKAGES REQUEST_IGNORE_BATTERY_OPTIMIZATIONS SET_ALARM SET_WALLPAPER SET_WALLPAPER_HINTS TRANSMIT_IR USE_FINGERPRINT VIBRATE WAKE_LOCK WRITE_SYNC_SETTINGS 2、签名权限该类权限只对拥有相同签名的应用开放。例如某个应用自定义了一个permission 且在权限标签中加入 android:protectionLevel=”signature”，其他应用想要访问该应用中的某些数据时，必须要在AndroidManifest.xml中声明该权限，而且还要与该应用具有相同的签名，系统会在app运行时自动授予该权限。这类我们用的比较少。 3、危险权限也叫敏感权限，运行时权限，跟普通权限相反，一旦某个应该获取了该类权限，用户的隐私数据就面临被泄露篡改的风险。所以你想使用该权限就必须在AndroidManifest.xml 中静态地声明需要用到的权限，并在使用到该功能时要动态的申请，除非用户同意该权限，否则你不能使用该权限对应的功能。如下： 可以看到android把危险权限分为10组，所以申请危险权限的时候都是按组申请，我们只要申请组内的任意一个危险权限就行，当用户一旦同意授权该危险权限，那么该权限所对应的权限组中的所有其他权限也会同时被授权。 4、特殊权限特殊权限我了解的有三个，如下： SYSTEM_ALERT_WINDOW：设置悬浮窗 WRITE_SETTINGS：修改系统设置 REQUEST_INSTALL_PACKAGES： 允许应用安装未知来源应用 它也是要要申请的，但是它不同于危险权限的申请，危险权限的申请会弹出一个对话框询问你是否同意，而特殊权限的申请需要跳转到指定的界面，让你手动确认同意。 动态权限申请流程所以动态权限的申请就是申请危险权限或特殊权限，权限的申请在不同的Android版本有不同的行为，如下： 如果设备运行的是 Android 5.1 或更低版本，或者应用的 targetSdkVersion 为 22 或更低：如果您在 Manifest 中列出了危险权限，则用户必须在安装应用时系统会要求用户授予此权限，如果他们不授予此权限，系统根本不会安装应用，用户一旦全部同意授予，他们撤销权限的唯一方式是卸载应用。 如果设备运行的是 Android 6.0 或更高版本，并且应用的 targetSdkVersion为23 或更高：应用必须在 Manifest 中列出权限，并且它必须在运行时请求其需要的每项危险权限。用户可以授予或拒绝每项权限，且即使用户拒绝权限请求，应用仍可以继续运行有限的功能。用户可以随时进入应用的“Settings”中调整应用的动态权限授权。所以你每次使用到该权限的功能时，都要动态申请，因为用户有可能在“Settings”界面中把它再次关闭掉。 我这里讨论的是6.0后的动态申请，所以从 Android 6.0开始，无论您的应用面向哪个 API 级别，您都应对应用进行测试，以验证它在缺少需要的权限时行为是否正常，我把权限申请的流程分为单个和多个权限申请，分别画了个图。 1、单个权限申请流程 2、多个权限申请流程 3、自定义提示权限组的提示框上面两个图有有提到自定义提示权限组，那么它主要包含以下内容： 1、包含需要授权的权限列表或单个权限提示 2、包含跳转到应用设置授权界面中的跳转按钮 3、包含放弃授权的取消按钮，即取消这个提示框 注意：如果用户不授权，则不能使用该功能或应用无法运行，可以考虑取消第3步的取消按钮，即无法取消这个提示框，一定要用户去“Settings”授权。 其他注意点除了特殊权限外，还有一个location权限也比较特殊，需要通过 LocationManager的isProviderEnabled(LocationManager.GPS_PROVIDER)判断是否打开定位开关后再进行权限申请，如下： 12345678910111213141516171819202122232425 lm = (LocationManager) this.getSystemService(this.LOCATION_SERVICE); if (lm.isProviderEnabled(LocationManager.GPS_PROVIDER)) &#123;//开了定位服务 //请求定位功能 PermissionHelper.getInstance().with(this).requestPermission( Manifest.permission.ACCESS_FINE_LOCATION, new IPermissionCallback() &#123; @Override public void onAccepted(Permission permission) &#123; //... &#125; @Override public void onDenied(Permission permission) &#123; //... &#125; &#125; ); &#125; else &#123; //跳转到开启定位的地方 Toast.makeText(this, \"系统检测到未开启GPS定位服务,请开启\", Toast.LENGTH_SHORT).show(); Intent intent = new Intent(); intent.setAction(Settings.ACTION_LOCATION_SOURCE_SETTINGS); startActivityForResult(intent, PRIVATE_CODE); &#125;&#125; 结语本文主要让让大家对权限的申请流程有进一步的认识，然后可以通过对动态权限的封装，将检测动态权限，请求动态权限，权限设置跳转，监听权限设置结果等处理和业务功能隔离开来，业务以后可以非常快速的接入动态权限支持，提高开发效率，更多细节查看PermissionHelper。 参考资料： Permissions 安卓系统权限，你真的了解吗？ Android 6.0运行权限解析（高级篇)","tags":[{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"发布开源库到jcenter","date":"2019-06-05T10:41:30.000Z","path":"2019/06/05/发布开源库到jcenter/","text":"前言前几天写过一篇文章快速发布开源库到jitpack，在里面我控诉发布jcenter的发布过程繁琐，对新手不友好，直到这几天我遇到了一个bintray-release插件，发现它可以帮助你更简单的发布开源库到jcenter上，而且过程也很简单。 如果你还不懂jcenter是什么或者你不懂那些配置有什么作用，强烈建议你先看一下这个两篇文章教你一步步发布一个开源库到 JCenter、手把手教你发布自己的开源库到jcenter，这两篇文章也教了另外两种发布开源库到jcenter的方式。本文是第3种方式，使用bintray-release发布开源库到jcenter上。 步骤如果你已经有账号和仓库了，就跳过1、2步。 1、注册bintray账号打开bintray网站(可能会有点慢，如果你没有翻墙)，点击下图的位置，如下： 千万不要点击绿色那个按钮，那个是给企业用的，我们是个人开发者，注册个人账号，然后出现以下画面： 可以关联github和google账号注册，但是如果你github和google关联的邮箱是中国的邮箱，会注册失败，所以这里是建议你先去注册一个Google邮箱，要有国外的邮箱才能注册成功。 这里假设你已经有Google邮箱了，然后你填好图中的信息，First Name填姓，Last Name填名，Username是填用户名，最好不要填中文，剩下的一看就直到填什么了，填好信息后点击Create My Account。这时它会发一封认证邮件给你的邮箱，因为邮箱是Google的，可能会有点慢，等你收到邮件点击确认后，它才会进入你的个人界面，否则就一直卡在那里，所以耐心等待邮件确认。 2、创建Maven库收到邮件确认后，进入个人界面，如图： 点击Add New Repository，进入如下界面： 这里填你的maven仓库的信息，Name填maven仓库名，这个很重要，记住你填的仓库名，Type就选maven，Licences就默认，Description可选，填仓库的描述，填完后点击Create。 然后你就可以在个人界面看到你刚才创建的maven仓库，如下： 你以后发布的开源库都会放到这个仓库中。 3、配置根目录build.gradle打开你的项目，在根目录的build.gradle种引入插件，这里以我的Utils为例，如下： 1classpath 'com.novoda:bintray-release:0.9.1' 插件的最新版本可以去这里找bintray-release。 4、配置库目录中的build.gradle点开你的库目录，在build.gradle中添加如下代码： 12345678910apply plugin: 'com.novoda.bintray-release'publish &#123; repoName = 'jianyu' //maven仓库名 userOrg = \"rain9155\" //bintray.com注册的用户名 groupId = \"com.jianyu\" //jcenter上的路径 artifactId = 'utils' //项目名称 publishVersion = \"v1.0\" //版本号 desc = \"a simple utils tool\" //描述，不重要，要填的话不要填中文，不然会乱码 website = \"https://github.com/rain9155/Utils\" ////网站，不重要，就填github上的地址就行了&#125; 我按上述填后，我到时库引用是这样：implementation ‘com.jianyu:utils:v1.0’。 5、执行构建上传命令打开Terminal面板，在命令行中输入：gradlew clean build bintrayUpload -PbintrayUser=你的用户名 -PbintrayKey=你的Api密匙 -PdryRun=false 用户名就是你上面的的用户名，我这里是rain9155，Api密匙需要到网站的个人简介中找，如下: 把命令填写完整后填点击回车，等待它上传，我大概等了10几分钟，出现以下代表上传成功： 否则出现BUILD FAILED，就是有错误，排错后再重新输入命令，重新上传，直到成功。一般的错误都是超时、maven库名字填错、无法找到该类。 6、Add to Jcenter打开你的maven仓库，如下： 可以看到utils库上传成功，点进去，如下： 点击1处那里会有一个Add to jcenter按钮，因为我已经add过了，所以会消失，但是你们的会有，进入如下画面： 直接点击Send，等待几个小时后，jcenter的审核人员会给你发一封站内邮件，如下： 然后你就可以愉快的一句话引用你的库到项目中了，在上面2的红色圈那里已经圈出来了。 结语有了插件的帮助，发布一个开源库还是挺简单的。大家尝试一下吧。 更多信息查看Utils","tags":[{"name":"jcenter","slug":"jcenter","permalink":"http://yoursite.com/tags/jcenter/"}]},{"title":"Android8.0的Activity启动流程(2)","date":"2019-05-19T08:12:34.000Z","path":"2019/05/19/Android8.0的Activity启动流程2/","text":"前言 上一篇文章Android8.0的Activity启动流程(1) 上一篇文章讲了应用进程请求AMS启动Activity过程和Activity在AMS中的启动过程，然后Activity启动的代码逻辑就从AMS所在进程，又重新回到了应用进程所在的ApplicationThread中。我们还留下了一个问题，Activity的生命周期方法是如何被回调的？，下面我们就带着这个疑问，去走一遍源码，看一下在应用进程中ApplicationThread启动Activity的过程。 本文基于android8.0，本文相关源码文件位置如下： frameworks/base/core/java/android/app/Activity.java frameworks/base/core/java/android/app/ActivityThread.java frameworks/base/core/java/android/app/Instrumentation.javaApplicationThread::scheduleLaunchActivity()上文结尾讲到在ActivityStackSupervisor的realStartActivityLocked()中调用了ApplicationThread中的scheduleLaunchActivity方法，这里是Activity启动的开始。ApplicationThread是ActivityThread的内部类，实现了IApplicationThread.stub接口。ActivityThread代表应用程序进程的主线程，它管理着当前应用程序进程的线程。 我们来看一下scheduleLaunchActivity的相关源码： 123456789101112131415161718192021222324252627282930313233//ActivityThread::ApplicationThreadpublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 上述方法中只是简单的把从AMS传过来的有关启动Activity的参数，封装成ActivityClientRecord，然后调用sendMessage向H发送LAUNCH_ACTIVITY的消息，并且将ActivityClientRecord作为参数传了过去，H是ActivityThread中的内部类，是Handler类型，有关Activity的启动消息都交给这个Handler处理，为什么这里要进行切换到主线程处理消息呢？因为此时这里还运行在Binder的线程池中，不能进行Activity的启动，所以要切换到主线程中才能进行Activity的生命周期的方法回调。 下面我们来看看sendMessage方法。 1、ApplicationThread::sendMessage()该方法如下： 1234567891011121314151617//ActivityThread::ApplicationThreadprivate void sendMessage(int what, Object obj) &#123; sendMessage(what, obj, 0, 0, false);&#125; private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; //... Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg); &#125; 可以看到，sendMessage方法中将H.LAUNCH_ACTIVITY与ActivityClientRecord封装成一个Message，然后调用mH的sendMessage方法，mH就是H的实例，如下： 1final H mH = new H(); 熟悉android消息机制的都知道(不了解的，可以看这一篇文章Android消息机制java层)，Handler发送消息后，都会统一到handlerMessage方法中处理。 我们来看一下Handler H对消息的处理。 2、H::handleMessage（）如下： 123456789101112131415161718192021//ActivityThread.javaprivate class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; public static final int RESUME_ACTIVITY = 107; public static final int DESTROY_ACTIVITY = 109; public static final int BIND_APPLICATION = 110; //... public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\"); &#125; break; //... &#125; &#125;&#125; H中有很多关于四大组件的消息处理的字段，如Activity的启动，这里我们只关心前面发送过来的LAUNCH_ACTIVITY字段的消息处理，可以看到这里首先把msg中的obj字段转换为ActivityClientRecord，然后为ActivityClientRecord的packageInfo赋值，packageInfo是LoadedApk类型，它表示已加载的APK文件，接下来调用了外部类ActivityThread的handleLaunchActivity方法。 接下来我们来看一下ActivityThread的handleLaunchActivity方法。 ActivityThread::handleLaunchActivity（）该方法源码如下： 1234567891011121314151617181920212223242526//ActivityThread.javaprivate void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; //... //最终回调Activity的onConfigurationChanged方法 handleConfigurationChanged(null, null); //这里面获取WindowManager系统服务的本地代理 WindowManagerGlobal.initialize(); //1、关注这里，启动Activity，调用了ActivityThread的performLaunchActivity方法，会最终回调Activity的onCreate，onStart方法 Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; //... //2、关注这里，调用了ActivityThread的handleResumeActivity方法，会最终回调Activity的onResume方法 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); //... &#125;else &#123; //如果出错了，这里会告诉AMS停止启动Activity try &#123; ActivityManager.getService() .finishActivity(r.token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125;&#125; 本文的重点是Activity的生命周期如何被回调，所以上面我们只需要关注注释1、2。注释1中调用了ActivityThread的performLaunchActivity方法，该方法最终完成了Activity对象的创建和启动过程，如果启动出错就会通知AMS停止启动Activity，并且在注释2中ActivityThread通过handleResumeActivity将被启动的Activity置为Resume状态。 我们首先看注释1的performLaunchActivity方法。 1、ActivityThread::performLaunchActivity()该方法相关源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//ActivityThread.javaprivate Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //从ActivityClientRecord中获取ActivityInfo。 ActivityInfo aInfo = r.activityInfo; //获取packageInfo，packageInfo是前面讲到的LoadedApk类型 if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; //获取ComponentName ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //创建要启动Activity的上下文环境 ContextImpl appContext = createBaseContextForActivity(r); //构造Activity对象，并设置参数 Activity activity = null; try &#123; //获取类加载器 java.lang.ClassLoader cl = appContext.getClassLoader(); //通过Instrumentation，用类加载创建该Activity实例 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); //设置相关参数准备初始化Activity r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; //初始化Activity失败 //.... &#125; try &#123; //创建Application Application app = r.packageInfo.makeApplication(false, mInstrumentation); //... if (activity != null) &#123; //构造Configuration对象 Configuration config = new Configuration(mCompatConfiguration); //... //把该Activity和ContextImpl关联 appContext.setOuterContext(activity); //通过attach方法将上述创建的信息保持到Activity内部，用来完成对Activity的初始化，如ContextImpl，Application，Configuration activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window, r.configCallback); //... //获取Activity的主题并设置 int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //1、根据是否需要持久化，调用Instrumentation的callActivityOnCreate方法通知Activity已经被创建，里面最终会调用Activity的onCreate方法 if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; //关注这里，走这个分支 mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; //... //无法调用Activity的onCreate方法，抛出异常 &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; //2、里面最终会调用Activity的onStart方法 activity.performStart(); r.stopped = false; &#125; if (!r.activity.mFinished) &#123; //根据是否需要持久化，调用Instrumentation的callActivityOnRestoreInstanceState方法通知Activity已经被创建，里面最终会调用Activity的onRestoreInstanceState方法 if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; //... &#125; r.paused = true; //把ActivityClientRecord缓存起来，以便在以后使用。mActivities的定义：ArrayMap&lt;IBinder, ActivityClientRecord&gt; mActivities = new ArrayMap&lt;&gt;(); mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; //... &#125; catch (Exception e) &#123; //... //抛异常，无法启动Activity &#125; return activity;&#125; 该方法的主要代码都贴出来了，并做了注释，它主要做了以下事情： 1、从ActivityClientRecord中获取待启动的Activity的组件信息，如ActivityInfo，ComponentName。 ActivityInfo类用于存储代码中AndroidManifes设置的activity节点信息，ComponentName类中保存了该Activity的包名和类名 2、通过createBaseContextForActivity方法创建要启动Activity的上下文环境ContextImp，并在下面作为参数传进attach方法中。 ContextImp是Context的具体实现，Context中的大部分逻辑都是交给ContextImpl来完成，Context中定义了许多与四大组件启动、系统级服务获取、类加载、资源获取等有密切关系的方法，而Activity继承自ContextThemeWrapper，ContextThemeWrapper继承自ContextWrapper，ContextWrapper继承自Context，ContextWrapper内部有一个Context类型的mBase引用，而在Activity的attach方法中会调用attachBaseContext方法把该ContextImp赋值给mBase，所以Activity是ContextImpl的包装类，Activity扩展了Context中的方法。（这里就是一个装饰者模式） 3、通过LoadedApk的makeApplication方法创建Application。 makeApplication方法里面最终是通过Instrumentation的newApplication方法用类加载器创建Application，如果Application已经被创建过了，那么就不会重复创建，如果创建成功，会紧接着通过Instrumentation的callApplicationOnCreate来调用Application的onCreate方法。 4、通过Instrumentation的newActivity方法用类加载器创建Activity对象。 Instrumentation是一个用来监控应用程序与系统交互的类，通过它可以创建Activity、Applicationd实例，还与Activity生命周期的回调有关，所以在下文看到mInstrumentation.callActivityOnXX, 一般都是要回调某个Activity的生命周期方法。 5、通过Activity的attach方法来完成一些重要数据的初始化，如ContextImpl，Application，Configuration等。 在attach方法中会创建Window对象（PhoneWindow）并与Activity自身进行关联，这样当Window接收到外部的输入事件后就可以将事件传递给Activity。第2点讲过，还会把ContextImpl与Activity关联。 6、调用Instrumentation的callActivityOnCreate方法，里面最终会调用Activity的onCreate方法。 这里就是重点关注的注释1，注释还写到这里会根据是否需要持久化来调用不同参数的mInstrumentation的callActivityOnCreate方法，这个持久化是什么？其实这是在API 21后，Activity新增的一个”persistableMode“属性，在AndroidManifest.xml的activity节点将他它设为android:persistableMode=”persistAcrossReboots，Activity就有了持久化的能力，这时候我们可以数据保存在outPersistentState（Bundle类型），那么即使是关机，仍然可以恢复这些数据。关于PersistableMode更多信息可以看这篇文章PersistableMode使Activity数据持久化保存，这不是本文的重点。 所以一般情况下我们没有使用这个属性，就会走到else分支，调用 mInstrumentation.callActivityOnCreate(activity, r.state)方法。 1.1、Instrumentation::callActivityOnCreate()该方法源码如下： 1234567 //Instrumentation.javapublic void callActivityOnCreate(Activity activity, Bundle icicle) &#123; prePerformCreate(activity); //1、关注这里，调用了Activity的performCreate方法 activity.performCreate(icicle); postPerformCreate(activity); &#125; 我们看注释1，调用了activity的performCreate方法，见名知意。 1.1.1、Activity::performCreate()该方法源码如下： 12345678//Activity.java final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123; restoreHasCurrentPermissionRequest(icicle); //1、看到我们的主角吧！onCreate方法 onCreate(icicle, persistentState); mActivityTransitionState.readState(icicle); performCreateCommon(); &#125; 看注释1，调用了我们熟悉的onCreate方法，我们平时一般在这里面进行Activity的控件、资源等初始化操作。 下面继续回到ActivityThread的performLaunchActivity方法，接着上面的第6点。 7、调用Activity的performStart方法，里面最终会调用Activity的onStart方法。 这里也就是重点关注的注释2，下面看一下performStart方法。 1.2、Activity::performStart()我们继续点进去看一下： 123456789101112//Activity.javafinal void performStart() &#123; //... mCalled = false; //1、关注这里，调用了Instrumentation的callActivityOnStart方法 mInstrumentation.callActivityOnStart(this); if (!mCalled) &#123; //... //无法调用Activity的onStart方法，抛出异常 &#125; //...&#125; 看注释1，该方法还是一样的套路，调用 mInstrumentation.callActivityOnStart方法，我们看一下 Instrumentation的callActivityOnStart方法： 1.2.1、Instrumentation::callActivityOnStart()该方法如下： 12345//Instrumentation.javapublic void callActivityOnStart(Activity activity) &#123; //看到我们的主角吧！onStart方法 activity.onStart(); &#125; 很简单的一句代码，调用了我们熟悉的onStart方法。 继续回到我们的ActivityThread的performLaunchActivity方法，还有一点没分析完，接下来到了根据需要调用Instrumentation的callActivityOnRestoreInstanceState方法，里面最终会调用Activity的onRestoreInstanceState方法，关于这个方法的作用已经不是本文的重点，但我们可以得出一个结论，onRestoreInstanceState方法的调用时机是在onStart方法之后。最后ActivityThread把ActivityClientRecord缓存起来。 分析完这个长长的方法，其实跟本文有关也就第6、7点。我们跳出ActivityThread::performLaunchActivity方法，回到ActivityThread的handleLaunchActivity方法。现在我们的Activity已经回调了onCreate和onStart方法，接下来应该是onResume方法。 下面我们我们接着来看handleLaunchActivity方法中注释2的handleResumeActivity方法。 2、ActivityThread::handleResumeActivity()该方法源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//ActivityThread.javafinal void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; //从缓存中拿出ActivityClientRecord ActivityClientRecord r = mActivities.get(token); //... //1、主要关注这里，调用了performResumeActivity方法，这里最终会调用Activity的onResume方法 r = performResumeActivity(token, clearHide, reason); //2、下面if（r ！= null）&#123;&#125;分支里面的逻辑都是把Activity显示出来 if (r != null) &#123; //拿到Activity final Activity a = r.activity; //... boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) &#123; try &#123; willBeVisible = ActivityManager.getService().willActivityBeVisible( a.getActivityToken()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; //得到Activity关联的Window r.window = r.activity.getWindow(); //得到Activity的DecorView，即Activity的顶级View View decor = r.window.getDecorView(); //先把DecorView设为不可见 decor.setVisibility(View.INVISIBLE); //得到ViewManager，用于添加DecorView ViewManager wm = a.getWindowManager(); //得到布局参加 WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; //下面设置布局参数 l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; //... if (a.mVisibleFromClient) &#123; if (!a.mWindowAdded) &#123; a.mWindowAdded = true; //用ViewManager添加DecorView wm.addView(decor, l); &#125; //... &#125; &#125; //... //此时用于承载DecorView的Window已经被WM添加了，但是还处于INVISIBLE状态,所以下面就把它值为VISIBLE if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; //... if (r.activity.mVisibleFromClient) &#123; //把Activity显示出来 r.activity.makeVisible(); &#125; &#125; &#125;else &#123; //... //Activity不能够Resume，通知AMS结束掉该Activity &#125;&#125; handleResumeActivity方法里面的代码也有点长，这个方法主要是把Activity置为Resume状态，并把Activity显示出来，所以我们只关注注释1，注释2是把Activity值为VISIBLE状态，大家要明白的是Activity其实也可以说是一个View，它的顶级View叫做DecorView，但系统回调完Activity的onResume函数时，只是说明Activity1已经完成所有的资源准备工作，Activity已经做好显示给用户的准备，所以还要通过类似于setVisible的方式把它显示出来，这个过程涉及到WindowManage的相关知识，为什么要这样做？大家可以看这篇文章Window,WindowManager和WindowManagerService之间的关系了解一下，所以注释2不是本文重点就不讲了。 下面我们来看注释1的performResumeActivity方法。 2.1 ActivityThread::performResumeActivity()该方法主要源码如下： 123456789101112131415161718192021222324252627//ActivityThread.javapublic final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide, String reason) &#123; //从缓存中拿到ActivityClientRecord ActivityClientRecord r = mActivities.get(token); if (r != null &amp;&amp; !r.activity.mFinished) &#123; if (clearHide) &#123; r.hideForNow = false; r.activity.mStartedActivity = false; &#125; //... try &#123; //... //1、主要关注这里，调用了Activity的performResume方法 r.activity.performResume(); //... r.paused = false; r.stopped = false; r.state = null; r.persistentState = null; &#125;catch(Exception e) &#123; //... //抛异常，无法resume Activity &#125; &#125; return r;&#125; 主要关注注释1，调用了Activity的performResume，和上面的performCreate，performStart很相似。 下面我们来看Activity的performResume方法。 2.1.1 Activity::performResume()该方法主要源码如下： 12345678910111213//Activity.javafinal void performResume() &#123; //这里处理Activity生命周期中的Restart流程 performRestart(); //... mCalled = false; //1、关注这里，调用Instrumentation的callActivityOnResume方法 mInstrumentation.callActivityOnResume(this); if (!mCalled) &#123; //... //抛异常，无法调用Activity的onResume方法 &#125;&#125; 在这个方法中我们看到了 performRestart()方法，这个是根据情况处理Restart流程，里面会执行onReStart() -&gt; onStart() ，到这里就执行onResume()， 所以我们看到注释1会Instrumentation的callActivityOnResume方法，这个和上面的callActivityOnCreate()、callActivityOnStart（）类似。 本着执着的态度，我们还是看一下Instrumentation的callActivityOnResume方法。 2.1.2、Instrumentation::callActivityOnResume()1234567 //Instrumentation.javapublic void callActivityOnResume(Activity activity) &#123; activity.mResumed = true; //又看到了我们的主角之一，onResume方法 activity.onResume(); //...&#125; 该方法先把Activity的mResumed 赋值为true，然后回调了我们熟悉的onResume方法。 我们跳出ActivityThread的handleResumeActivity方法，回到handleLaunchActivity方法，至此handleLaunchActivity方法分析完，Activity已经显示到用户面前。 总结到目前为止我们已经回调了Activity的三个生命周期方法：onCreate -&gt; onStart -&gt; onResume，onRestart也介绍了一下，可以说开头那个问题已经解解决了一半，我先来看一下本文的时序图： 所以现在我们知道了在应用进程中ApplicationThread启动Activity的过程。 那么还有三个方法：onPause -&gt; onStop -&gt; onDestory 什么时候被回调呢？大家都知道Activity有7个生命周期方法，除去onRestart，其他3个都是一 一对应的，结合前面那篇文章Android8.0的Activity启动流程(1)我们知道： 1、在AMS中含有ApplicatiThread的本地代理，所以AMS所在进程可以通过这个代理与ActivityThread的主线程通信，也就能调用ApplicatiThread的一些方法。 2、在应用进程中也含有系统服务AMS的本地代理对象，所以应用进程可以通过这个代理与AMS通信，可以请求AMS启动一个Activity。 3、双方都含有双方的代理，通过Binder，也就建立起双方的通信通道。 每个应用都有自己专属Activity任务栈，Activity任务栈的管理是在AMS那边，在本文的情况下，一个Activity已经被启动了，该Activity被加入到栈顶中去，如果此时我按back键返回上一个Activity，那么该Activity就会调用相应的回调onPause -&gt; onStop -&gt; onDestory方法，这个过程在AMS那边对应一个出栈动作，此时AMS也就像启动Activity调用scheduleLaunchActivity方法那样调用ApplicationThread中schedulePauseActivity、scheduleStopActivity、scheduleDestroyActivity方法来结束掉这个Activity，这个调用过程是IPC，所以大家通过本文举一反三也就明白了Activity的其他生命周期是如何被回调的，这个过程离不开与AMS的交互。 至此我们已经走完startActivity后发生的流程。在这整个过程中也发现了自己平常很多遗落的知识点，让我更进一步的认识了Activity。希望大家也有所收获。 参考资料： Activity生命周期回调是如何被回调的 Android8.0 根Activity启动过程（后篇）","tags":[{"name":"activity","slug":"activity","permalink":"http://yoursite.com/tags/activity/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"Android8.0的Activity启动流程(1)","date":"2019-05-19T08:11:17.000Z","path":"2019/05/19/Android8.0的Activity启动流程1/","text":"前言Activity的启动流程有俩种过程，一种是根Activity的启动过程，即在Launch界面点击一个应用图标启动应用程序，根Activity指的是应用程序启动的第一个Activity；另一种是普通Activity的启动流程，即我们平时调用startActivity方法来启动一个Activity。本文讨论第二种，startActivity方法大家都知道是用来启动一个Activity的，那么大家有没有想过它在底层是怎么启动的呢？Activity的生命周期方法是如何被回调的？它启动过程中涉及到多少个进程？接下来我们通过撸一篇源码来了解Activity的大概启动流程，然后解答这几个问题。 本文源码基于Android8.0，本文涉及的源码文件位置如下： frameworks/base/core/java/android/app/Activity.java frameworks/base/services/core/java/com/android/server/am/*.java(*代表ActivityManagerService，ActivityStack，ActivityStarter，ActivityStackSupervisor，ActivityStack)Activity::startActivity()startActivity有好几种重载方法，如下： 1234567891011121314151617181920@Override public void startActivity(Intent intent) &#123; this.startActivity(intent, null); &#125;@Override public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; //我们一般没有传options参数给startActivity，所以options为空，就会走到这个分支 //第二参数requestCode为-1，表示不需要知道Activity启动的结果 startActivityForResult(intent, -1); &#125; &#125; //发现两个参数的startActivityForResult方法最终还是调用三个参数的startActivityForResult方法，options参数传入null public void startActivityForResult(@RequiresPermission Intent intent, int requestCode) &#123; startActivityForResult(intent, requestCode, null); &#125; 可以发现startActivity最终都会调用到startActivityForResult方法。 1、Activity::startActivityForResult()这里我们来到了具有三个参数的startActivityForResult方法，如下： 12345678910111213141516171819//Activity.javapublic void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) &#123; //mParent一直为空 if (mParent == null) &#123; //... //1、关注这里，调用Instrumentation的execStartActivity方法 Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); //... //此时requestCode为-1 if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; //... &#125; else &#123; //... &#125; 在上面的的代码中，会进入mParent==null的这个分支里，mParent是Activity类型，它只会在LocalActivityManger构造中被赋值，在我们startActivity过程中一直为空（关于为甚么mParent一直为空，可以查看这篇文章StartActivity路上的mParent）。这里我们只关注注释1，调用Instrumentation的execStartActivity方法，Instrumentation是一个用来监控应用程序与系统交互的类，我们还要注意传入execStartActivity方法的两个参数： 1、mMainThread.getApplicationThread()：ApplicationThread类型，mMainThread是ActivityThread类型，它是应用程序的入口类，而mMainThread.getApplicationThread()就是获得一个ApplicationThread，它是ActivityThread的内部类，它实现了IApplicationThread.Stub，如下： 1234//ActivityThread.java::ApplicationThreadprivate class ApplicationThread extends IApplicationThread.Stub &#123; //...&#125; IApplicationThread.java类是在编译时由IApplicationThread.aidl通过AIDL工具自动生成的，IApplicationThread的内部会自动生成一个 IApplicationThread.Stub类，它继承自Binder类，而Binder实现了IBinder接口，并且 IApplicationThread.Stub实现了IActivityManager接口。要想进行进程间通信，ApplicationThread只需要继承IApplicationThread.Stub类并实现相应的方法就可以，这样主线程ActivityThread就可以通过ApplicationThread就能对外提供远程服务。要记住这个ApplicationThread，他在Activity的启动过程中发挥重要作用。 2、mToken： 它的类型为IBinder，代表着当前Activity的token，它保存自己所处Activity的ActivityRecord信息 2、Instrumentation::execStartActivity()我们继续看Instrumentation的execStartActivity方法，如下： 1234567891011121314151617181920//Instrumentation.javapublic ActivityResult execStartActivity(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; //还记得上面提到的ApplicationThread吗，这里把它转成了IApplicationThread，并在下面作为startActivity方法的参数 IApplicationThread whoThread = (IApplicationThread) contextThread; //... try &#123; //... //1、关注这里，这里实际调用的是ActivityManagerService的startActivity方法 int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //检查启动Activity的结果，无法正确启动一个Activiy时，这个方法抛出异常 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException(\"Failure from system\", e); &#125; return null;&#125; 我们看注释1，ActivityManager.getService()返回的是ActivityManagerService（下面简称AMS）在应用进程的本地代理，该方法在ActivityManager中，如下： 12345678910111213141516171819//ActivityManager.javapublic static IActivityManager getService() &#123; //IActivityManagerSingleton是Singleton类型，Singleton是一个单例的封装类 //第一次调用它的get方法时它会通过create方法来初始化AMS这个Binder对象，在后续调用中返回之前创建的对象 return IActivityManagerSingleton.get();&#125; private static final Singleton&lt;IActivityManager&gt; IActivityManagerSingleton = new Singleton&lt;IActivityManager&gt;() &#123; @Override protected IActivityManager create() &#123; //ServiceManager是服务大管家，这里通过getService获取到了IBinder类型的AMS引用 final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); //这通过asInterface方法把IBinder类型的AMS引用转换成AMS在应用进程的本地代理 final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; &#125; &#125;; 上面出现的IActivityManager.java类的意义类似于前面提到的ApplicationThread.java。要想进行进程间通信，AMS只需要继承IActivityManager.Stub类并实现相应的方法就可以，这样AMS就能对外提供远程服务，如下： 1234//ActivityManagerService.javapublic class ActivityManagerService extends IActivityManager.Stub&#123; //...&#125; 所以继续回到Instrumentation的execStartActivity方法中，ActivityManager.getService()返回的是AMS的本地代理，注意AMS是在系统进程SystemServer中，所以注释1这里通过Binder的IPC，调用的其实是AMS的startActivity方法。 整个过程的时序图如下： 在这里开始，Activity的启动过程从应用进程转移到AMS中去。 AMS::startActivity()AMS的startActivity方法如下： 123456//AMS.java public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId()); &#125; 简单的return了startActivityAsUser方法，该方法在最后多了个 UserHandle.getCallingUserId()参数，AMS根据这个确定调用者权限。我们再来看看其他参数： caller：IApplicationThread类型，还记得上面提到的ApplicationThread吗？到这里它已经被转成了ApplicationThread的本地代理，这个转换的过程发生在上面讲到的Binder的IPC中，就像上面提到的AMS本地代理转换一样。 callingPackage：前面一直传过来的，代表调用者Activity所在的包名 intent：前面startActivity时传递过来的intent resolvedType：从上面传过来，intent.resolveTypeIfNeeded() resultTo：IBinder类型，还记得上面提到的mToken吗？就是从上面一直传过来的，保存着的调用者Activity的ActivityRecord信息 resultWho：String类型，调用者Activity的mEmbeddedID，前面一直传过来的 requestCode：从上面一直传过来的，一直为-1 startFlags：从上面传过来，为0 profilerInfo：ProfilerInfo类型，从上面传过来，等于null bOptions：Bundle类型，从上面传过来，等于null 下面继续看AMS的startActivityAsUser方法。 1、AMS::startActivityAsUser()startActivityAsUser方法如下： 12345678//AMS.java public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) &#123; //... return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null, \"startActivityAsUser\"); &#125; 省略了两个判断，1、判断调用者进程是否被隔离，2、判断调用者是否有权限，这些都不是重点。下面继续简单的return了mActivityStarter.startActivityMayWait方法，mActivityStarter是ActivityStarter类型，它是AMS中加载Activity的控制类，会收集所有的逻辑来决定如何将Intent和Flags转换为Activity，并将Activity和Task以及Stack相关联。传入startActivityMayWait方法的参数又多了几个，看一下几个： callingUid：第二个参数，等于-1 inTask：倒数第二个参数，TaskRecord类型，代表要启动的Activity所在的栈，这里为null，表示还没创建 reason：倒数第一个参数，值为”startActivityAsUser”，代表启动的理由 其他的参数有一些传入null，有一些是从上面传过来的 下面看ActivityStarter中的startActivityMayWait方法。 2、ActivityStarter::startActivityMayWait()来看看这个方法的源码，如下： 12345678910111213141516171819//ActivityStarter.javafinal int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, Bundle bOptions, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask, String reason) &#123; //... //把上面传进来的intent再构造一个新的Intent对象，这样即便intent被修改也不受影响 intent = new Intent(intent); //... ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId); if(rInfo == null)&#123; //... &#125; //解析这个intent，收集intent指向的Activity信息 ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo); //... final ActivityRecord[] outRecord = new ActivityRecord[1]; //1、主要关注这里，调用了本身的startActivityLocked方法 int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, container, inTask, reason); //... return res;&#125; ActivityInfo里面收集了要启动的Activity信息（关于ResolveInfo与ActivityInfo可以看这篇如何获取Android应用与系统信息），主要还是关注注释1，这里又调用了ActivityStarter中的startActivityLocked方法。传入startActivityLocked方法的参数又多了几个（callingPid等）。关于pid于与uid的介绍可以看这篇文章Android手机中UID、PID作用及区别。 下面来看一下startActivityLocked方法。 2.1、ActivityStarter::startActivityLocked()该方法的相关源码如下： 123456789101112131415161718192021//ActivityStarter.javaint startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask, String reason) &#123; //这里对上面传进来值为\"startActivityAsUser\"理由参数判空 if (TextUtils.isEmpty(reason)) &#123; throw new IllegalArgumentException(\"Need to specify a reason.\"); &#125; mLastStartReason = reason; mLastStartActivityTimeMs = System.currentTimeMillis(); mLastStartActivityRecord[0] = null; //1、主要关注这里，调用了本身的startActivity方法 mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord, container, inTask); if (outActivity != null) &#123; outActivity[0] = mLastStartActivityRecord[0]; &#125; return mLastStartActivityResult; &#125; 这里主要关注注释1，调用了ActivityStarter中的startActivity方法，该方法多了一个参数，最后一个mLastStartActivityRecord，mLastStartActivityRecord是一个ActivityRecord数组类型，ActivityRecord是用来保存一个Activity的所有信息的类。 下面来看ActivityStarter中的startActivity方法。 2.2、ActivityStarter::startActivity()123456789101112131415161718192021222324252627282930313233343536373839 //ActivityStarter.javaprivate int startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified,ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) &#123; int err = ActivityManager.START_SUCCESS; //... //获取调用者所在进程记录的对象，caller就是上面一直强调的代表调用者进程的ApplicationThread对象 ProcessRecord callerApp = null; if (caller != null) &#123; //这里调用AMS的getRecordForAppLocked方法获得代表调用者进程的callerApp callerApp = mService.getRecordForAppLocked(caller); if (callerApp != null) &#123; //获取调用者进程的pid与uid并赋值 callingPid = callerApp.pid; callingUid = callerApp.info.uid; &#125; else &#123; err = ActivityManager.START_PERMISSION_DENIED; &#125; &#125; //下面startActivity方法的参数之一，代表调用者Activity的信息 ActivityRecord sourceRecord = null; if (resultTo != null) &#123; sourceRecord = mSupervisor.isInAnyStackLocked(resultTo); //... &#125; //... //创建即将要启动的Activity的信息描述类ActivityRecord ActivityRecord r = new ActivityRecord(mService, callerApp, callingPid, callingUid, callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, mSupervisor, container, options, sourceRecord); //outActivity是ActivityRecord[]类型，从上面传进来，这里把ActivityRecord赋值给了它，下面会作为参数传进startActivity方法中 if (outActivity != null) &#123; outActivity[0] = r; &#125; //... //1、关注这里，调用了本身的另一个startActivity方法 return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask, outActivity); &#125; 上面的startActivity代码非常长，省略了很多，上面讲的调用者进程，在这里等价于应用程序进程，ProcessRecord是用来描述一个应用进程的信息，ActivityRecord上面也讲过了，就是用来记录一个要启动的Activity的所有信息，在注释1处的调用了ActivityStarter的startActivity方法，这个方法参数少了很多，大多数有关要启动的Activity的信息都被封装进了ActivityRecord类中，作为参数r传了进去。 下面来看ActivityStarter的startActivity方法。 2.3、ActivityStarter::startActivity()该方法代码如下： 12345678910111213141516 //ActivityStarter.javaprivate int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; int result = START_CANCELED; try &#123; mService.mWindowManager.deferSurfaceLayout(); //1、主要关注这里，调用本身的startActivityUnchecked方法 result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, doResume, options, inTask, outActivity); &#125; finally &#123; //... mService.mWindowManager.continueSurfaceLayout(); &#125; //... return result; &#125; 这里主要调用了ActivityStarter的startActivityUnchecked方法。 2.4、ActivityStarter::startActivityUnchecked()该方法代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//ActivityStarter.javaprivate int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord,IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity) &#123; //把上面传进来的参数除了outActivity都传进去了，主要是把这些参数赋值给ActivityStarter的成员变量，如mDoResume = doResume, mStartActivity = r //mStartActivity就是即将要启动的Activity的信息 setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession, voiceInteractor); //计算出启动Activity的模式，并赋值给mLaunchFlags computeLaunchingTaskFlags(); //... //设置启动模式 mIntent.setFlags(mLaunchFlags); //... boolean newTask = false; //1、下面会进行判断，到底需不需要创建一个新的Activity任务栈 int result = START_SUCCESS; if (mStartActivity.resultTo == null &amp;&amp; mInTask == null &amp;&amp; !mAddingToTask &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) &#123; //1.1走这里就会在setTaskFromReuseOrCreateNewTask方法内部创建一个新的Activity任务栈 newTask = true; result = setTaskFromReuseOrCreateNewTask( taskToAffiliate, preferredLaunchStackId, topStack); &#125; else if (mSourceRecord != null) &#123; //1.2走这里就会在setTaskFromSourceRecord方法内部获得调用者Activity的的任务栈赋值给mTargetStack result = setTaskFromSourceRecord(); &#125; else if (mInTask != null) &#123; //1.3走这里就会在setTaskFromInTask方法内部直接把mInTask赋值给mTargetStack，前面已经说过mInTask等于null result = setTaskFromInTask(); &#125; else &#123; //1.4、就是前面的条件都不满足了，但是这种情况很少发生 setTaskToCurrentTopOrCreateNewTask(); &#125; if (result != START_SUCCESS) &#123; return result; &#125; //... //mDoResume等于上面传进来的doResume，为true if (mDoResume) &#123; final ActivityRecord topTaskActivity = mStartActivity.getTask().topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123; //走这里不会显示Activity，因为Activity还没有获取焦点或者Activity的栈溢出 //... &#125; else &#123; //正常的话会走到这里 if (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123; mTargetStack.moveToFront(\"startActivityUnchecked\"); &#125; //2、主要关注这里调用mSupervisor的resumeFocusedStackTopActivityLocked方法 mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); &#125; &#125; else &#123; //... &#125; return START_SUCCESS;&#125; 上面的startActivityUnchecked方法也是很长，这个方法主要处理Activity栈管理相关的逻辑，如果对于这方面信息不熟悉的话可以查看这两篇文章Android任务和返回栈完全解析、ActivityTask和Activity栈管理。一个或多个ActivityRecord会组成一个TaskRecord，TaskRecord用来记录Activity的栈，而ActivityStack包含了一个或多个TaskRecord。上面代码的mTargetStack就是ActivityStack类型，我们先来看注释1，注释1会根据mLaunchFlags等条件到底需不需要创建一个新的Activity任务栈，而本文所讨论的条件限定在从一个应用程序调用Activity的startActivity去启动另外一个Activity的情景，而且默认Activity的启动模式是standard，并不会创建一个新的任务栈，所以就会走到1.2的条件分支，然后我们再来看注释2，这里会调用mSupervisor.resumeFocusedStackTopActivityLocked方法，mSupervisor是ActivityStackSupervisor类型，ActivityStackSupervisor主要用来管理ActivityStack。启动Activity的过程从ActivityStack来到了ActivityStackSupervisor。 下面我们来看ActivityStackSupervisor的resumeFocusedStackTopActivityLocked方法。 3、ActivityStackSupervisor::resumeFocusedStackTopActivityLocked()该方法源码如下： 123456789101112131415//ActivityStackSupervisor.javaboolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; //... //获取要启动的Activity所在栈的栈顶的ActivityRecord final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); //1、r是否null或是否为RESUMED状态 if (r == null || r.state != RESUMED) &#123; //2、关注这里，调用ActivityStack的resumeTopActivityUncheckedLocked方法 mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; else if (r.state == RESUMED) &#123; mFocusedStack.executeAppTransition(targetOptions); &#125; return false; &#125; 首先这里会获取要启动的Activity所在栈的栈顶的ActivityRecord赋值给r，因为要启动的Activity的还没有启动，所以此时栈顶就是调用者Activity，调用者Activity启动Activity，肯定会从RESUME状态转到其他状态如STPO，所以注释1满足r.state != RESUMED的条件，此时就是走带注释2，注释2调用了mFocusedStack的resumeTopActivityUncheckedLocked方法，mFocusedStack就是ActivityStack类型。启动Activity的过程从ActivityStackSupervisor又回到到了ActivityStack。 下面我们来看ActivityStack的resumeTopActivityUncheckedLocked方法。 3.1、ActivityStack:: resumeTopActivityUncheckedLocked()该方法的源码如下： 12345678910111213//ActivityStack.javaboolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; //... boolean result = false; try &#123; //1、关注这里，这里调用了本身的resumeTopActivityInnerLocked方法 result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; //... &#125; //... return result; &#125; 我们来看注释1，简单的调用了resumeTopActivityInnerLocked方法。 3.1.1、 ActivityStack:: resumeTopActivityInnerLocked()该方法源码如下： 12345678910111213141516//ActivityStack.javaprivate boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; //... //获得将要启动的Activity的信息 final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */) //... if (next.app != null &amp;&amp; next.app.thread != null) &#123; //... &#125;else&#123; //... //1、关注这里，调用了ActivityStackSupervisor的startSpecificActivityLocked方法 mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked(); return true;&#125; topRunningActivityLocked方法获得将要启动的Activity的信息next，因为此时要启动的Activity还不属于任何进程，故它的ProcessRecord为空成立，就会走到else分支，所以注释1这里调用了ActivityStackSupervisor的startSpecificActivityLocked方法，又回到了ActivityStackSupervisor中。 下面来看ActivityStackSupervisor的startSpecificActivityLocked方法。 3.2、ActivityStackSupervisor::startSpecificActivityLocked()该方法源码如下： 123456789101112131415161718//ActivityStackSupervisor.javavoid startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; //获取要启动的Activity的所在应用程序进程 ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.getStack().setLaunchTime(r); //要启动的Activity的所在应用程序进程存在 if (app != null &amp;&amp; app.thread != null) &#123; try &#123; //... //1、关注这里，调用了本身的realStartActivityLocked方法 realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; //... &#125; &#125; //... &#125; 这里首先会获取要启动的Activity所在的应用进程app，当app进程已经运行时，就会调用注释1处的realStartActivityLocked方法，注意这里多了一个参数，把代表应用进程的app传了进去。 下面来看ActivityStackSupervisor的realStartActivityLocked方法。 3.3、ActivityStackSupervisor::realStartActivityLocked()123456789101112131415161718192021222324final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; //... //1、把应用所在进程信息赋值给要启动的Activity的ActivityRecord r.app = app; //... try&#123; //... //2、关注这里，app是ProcessRecord类型，app.thread是IApplicationThread类型 //app.thread是应用进程的ApplicationThread在AMS的本地代理，前面已经讲过 //所以这里实际调用的是ApplicationThread的scheduleLaunchActivity方法 app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, mergedConfiguration.getGlobalConfiguration(), mergedConfiguration.getOverrideConfiguration(), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); //... &#125;catch (RemoteException e) &#123; //... &#125; //... return true;&#125; 正如这方法名所示，realStartActivity，兜兜转转，这里就是真正启动Activity的地方，注释1处app指的是传入的要启动的Activity的所在的应用程序进程，是从前面传过来的，这里把它赋值给了要启动的Activity的ActivityRecord的app字段去，这样就可以说要启动的Activity属于应用进程，我们再来看注释2这里，app.thread就是我们上面一直强调的ApplicationThread，所以这里通过Binder的IPC其实调用的是ApplicationThread中的scheduleLaunchActivity方法。 整个过程的时序图如下： 当前的代码逻辑执行在AMS所在进程，从这里开始Activity的启动流程最终又回到了应用进程所在的ApplicationThread中。 总结本来一篇文章写完Activity的启动，写到这里才发现，篇幅太长，所以Activity在应用进程中的启动过程就放到下一篇文章。本文简单的介绍了应用进程请求AMS启动Activity过程和Activity在AMS中的启动过程，现在让我们来回答一下开头给出的几个问题： 1、Activity的启动流程是怎样的？ 从应用调用一个startActivity方法开始，应用进程开始请求AMS启动Activity，然后在AMS中Activity完成它的一系列准备，最后再回到应用进程中开始回调Activity的生命周期，本文回答了一半这个问题，即本文讲解了应用进程开始请求AMS启动Activity，然后在AMS中完成它的一系列准备的过程，这个过程用时序图表示如下： 2、Activity的生命周期方法是如何被回调的？ 本文并没有解答这个问题，这个问题要到下一篇文章才能有答案。 3、它启动过程中涉及到多少个进程？ 答案是2个，前言已经讲过本文讨论的是普通Activity的启动流程，即我们平时调用startActivity方法来启动一个Activity，所以本文这个过程涉及的进程可以可以用下面这个图表示： 图中AppProcess代表应用所在进程，systemServer代表AMS所在进程，两个进程之间通过Binder进行通信，实现了XX.Stub的类就可以进行Binder通信，如本文的ApplicationThread和AMS都实现了各自的Stub类，所以应用进程startActivity时请求AMS启动Activity，AMS准备好后，再发送scheduleLaunchActivity请求告诉应用可以开始启动Activity了。 那么如果是前言所讲的第一种启动Activity的过程，即在Launch界面点击一个应用图标启动应用程序，那么会涉及多少个进程？答案是4个，如图： 可以看到会涉及Launcher进程、SystemServer进程、App进程、Zygote进程(关于这些进程的简单信息可以看这篇从进程的角度看Android的系统架构)，这整个过程如下：首先是点击App图标，此时是运行在Launcher进程, Launcher通过AMS本地代理向AMS发起startActivity请求，AMS收到请求后，发现要启动的Activity的进程不存在，就通过Process.start方法向Zygote进程发送创建进程的请求，Zygote进程收到请求后，fork出新的子进程，即App进程，然后进入ActivityThread.main方法中，这时运行在App进程中，App进程通过AMS本地代理向AMS发起attachApplication请求，AMS接收到请求后，进行一些列准备工作(通知Activity创建Application)后，再通过ApplicationThread向App进程发送scheduleLaunchActivity请求，App进程收到请求后，后面就会进行Activity的生命周期回调。 关于ApplicationThread中的scheduleLaunchActivity方法之后的流程就留到下一篇文章了。 阅读源码真的是一个漫长的过程，又时候看别人写的那么简单，但是当自己去写，才发现要考虑的东西很多，所以这是一个日积月累的过程，所以阅读源码的时候，最好跟着前人的文章阅读，这样理解的更快。 参考文章： startActivity启动过程分析 Android8.0 根Activity启动过程 从Activity的启动流程理解Binder","tags":[{"name":"activity","slug":"activity","permalink":"http://yoursite.com/tags/activity/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"Window,WindowManager和WindowManagerService之间的关系","date":"2019-03-22T14:36:32.000Z","path":"2019/03/22/Window, WindowManager和WindowManagerService之间的关系/","text":"前言上面3个名词在开发中经常听到，在Android开发中，Window是所有视图的载体，如Activity，Dialog和Toast的视图，我们想要对Window进行添加和删除就要通过WindowManager来操作，而WindowManager就是通过Binder与WindowManagerService进行跨进程通信，把具体的实现工作交给WindowManagerService（下面简称WMS）。下面分别介绍它们，理清它们的基本脉络。 本文基于Android8.0, 相关源码位置如下: frameworks/base/core/java/android/view/*.java（*代表Window, WindowManager, ViewManager, WindowManagerImpl，WindowManagerGlobal, ViewRootImpl） frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java frameworks/base/services/core/java/com/android/server/wm/Session.javaWindow1、Window是什么Window在Android开发中是一个窗口的概念，它是一个抽象类，我们打开Window，如下: 12345678910111213public abstract class Window &#123; public static final int FEATURE_NO_TITLE = 1; public static final int FEATURE_CONTENT_TRANSITIONS = 12; //... public abstract View getDecorView(); public abstract void setContentView(@LayoutRes int layoutResID); public abstract void setContentView(View view); public abstract void setContentView(View view, ViewGroup.LayoutParams params); public &lt;T extends View&gt; T findViewById(@IdRes int id) &#123; return getDecorView().findViewById(id); &#125; //...&#125; 可以看到里面有我们熟悉的一些字段和方法，以Activity对应的Window为例，具体的实现类是PhoneWindow，在PhoneWindow中有一个顶级View—DecorView，继承自FrameLayout，我们可以通过getDecorView()获得它，当我们调用Activity的setContentView时，其实最终会调用Window的setContentView，当我们调用Activity的findViewById时，其实最终调用的是Window的findViewById，这也间接的说明了Window是View的直接管理者。但是Window并不是真实存在的，它更多的表示一种抽象的功能集合，View才是Android中的视图呈现形式，绘制到屏幕上的是View不是Window，但是View不能单独存在，它必需依附在Window这个抽象的概念上面，Android中需要依赖Window提供视图的有Activity，Dialog，Toast，PopupWindow，StatusBarWindow（系统状态栏），输入法窗口等，因此Activity，Dialog等视图都对应着一个Window。 2、Window的类型（应用窗口，子窗口，系统窗口)与层级Window的类型type被定义在WindowManager中的静态内部类LayoutParams中，如下： 123456789101112131415161718192021222324252627282930public interface WindowManager extends ViewManager &#123; //... public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable &#123; //应用程序窗口type值 public static final int FIRST_APPLICATION_WINDOW = 1;//代表应用程序窗口的起始值 public static final int TYPE_BASE_APPLICATION = 1;//窗口的基础值，其他窗口的type值要大于这个值 public static final int TYPE_APPLICATION = 2;//普通应用程序窗口，token必须设置为Activity的token来指定窗口属于谁 public static final int TYPE_APPLICATION_STARTING = 3; public static final int TYPE_DRAWN_APPLICATION = 4; public static final int LAST_APPLICATION_WINDOW = 99;//代表应用程序窗口的结束值 //子窗口type值 public static final int FIRST_SUB_WINDOW = 1000;//代表子窗口的起始值 public static final int TYPE_APPLICATION_PANEL = FIRST_SUB_WINDOW; public static final int TYPE_APPLICATION_MEDIA = FIRST_SUB_WINDOW + 1; public static final int TYPE_APPLICATION_SUB_PANEL = FIRST_SUB_WINDOW + 2; public static final int TYPE_APPLICATION_ATTACHED_DIALOG = FIRST_SUB_WINDOW + 3; public static final int TYPE_APPLICATION_MEDIA_OVERLAY = FIRST_SUB_WINDOW + 4; public static final int TYPE_APPLICATION_ABOVE_SUB_PANEL = FIRST_SUB_WINDOW + 5; public static final int LAST_SUB_WINDOW = 1999;//代表子窗口的结束值 //系统窗口的type值 public static final int FIRST_SYSTEM_WINDOW = 2000;//代表系统窗口的起始值 public static final int TYPE_STATUS_BAR = FIRST_SYSTEM_WINDOW;//系统状态栏 public static final int TYPE_SEARCH_BAR = FIRST_SYSTEM_WINDOW+1;//搜索条窗口 public static final int TYPE_PHONE = FIRST_SYSTEM_WINDOW+2;//通话窗口 //... public static final int LAST_SYSTEM_WINDOW = 2999;//代表系统窗口结束值 &#125;&#125; LayoutParams中以TYPE开头的值有很多，但总体可以分为3类： 应用程序窗口：type值范围是1~99，Activity就是一个典型的应用程序窗口，type值是TYPE_BASE_APPLICATION，WindowManager的LayoutParams默认type值是TYPE_APPLICATION。 子窗口：type值范围是1000~1999，PupupWindow就是一个典型的子窗口，type值是TYPE_APPLICATION_PANEL，子窗口不能独立存在，必须依附于父窗口 系统窗口：type值范围是2000~2999,系统窗口的类型很多，上面并没有全部列举出来，系统状态栏就是一个典型的系统窗口，type值是TYPE_STATUS_BAR，与应用程序窗口不同的是，系统窗口的创建是需要声明权限的。 type值决定了决定了Window显示的层级（z-ordered），即在屏幕Z轴方向的显示次序，一般情况下type值越大，则窗口显示的越靠前，在Window的3种类型中，应用程序窗口的层级范围是199，子窗口的层级范围是10001999，系统窗口的层级范围是2000~2999，层级范围对应着type值，如果想要Window位于所有的Window上，采用较大的层级即可，例如系统层级。 3、Window的属性Window的类型flag同样被定义在WindowManager中的静态内部类LayoutParams中，如下： 12345678910111213public interface WindowManager extends ViewManager &#123; //... public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable &#123; public static final int FLAG_ALLOW_LOCK_WHILE_SCREEN_ON = 0x00000001; public static final int FLAG_DIM_BEHIND = 0x00000002; public static final int FLAG_BLUR_BEHIND = 0x00000004; public static final int FLAG_NOT_FOCUSABLE = 0x00000008; public static final int FLAG_NOT_TOUCHABLE = 0x00000010; public static final int FLAG_NOT_TOUCH_MODAL = 0x00000020; public static final int FLAG_KEEP_SCREEN_ON = 0x00000080; //... &#125;&#125; LayoutParams中定义的flag属性同样很多，这里挑几个常见的讲解： FLAG_ALLOW_LOCK_WHILE_SCREEN_ON：只要窗口对用户可见，就允许在屏幕开启状态下锁屏。 FLAG_KEEP_SCREEN_ON： 只要窗口对用户可见，屏幕就一直亮着。 FLAG_SHOW_WHEN_LOCKED：窗口可以在锁屏的界面上显示。 FLAG_NOT_FOCUSABLE：窗口不能获取焦点，也不能接受任何输入事件，此标志同时会启用FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层的具有焦点的窗口。 FLAG_NOT_TOUCH_MODAL：当前窗口区域以外的触摸事件会传递给底层的窗口，当前窗口区域内的触摸事件则自己处理，一般来说都要开启此标记，否则其他Window将无法收到单机事件。 FLAG_NOT_TOUCHABLE：窗口不接收任何触摸事件 可以看到LayoutParams中的type和flag非常重要，可以控制Window的显示特性。知道了Window的相关信息，就能更好的了解WindowManager。 WindowManagerWindowManager是一个接口，里面常用的方法有：添加View，更新View和删除View，WindowManager继承自ViewManager，这三个方法定义在ViewManager中，如下： 123456public interface ViewManager&#123; public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; 可以看到这些方法传入的参数是View，不是Window，说明WindowManager管理的是Window中的View，我们通过WindowManager操作Window就是在操作Window中的View。WindowManager的具体实现类是WindowManagerImp，我们看一下相应方法的实现，如下： 12345678910111213141516171819202122232425262728public final class WindowManagerImpl implements WindowManager &#123; private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); private final Context mContext; private final Window mParentWindow; //... private WindowManagerImpl(Context context, Window parentWindow) &#123; mContext = context; mParentWindow = parentWindow; &#125; @Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; //... mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); &#125; @Override public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; //... mGlobal.updateViewLayout(view, params); &#125; @Override public void removeView(View view) &#123; mGlobal.removeView(view, false); &#125;&#125; 可以看到WindowManagerImp也没有做什么，它把3个方法的操作都委托给了WindowManagerGlobal这个单例类，我们还看到了mParentWindow这个字段，它是Window类型，是从构造中被传入，所以WindowManager会持有Window的引用，这样WindowManager就可以对Window做操作了。比如mGlobal.addView，我们可以理解为往window中添加View，在WindowManagerGlobal中，如下： 1234567public void addView(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow)&#123; //... ViewRootImpl root; root = new ViewRootImpl(view.getContext(), display);//注释1 //... root.setView(view, wparams, panelParentView);&#125; 最终会走到ViewRootlmp的setView中, 如下： 123456789101112public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; //... //这里会进行View的绘制流程 requestLayout(); //... //通过session与WMS建立通信 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); //...&#125; 在ViewRootlmp的setView中，首先通过requestLayout()发起View绘制流程，然后在mWindowSession的addToDisplay中通过Binder与WMS进行跨进程通信，请求显示窗口上的视图，至此View就会显示到屏幕上。这个mWindowSession是一个IWindowSession.AIDL接口类型，用来实现跨进程通信，在WMS内部会为每一个应用的请求保留一个单独的Session，同样实现了IWindowSession接口，应用与WMS之间的通信就通过这个Session。那么这个mWindowSession什么时候被赋值的呢？就在上面的注释1中，我们打开ViewRootlmp的构造函数，如下： 1234public ViewRootImpl(Context context, Display display) &#123; mWindowSession = WindowManagerGlobal.getWindowSession(); //...&#125; 可以看到mWindowSession是通过WindowManagerGlobal的单例类的getWindowSession()获得的，我们打开WindowManagerGlobal的getWindowSession()，如下： 1234567891011121314151617181920212223public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; InputMethodManager imm = InputMethodManager.getInstance(); //1、首先获取WMS的本地代理 IWindowManager windowManager = getWindowManagerService(); //2、通过WMS的本地代理的openSession来获取Session sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123; @Override public void onAnimatorScaleChanged(float scale) &#123; ValueAnimator.setDurationScale(scale); &#125; &#125;, imm.getClient(), imm.getInputContext()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowSession; &#125; &#125; 我们首先看1，getWindowManagerService()源码如下： 1234567891011121314public static IWindowManager getWindowManagerService() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowManagerService == null) &#123; //获取WMS的本地代理对象 sWindowManagerService = IWindowManager.Stub.asInterface( ServiceManager.getService(\"window\")); //... &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowManagerService; &#125; &#125; 可以看到， ServiceManager.getService(“window”)就是获得WMS，然后通过IWindowManager.Stub.asInterface()转换成WMS在应用进程的本地代理，getWindowManagerService()就是返回WMS在本地应用进程的代理。（这里涉及到Binder知识） 然后看2，通过WMS的本地代理的openSession来获取Session，我们可以在WMS中找到这个函数实现，如下： 12345678@Override public IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client, IInputContext inputContext) &#123; //... //为每个窗口请求创建一个Session并返回 Session session = new Session(this, callback, client, inputContext); return session; &#125; 至此建立起与WMS的通信的桥梁。然后WindowManager就间接的通过Session向WMS发起显示窗口视图的请求，WMS会向应用返回和窗口交互的信息。至于mGlobal.updateViewLayout和mClobal.removeView也是类似的过程，可自行研究。 WindowManagerServiceWindowManagerService是一个系统级服务，由SystemService启动，实现了IWindowManager.AIDL接口，它的主要功能分为以下俩方面: 1、窗口管理它负责窗口的启动，添加和删除，它还负责窗口的层级显示（z-orderes）和维护窗口的状态。我们继续上面的mGlobal.addView，上面讲到这个方法是向WMS发起一个显示窗口视图的请求，最终会走到mWindowSession.addToDisplay()方法，我们可以在Session中找到这个函数实现，如下： 12345678@Override public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; //返回WMS中addWindow所返回的结果 return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outStableInsets, outOutsets, outInputChannel); &#125; 可以看到addToDisplay方法中最终返回了WMS中addWindow所返回的结果，Window的添加请求就交给WMS去处理，addWindow的实现在WMS中，里面代码很长，这里就不再深究了（留在下一篇文章从一个例子分析），addWindow主要做的事情是先进行窗口的权限检查，因为系统窗口需要声明权限，然后根据相关的Display信息以及窗口信息对窗口进行校对，再然后获取对应的WindowToken，再根据不同的窗口类型检查窗口的有效性，如果上面一系列步骤都通过了，就会为该窗口创建一个WindowState对象，以维护窗口的状态和根据适当的时机调整窗口状态，最后就会通过WindowState的attach方法与SurfaceFlinger通信。因此SurfaceFlinger能使用这些Window信息来合成surfaces,并渲染输出到显示设备。 2、输入事件的中转站当我们的触摸屏幕时就会产生输入事件，在Android中负责管理事件的输入是InputManagerService，在启动IMS的时候会在native层创建NativeInputManager，在NativeInputManager的构造中会创建InputManager和Eventhub（监听/dev/input/设备节点中所有事件的输入），在InputManager构造中会依此创建InputDispatcher、InputReader、InputReaderThread、InputDispatcherThread。 InputReader运行在InputReaderThread中，它会不断循环从EventHub中读取原始输入事件，InputReader将这些原始输入事件加工后就交给运行在InputDispatcherThread中的InputDispatcher，而InputDispatcher它会寻找一个最合适的窗口来处理输入事件，WMS是窗口的管理者，WMS会把所有窗口的信息更新到InputDispatcher中，这样InputDispatcher就可以将输入事件派发给合适的Window，Window就会把这个输入事件传给顶级View，然后就会涉及我们熟悉的事件分发机制。 我们来再来看在ViewRootImp的setView中调用mWindowSession.addToDisplay方法时传入的参数： 1234567891011121314151617public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; //... mInputChannel = new InputChannel(); //... //通过session与WMS建立通信,同时通过InputChannel接收输入事件回调 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); //... if (mInputChannel != null) &#123; //... //处理输入事件回调 mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); &#125;&#125; 注意这个传入的mInputChannel参数，它是InputChannel类型，它实现了Parcelable接口，用于接受WMS返回来的输入事件，在WMS中会创建两个InputChannel实例，一个会通过mInputChannel参数传回来，一个会放在WMS的WindowState中，WindowState中的InputChannel会交给InputDispatcher，这样应用端和InputDispatcher端就可以通过这两个InputChannel来进行事件的接收和发送。 它们之间的类图关系如下： 总结通过上面简单的介绍，我们知道Window是View的载体，我们想要对Window进行删除，添加，更新View就得通过WindowManager，WindowManager与WMS通过Session进行通信，具体的实现就交给了WMS处理，WMS会为每一个Window创建一个WindowState并管理它们，具体的渲染工作WMS就交给SurfaceFinger处理。本文所讨论的WMS系统相关结构如下： 参考资料： 《Anddroid开发艺术探索》 《Android源码设计模式》 Android解析WindowManager","tags":[{"name":"window","slug":"window","permalink":"http://yoursite.com/tags/window/"},{"name":"windowManager","slug":"windowManager","permalink":"http://yoursite.com/tags/windowManager/"},{"name":"WMS","slug":"WMS","permalink":"http://yoursite.com/tags/WMS/"}]},{"title":"RecyclerView之观察者模式","date":"2019-03-09T09:39:00.000Z","path":"2019/03/09/RecyclerView之观察者模式/","text":"前言RecyclerView是Android开发中的一个重要的模式，通常我们往RecyclerView添加数据时，都会调用Adapter的notifiyXX函数，这是为什么呢，今天我们就从源码来探究一下，对观察者模式不熟悉的读者，可以看一下这一篇博客观察者模式, RecyclerView在更新数据时也算是对观察者模式的一种应用。 本文源码基于Android8.0, 相关源码位置如下 frameworks/support/v7/recyclerview/src/android/support/v7/widget/RecyclerView.java frameworks/base/core/java/android/database/Observable.javaAdapter.notifyDataSetChange()我们来看一下我们平常可能使用到的notifyXX方法： 可以看到，RecyclerView可ListView相比多了很多notifyItemXX方法，说明RecyclerView支持定向刷新，如果只有部分itemView数据发生变化，在使用ListView时我们没得选择只能使用notifyDataSetChange()方法来对整体itemView更新数据，但是在RecyclerView中，我们可以只对发生数据变化的itemView更新，当样也可以整体更新，而且相信大家现在在使用RecyclerView更新itemView时使用最多的方法还是Adapter.notifyDataSetChange()吧。那我们就以这个方法为例，该方法的源码如下: 123public final void notifyDataSetChanged() &#123; mObservable.notifyChanged();&#125; 这个mObservable是声明在Adapter中的AdapterDataObservable对象，如下: 1234public abstract static class Adapter&lt;VH extends ViewHolder&gt; &#123; private final AdapterDataObservable mObservable = new AdapterDataObservable(); //...&#125; 而AdapterDataObservable定义在RecyclerView中，Adapter.notifyDataSetChange()调用了AdapterDataObservable.notifyChanged()方法，该方法源码如下: 12345678static class AdapterDataObservable extends Observable&lt;AdapterDataObserver&gt; &#123; public void notifyChanged() &#123; for (int i = mObservers.size() - 1; i &gt;= 0; i--) &#123; mObservers.get(i).onChanged(); &#125; &#125;//...&#125; 可以看到该方法做的事情是遍历mObservers集合，然后逐个调用onChanged()方法，那么mObservers是什么东西？mObservers其实就是一个观察者列表，而mObservable就是一个被观察者，每个Adapter中只有一个被观察者，被观察者中有一个观察者列表，当有数据更新时，被观察者就会调用遍历调用注册到观察者列表中观察者的onChanged方法，来通知观察者更新数据。mObservers其实是一个ArrayList，它定义在AdapterDataObservable的父类Observable中，Observable的定义如下: 12345678910111213141516171819202122public abstract class Observable&lt;T&gt; &#123; protected final ArrayList&lt;T&gt; mObservers = new ArrayList&lt;T&gt;();//观察者集合列表 //注册一个观察者 public void registerObserver(T observer) &#123; //... mObservers.add(observer); &#125; //取消该观察者的注册 public void unregisterObserver(T observer) &#123; //... mObservers.remove(index); &#125; //取消所有观察者的注册 public void unregisterAll() &#123; synchronized(mObservers) &#123; mObservers.clear(); &#125; &#125;&#125; Observable中只有几个简单的方法，所以我们要向观察者列表中注册一个观察者，才能接受到更新通知，那么RecyclerView是怎么注册一个观察者的吗？其实是通过RecyclerView.setAdapter()方法实现的。 RecyclerView.setAdapter()我们每次使用RecyclerView都要调用setAdapter()设置一个Adapter，不然数据就无法展示，该方法的源码如下: 1234public void setAdapter(@Nullable Adapter adapter) &#123; //... setAdapterInternal(adapter, false, true);&#125; 在setAdapter又调用了setAdapterInternal(), 该方法相关源码如下: 1234567891011121314151617181920private void setAdapterInternal(@Nullable Adapter adapter, boolean compatibleWithPrevious, boolean removeAndRecycleViews) &#123; //1、移除旧的Adapter，并注销观察者 if (mAdapter != null) &#123; mAdapter.unregisterAdapterDataObserver(mObserver); &#125; //2、compatibleWithPrevious为false，表示不使用旧的Adapter中ViewHolder，所以调用removeAndRecycleViews方法把ViewHolder旧的Adapter中的ViewHolder回收复用 if (!compatibleWithPrevious || removeAndRecycleViews) &#123; removeAndRecycleViews(); &#125; //3、更新Adapter并注册一个观察者 final Adapter oldAdapter = mAdapter; mAdapter = adapter; if (adapter != null) &#123; //注册一个观察者 adapter.registerAdapterDataObserver(mObserver); &#125; //...&#125; setAdapterInternal()方法中就主要做了上面3件事，而且上面Adapter中调用的registerXX或unregisterXX最终调用mObservable的方法, 如下: 123456789101112public abstract static class Adapter&lt;VH extends ViewHolder&gt; &#123; public void registerAdapterDataObserver(@NonNull AdapterDataObserver observer) &#123; mObservable.registerObserver(observer); &#125; public void unregisterAdapterDataObserver(@NonNull AdapterDataObserver observer) &#123; mObservable.unregisterObserver(observer); &#125; //...&#125; 这些方法的含义已经在上面讲解Observable时解释过了。那么在setAdapterInternal()中注册的观察者mObserver是什么呢？它其实就是一个RecyclerViewDataObserver类型，定义在RecyclerView中，如下: 1234public class RecyclerView extends ViewGroup implements ScrollingView, NestedScrollingChild2 &#123; private final RecyclerViewDataObserver mObserver = new RecyclerViewDataObserver(); //...&#125; 而RecyclerViewDataObserver是AdapterDataObserver的子类，它定义在RecyclerView中，如下： 12345678910111213private class RecyclerViewDataObserver extends AdapterDataObserver &#123; @Override public void onChanged() &#123; //... if (!mAdapterHelper.hasPendingUpdates()) &#123; //请求重新布局 requestLayout(); &#125; &#125; //...&#125; 可以看到我们熟悉的onChange方法，RecyclerViewDataObserver重写了它，当满足一定条件时就会重新布局从而从可以从Adapter中获取更新数据并绑定数据到itemView,达到更新itemView的目的。所以RecyclerView在设置Adapter是时，会注册一个观察者mObserver到Adapter的被观察者mObservable中。 总结最后我们来整理一下这个过程，RecyclerView中有一个观察者mObserver，是RecyclerViewDataObserver类型，在RecyclerView设置Adapter时会把它注册到Adapter中，而Adapter中包含一个被观察者mObservable，是AdapterDataObservable类型，注册到Adapter中的观察最终会注册到mObservable的mObservers列表中，当我们手动调用Adapter的notifyXX函数时，notifyXX函数实际上会调用AdapterDataObservable的notifyXX函数，该函数会遍历所有观察者的onChange函数，在RecyclerViewDataObserver的onChange函数中会要求RecyclerView调用requestLayout()重新布局,更新用户界面。如图：","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"recyclerView","slug":"recyclerView","permalink":"http://yoursite.com/tags/recyclerView/"}]},{"title":"RecyclerView之缓存设计","date":"2019-03-08T06:56:50.000Z","path":"2019/03/08/RecyclerView之缓存设计/","text":"前言 上一篇文章RecyclerView之布局设计 RecyclerView，见名之义，这个View代表了可循环使用的视图集合控件，封装了View的缓存逻辑判断，RecyclerView的基本单元是ViewHolder，里面有一个itemView代表了视图上的子View，所以RecyclerView的缓存基本单元也是ViewHolder。本文将从源码的角度来讲解RecyclerView的缓存设计。 本文相关源码基于Android8.0，相关源码位置如下: frameworks/support/v7/recyclerview/src/android/support/v7/widget/RecyclerView.java frameworks/support/v7/recyclerview/src/android/support/v7/widget/LinearLayoutManager.javaRecycler介绍这里首先介绍一下Recycler，它定义在RecyclerView中，如下： 1234567891011public final class Recycler &#123; final ArrayList&lt;ViewHolder&gt; mAttachedScrap = new ArrayList&lt;&gt;();//缓存着在屏幕中显示的ViewHolder final ArrayList&lt;ViewHolder&gt; mCachedViews = new ArrayList&lt;ViewHolder&gt;();//缓存着已经滚动出屏幕的ViewHolder,即屏幕外的ViewHolder RecycledViewPool mRecyclerPool;//ViewHolder的缓存池，屏幕外缓存的mCachedViews已满时，会将ViewHolder缓存到RecycledViewPool中。 private ViewCacheExtension mViewCacheExtension;//自定义缓存，自己实现ViewCacheExtension类来实现缓存。 ArrayList&lt;ViewHolder&gt; mChangedScrap = null;//屏幕内缓存，缓存着数据已经改变的ViewHolder int mViewCacheMax = DEFAULT_CACHE_SIZE;//mCachedViews默认缓存数量 static final int DEFAULT_CACHE_SIZE = 2;//默认缓存数量为2 private int mRequestedCacheMax = DEFAULT_CACHE_SIZE; //可以设置mCachedViews的最大缓存数量，默认为2 //...&#125; Recycler是RecyclerView的核心类，是RecyclerView的缓存实现类，它有着四级缓存： 1、mAttachedScrap屏幕内缓存, 当我们调用notifiXX函数重新布局时，在布局之前，LayoutManager会调用detachAndScrapAttachedViews(recycler)把在RecyclerView中显示的ViewHolder一个个的剥离下来,然后缓存在mAttachedScrap中，等布局时会先从mAttachedScrap查找，再把ViewHolder一个个的放回RecyclerView原位中去，mAttachedScrap只是单纯的保存从RecyclerView中剥离的ViewHolder，再重新放回RecyclerView中去，如果放回后还有剩余的ViewHolder没有参加新布局，会从mAttachedScrap移到mCachedViews中。 2、mCachedViews在RecyclerView滚动时，对于那些不在RecyclerView中显示的ViewHolder，LayoutManager会调用removeAndRecycleAllViews(recycler)把这些已经移除的ViewHolder缓存在mCacheViews中，它的默认大小是2，当它满了的时候，就会利用先进先出原则，把老的ViewHolder移到mRecyclerPool中，mCachedViews它只是缓存最新被移除出屏幕的ViewHolder。 3、mViewCacheExtension自定义缓存实现，一般而言，我们不会自定义缓存实现，使用Recycler提供的3级缓存足够。 4、mRecyclerPool缓存池，通过前面1、2可以知道，真正废弃的ViewHolder最终移到mRecyclerPool，当我们向RecyclerView申请一个HolderView来使用的时，如果在mAttachedScrap、mCachedViews匹配不到，即使他们中有ViewHolder也不会返回给我们使用，而是会到mRecyclerPool中去拿一个废弃的ViewHolder返回。 mRecyclerPool内部维护了一个SparseArray，在mRecyclerPool中会根据每个ViewType把ViewHolder分别存储在不同的列表中，每个ViewType默认缓存5个ViewHolder，而且RecyclerViewPool也可以是多个RecyclerView之间的ViewHolder的缓存池，只要通过RecyclerView.setRecycledViewPool(RecycledViewPool)设置同一个RecycledViewPool，设置时，不需要自己去new 一个 RecyclerViewPool，每个RecyclerView默认都有一个RecyclerViewPool，只需要通过mRecyclerView.getRecycledViewPool()获取。RecyclerViewPool大概结构如下： 123456789101112131415161718192021222324252627282930313233343536public static class RecycledViewPool &#123; private static final int DEFAULT_MAX_SCRAP = 5; static class ScrapData &#123; final ArrayList&lt;ViewHolder&gt; mScrapHeap = new ArrayList&lt;&gt;(); int mMaxScrap = DEFAULT_MAX_SCRAP; //... &#125; //SparseArray的key为type，value为ScrapData，ScrapData中包含ViewHolder列表 SparseArray&lt;ScrapData&gt; mScrap = new SparseArray&lt;&gt;(); //... //根据type从缓存池中获取一个ViewHolder public ViewHolder getRecycledView(int viewType) &#123; final ScrapData scrapData = mScrap.get(viewType); if (scrapData != null &amp;&amp; !scrapData.mScrapHeap.isEmpty()) &#123; final ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap; return scrapHeap.remove(scrapHeap.size() - 1); &#125; return null; &#125; //把一个ViewHolder放入缓存池中缓存 public void putRecycledView(ViewHolder scrap) &#123; final int viewType = scrap.getItemViewType(); final ArrayList&lt;ViewHolder&gt; scrapHeap = getScrapDataForType(viewType).mScrapHeap; if (mScrap.get(viewType).mMaxScrap &lt;= scrapHeap.size()) &#123; return; &#125; //... scrap.resetInternal(); scrapHeap.add(scrap); &#125;&#125; 所以我们从Recycler中获取一个ViewHolder时，是这样的顺序：mAttachedScrap -&gt; mCachedViews -&gt; mViewCacheExtension -&gt; mRecyclerPool,当上述步骤都找不到了，就会调用Adapter的creat函数创建一个ViewHolder。那这里为什么省略mChangedScrap不讲呢？因为mChangedScrap是跟RecyclerView的预布局有关，缓存着RecyclerView中数据改变过的ViewHolder，而预布局默认为false，一般是RecyclerView执行动画时才会为true，我们上一篇文章也没有讨论执行动画的时候的布局过程，所以这里就不分析mChangedScrap。 Recycler.getViewForPosition()在上篇文章中，提到在layoutChunk函数中，首先会调用LayoutState对象的next函数获取到一个itemView，然后布局这个itemView，我们来看LayoutState的next函数相关实现: 123456789View next(RecyclerView.Recycler recycler) &#123; //省略了一个mScrapList，属于LayoutManager，跟执行动画时的缓存有关，这里不分析 //... //这里才是核心，调用Recycler中的getViewForPosition获取itemView final View view = recycler.getViewForPosition(mCurrentPosition); //把itemView索引移到下一个位置 mCurrentPosition += mItemDirection; return view;&#125; 上述代码实际是调用RecyclerView.Recycler对象的getViewForPosition方法获取itemView，而该函数最终会获取一个ViewHolder，从而返回ViewHolder中的itemView，我们来看该函数相关调用和实现： 12345678910111213public View getViewForPosition(int position) &#123; return getViewForPosition(position, false);&#125;View getViewForPosition(int position, boolean dryRun) &#123; //可以看到最终返回的是ViewHolder中的itemView return tryGetViewHolderForPositionByDeadline(position, dryRun, FOREVER_NS).itemView;&#125;//获取一个ViewHolderViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; //...&#125; Recycler的getViewForPosition方法最终会调用到tryGetViewHolderForPositionByDeadline方法，tryGetViewHolderForPositionByDeadline方法的意图是通过给定的position从Recycler的scrap, cache，RecycledViewPool获取一个ViewHolder或者通过Adapter直接创建一个ViewHolder。我们来看tryGetViewHolderForPositionByDeadline方法相关源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//参数解释：//position：要获得哪个位置的ViewHolder//dryRun: 代表position的ViewHolder是否已经从scrap或cache列表中移除，这里为false，表示没有，因为布局函数layoutChildren中一定会调用detachAndScrapAttachedViews(recycler)函数，表示把ViewHolder放入scrap列表中ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; //省略了跟预布局有关的mChangedScrap获取ViewHolder，mChangedScrap不属于常规缓存 //... ViewHolder holder = null; if (holder == null) &#123; //1、第一次查找，通过position从scrap或hidden或cache中找ViewHolder holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun); //如果找到ViewHolder，检查ViewHolder的合法性 if (holder != null) &#123; //检查ViewHolder的是否被移除，position是否越界等，如果检查通过返回true，失败返回false if (!validateViewHolderForOffsetPosition(holder)) &#123; //检查不通过 //上述讲过dryRun为false if (!dryRun) &#123; //设置这个ViewHolder为无效标志 holder.addFlags(ViewHolder.FLAG_INVALID); //把这个ViewHolder从scrap列表中移除 if (holder.isScrap()) &#123; removeDetachedView(holder.itemView, false); holder.unScrap(); &#125; //... //把这个ViewHolder放入cache列表中或mRecyclerPool中 recycleViewHolderInternal(holder); &#125; //置空不匹配的ViewHolder，进入下一步查找 holder = null; &#125; else &#123; //检查通过了 fromScrapOrHiddenOrCache = true; &#125; &#125; &#125; if (holder == null) &#123; //... final int offsetPosition = mAdapterHelper.findPositionOffset(position); //这里可以看到我们熟悉的Adapter中的getItemViewType方法，重写此方法可以让RecyclerView显示多种type的itemView final int type = mAdapter.getItemViewType(offsetPosition); //如果mAdapter.hasStableIds()为true，就进入第2次查找，默认返回false if (mAdapter.hasStableIds()) &#123; //2、第2次查找，根据ViewHolder的type和id从scrap或cached列表查找 holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition), type, dryRun); if (holder != null) &#123; //找到了 //更新ViewHolder的位置 holder.mPosition = offsetPosition; fromScrapOrHiddenOrCache = true; &#125; &#125; if (holder == null &amp;&amp; mViewCacheExtension != null) &#123; //3、第3次查找，从自定义缓存中查找，一般我们不会重写ViewCacheExtension final View view = mViewCacheExtension.getViewForPositionAndType(this, position, type); //... &#125; if (holder == null) &#123; //4、第4次查找，从RecycledViewPool中查找，可以看到这里会根据type返回一个使用过的ViewHolder给你 holder = getRecycledViewPool().getRecycledView(type); if (holder != null) &#123;//找到了 //重置ViewHolder中的信息 holder.resetInternal(); //... &#125; &#125; //前面的4次还找不到合适的ViewHolder，就重新创建一个 if (holder == null) &#123; //... //5、这里会调用Adapter中的OnCreateViewHolder方法 holder = mAdapter.createViewHolder(RecyclerView.this, type); &#125; &#125; //... boolean bound = false; //6、只要满足以下3个情况： //1、ViewHolder没有被绑定过，即没有设置FLAG_BOUND标志位 //2、ViewHolder需要更新，即设置了FLAG_UPDATE标志位 //3、ViewHolder是无效的，即设置了FLAG_INVALID标志位 //就会调用Adapter中的OnBindViewHolder方法 if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); //这里最终调用Adapter中的OnBindViewHolder方法 bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs); &#125; &#125; 看起来函数很长但是步骤还是很清晰的，我们把它分为注释1、2、3、4、5、6来看： 1、调用getScrapOrHiddenOrCachedHolderForPosition()注释1中通过position从scrap或hidden或cache中找ViewHolder，我们来看getScrapOrHiddenOrCachedHolderForPosition方法的关键源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 ViewHolder getScrapOrHiddenOrCachedHolderForPosition(int position, boolean dryRun) &#123; //1.1、第一次尝试，从mAttachedScrap找到一个精确，没有失效的ViewHolder并返回 final int scrapCount = mAttachedScrap.size(); for (int i = 0; i &lt; scrapCount; i++) &#123; final ViewHolder holder = mAttachedScrap.get(i); if (!holder.wasReturnedFromScrap() &amp;&amp; holder.getLayoutPosition() == position &amp;&amp; !holder.isInvalid() &amp;&amp; (mState.mInPreLayout || !holder.isRemoved()))&#123; //标志这个ViewHolder是从mAttachedScrap取出并返回的 holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP); return holder; &#125; &#125; //1.2、第二次尝试，dryRun为false，从RecyclerView中隐藏的itemView中找，如果找到合适的View，就让它显示并把它从RecyclerView中剥离，然后根据这个View的LayoutParam获取ViewHolder，最后把这个ViewHolder放入mAttachedScrap并返回 if (!dryRun) &#123; View view = mChildHelper.findHiddenNonRemovedView(position); if (view != null) &#123; //获取ViewHolder final ViewHolder vh = getChildViewHolderInt(view); //显示这个View mChildHelper.unhide(view); //从RecyclerView剥离这个View mChildHelper.detachViewFromParent(layoutIndex); //把这个ViewHolder放入mAttachedScrap scrapView(view); vh.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP | ViewHolder.FLAG_BOUNCED_FROM_HIDDEN_LIST); //返回 return vh; &#125; &#125; //1.3、第三次尝试，从mCachedViews找到没有失效的ViewHolder并返回 final int cacheSize = mCachedViews.size(); for (int i = 0; i &lt; cacheSize; i++) &#123; final ViewHolder holder = mCachedViews.get(i); if (!holder.isInvalid() &amp;&amp; holder.getLayoutPosition() == position) &#123; if (!dryRun) &#123; mCachedViews.remove(i); &#125; return holder; &#125; &#125; return null;&#125; 可以看到注释1的第一次查找，里面分为3步： 1.1、从mAttachedScrap找。 1.2、如果上一步没有得到合适的缓存，从HiddenViews找。 1.3、如果上一步没有得到合适的缓存，从mCachedViews找。 从上面3个步骤之一找到，就返回ViewHolder，然后检查ViewHolder的有效性，如果无效，则从mAttachedScrap中移除，并加入到mCacheViews或者mRecyclerPool中，并且将ViewHolder置为null，走到下一步。 2、调用getScrapOrCachedViewForId()下一步就是注释2，如果我们通过Adapter.setHasStableIds(boolean)设置为true，就会进入,里面根据ViewHolder的type和id从scrap或cached列表查找ViewHolder，我们来看一下相关源码该方法的相关源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546ViewHolder getScrapOrCachedViewForId(long id, int type, boolean dryRun) &#123;//2.1、第一次尝试，从mAttachedScrap找到一个id相同并且没有从mAttachedScrap取出并返回过的ViewHolder，还要type相同的ViewHolder返回 final int count = mAttachedScrap.size(); for (int i = count - 1; i &gt;= 0; i--) &#123; final ViewHolder holder = mAttachedScrap.get(i); if (holder.getItemId() == id &amp;&amp; !holder.wasReturnedFromScrap()) &#123; //id相同type相同 if (type == holder.getItemViewType()) &#123; holder.addFlags(ViewHolder.FLAG_RETURNED_FROM_SCRAP); //... &#125; return holder; &#125; else if (!dryRun) &#123; //id相同但type不同 //从mAttachedScrap移除这个ViewHolder mAttachedScrap.remove(i); removeDetachedView(holder.itemView, false); //把这个ViewHolder放入caches或RecyclerViewPool quickRecycleScrapView(holder.itemView); &#125; &#125; &#125; //2.2、第2次尝试，从mCachedViews中找到一个id相同并且type相同的ViewHolder返回 final int cacheSize = mCachedViews.size(); for (int i = cacheSize - 1; i &gt;= 0; i--) &#123; final ViewHolder holder = mCachedViews.get(i); if (holder.getItemId() == id) &#123; //id相同并且type相同 if (type == holder.getItemViewType()) &#123; if (!dryRun) &#123; //从cache中移除 mCachedViews.remove(i); &#125; return holder; &#125; else if (!dryRun) &#123; //id相同type不相同 //把这个ViewHolder从cache中移除并放入RecyclerViewPool中 recycleCachedViewAt(i); return null; &#125; &#125; &#125; return null;&#125; 可以看到注释2的第二次查找，里面分为2步： 2.1、从mAttachedScrap找。 2.2、如果上一步没有得到合适的缓存，从mCachedViews找。 第二次查找跟第一次不同的是，它是通过Adapter.getItemId(position)获得该位置ViewHolder的id，来查找ViewHolder，我们可以重写Adapter.getItemId(position)返回每个position的ViewHolder的id，默认返回RecyclerView.NO_ID。从上面2个步骤之一找到，就返回ViewHolder，如果找不到就进入下一步。 3、从ViewCacheExtension中找注释3的第三次查找是从自定义缓存中查找，这个没什么好说，可以直接到下一步。 4、从RecyclerViewRool中找下一步就是第4次查找，从RecyclerdViewPool中查找，可以看到这里先使用getRecyclerViewPool获得Recycler中的RecyclerViewPool，然后调用RecyclerViewPool的getRecycledView(type)根据type获取一个ViewHolder，我们来看该方法的源码： 1234567891011 public ViewHolder getRecycledView(int viewType) &#123; //根据type取出ScrapData final ScrapData scrapData = mScrap.get(viewType); if (scrapData != null &amp;&amp; !scrapData.mScrapHeap.isEmpty()) &#123; //取出ScrapData中的ViewHolder列表 final ArrayList&lt;ViewHolder&gt; scrapHeap = scrapData.mScrapHeap; //返回一个ViewHolder并从pool中删除 return scrapHeap.remove(scrapHeap.size() - 1); &#125; return null;&#125; mScrap是SparseArray类型，它会根据type把ViewHolder存放在不同ScrapData中，ScrapData中有一个mScrapHeap，是ArrayList类型，它会存放RecyclerViewPool中放进来的ViewHolder。所以上面这个方法首先会根据type取出ScrapData，然后取出mScrapHeap，如果mScrapHeap有元素，就返回并删除，然后重置这个ViewHolder让它复用，如果没有就进入下一步。 5、调用Adapter的createViewHolder()既然缓存中没有就创建一个，该方法的相关源码如下： 1234 public final VH createViewHolder(@NonNull ViewGroup parent, int viewType) &#123; //... final VH holder = onCreateViewHolder(parent, viewType);&#125; 可以看到，调用了我们熟悉的onCreateViewHolder方法，该方法就是用来创建ViewHolder。 到这里，经过tryGetViewHolderForPositionByDeadline方法中的注释1、2、3、4、5步骤之一拿到了ViewHolder，接下来就是看是否需要调用Adapter的OnBindViewHolder方法绑定ViewHolder。 6、根据情况调用Adapter的OnBindViewHolder()从上面知道当缓存中不能提供ViewHolder就会调用adapter的onCreateViewHolder创建一个，那么我们同样熟悉的OnBindViewHolder方法是什么时候执行的呢？如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243ViewHolder tryGetViewHolderForPositionByDeadline(int position, boolean dryRun, long deadlineNs) &#123; //... ViewHolder holder = null; //... //走到这里表示holder已经经过各种手段赋值了 //6、只要满足以下3个情况： //1、ViewHolder没有被绑定过，即没有设置FLAG_BOUND标志位 //2、ViewHolder需要更新，即设置了FLAG_UPDATE标志位 //3、ViewHolder是无效的，即设置了FLAG_INVALID标志位 //就会调用Adapter中的OnBindViewHolder方法 if (!holder.isBound() || holder.needsUpdate() || holder.isInvalid()) &#123; final int offsetPosition = mAdapterHelper.findPositionOffset(position); //这里最终调用Adapter中的OnBindViewHolder方法 bound = tryBindViewHolderByDeadline(holder, offsetPosition, position, deadlineNs); &#125;&#125;private boolean tryBindViewHolderByDeadline(ViewHolder holder, int offsetPosition, int position, long deadlineNs) &#123; //... //调用Adapter的OnBindViewHolder方法 mAdapter.bindViewHolder(holder, offsetPosition); return true;&#125;public abstract static class ViewHolder &#123; //... boolean isBound() &#123; return (mFlags &amp; FLAG_BOUND) != 0; &#125; boolean needsUpdate() &#123; return (mFlags &amp; FLAG_UPDATE) != 0; &#125; boolean isInvalid() &#123; return (mFlags &amp; FLAG_INVALID) != 0; &#125;&#125; holder.isBound()、holder.needsUpdate() 、holder.isInvalid()方法中会分别判断ViewHolder中有没有设置FLAG_BOUND标志位、FLAG_UPDATE标志位、FLAG_INVALID标志位，只要满足3种情况之一，就会调用Adapter的OnBindViewHolder方法绑定数据，这3种情况的解释如下： 1、没有设置FLAG_BOUND标志位：它表示ViewHolder没有调用过OnBindViewHolder方法，一般是调用Adapter的OnCreateViewHolder方法创建的ViewHolder会出现这种情况； 2、设置了FLAG_UPDATE标志位：它表示ViewHolder需要更新，一般是调用了Adapter的定向更新的相关方法或者ViewHolder是从RecycledViewPool中取出的就会出现这种情况； 3、设置了FLAG_INVALID标志位：它表示ViewHolder是无效的，一般是从mAttachedScrap或mCacheViews中取出ViewHolder后，发现它满足被移除或者position越界了等不合法的条件，就会把取出ViewHolder设置FLAG_INVALID标志位，标志无效，然后调用recycleViewHolderInternal方法把它放入mCacheViews或RecycledViewPool中，在recycleViewHolderInternal方法中ViewHolder首先会被尝试放入mCacheViews(默认大小为2)中，如果满了，就会利用先进先出原则，把老的ViewHolder移到mRecyclerPool中。 bind方法是用来绑定数据，对于从mAttachedScrap中拿出来的ViewHolder是不用重新bind的，而对于从mRecyclerPool拿出和通过Create方法创建的ViewHolder是需要重新bind的，而对于从mCacheViews中拿出的ViewHolder有可能会被bind，当调用getScrapOrHiddenOrCachedHolderForPosition方法根据position获取ViewHolder时，如果这个ViewHoler是从mCacheViews中取出的，说明满足有效的、positioin匹配这两种情况，如果这个ViewHolder同时是合法的，那么这个ViewHolder不需要重新bind，而如果是不合法的，就会标志无效，再次放入mCacheViews中(有可能会移动到mRecyclerPool)，等待调用getScrapOrCachedViewForId方法根据type和id从mCacheViews再次获取这个已经被标记为无效的ViewHolder，如果这个无效的ViewHolder的type和id都匹配的话，就会获取这个无效的ViewHolder，而此时这个ViewHolder是需要重新bind的。 从前面的分析来看，mAttachedScrap和mCacheViews都是position匹配或者type和id匹配才会命中返回ViewHolder，而mRecyclerPool则没有这些限制，只要mRecyclerPool中相应type类型的ViewHolder缓存有，就会命中返回ViewHolder，且优先级mAttachedScrap &gt; mCacheViews &gt; mRecyclerPool，通过以下3个场景，加深大家理解mAttachedScrap、mCacheViews、mRecyclerPool的作用： 1、当RecyclerView列表上下滑动时，屏幕内的ViewHolder会被缓存到mAttachedScrap中，在屏幕内改变位置的ViewHolder复位后，很快会从mAttachedScrap复用到原位置上； 2、当RecyclerView列表向上滑动，列表顶部有ViewHolder滑出屏幕，滑出屏幕的ViewHolder会被缓存到mCacheViews中，当列表向下滑动复位时，滑出屏幕的ViewHolder很快从mCacheViews复用到原位置上； 3、当RecyclerView列表向上滑动，列表顶部有ViewHolder滑出屏幕，滑出屏幕的ViewHolder会被缓存到mCacheViews中，多余的会移动到mRecyclerPool中，列表底部有空余的ViewHolder位置，这时会从mRecyclerPool取出ViewHolder复用，填充底部空余的ViewHolder位置。 总结本文中源码角度简单的分析RecyclerView布局一个itemView时是怎样通过Recycler来获取一个ViewHolder，从而获取itemView，如图： 准确的来说，Recycler是RecyclerView的itemView的提供者和管理者，它在内部封装了RecyclerView的缓存设计实现，在RecyclerView中有着四级缓存：AttachedScrap,mCacheViews,ViewCacheExtension,RecycledViewPool，正因为这样RecyclerView在使用的时候效率更好。 参考文章: RecyclerView和ListView原理 RecyclerView缓存机制（咋复用？）","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"recyclerView","slug":"recyclerView","permalink":"http://yoursite.com/tags/recyclerView/"}]},{"title":"RecyclerView之布局设计","date":"2019-03-01T07:10:00.000Z","path":"2019/03/01/RecyclerView之布局设计/","text":"前言RecyclerView功能强大，自推出以来受到了无数人的喜爱，它可以通过一个LayoutManager将一个RecyclerView显示为不同的样式，例如ListView、GridView样式、瀑布流样式，所以加深对于RecyclerView的学习对于开发有很重要的意义。关于RecyclerView如何使用网上有很多文章，本篇文章从源码讲解RecyclerView如何通过layoutManager来进行布局。 本文相关源码基于Android8.0，相关源码位置如下: frameworks/support/v7/recyclerview/src/android/support/v7/widget/RecyclerView.java frameworks/support/v7/recyclerview/src/android/support/v7/widget/LinearLayoutManager.javaRecyclerView.onLayout()Android中每一个控件从它被定义到xml布局文件到呈现在屏幕上都要经过onMeasure -&gt; onLayout -&gt; onDraw 三个阶段，RecyclerView同样不例外，它的布局在OnLayout函数中进行，该方法相关源码如下: 1234protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; dispatchLayout(); mFirstLayoutComplete = true;&#125; 可以看到该方法只是简单的调用了dispatchLayout方法,并记录了是第一次布局，dispatchLayout()相关源码如下： 12345678910111213141516171819202122232425262728 void dispatchLayout() &#123; //1、检查是否设置了Adapter和LayoutManager if (mAdapter == null) &#123; return; &#125; if (mLayout == null) &#123; return; &#125; //... //2、RecyclerView的布局分3步，即dispatchLayoutStep1()，dispatchLayoutStep2()，dispatchLayoutStep3()，下面分情况进行dispatchLayoutStep1()，dispatchLayoutStep2() //2.1、没有执行过布局流程，执行 dispatchLayoutStep1()， dispatchLayoutStep2() if (mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); //2.2、已经执行过布局流程，但是因为数据变化或布局大小发生改变，重新执行 dispatchLayoutStep2() &#125;else if (mAdapterHelper.hasUpdates() || mLayout.getWidth() != getWidth() || mLayout.getHeight() != getHeight()) &#123; mLayout.setExactMeasureSpecsFrom(this); dispatchLayoutStep2(); //2.3、已经执行过布局流程并且数据和布局大小也确定了 &#125; else &#123; //设置RecyclerView的宽高为精确模式（即MeasureSpecMode == MeasureSpec.EXACTLY） mLayout.setExactMeasureSpecsFrom(this); &#125; //3、RecyclerView的布局第3步 dispatchLayoutStep3() dispatchLayoutStep3();&#125; 上面源码我分3部分解释，首先注释1，没有设置RecyclerView的Adapter和LayoutManager直接return，这也解释了为什么我们平时忘记设置它们时RecyclerView会显示不出数据。然后注释2、3，这两部分一起讲，因为RecyclerView的布局过程分为3步：dispatchLayoutStep1，dispatchLayoutStep2和dispatchLayoutStep3。在讲解之前先讲解mState.mLayoutStep，mState是State类型用于保存RecyclerView的状态，mLayouStep定义在State中，有三种取值分别代表了布局过程的3个步骤，如下： 1234567//RecyclerView.Statepublic static class State &#123; static final int STEP_START = 1; //还未执行dispatchLayoutStep1()，初始步骤 static final int STEP_LAYOUT = 1 &lt;&lt; 1; //已经执行了dispatchLayoutStep1()或dispatchLayoutStep2()，布局步骤 static final int STEP_ANIMATIONS = 1 &lt;&lt; 2; //已经执行dispatchLayoutStep2()，动画步骤 //... int mLayoutStep = STEP_START; 可以看到mLayoutStep默认是STEP_START取值，下面我们简单分析RecyclerView的布局过程3步分别做了什么，首先dispatchLayoutStep1()的相关源码如下： 123456789101112131415161718private void dispatchLayoutStep1() &#123; //确保dispatchLayoutStep1()还未被执行过 mState.assertLayoutStep(State.STEP_START); //... //1、处理Adapter数据更新的问题，计算需要运行的动画类型 processAdapterUpdatesAndSetAnimationFlags(); //2、存储关于View的一些状态和信息 //... //3、 如果有必要，会进行预言性的布局，并且保存相关信息。 if (mState.mRunSimpleAnimations) &#123; //... &#125; if(mState.mRunPredictiveAnimations)&#123; //... &#125; //更新mLayoutStep的值，进入布局步骤 mState.mLayoutStep = State.STEP_LAYOUT;&#125; 省略了很多东西，dispatchLayoutStep1()主要是来存储当前子View的状态并确定是否要执行动画、如果过有必要，会进行预言性的布局，并且保存相关信息，本文重点不在此，然后来看看dispatchLayoutStep2()，相关源码如下： 1234567891011121314151617181920private void dispatchLayoutStep2() &#123; //方法执行期间不能要求RequestLayout() startInterceptRequestLayout(); //确保已经执行了dispatchLayoutStep1()或dispatchLayoutStep2(), 从这里可以看出dispatchLayoutStep2()可能会被多次执行 mState.assertLayoutStep(State.STEP_LAYOUT | State.STEP_ANIMATIONS); //1、设置好初始状态 mAdapterHelper.consumeUpdatesInOnePass(); mState.mItemCount = mAdapter.getItemCount(); mState.mDeletedInvisibleItemCountSincePreviousLayout = 0; mState.mInPreLayout = false; //2、调用布局管理器去布局（布局核心方法） mLayout.onLayoutChildren(mRecycler, mState)； // 动画相关状态 mState.mRunSimpleAnimations = mState.mRunSimpleAnimations &amp;&amp; mItemAnimator != null; //更新mLayoutStep值，进入动画步骤 mState.mLayoutStep = State.STEP_ANIMATIONS; stopInterceptRequestLayout(false);&#125; dispatchLayoutStep2()大部分源码都在此，它才是本文的重点，它在里面调用 mLayout.onLayoutChildren(）将布局的具体策略交给了LayoutManager，下面我们会重点分析这个函数，最后我们再来看看dispatchLayoutStep3()，相关源码如下： 12345678910111213141516private void dispatchLayoutStep3() &#123; //确保已经执行dispatchLayoutStep2() mState.assertLayoutStep(State.STEP_ANIMATIONS); //... //重置mLayoutStep的值 mState.mLayoutStep = State.STEP_START; //1、触发动画 if(mState.mRunSimpleAnimations)&#123; //... &#125; //2、保存View的一些信息 //... //3、清除状态和清除无用的信息 mViewInfoStore.clear() //...&#125; 省略了大量代码，dispatchLayoutStep3()同样跟动画相关，它主要保存关于Views的所有信息、触发动画、做必要的清理操作，它也不是本文的重点。可以看到mLayoutStep与dispatchLayoutStep()对应关系如下： 123STEP_START --&gt; dispatchLayoutStep1()STEP_LAYOUT --&gt; dispatchLayoutStep2()STEP_ANIMATIONS --&gt; dispatchLayoutStep2(), dispatchLayoutStep3() 讲完3个步骤我们在回到RecyclerView.dispatchLayout()，RecyclerView的布局入口OnLayout()会执行dispatchLayout()，dispatchLayout（）会根据RecyclerView的布局步骤执行dispatchLayoutStep1、2、3。那么为什么dispatchLayout（）中会分2.1, 2.2, 2.3条件执行dispatchLayoutStep1、2，而不直接按顺序dispatchLayoutStep1、2、3执行布局流程？这是因为在RecyclerView的onMeasure中，dispatchLayoutStep1、2就已经有可能因为RecyclerView自动测量模式中由于测量出来的宽高不精确而被调用，相应代码如下： 123456789101112131415161718192021222324252627282930protected void onMeasure(int widthSpec, int heightSpec) &#123; //... //设置了layoutaManager后，layoutaManager默认开启自动测量模式 if (mLayout.isAutoMeasureEnabled()) &#123; final int widthMode = MeasureSpec.getMode(widthSpec); final int heightMode = MeasureSpec.getMode(heightSpec); //首先执行LayoutManager的onMeasure方法,里面会调用RecyclerView的onMeasure方法测量自身width和height mLayout.onMeasure(mRecycler, mState, widthSpec, heightSpec); //Measure过后检查RecyclerView的width和height是否是精确值 final boolean measureSpecModeIsExactly = widthMode == MeasureSpec.EXACTLY &amp;&amp; heightMode == MeasureSpec.EXACTLY; //如果RecyclerView的width和height是精确值，就跳过下面步骤 if (measureSpecModeIsExactly || mAdapter == null) &#123; return; &#125; //如果RecyclerView的width和height不是精确值，则会进行下面步骤 //1、dispatchLayoutStep1()还未被执行过，执行 dispatchLayoutStep1() if (mState.mLayoutStep == State.STEP_START) &#123; dispatchLayoutStep1(); &#125; mLayout.setMeasureSpecs(widthSpec, heightSpec); mState.mIsMeasuring = true; //2、执行dispatchLayoutStep2()进行布局 dispatchLayoutStep2(); //3、布局过程结束，该方法里面会根据childView中的边界信息计算并设置RecyclerView长宽的测量值 mLayout.setMeasuredDimensionFromChildren(widthSpec, heightSpec); //下面省略一些代码，下面还会再次检查，如果RecyclerView的宽高还不是精确值或至少有一个childView的宽高还不是精确值，还会再次执行执行dispatchLayoutStep2()进行布局 //... &#125; //...&#125; RecyclerView是一个ViewGroup，如果自身的宽高设置了warp_content必须先调用dispatchLayoutStep2()布局childView后才能测量出准确宽高。所以我们再看回dispatchLayout()中的3个判断: dispatchLayout()中2.1条件：如果mLayoutStep == State.STEP_START，证明OnMeasure中还没有进行过布局，如果mLayoutStep ！= State.STEP_START，证明OnMeasure中进行过布局了，直接跳到2.3条件，不用重复布局，直接使用直接使用之前数据设置RecyclerView的宽高为精确模式。 dispatchLayout()中2.2条件：2.1条件不成立时为什么直接跳到2.3条件不到2.2条件，因为上述条件基于RecyclerView正常的测量布局绘制到呈现在屏幕的过程，如果在这之后你对RecyclerView调用了notifXX函数，就会造成数据变化从而要求重新布局（requestLayout()函数调用），此时2.2条件就会成立，RecyclerView会调用dispatchLayoutStep2()重新布局。 dispatchLayout()中2.3条件：2.1条件中分析过了。 3个判断后，最终一定会调用dispatchLayoutStep3()。至此分析完RecyclerView的onLayout()。 RecyclerView.dispatchLayoutStep2() -&gt; LayoutManager.onLayoutChildren（）RecyclerView真正布局的进行就是在LayoutManager.onLayoutChildren（）中进行，LayoutManager的onLayoutChildren()的实现在LayoutManager的三个子类中：LinearLayoutManager、GridLayoutManager、StaggeredGridLayoutMnager，分别对应3种不同的布局样式。这里以LinearLayoutManager中的实现为例，下面是该函数在LinearLayoutManager实现中的相关源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//源码很长，这里先抛出它的主要步骤：//1、通过检查childView和其他变量，找出锚点的坐标（coordinate）和位置（position），并把锚点信息设置到AnchorInfo//2、根据锚点向俩边填充//这里还讲一下下面出现End和Start的方法或字段的意思：//如果LinearLayoutManager的Orientation是VERTICAL方向，End指屏幕的最下面（即Bottom），Start指屏幕的最上面(即Top)//如果LinearLayoutManager的Orientation是HORIZONTAL方向，End指屏幕的最左边（即Left），Start指屏幕的最右边(即Right)public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) &#123; //... //解析布局方向，设置mShouldReverseLayout的值，它是一个Boolean类型，false表示LinearLayoutManager的Orientation是VERTICAL方向或者LinearLayoutManager的Orientation是HORIZONTAL方向并且你在manifest中没有设置RTL布局，true表示LinearLayoutManager的Orientation是HORIZONTAL方向并且你在manifest中设置了RTL布局 resolveShouldLayoutReverse(); //... //根据mStackFromEnd（表示从End开始填充itemView，默认是false）和mShouldReverseLayout决定mLayoutFromEnd的值，mLayoutFromEnd表示itemView从End开始布局还是从Start开始布局，从Start开始布局为false 从End开始布局是为true，这里一般都为false，即从Start到End开始布局 mAnchorInfo.mLayoutFromEnd = mShouldReverseLayout ^ mStackFromEnd; //1、计算AnchorInfo的信息，即找出锚点的position和coordinate updateAnchorInfoForLayout(recycler, state, mAnchorInfo); //... //从End到Start开始布局，这里省略不讲，原理和从Start到End开始布局一样 if (mAnchorInfo.mLayoutFromEnd) &#123; //... //这里我们只讨论从Start到End开始布局 &#125;else&#123; //更新LayoutState，确定从锚点到RecyclerView底部有多少可用空间 updateLayoutStateToFillEnd(mAnchorInfo); mLayoutState.mExtra = extraForEnd; //2.1、第一次填充itemView，从锚点向底部填充 fill(recycler, mLayoutState, state, false); endOffset = mLayoutState.mOffset; final int lastElement = mLayoutState.mCurrentPosition; if (mLayoutState.mAvailable &gt; 0) &#123; extraForStart += mLayoutState.mAvailable; &#125; //更新LayoutState，确定从锚点到RecyclerView顶部有多少可用空间 updateLayoutStateToFillStart(mAnchorInfo); mLayoutState.mExtra = extraForStart; mLayoutState.mCurrentPosition += mLayoutState.mItemDirection; //2.2、第二次填充itemView，从锚点向顶部填充 fill(recycler, mLayoutState, state, false); startOffset = mLayoutState.mOffset; //如果屏幕上还有剩余的空间 if (mLayoutState.mAvailable &gt; 0) &#123; extraForEnd = mLayoutState.mAvailable; updateLayoutStateToFillEnd(lastElement, endOffset); mLayoutState.mExtra = extraForEnd; fill(recycler, mLayoutState, state, false); endOffset = mLayoutState.mOffset; &#125; &#125; //...&#125; onLayoutChildren方法有接近200行代码，但怎么也逃不出注释的2步，首先确定锚点（大部分情况下锚点就是RecyclerView上的itemView），并设置锚点的信息AnchorInfo。它定义在LinearLayoutManager中，有几个关键的属性： 1234567 static class AnchorInfo &#123; OrientationHelper mOrientationHelper;//根据LinearLayoutManager的布局方向来测量itemView位置信息的帮助类，当你调用LinearLayoutManager的setOrientation(int orientation)方法时，LinearLayoutManager会根据不同orientation创建不同的OrientationHelper实现并设置给mOrientation属性 int mPosition;//锚点在Adapter中的索引位置 int mCoordinate;//锚点相对于LinearLayoutManager的布局方向在屏幕上的坐标，如果是VERTICAL方向，代表y轴偏移量，如果是HORIZONTAL方向，代表x轴偏移量 boolean mLayoutFromEnd;//上面解释过了 //...&#125; 那么它是怎么确定锚点信息的？我们来看注释1 updateAnchorInfoForLayout方法的源码： 1234567891011121314private void updateAnchorInfoForLayout(RecyclerView.Recycler recycler, RecyclerView.State state, AnchorInfo anchorInfo) &#123; //1、如果屏幕上有itemView并且RecyclerView要滚动到某个itemView，则以这个itemView为锚点 if (updateAnchorFromPendingData(state, anchorInfo)) &#123; return; &#125; //2、如果屏幕上有itemView,则根据anchorInfo.mLayoutFromEnd找出最接近End或Start位置的itemView为锚点 if (updateAnchorFromChildren(recycler, state, anchorInfo)) &#123; return; &#125; //3、如果屏幕上没有itemView，则根据anchorInfo.mLayoutFromEnd和RecyclerView的padding来决定锚点coordinate和mStackFormEnd决定锚点的position anchorInfo.assignCoordinateFromPadding(); anchorInfo.mPosition = mStackFromEnd ? state.getItemCount() - 1 : 0;&#125; 对于里面的俩个updataAnchorFormXX函数就不展开了，对于情况1一般是我们滚动了RecyclerView的itemView或调用了RecyclerView的scrolltoXX函数，对于情况2一般是我们itemView已经加载到屏幕上了并且此时我们调用notifiXX函数来刷新或增删itemView，而情况3就是我们现在讨论的情况，RecyclerView加载到屏幕上，此时还没有布局itemView。我们点进AnchorInfo的assignCoordinateFromPadding()看看干了什么，相关源码如下： 1234567891011 void assignCoordinateFromPadding() &#123; mCoordinate = mLayoutFromEnd ? mOrientationHelper.getEndAfterPadding() : mOrientationHelper.getStartAfterPadding();&#125; //下面只给出LinearLayoutManager的Orientation为VERTICAL方向的实现public int getEndAfterPadding() &#123; return mLayoutManager.getHeight() - mLayoutManager.getPaddingBottom();&#125; public int getStartAfterPadding() &#123; return mLayoutManager.getPaddingLeft();&#125; 可以看到如果此时RecyclerView中没有itemView并且LinearLayoutManager的布局方向为VERTICAL和mLayoutFromEnd值为false：anchorInfo的mCoordinate就是RecyclerView的paddingLeft，anchorInfo的position就是0（锚点为RecyclerView左上角的位置）。 我们回到onlayoutChildern方法，确定了锚点后，然后就要根据AnchorInfo开始填充itemView，在开始填充之前，LinearLayoutManager会用LayoutState暂时保存一些布局信息，它定义在LinearLayoutManager中，有几个关键属性： 123456789static class LayoutState &#123; int mAvailable;//表示当前的布局方向中，RecyclerView中要用于填充itemView的可用空间大小 int mOffset;//表示当前的布局方向中，在RecyclerView中距离锚点的位置偏移量 int mExtra = 0;//表示自己设置的额外布局的范围，一般不会设置 int mLayoutDirection;//表示布局往哪个方向填充，俩个取值：LAYOUT_START为向RecyclerView顶部，LAYOUT_END为向底部 int mCurrentPosition;//表示当前锚点在Adapter中的索引，可用它获得下一个itemView的索引 int mItemDirection;//决定由mCurrentPosition获得下一个itemView的索引时是+1还是-1，俩个取值：ITEM_DIRECTION_HEAD表示索引-1，ITEM_DIRECTION_TAIL表示索引+1 //...&#125; updateLayoutStateToFillEnd函数会在向下填充前更新layoutState的值，相关源码如下： 123456789101112131415161718private void updateLayoutStateToFillEnd(AnchorInfo anchorInfo) &#123; updateLayoutStateToFillEnd(anchorInfo.mPosition, anchorInfo.mCoordinate);&#125;private void updateLayoutStateToFillEnd(int itemPosition, int offset) &#123; //下面基于在当前讨论的情景中： //这里可用布局空间mLayoutState.mAvailable就是RecyclerView的高度 mLayoutState.mAvailable = mOrientationHelper.getEndAfterPadding() - offset; //这里为LayoutState.ITEM_DIRECTION_TAIL，索引+1 mLayoutState.mItemDirection = mShouldReverseLayout ? LayoutState.ITEM_DIRECTION_HEAD : LayoutState.ITEM_DIRECTION_TAIL; //当前锚点索引 mLayoutState.mCurrentPosition = itemPosition; //这里为向RecyclerView底部填充 mLayoutState.mLayoutDirection = LayoutState.LAYOUT_END; //这里offet为0 mLayoutState.mOffset = offset;&#125; 准备好layoutState后，就调用fill方法进行填充itemView，核心源码如下: 12345678910111213141516171819202122232425262728293031int fill(RecyclerView.Recycler recycler, LayoutState layoutState, RecyclerView.State state, boolean stopOnFocusable) &#123; //前面讲过，表示可用布局空间大小 final int start = layoutState.mAvailable; //... // 1、计算剩余可用的填充空间，可用布局空间加上额外布局空间 int remainingSpace = layoutState.mAvailable + layoutState.mExtra; //用于记录每一次while循环的填充一个itemView后的结果 LayoutChunkResult layoutChunkResult = mLayoutChunkResult; //2、while判断条件，屏幕还有剩余可用空间并且还有数据就继续执行 while ((layoutState.mInfinite || remainingSpace &gt; 0) &amp;&amp; layoutState.hasMore(state)) &#123; //重置LayoutChunkResult layoutChunkResult.resetInternal(); //3、循环调用layoutChunk方法一个一个的填充itemView，里面会根据LinearLayoutmanager的orientation方向布局itemView（布局子View的核心方法） layoutChunk(recycler, state, layoutState, layoutChunkResult); if (layoutChunkResult.mFinished) &#123; break; &#125; //计算填充一次itemView消耗了多少空间，或者说计算距离锚点的偏移量 layoutState.mOffset += layoutChunkResult.mConsumed * layoutState.mLayoutDirection; //4、如果layoutChunkResult没有要求忽略这次消耗或这次布局的不是ScrapView或我们不是在做预布局，就更新可填充空间的大小 if (!layoutChunkResult.mIgnoreConsumed || mLayoutState.mScrapList != null || !state.isPreLayout()) &#123; layoutState.mAvailable -= layoutChunkResult.mConsumed; remainingSpace -= layoutChunkResult.mConsumed; &#125; //下面省略的是，如果是因滚动引起的布局，会通过判断滑动后view是否滑出边界决定是否回收View //... &#125; //填充完成，修改起始位置，即填充到哪个位置 return start - layoutState.mAvailable;&#125; 上面的注释很详细，大概流程就是在while循环中根据剩余可用空间不断的调用layoutChunk（）函数进行布局itemView，layoutChunk方法会在里面根据RecyclerView的缓存机制获取一个View从而把它填充到RecyclerView中去，下面继续来看layoutChunk方法相关源码： 1234567891011121314151617181920212223242526272829303132333435363738394041void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state, LayoutState layoutState, LayoutChunkResult result) &#123; //1、获取一个View View view = layoutState.next(recycler); if (view == null) &#123; result.mFinished = true; return; &#125; RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) view.getLayoutParams(); //... //2、测量itemView measureChildWithMargins(view, 0, 0); //3、计算该itemView消耗的高度或宽度 result.mConsumed = mOrientationHelper.getDecoratedMeasurement(view); int left, top, right, bottom; //4、按竖直方向布局，计算itemView的上下左右布局 if (mOrientation == VERTICAL) &#123; if (isLayoutRTL()) &#123; right = getWidth() - getPaddingRight(); left = right - mOrientationHelper.getDecoratedMeasurementInOther(view); &#125; else &#123; left = getPaddingLeft(); right = left + mOrientationHelper.getDecoratedMeasurementInOther(view); &#125; if (layoutState.mLayoutDirection == LayoutState.LAYOUT_START) &#123; bottom = layoutState.mOffset; top = layoutState.mOffset - result.mConsumed; &#125; else &#123; top = layoutState.mOffset; bottom = layoutState.mOffset + result.mConsumed; &#125; //水平布局的计算方式 &#125; else &#123; //... &#125; //5、布局itemView layoutDecoratedWithMargins(view, left, top, right, bottom); //消耗可用布局空间如果itemView没有被移除或没有改变 if (params.isItemRemoved() || params.isItemChanged()) &#123; result.mIgnoreConsumed = true; &#125;&#125; 在layoutChunk方法中首先从layoutState中根据mCurrentPosition获取itemView，然后获取itemView的布局参数，并且根据布局方式(横向或纵向)计算出itemView的上下左右布局，最后调用layoutDecoratedWithMargins方法实现布局itemView，layoutDecoratedWithMargins方法定义在LayoutManger中，具体代码如下： 1234567 public void layoutDecoratedWithMargins(@NonNull View child, int left, int top, int right, int bottom) &#123; final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final Rect insets = lp.mDecorInsets; child.layout(left + insets.left + lp.leftMargin, top + insets.top + lp.topMargin,right - insets.right - lp.rightMargin, bottom - insets.bottom - lp.bottomMargin); &#125; 可以看到，只是调用了itemView的layout函数将itemView布局到具体的位置。 我们再回到onlayoutChildern方法，按照上面图一，我们已经填充了下面，但是上面是不用填充的，因为没有可用空间，所以注释2.2基本下是不会走的了。而fill towaards Start步骤和fill towards End差不多。那么为什么RecyclerView进行两次填充呢？因为RecyclerView理想的锚点如下图： 上面是RecyclerView的方向为VERTICAL的情况，当为HORIZONTAL方向的时候填充算法是不变的。但我们一般是图一的情况，从上往下填充。 总结一图胜千言，下图是LayoutManager循环布局所有的itemView。 可以看到RecyclerView将布局的职责分离到LayoutManager中，使得RecyclerView更加灵活，我们也可以自定义自己的LayoutManger，实现自己想要的布局。可以看到RecyclerView具有很强大的扩展性，所以深入学习这个控件是很有必要的。能看到这里的都是有毅力的人，本文只是RecyclerView学习的第一篇，以后会继续分析RecyclerView的缓存设计。 参考资料： 《Android源码设计与分析》 RecyclerView和ListView原理 RecyclerView源码分析(三)–布局流程","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"recyclerView","slug":"recyclerView","permalink":"http://yoursite.com/tags/recyclerView/"}]},{"title":"ThreadLocal原理解析","date":"2019-02-21T05:55:50.000Z","path":"2019/02/21/ThreadLocal解析/","text":"概述ThreadLocal，线程本地存储区（Thread Local Storage，简称为TLS），通过它可以在指定的线程中存储数据，数据存储之后，只能在指定的线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。 使用ThreadLocal 提供了 get()，set(T value)，remove() 3个对外方法，来看一个简单的例子： 12345678910111213141516171819202122232425262728293031public class Main &#123; //定义两个ThreadLocal private static ThreadLocal&lt;Integer&gt; mThreadLocal = new ThreadLocal&lt;&gt;(); private static ThreadLocal&lt;Integer&gt; mThreadLocal2 = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; //主线程 mThreadLocal.set(0);//mThreadLocal存值 System.out.println(Thread.currentThread().getName() + \" - \" + mThreadLocal.get());////mThreadLocal取值 mThreadLocal2.set(1);//mThreadLocal2存值 System.out.println(Thread.currentThread().getName() + \" - \" + mThreadLocal2.get());////mThreadLoca2取值 //子线程1 new Thread(() -&gt; &#123; mThreadLocal.set(2);//mThreadLocal存值 System.out.println(Thread.currentThread().getName() + \" - \" + mThreadLocal.get());//mThreadLocal取值 &#125;).start(); //子线程2 new Thread(() -&gt; System.out.println(Thread.currentThread().getName() + \" - \" + mThreadLocal.get())).start();//mThreadLocal取值 &#125;&#125;/* 输出结果：*/main - 0main - 1Thread-0 - 2Thread-1 - null 上面代码中，有三个线程，分别为主线程(main)、子线程1(Thread-0)、子线程2(Thread-1)，有两个不同的ThreadLocal实例，分别为mThreadLocal、mThreadLocal2，根据输出结果，得出以下结论： 1、在同一线程中，通过不同的ThreadLocal存值，则通过相应的ThreadLocal取出的值也不一样，例如这里在主线程通过分别设置mThreadLocal的值为0，mThreadLocal2的值为1，从输出结果可以看出mThreadLocal取出的值还是0，mThreadLocal2取出的值还是1； 2、在不同线程中，访问的是同一个ThreadLocal对象，但通过同一个ThreadLocal获取的值却不一样，例如这里在子线程1设置mThreadLocal的值2，在子线程2没有设置mThreadLocal的值，从输出结果可以看出通过同一个ThreadLocal获取的值不一样，一个为2，一个为null； 这里给出先给出解释： 在java中，线程的表示是用java.lang.Thread类来表示，在Thread类中定义了一个ThreadLocalMap字段，如下： 12//Thread.javaThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocalMap是ThreadLocal中的一个静态内部类，它是一个简化版的HashMap容器，也就是说这个容器是以key-value来存值的，每个线程都管理着自己的容器，我们可以从外部拿到这个threadLocals，然后往这个容器中存值、取值等，而ThreadLocal就是这样做的，当我们通过ThreadLocal的set方法存值时，它会以当前ThreadLocal实例为key，要存的值为value，把这个映射保存进相应的线程的容器中，当我们通过ThreadLocal的get方法取值时，它会以当前ThreadLocal实例为Key，然后去相应线程的容器中查找这个键为Key的value值返回。 所以： 1、在上面的主线程中，mThreadLocal和mThreadLocal2这两个ThreadLocal实例都往主线程的容器中存值，但由于mThreadLocal和mThreadLocal2的两个实例不一样，导致key不一样，所以在容器中存放value的位置也不一样，这样就可以根据相应的key获取出相应的value； 2、在上面的子线程1和子线程2中，都是通过mThreadLoca这个ThreadLocal实例来存取值，但是由于线程实例不一样，导致获取的容器也不一样，所以根据同一个key从不同的容器中获取的value也就不一样。 如果不是很理解，就来看一下下面关于ThreadLocal的源码分析： 源码分析1、ThreadLocal1.1、get方法该方法用于获取当前线程TLS区域的数据，该方法的源码如下： 12345678910111213141516171819202122//ThreadLocal.javapublic T get() &#123; //1、获取当前线程 Thread t = Thread.currentThread(); //2、 以当前线程为参数，获取一个 ThreadLocalMap 对象 ThreadLocalMap map = getMap(t)； if (map != null) &#123; //2.1、map不为空，则以当前 ThreadLocal 对象实例作为key值，去map中取值，有找到直接返回 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; T result = (T)e.value; return result; &#125; &#125; //2.2、 map 为空或者在map中取不到值，那么走这里，返回默认初始值 return setInitialValue();&#125;ThreadLocalMap getMap(Thread t) &#123; //getMap方法返回传进来的线程中的threadlocals字段，threadlocals是一个ThreadLocalMap对象，它就是我们上面提到的每个线程中保存数据的Map容器 return t.threadLocals;&#125; ThreadLocal的get方法，首先获取当前线程，接着以当前线程为参数调用getMap方法，getMap方法返回当前线程中保存数据的Map容器，调用getMap之后就得到了当前线程的数据存储容器即map，然后判断它是否为null： 注释2.1：当map不为空时，就以当前ThreadLocal实例为参数调用map.getEntry方法，该方法返回一个ThreadLocalMap.Entry对象，Entry就是线程容器中表示key-value映射的类，它里面有一个key和一个value值，而value值就是我们需要的数据； 注释2.2： 当map为空时或者在map中找不到数据即map.getEntry返回了null，就调用setInitialValue方法返回默认初始值，该方法源码如下：12345678910111213141516171819//ThreadLocal.javaprivate T setInitialValue() &#123; //1. 获取初始值，默认返回Null，允许重写 T value = initialValue(); //2、获取当前线程并以当前线程为参数，获取一个ThreadLocalMap 对象 Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); //3、当map不为空，设置初始值给map if (map != null) map.set(this, value); else//当map为空， 创建当前线程的数据存储容器map createMap(t, value); //返回初始值 return value;&#125;protected T initialValue() &#123; return null;&#125; 该方法分为以下3步： 1、 调用initialValue()，可以看到它默认返回null，但是我们可以重写该方法并返回你想要的初始值； 2、获取当前线程，再次以当前线程为参数，获取一个ThreadLocalMap 对象； 3、再次判断map是否为空，如下： 当map不为空时，以当前ThreadLocal实例为key，initialvalue方法获取到的初始值为value，将（key - value）值保存到map中； 当map为空时，就调用createMap方法， ThreadLocal 中的 createMap() 方法就是对当前Thread 中的 threadLocals成员变量赋值，该方法源码如下:1234void createMap(Thread t, T firstValue) &#123; //以当前ThreadLocal实例对象为key，传进来的value为值，创建一个ThreadLocalMap实例 t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; Thread 中的 threadLocal 成员变量初始值为 null，并且在 Thread 类中没有任何赋值的地方，只有在 ThreadLocal 中的 createMap方法中对其赋值，而调用createMap方法的地方就两个：set 和 setInitialValue方法，而调用 setInitialValue() 方法的地方只有 get方法。 到此，get方法就已经讲完了。 1.2、set方法set方法是将value存储到当前线程的TLS区域，在上面的get方法中，ThreadLocal会根据线程取出线程的容器，然后再根据key（ThreadLocal实例）去容器中取值，如果取不到值，就会返回初始值，初始值默认是null，那是因为ThreadLocal要调用set方法后，容器中才有我们想要的值，set方法的源码如下: 12345678910111213//ThreadLocal.javapublic void set(T value) &#123; //1. 取当前线程对象 Thread t = Thread.currentThread(); //2. 取当前线程的数据存储容器 ThreadLocalMap map = getMap(t); if (map != null) //2.1. 如果map不为空，以当前ThreadLocal实例对象为key，存值 map.set(this, value); else //2.2. 如果map为空，新建一个当前线程的数据存储容器 createMap(t, value);&#125; set方法的步骤是不是感觉似曾相识，没错，它和get方法中所讲的setInitialValue方法几乎一模一样，只是没有调用initialValue方法返回初始值，因为set方法的参数value就是我们想要保存的值，而不用调用initialValue方法设置默认初始值。 至此，set方法讲解完毕。 get和set两个方法内部都会自动根据当前线程选择相对应的容器存取，所以其实ThreadLocal的核心还是ThreadLocalMap对象，get方法会调用ThreadLocalMap的getEntry(ThreadLocal&lt;?&gt;)根据ThreadLocal实例获取一个Entry对象，该Entry对象保存了key-value映射，set方法会调用ThreadLocalMap的set(ThreadLocal&lt;?&gt;, Object)保存key-value映射到ThreadLocalMap中，下面我们就简单的讲解一下ThreadLocalMap的组成。 2、ThreadLocal::ThreadLocalMap123456789101112131415161718192021222324252627282930//ThreadLocal::ThreadLocalMapstatic class ThreadLocalMap &#123; private static final int INITIAL_CAPACITY = 16;//初始容量为16，必须为2^n private int size = 0;//table中Entry的数量 private int threshold;//扩容阈值, 当size &gt;= threshold时就会触发扩容逻辑 private Entry[] table;//table数组 private void setThreshold(int len) &#123; //ThreadLocalMap的threshold为table数组长度的2/3 threshold = len * 2 / 3; &#125; //以下为ThreadLocal调用ThreadLocalMap的主要方法 //分别对应ThreadLocal的get、set、remove方法 private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; //... &#125; private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; //... &#125; private void remove(ThreadLocal&lt;?&gt; key) &#123; //... &#125; //...&#125; ThreadLocalMap 就是一个用于存储数据的容器类, 它是ThreadLocal中的静态内部类， 它的底层实现类似于hashMap的实现，也是基于哈希算法，里面table数组就是真正的存储每个线程的数据，数组的每个元素类型就是一个具有（key-value）键值对的Entry，key对应ThreadLocal实例，value对应要存储的数据，Entry在数组中的index值是根据key的threadLocalHashCode用hash算法算出来的，threadLocalHashCode是ThreadLocal中的一个字段，如下： 12345678//ThreadLocal.javaprivate final int threadLocalHashCode = nextHashCode();//threadLocalHashCode的值等于nextHashCode方法的返回值private static AtomicInteger nextHashCode = new AtomicInteger();private static final int HASH_INCREMENT = 0x61c88647;private static int nextHashCode() &#123; //每次调用nextHashCode方法都会在原本的int值加上0x61c88647后再返回 return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; 而ThreadLocalMap 的hash算法，即计算index值的算法如下： 123//hash算法：threadLocalHashCode与（table数组长度-1）相与//这样会使得i均匀的分布在数组的长度之内int i = key.threadLocalHashCode &amp; (table.length - 1); 当出现冲突时，ThreadLocalMap是使用线性探测法来解决冲突的，即如果i位置已经有了key-value映射，就会在i + 1位置找，直到找到一个合适的位置。 我们看一下Entry的实现，如下： 12345678static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; //key是弱引用 super(k); value = v; &#125;&#125; Entry 继承至 WeakReference，并且它的key是弱引用，但是value是强引用，所以如果key关联的ThreadLocal实例没有强引用，只有弱引用时，在gc发生时，ThreadLocal实例就会被gc回收，当ThreadLocal实例被gc回收后，由于value是强引用，导致table数组中存在着null - value这样的映射，称之为脏槽，这种脏槽会浪费table数组的空间，所以需要及时清除，所以ThreadLocalMap 中提供了expungeStaleEntry方法和expungeStaleEntries方法去清理这些脏槽，每次ThreadLocalMap 运行getEntry、set、remove等方法时，都会主动的间接使用这些方法去清理脏槽，从而释放更多的空间，避免无谓的扩容操作。 java中有4种引用，分别为：强引用、软引用、弱引用和虚引用. 3、小结根据使用实例和源码分析，我们得出以下两个结论： 1、使用同一个ThreadLocal对象，可以维护着不同线程的数据副本： 这是因为，这些数据本来就是存储在各自线程中了，ThreadLocal 的 get() 方法内部其实会先去获取当前的线程对象，然后直接将线程存储数据的容器(ThreadLocalMap)取出来，如果为空就会先创建并将初始值和当前 ThreadLocal 对象绑定存储进去，这样不同线程即使调用了同一 ThreadLocal 对象的get方法，取的数据也是各自线程的数据副本，这样自然就可以达到维护不同线程各自相互独立的数据副本，且以线程为作用域的效果了。 2、在同一线程中不同ThreadLocal对象虽然共用同一个线程中的容器，但却可以相互独立运作： 这是因为，ThreadLocal 的 get() 方法内部根据线程取出map后，当map不为空时，会根据ThreadLocal实例去map中查找value，换句话说，在将数据存储到线程的容器map中是以当前 ThreadLocal 对象实例为 key 存储，这样，即使在同一线程中调用了不同的 ThreadLocal 对象的 get() 方法，所获取到的数据也是不同的，达到同一线程中不同 ThreadLocal 虽然共用一个容器，但却可以相互独立运作的效果。 使用场景如果你是单线程环境，那么不用考虑使用ThreadLocal了，ThreadLocal是用来在多线程环境下的。 在多线程环境下，如果某个变量只在特定的某个线程中使用，即我们对这个变量的操作只限定在同一个线程内，那么就不需要使用同步来保证这个变量的正确性，因为没有存在竞争，这时我们可以把这个变量直接存储在线程内部中，要使用这个变量时直接从线程内部拿出来后再操作，这就避免了使用同步带来的性能消耗，典型的例子有Android中的Looper，通过Looper.myLooper方法就可以返回当前线程关联的Looper。 总的来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，就可以考虑采用 ThreadLocal。 正确使用上面介绍ThreadLocalMap时提到，如果ThreadLocalMap中的key关联的ThreadLoca实例被回收了，就会导致ThreadLocalMap还残留着这个key对应的value实例，出现了脏槽，而脏槽是通过ThreadLocalMap主动的调用expungeStaleEntry或expungeStaleEntries方法清理，而这两个方法只会在主动调用ThreadLocalMap的set(ThreadLocal , Object)、getEntry(ThreadLocal)和remove(ThreadLocal)等方法时才会被调用，而ThreadLocalMap的set、getEntry、remove方法只有在调用ThreadLocal的set、get、remove方法时才会被调用。 所以想象这样的一种情况：我们使用ThreadLocal的set方法往线程的ThreadLocalMap中保存了一个非常大的数据，从这之后，我没有再调用过ThreadLocal的set、get、remove等方法，当这个数据对应的ThreadLocal实例被gc回收后，ThreadLocalMap中还残留这这个null-value映射，并且这个线程的生命周期是和程序同步的，直到程序结束它才会结束，这样就导致了内存泄漏的发生，产生内存浪费。 所以我们平常使用完ThreadLocal后，应该手动的调用remove方法把映射删除，如下： 123456private static ThreadLocal&lt;Integer&gt; mThreadLocal = new ThreadLocal&lt;&gt;();try &#123; //调用mThreadLocal的set方法&#125; finally &#123; threadLocal对象.remove();&#125; 为什么ThreadLocal要定义为静态变量？，可以参考： 总结本文从使用到源码简单的分析了一下ThreadLocal，介绍了ThreadLocal的使用场景和正确使用方法，从ThreadLocal的get和set方法中都可以看出，它们所操作的对象都是当前线程中的容器ThreadLocalMap，所以在不同线程中访问同一个ThreadLocal的get和set方法，它们对ThreadLocal所做的读写操作仅限与线程内部。 参考资料： ThreadLocal 相关的各种面试问法了解一下？","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"http://yoursite.com/tags/ThreadLocal/"}]},{"title":"Android消息机制(native层)","date":"2019-02-21T05:51:51.000Z","path":"2019/02/21/Android消息机制native层/","text":"前言 上一篇文章：Android消息机制java层 MessageQueue中有多个native方法，MessaeQueue是Android消息机制的Java层和native层的连接纽带，Android的java层和native层通过JNI调用打通，java层和native各有一套消息机制，实现不一样，本文讲解native层的Android消息机制，了解了native层的消息机制，你就能明白为什么java层的loop方法是死循环但却不会消耗性能这个问题。 native层消息机制架构图 MessageQueue — 里面有一个Looper，和java层的MessageQueue同名; NativeMessageQueue — MessageQueue的继承类，native层的消息队列，只是一个代理类，其大部分方法操作都转交给Looper的方法; Looper — native层的Looper，其功能相当于java层的Handler，它可以取出消息，发送消息，处理消息； MessageHandler — native层的消息处理类，Looper把处理消息逻辑转交给此类; WeakMessageHanlder — MessageHandler的继承类，也是消息处理类，但最终还是会把消息处理逻辑转交给MessageHandler。 java层的MessageQueue要讲解native层的消息机制，我们需要从java层消息机制调用到的MessageQueue的native方法讲起，MessageQueue中所有的native方法如下: 12345678910//MessageQueue.javapublic final class MessageQueue &#123; private native static long nativeInit(); private native static void nativeDestroy(long ptr); private native void nativePollOnce(long ptr, int timeoutMillis); private native static void nativeWake(long ptr); private native static boolean nativeIsPolling(long ptr); private native static void nativeSetFileDescriptorEvents(long ptr, int fd, int events); //...&#125; 我们主要讲解三个：nativeInit()、 nativePollOnce(long ptr, int timeoutMillis)和 nativeWake(long ptr)，nativeInit方法在java层的MessageQueue构造的时候调用到，nativePollOnce方法在java层的MessageQueue的next方法调用到，nativeWake方法在java层的MessageQueue的enqueueuMessage方法调用到。 1、nativeInit()java层中，在ActivityThread的main方法创建UI线程的消息循环，Looper.prepareMainLooper -&gt; Looper.prepare -&gt; new Looper -&gt; new MessageQueue，MessageQueue是在Looper的构造中创建的，在MessageQueue的构造中: 12345//MessageQueue.javaMessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; mPtr = nativeInit();&#125; 在java层中，mPtr保存了nativeInit()返回的值，nativeInit方法的实现在android_os_MessageQueue.cpp文件中的android_os_MessageQueue_nativeInit方法中，该方法源码如下: 12345678910//frameworks/base/core/jni/android_os_MessageQueue.cppstatic jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; //创建native消息队列NativeMessageQueue NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); //... //增加引用计数 nativeMessageQueue-&gt;incStrong(env); //使用C++强制类型转换符reinterpret_cast把NativeMessageQueue指针强转成long类型并返回到java层 return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);&#125; 可以看到在android_os_MessageQueue_nativeInit方法中会创建一个NativeMessageQueue对象，并增加其引用计数，并将NativeMessageQueue指针mPtr保存在Java层的MessageQueue中，现在我们来看NativeMessageQueue的构造函数, 如下: 123456789101112//frameworks/base/core/jni/android_os_MessageQueue.cppNativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123; //获取TLS中的Looper(Looper::getForThread相当于java层的Looper.mLooper中的ThreadLocal.get方法) mLooper = Looper::getForThread(); if (mLooper == NULL) &#123; //创建native层的Looper mLooper = new Looper(false); //保存Looper到TLS中(Looper::setForThread相当于java层的ThreadLocal.set方法) Looper::setForThread(mLooper); &#125;&#125; 在NativeMessageQueue的构造中会先调用Looper的getForThread方法从当前线程获取Looper对象，如果为空，就会创建一个Looper并调用Looper的setForThread方法设置给当前线程。 关于TLS更多信息可以查看ThreadLocal原理解析 也就是说Looper和MessageQueue在java层和native层都有，但它们的功能并不是一一对应，此处native层的Looper与Java层的Looper没有任何的关系，只是在native层重实现了一套类似功能的逻辑，我们来看看native层在创建Looper时做了什么，Looper的构造函数如下: 1234567891011//system/core/libutils/Looper.cppLooper::Looper(bool allowNonCallbacks) : mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false), mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false), mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123; //1、构造唤醒事件的fd（文件描述符） mWakeEventFd = eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC); //... //2、重建epoll事件 rebuildEpollLocked();&#125; 这里我们忽略一大堆字段赋值，只关注字段mWakeEventFd和函数:rebuildEpollLocked()，mWakeEventFd就是用于唤醒线程的文件描述符，而rebuildEpollLocked方法就是用来重建epoll事件，建立起epoll机制，通过epoll机制监听各种文件描述符. 文件描述符是什么？它就是一个int值，又叫做句柄，在Linux中，打开或新建一个文件，它会返回一个文件描述符，读写文件需要使用文件描述符来指定待读写的文件，所以文件描述符就是指代被打开的文件，所有对这个文件的IO操作都要通过文件描述符 但其实文件描述符也不仅仅是指代文件，它还有更多的含义，可以看后文的epoll机制解释。 rebuildEpollLocked方法的核心源码如下: 123456789101112131415161718192021222324252627282930313233//system/core/libutils/Looper.cppvoid Looper::rebuildEpollLocked() &#123; //1、关闭旧的管道 if (mEpollFd &gt;= 0) &#123; close(mEpollFd); &#125; //2、创建一个新的epoll文件描述符，并注册wake管道 mEpollFd = epoll_create(EPOLL_SIZE_HINT);//EPOLL_SIZE_HINT为8 struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); //置空eventItem //3、设置监听事件类型和需要监听的文件描述符 eventItem.events = EPOLLIN;//监听可读事件（EPOLLIN） eventItem.data.fd = mWakeEventFd;//设置唤醒事件的fd（mWakeEventFd） //4、将唤醒事件fd(mWakeEventFd)添加到epoll文件描述符(mEpollFd)，并监听唤醒事件fd(mWakeEventFd) int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem); //5、将各种事件，如键盘、鼠标等事件的fd添加到epoll文件描述符(mEpollFd)，进行监听 for (size_t i = 0; i &lt; mRequests.size(); i++) &#123; const Request&amp; request = mRequests.valueAt(i); struct epoll_event eventItem; request.initEventItem(&amp;eventItem); int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem); if (epollResult &lt; 0) &#123; ALOGE(\"Error adding epoll events for fd %d while rebuilding epoll set: %s\", request.fd, strerror(errno)); &#125; &#125;&#125;&#125; Looper的构造函数中涉及到Linux的epoll机制，epoll机制是Linux最高效的I/O复用机制, 使用一个文件描述符管理多个描述符，这里简单介绍一下它的使用方法: epoll操作过程有3个方法，分别是: 1、int epoll_create(int size)：用于创建一个epoll的文件描述符，创建的文件描述符可监听size个文件描述符;参数介绍：size：size是指监听的描述符个数 2、int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)： 用于对需要监听的文件描述符fd执行op操作，比如将fd添加到epoll文件描述符epfd;参数介绍:epfd：是epoll_create()的返回值op：表示op操作，用三个宏来表示，分别为EPOLL_CTL_ADD(添加)、EPOLL_CTL_DEL(删除)和EPOLL_CTL_MOD(修改)fd：需要监听的文件描述符epoll_event：需要监听的事件，有4种类型的事件，分别为EPOLLIN(文件描述符可读)、EPOLLOUT(文件描述符可写), EPOLLERR(文件描述符错误)和EPOLLHUP(文件描述符断) 3、int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)： 等待事件的上报, 该函数返回需要处理的事件数目，如返回0表示已超时;参数介绍：epfd：等待epfd上的io事件，最多返回maxevents个事件events：用来从内核得到事件的集合maxevents：events数量，该maxevents值不能大于创建epoll_create()时的sizetimeout：超时时间（毫秒，0会立即返回） 关于更多资料可以自行查找资料，有Linux基础的可以阅读源码解读epoll内核机制 要了解epoll机制，首先要知道，在Linux中，文件、socket、管道(pipe)等可以进行IO操作的对象都可以称之为流，既然是IO流，那肯定会有两端：read端和write端，我们可以创建两个文件描述符wiretFd和readFd，对应read端和write端，当流中没有数据时，读线程就会阻塞(休眠)等待，当写线程通过wiretFd往流的wiret端写入数据后，readFd对应的read端就会感应到，唤醒读线程读取数据，大概就是这样的一个读写过程，读线程进入阻塞后，并不会消耗CPU时间，这是epoll机制高效的原因之一。 说了一大堆，我们再回到rebuildEpollLocked方法，rebuildEpollLocked方法中使用了epoll机制，在Linux中，线程之间的通信一般是通过管道(pipe)，在rebuildEpollLocked方法中，首先通过epoll_create方法创建一个epoll专用文件描述符(mEpollFd)，同时创建了一个管道，然后设置监听可读事件类型（EPOLLIN），最后通过epoll_ctl方法把Looper对象中的唤醒事件的文件描述符（mWakeEventFd）添加到epoll文件描述符的监控范围内，当mWakeEventFd那一端发生了写入，这时mWakeEventFd可读，就会被epoll监听到（epoll_wait方法返回），我们发现epoll文件描述符不仅监听了mWakeEventFd，它还监听了其他的如键盘、鼠标等事件的文件描述符，所以一个epoll文件描述符可以监听多个文件描述符。 至此，native层的MessageQueue和Looper就构建完毕，底层通过管道与epoll机制也建立了一套消息机制。 我们跟着MessageQueue#nativeInit()一路走下来，这里小结一下： 1、首先java层的Looper对象会在构造函数中创建java层的MessageQueue对象; 2、 java层的MessageQueue对象又会调用nativeInit函数初始化native层的NativeMessageQueue，NativeMessageQueue的构造函数又会创建native层的Looper，并且在Looper中通过管道与epoll机制建立一套消息机制; 3、native层构建完毕，将NativeMessageQueue对象转换为一个long类型存储到java层的MessageQueue的mPtr中。 2、nativePollOnce()在native层通过epoll机制也建立了一套消息机制后，java层的消息循环也就创建好，在此之后就会在java层中启动消息循环，Looper.loop -&gt; MessageQueue.next，在java层中每次循环去读消息时，都会调用MessageQueue的next函数，如下: 123456789//MessageQueue.java Message next() &#123; //... for(;;)&#123; nativePollOnce(ptr, nextPollTimeoutMillis); //... &#125; //... &#125; next方法返回一个Message，没有消息时，会调用nativePollOnce方法进入阻塞，nativePollOnce方法的实现在android_os_MessageQueue.cpp文件中的android_os_MessageQueue_nativePollOnce方法中，该方法的源码如下: 1234567//frameworks/base/core/jni/android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; //把ptr强转为NativeMessageQueue NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125; ptr是从java层传过来的mPtr的值，mPtr在初始化时保存了NativeMessageQueue的指针，此时首先把传递进来的ptr转换为NativeMessageQueue，然后调用NativeMessageQueue的pollOnce函数，该函数核心源码如下: 1234567//frameworks/base/core/jni/android_os_MessageQueue.cppvoid NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123; //... //核心是调用了native层的Looper的pollOnce方法 mLooper-&gt;pollOnce(timeoutMillis); //...&#125; NativeMessageQueue是一个代理类，所以它把逻辑转交给Looper，这段代码主要就是调用了native层的Looper的pollOnce(timeoutMillis)方法，该方法定义在Looper.h文件中，如下： 12345//system/core/libutils/Looper.hinline int pollOnce(int timeoutMillis) &#123; //调用了带4个参数的pollOnce方法 return pollOnce(timeoutMillis, NULL, NULL, NULL);&#125; pollOnce(timeoutMillis)方法会调用Looper的polOnce(timeoutMillis, NULL, NULL, NULL)，该方法的实现在Looper.cpp文件中，如下: 123456789101112131415//system/core/libutils/Looper.cppint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123; int result = 0; //一个死循环 for (;;) &#123; //... //当result不等于0时，就会跳出循环，返回到java层 if (result != 0) &#123; //... return result; &#125; //处理内部轮询 result = pollInner(timeoutMillis); &#125;&#125; 该方法内部是一个死循环，核心在于调用了pollInner方法，pollInner方法返回一个int值result，代表着本次轮询是否成功处理了消息，当result不等于0时，就会跳出循环，返回到java层继续处理java层消息，result有以下4种取值： 12345678910111213enum &#123; //表示Looper的wake方法被调用，即管道的写端的write事件触发 POLL_WAKE = -1, //表示某个被监听fd被触发。 POLL_CALLBACK = -2, //表示等待超时 POLL_TIMEOUT = -3, //表示等待期间发生错误 POLL_ERROR = -4,&#125;; 我们接着来看pollInner方法，如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//system/core/libutils/Looper.cppint Looper::pollInner(int timeoutMillis) &#123; //timeoutMillis等于-1，并且mNextMessageUptime不等于LLONG_MAX //这说明java层没有消息但是native层有消息处理，这时在epoll_wait中，线程不能因为timeoutMillis等于-1而进入休眠，它还需要处理native层消息 //所以这里会根据mNextMessageUptime把timeoutMillis更新为大于0的值 if (timeoutMillis != 0 &amp;&amp; mNextMessageUptime != LLONG_MAX) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); int messageTimeoutMillis = toMillisecondTimeoutDelay(now, mNextMessageUptime); if (messageTimeoutMillis &gt;= 0 &amp;&amp; (timeoutMillis &lt; 0 || messageTimeoutMillis &lt; timeoutMillis)) &#123; //更新timeoutMillis为大于0的值，这个大于0的值就是需要等待多久后，才会到达native层消息的执行时间，等待timeoutMillis后，epoll_wait就会返回处理native层消息 timeoutMillis = messageTimeoutMillis; &#125; //... &#125; int result = POLL_WAKE; //... //事件集合(eventItems)，EPOLL_MAX_EVENTS为最大事件数量，它的值为16 struct epoll_event eventItems[EPOLL_MAX_EVENTS]; //1、等待事件发生或者超时(timeoutMillis)，如果有事件发生，就从管道中读取事件放入事件集合(eventItems)返回，如果没有事件发生，进入休眠等待，如果timeoutMillis时间后还没有被唤醒，就会返回 int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); //获取锁 mLock.lock(); //...省略的逻辑是：如果eventCount &lt;= 0 都会直接跳转到Done:;标记的代码段 //2、遍历事件集合（eventItems），检测哪一个文件描述符发生了IO事件 for (int i = 0; i &lt; eventCount; i++) &#123; //取出文件描述符 int fd = eventItems[i].data.fd; //取出事件类型 uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd) &#123;//如果文件描述符为mWakeEventFd if (epollEvents &amp; EPOLLIN) &#123;//并且事件类型为EPOLLIN（可读事件） //这说明当前线程关联的管道的另外一端写入了新数据 //调用awoken方法不断的读取管道数据，直到清空管道 awoken(); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on wake event fd.\", epollEvents); &#125; &#125; else &#123;//如果是其他文件描述符，就进行它们自己的处理逻辑 //... &#125; &#125; //2、下面是处理Native的Message Done:; //mNextMessageUptime如果没有值，会被赋值成LLONG_MAX，但是如果mNextMessageUptime已经有值，它还是保持原来的值 mNextMessageUptime = LLONG_MAX; //mMessageEnvelopes是一个Vector集合，它代表着native中的消息队列 while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); //取出MessageEnvelope，MessageEnvelop有收件人Hanlder和消息内容Message const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); //判断消息的执行时间 if (messageEnvelope.uptime &lt;= now) &#123;//消息到达执行时间 &#123; //获取native层的Handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; //获取native层的消息 Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; //释放锁 mLock.unlock(); //通过MessageHandler的handleMessage方法处理native层的消息 handler-&gt;handleMessage(message); &#125; mLock.lock(); mSendingMessage = false; //result等于POLL_CALLBACK，表示某个监听事件被触发 result = POLL_CALLBACK; &#125; else &#123;//消息还没到执行时间 //把消息的执行时间赋值给mNextMessageUptime mNextMessageUptime = messageEnvelope.uptime; //跳出循环，进入下一次轮询 break; &#125; &#125; //释放锁 mLock.unlock(); //... return result;&#125; pollInner方法很长，省略了一大堆代码，这里讲解一些核心的点，pollInner实际上就是从管道中读取事件，并且处理这些事件，pollInner方法可分为3部分： 1、执行epoll_wait方法，等待事件发生或者超时 这里再次贴出epoll_wait方法的作用： int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)： 等待事件的上报, 该函数返回需要处理的事件数目，如返回0表示已超时;参数介绍：epfd：等待epfd上的io事件，最多返回maxevents个事件；events：用来从内核得到事件的集合；maxevents：events数量，该maxevents值不能大于创建epoll_create()时的size；timeout：超时时间（毫秒，0会立即返回）. epoll_wait方法就是用来等待事件发生返回或者超时返回，它是一个阻塞方法， 如果epoll_create方法创建的epoll文件描述符（mEpollFd）所监听的任何事件发生，epoll_wait方法就会监听到，并把发生的事件从管道读取放入事件集合(eventItems)中，返回发生的事件数目eventCount，如果没有事件，epoll_wait方法就会让当前线程进入休眠，如果休眠timeout后还没有其他线程写入事件唤醒，就会返回，而此时返回的eventCount == 0，表示已经超时，timeout就是从java层一直传过来的nextPollTimeoutMillis，它的含义和nextPollTimeoutMillis一样，当timeout == -1时，表示native层的消息队列中没有消息，会一直等待下去，直到被唤醒，当timeout = 0时或到达timeout 时，它会立即返回。 我们发现epoll机制只会把发生了的事件放入事件集合中，这样线程对事件集合的每一个事件的相应IO操作都有意义，这也是epoll机制高效的原因之一。 2、遍历事件集合（eventItems），检测哪一个文件描述符发生了IO事件 遍历事件集合中，如果是mWakeEventFd，就调用awoken方法不断的读取管道数据，直到清空管道，如果是其他的文件描述符发生了IO事件，让它们自己处理相应逻辑。 3、处理native层的Message 只要epoll_wait方法返回后，都会进入Done标记位的代码段, 就开始处理处理native层的Message, 在此之前先讲解一下MessageEnvelope，正如其名字，信封，其结构体定义在Looper.h中，如下: 123456789101112131415//system/core/libutils/Looper.hclass Looper : public RefBase &#123; struct MessageEnvelope &#123; MessageEnvelope() : uptime(0) &#123; &#125; MessageEnvelope(nsecs_t u, const sp&lt;MessageHandler&gt; h, const Message&amp; m) : uptime(u), handler(h), message(m) &#123;&#125; nsecs_t uptime; //收信人handler sp&lt;MessageHandler&gt; handler; //信息内容message Message message; &#125;; //...&#125; MessageEnvelope里面记录着收信人（handler，MessageHandler类型，是一个消息处理类），发信时间(uptime)，信件内容(message，Message类型)，Message结构体，消息处理类MessageHandler都定义在Looper.h文件中, 在java层中，消息队列是一个链表，在native层中，消息队列是一个C++的Vector向量，Vector存放的是MessageEnvelope元素，接下来就进入一个while循环，里面会判断消息是否达到执行时间，如果到达执行时间，就会取出信封中的MessageHandler和Message，把Message交给MessageHandler的handlerMessage方法处理；如果没有到达执行时间，就会更新mNextMessageUptime为消息的执行时间，这样在下一次轮询时，如果由于java层没有消息导致timeoutMillis等于-1，就会根据mNextMessageUptime更新timeoutMillis为需要等待执行的时间，超时后返回继续处理native层消息队列的头部信息。 我们跟着MessageQueue#nativePollOnce()一路走下来，小结一下： 1、当在java层通过Looper启动消息循环后，就会走到MessageQueue的nativePollOnce方法，在该方法native实现中，会把保存在java层的mPtr再转换为NativeMessageQueue； 2、然后调用NativeMessageQueue的pollOnce方法，该方法中最终会调用native层的Looper的pollInner方法，Looper的pollInner方法是阻塞方法，等从管道取到事件或超时就会返回，并通过native层的Handler处理native层的Message消息； 3、处理完native层消息后，又会返回到java层处理java层的消息，这俩个层次的消息都通过java层的Looper消息循环进行不断的获取，处理等操作. 可以看到，native层的NativeMessageQueue实际上并没有做什么实际工作，只是把操作转发给native层的Looper，而native层的Looper则扮演了java层的Handle角色，它可以取出，发送，处理消息， 3、nativeWake()我们在Java层通过Hanlder发送消息时，实际是把消息添加到消息队列，Handler.sendXX -&gt; Handler.enqueueMessage -&gt; MessageQueuue.enqueueMessage，最终会调用到MessageQueue的enqueueMessage方法,，如下： 12345678910//MessageQueue.javaboolean enqueueMessage(Message msg, long when) &#123; //... synchronized (this) &#123; //... if (needWake) &#123; nativeWake(mPtr); &#125; &#125;&#125; 该方法中如果需要进行唤醒MessageQueuue的话，都会调用到nativeWake方法,，MessageQueue的nativeWake方法的实现在android_os_MessageQueue.cpp文件中的android_os_MessageQueue_nativeWake方法中，该方法的源码如下: 12345//frameworks/base/core/jni/android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;wake();&#125;首先把传递进来的ptr转换为NativeMessageQueue，然后调用NativeMessageQueue的wake函数，该函数源码如下: 1234//frameworks/base/core/jni/android_os_MessageQueue.cppvoid NativeMessageQueue::wake() &#123; mLooper-&gt;wake();&#125;前面说过在native层中NativeMessageQueue只是一个代理Looper的角色，该方法把操作转发给native层的Looper，Looper的wake方法核心源码如下: 1234567//system/core/libutils/Looper.cppvoid Looper::wake() &#123; uint64_t inc = 1; //使用write函数通过mWakeEventFd往管道写入字符inc ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t))); //...&#125; Looper的wake方法其实是使用write函数通过mWakeEventFd往管道写入字符inc，其中TEMP_FAILURE_RETRY 是一个宏定义， 当执行write方法失败后，会不断重复执行，直到执行成功为止，在nativeinit中，我们已经通过epoll_create方法监听了mWakeEventFd的可读事件，当mWakeEventFd可读时，epoll文件描述符就会监听到，这时epoll_wait方法就会从管道中读取事件返回，返回后就执行消息处理逻辑，所以这里的往管道写入字符inc，其实起到一个通知的作用，告诉监听的线程有消息插入了消息队列了，快点醒过来(因为进入了休眠状态)处理一下。 我们跟着MessageQueue#nativeWake一路走下来，小结一下： 1、在java层插入消息到消息队列后，就会根据需要判断是否要调用nativeWake方法，如果调用，就转到2。 2、在nativeWake方法native实现中，会把保存在java层的mPtr再转换为NativeMessageQueue，然后调用NativeMessageQueue的wake方法，最终调用Looper的wake方法。 3、前面讲到Looper::pollInner方法是一个阻塞操作，当管道中没有事件时当前线程就会进入休眠等待，当管道有事件就会立即返回，从管道中读取事件并处理，而Looper::wake方法就是一个唤醒操作，它就是通过前面创建的唤醒事件文件描述符mWakeEventFd来往管道中写入内容，这时另外等待管道事件的线程就会被唤醒处理事件。 4、小结1、在创建java层的MessageQueue对象同时会在构造中调用nativeInit方法创建native层的NativeMessageQueue，在创建NativeMessageQueue同时会在构造中创建native层的Looper对象，并把它保存到TLS区域中，然后返回NativeMessageQueue的指针给java层的mPtr保存； 2、在创建Looper时会在构造中通过管道与epoll机制建立一套native层的消息机制，它首先创建一个唤醒文件描述符mWakeEventFd，然后使用epoll_create方法创建一个epoll文件描述符mEpollFd和管道，然后使用epoll_ctl把mWakeEventFd添加到mEpollFd的监控范围内； 3、当java层使用Handler发送消息时，会把消息插入到消息队列中，然后根据情况调用nativeWake方法唤醒阻塞线程，nativeWake方法会调用到native层的Looper的wake方法，里面会通过mWakeEventFd往管道中写入一个字符，唤醒阻塞线程处理消息； 4、当java层使用Looper的loop方法取消息时，如果没有消息，调用nativePollOnce方法进入阻塞状态，这时nativePollOnce方法会调用到native层的Looper的pollInner方法，里面会使用epoll_wait等待事件发生或超时，当mEpollFd监听的任何文件描述符（包括mWakeEventFd）的相应IO事件发生时，epoll_wait方法就会返回，返回就会通过native层的MessageHandler处理native层的Message，处理完native层消息后，再返回处理java层的消息。 总结Java层和Native层的MessageQueue通过JNI建立关联，从而使得MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理native层消息，而Handler/Looper/Message这三大类在Java层与Native层之间没有任何的关联，只是分别在Java层和Native层的消息模型中具有相似的功能，都是彼此独立的，各自实现相应的逻辑。 这里我们可以回答为什么java层的loop方法是死循环但却不会消耗性能这个问题： 因为java层的消息机制是依赖native层的消息机制来实现的，而native层的消息机制是通过Linux的管道和epoll机制实现的，epoll机制是一种高效的IO多路复用机制， 它使用一个文件描述符管理多个描述符，java层通过mPtr指针也就共享了native层的epoll机制的高效性，当loop方法中取不到消息时，便阻塞在MessageQueue的next方法，而next方法阻塞在nativePollOnce方法，nativePollOnce方法通过JNI调用进入到native层中去，最终nativePollOnce方法阻塞在epoll_wait方法中，epoll_wait方法会让当前线程释放CPU资源进入休眠状态，等到下一个消息到达(mWakeEventFd会往管道写入字符)或监听的其他事件发生时就会唤醒线程，然后处理消息，所以就算loop方法是死循环，当线程空闲时，它会进入休眠状态，不会消耗大量的CPU资源。 以上就是本文的所有内容，希望大家有所收获。 参考资料： epoll、looper.loop主线程阻塞 Android消息机制2-Handler","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"handler","slug":"handler","permalink":"http://yoursite.com/tags/handler/"},{"name":"native","slug":"native","permalink":"http://yoursite.com/tags/native/"}]},{"title":"Android消息机制(java层)","date":"2019-02-21T05:33:11.000Z","path":"2019/02/21/Android消息机制java层/","text":"前言Android的消息机制用于同进程的线程间通信，它是由MessageQueue，Message，Looper，Handler共同组成，Android中大量的交互都是通过消息机制，比如四大组件启动过程与服务的交互、View的绘制、更新等都离不开消息机制，所以Android在某种意义上也可以说成是一个以消息驱动的系统，在Android中消息机制的运作分为java层和native层，它们之间的运作机制不一样，本文讲解的是java层的消息机制，如果你想了解native层的消息机制，可以阅读： Android消息机制(native层) 但其实java层的消息机制的核心功能都交给了native层的消息机制来完成，但作为应用开发，首先要掌握java层的消息机制。 本文源码基于Android8.0，源码相关位置:frameworks/base/core/java/android/os/.java (\\代表MessageQueue、Handler、Looper、Message) 消息机制概述Android应用的每个事件都会转化为一个系统消息即Message，消息中包含了事件的相关信息和消息的处理人即Handler，消息要通过Handler发送，最终被投递到一个消息队列中即MessageQueue，它维护了一个待处理的消息列表，然后通过Looper开启了一个消息循环不断地从这个队列中取出消息，当从消息队列取出一个消息后，Looper根据消息的处理人（target）将此消息分发给相应的Handle处理，整个过程如下图所示。 它们的工作原理就像工厂的生产线，Looper是发动机，MessageQueue是传送带，Handler是工人，Message则是待处理的产品。 java层消息机制架构图 Looper — 是每个线程的MessageQueue管家，里面有一个MessageQueue消息队列，负责把消息从MessageQueue中取出并把消息传递到Handler中去，每个线程只有一个Looper； MessageQueue — 消息队列，有一组待处理的Message，主要用于存放所有通过Handler发送的消息，每个线程只有一个MessageQueue； Message — 是线程之间传递的消息，里面有一个用于处理消息的Handler； Handler — 主要用于发送和处理消息，里面有Looper和MessageQueue。 简单使用在开发中，我们在子线程中执行完操作后通常需要更新UI，但我们都知道不能在子线程中更新UI，此时我们就要通过Handler将一个消息post到UI线程中，然后再在Handler中的handleMessage方法中进行处理，如果我们不传递UI线程所属的Looper去创建Handler，那么该Handler必须在主线程中创建，如下： 1234567891011121314//在主线程中创建Handler Handler mHandler = new Handler（）&#123; @Override public void handleMessage(Message msg)&#123; //更新UI &#125;&#125;//在子线程中进行耗时操作new Thread（）&#123; public void run()&#123; mHandler.sendEmptyMessage(0); &#125;&#125; 以上就是我们平时使用Handler的常规用法了。 接下来我们以应用主线程(又叫做UI线程)的消息机制运作为例讲解Android消息机制的原理。 源码分析1、 Looper的创建我们知道Android应用程序的入口实际上是ActivityThread.main方法，而应用的消息循环也是在这个方法中创建，具体源码如下： 123456789//ActivityThread.java public static void main(String[] args) &#123; //... //1、创建消息循环Looper Looper.prepareMainLooper(); //... //2、执行消息循环 Looper.loop(); &#125; 我们关注注释1，ActivityThread调用了Looper的prepareMainLooper方法来创建Looper实例，Looper的prepareMainLooper方法如下： 123456789101112131415161718192021222324252627282930//Looper.java public static void prepareMainLooper() &#123; //1、创建不允许退出的Looper prepare(false); synchronized (Looper.class) &#123;//保证只有一个线程执行 if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; //2、将刚刚创建的Looper实例赋值给sMainLooper //sMainLooper字段是Looper类中专门为UI线程保留的，只要某个线程调用了prepareMainLooper方法，把它创建的Looper实例赋值给sMainLooper，它就可以成为UI线程，prepareMainLooper方法只允许执行一次 sMainLooper = myLooper(); &#125;&#125;private static void prepare(boolean quitAllowed)&#123;//quitAllowed表示是否允许Looper运行时退出 //Looper.prepare()只能执行一次 if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; //把Looper保存到TLS中 sThreadLocal.set(new Looper(quitAllowed));&#125;public static @Nullable Looper myLooper() &#123; //获取当前线程TLS区域的Looper return sThreadLocal.get();&#125;private static Looper sMainLooper; // guarded by Looper.classstatic final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); 线程在调用prepareMainLooper方法后，就代表它成为了一个UI线程，可以看到prepareMainLooper方法中是调用Looper的prepare方法来创建Looper实例，当要获取创建的Looper实例时，是通过Looper的myLooper方法来获取的，在调用prepare方法时，会把创建的Looper实例set到ThreadLocal中，当获取时也会从ThreadLocal中通过get方法获取，那么ThreadLocal是什么？这里简单介绍一下ThreadLocal： ThreadLocal：线程本地存储区（Thread Local Storage，简称为TLS），每 个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。 它的常用操作方法有：ThreadLocal.set(T value)：将value存储到当前线程的TLS区域。ThreadLocal.get()：获取当前线程TLS区域的数据 关于ThreadLocal更多信息可以查看ThreadLocal原理解析. ThreadLocal的get()和set()方法操作的类型都是泛型，我们从ThreadLocal在Looper中的定义可以看出，sThreadLocal的get()和set()操作的类型都是Looper类型, 所以，由于ThreadLocal的作用，每个线程只能保存一个Looper，不同线程的Looper是不相同的，这样，通过调用Looper.prepare(false)方法，UI线程中就保存了它对应的、唯一的Looper实例，当在UI线程调用Looper.myLooper方法时它就会返回UI线程关联的Looper实例，当然，如果你在子线程中想要获得UI线程关联的Looper实例，就需要调用getMainLooper方法，该方法如下： 123456public static Looper getMainLooper() &#123; synchronized (Looper.class) &#123; //返回UI线程的Looper实例 return sMainLooper; &#125;&#125; 以上就是UI线程的Looper的创建过程，执行ActivityThread.main后，应用程序就启动了，UI的消息循环也在Looper.loop方法中启动，此后Looper会一直从消息队列中取出消息，用户或系统通过Handler不断往消息队列中添加消息，这些消息不断的被取出，处理，回收，使得应用运转起来。 我们在平时开发时，一般是使用不带参数的prepare()方法来创建子线程对应的Looper实例，如下： 12345//我们平时使用的prepare方法public static void prepare() &#123; //quitAllowed = true prepare(true);&#125; 和UI线程的区别是，UI线程的Looper是不允许推出的，而我们的Looper一般是允许退出的。 2、MessageQueue的创建我们在上面知道，调用Looper的prepare方法就会创建Looper实例，同时会把Looper实例通过ThreadLocal保存到线程中，在创建Looper时还会同时在构造中创建MessageQueue实例，如下： 12345678//Looper.javafinal MessageQueue mQueue;//Looper唯一的构造函数private Looper(boolean quitAllowed) &#123; //可以看到MessageQueue是在Looper中创建的 mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; Looper只有这一个构造函数，并且它是私有的，所以我们只能通过Looper的prepare方法创建Looper实例，由于ThreadLocal，每个线程最多只能对应一个Looper实例，而每个Looper内部只有一个MessageQueue实例，推出：每个线程最多对应一个MessageQueue实例。 我们看一下MessageQueue的构造，如下： 1234567//MessageQueue.javaprivate long mPtr; // used by native codeMessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; //通过native方法初始化消息队列，其中mPtr是供native代码使用 mPtr = nativeInit();&#125; MessageQueue的构造中会通过native方法在native层创建一个属于native层的消息队列NativeMessageQueue，然后把NativeMessageQueue的地址返回给java层保存在mPtr中，java层和native层之间的通信就通过这个mPtr指针。 MessageQueue是消息机制的核心类，它是java层和native层的连接纽带，它里面有大量的native方法，Android有俩套消息机制（java层和native层，实现不一样），但本文只讲解java层的消息机制，不会涉及到native层. 关于native层的查看Android消息机制（native层） 我们通过Looper的myQueue方法就能获取到它关联的MessageQueue实例，如下： 12345//Looper.javapublic static @NonNull MessageQueue myQueue() &#123; //先通过TLS获取Looper实例，再从对应的Looper中获取MessageQueue实例 return myLooper().mQueue;&#125; 3、消息循环的运行在ActivityThread的mian方法在创建Looper后，通过Looper.loop方法就启动了消息循环，这个函数会不断的从MessageQueue中取出消息、处理消息，我们点进此方法看一下它的源码： 123456789101112131415161718192021222324//Looper.javapublic static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; //从Looper中取出MessageQueue final MessageQueue queue = me.mQueue; //... for (;;) &#123; //1、从MessageQueue中取出消息，没有消息时会阻塞等待 Message msg = queue.next(); //next()返回了null，表示MessageQueue正在退出，即调用了Looper的quit或quitSafely方法 if (msg == null) &#123; return; &#125; //... //2、分发消息 msg.target.dispatchMessage(msg); //... //3、回收消息 msg.recycleUnchecked(); &#125;&#125; loop()中是一个死循环，我们关注注释1，loop()会调用MessageQueue的next()来获取最新的消息，当没有消息时，next()会一直阻塞在那里，这也导致loop()阻塞，唯一跳出循环的条件是next()返回null，这时代表Looper的quit()或quitSafely()被调用，从而调用MessageQueue的quit()来通知消息队列退出，如下： 123456789//Looper.javapublic void quit() &#123; mQueue.quit(false);&#125;//quitSafely和quit方法的区别是，quitSafely方法会等MessageQueue中所有的消息处理完后才退出，而quit会直接退出public void quitSafely() &#123; mQueue.quit(true);&#125; 所以MessageQueue的next()是最关键的函数，我们来看看next函数的关键代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//MessageQueue.javaMessage next() &#123; //mPtr是在构造中被赋值，是指向native层的MessageQueue final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; int nextPollTimeoutMillis = 0; //一个死循环，里面分为两部分，1、处理java层消息；2、如果没有消息处理，执行IdleHandler for(;;)&#123; //... //Part1：获取java层的消息处理 //nativePollOnce方法用于处理native层消息，是一个阻塞操作 //它在这两种情况下返回：1、等待nextPollTimeoutMillis时长后；2、MessageQueue被唤醒 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); Message prevMsg = null; //mMessages是java层的消息队列，这里表示取出消息队列的第一个消息 Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123;//遇到同步屏障（target为null的消息） //在do-while中找到异步消息，优先处理异步消息 //异步消息的isAsynchronous方法返回true do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123;//有消息 if (now &lt; msg.when) &#123; //消息还没到触发时间 //设置下一次轮询的超时时长（等待时长） nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123;//now == msg.when, 消息到达触发时间 mBlocked = false; //从mMessages的头部获取一条消息并返回 if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; //设置消息的使用状态，即flags |= FLAG_IN_US msg.markInUse(); //返回这个消息 return msg; &#125; &#125; else &#123;//msg == null，没有消息 //设置nextPollTimeoutMillis为-1，准备进入阻塞，等待MessageQueue被唤醒 nextPollTimeoutMillis = -1; &#125; //调用了quit方法 if (mQuitting) &#123; dispose(); return null; &#125; //当处于以下2种情况时，就会执行到Part2： //1、mMessages == null，java层没有消息处理 //2、now &lt; msg.when，有消息处理，但是还没有到消息的执行时间 //1、2两种情况都表明线程的消息队列处于空闲状态，处于空闲状态，就会执行IdleHandler //Part2：没有消息处理，执行IdleHandler //mIdleHandlers表示IdleHandler列表 //pendingIdleHandlerCount表示需要执行的IdleHandler的数量 if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; //没有IdleHandler需要处理，可直接进入阻塞 mBlocked = true; continue; &#125; //有IdleHandler需要处理 if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; //把mIdleHandlers列表转成mPendingIdleHandlers数组 mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; //遍历mPendingIdleHandlers数组 for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; //取出IdleHandler final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; //执行IdleHandler的queueIdle方法，通过返回值由自己决定是否保持存活状态 keep = idler.queueIdle(); &#125; //...省略异常处理 if (!keep) &#123; // 不需要存活，移除 synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; //重置pendingIdleHandlerCount和nextPollTimeoutMillis为0 pendingIdleHandlerCount = 0; //nextPollTimeoutMillis为0，表示下一次循环会马上从Messages中取出一个Message判断是否到达执行时间 //因为IdleHandler在处理事件的时间里，有可能有新的消息发送来过来，需要重新检查 nextPollTimeoutMillis = 0; &#125;&#125; MessageQueue的next方法有点长，但是它里面的逻辑是很好理解的，它主要是通过一个死循环不断的返回Message给Looper处理，next方法可以分为两部分阅读： 1、获取java层的消息处理： 我们看Part1，先执行nativePollOnce方法，它是一个阻塞操作，其中nextPollTimeoutMillis代表下一次等待的超时时长，当nextPollTimeoutMillis = 0时或到达nextPollTimeoutMillis时，它会立即返回；当nextPollTimeoutMillis = -1时，表示MessageQueue中没有消息，会一直等待下去，直到Hanlder往消息队列投递消息，执行nativeWake方法后，MessageQueue被唤醒，nativePollOnce就会返回，但它此时并不是立即返回，它会先处理完native层的消息后，再返回，然后获取java层的消息处理； 接着next方法就会从mMessages链表的表头中获取一个消息，首先判断它是否是同步屏障，同步屏障就是target为null的Message，如果遇到同步屏障，MessageQueue就会优先获取异步消息处理，异步消息就是优先级比同步消息高的消息，我们平时发送的就是同步消息，通过Message的setAsynchronous(true)可以把同步消息变成异步消息，不管是同步还是异步，都是Message，获取到Message后； 接着判断Message是否到达它的执行时间(if(now == msg.when))，如果到达了执行时间，next方法就会返回这条消息给Looper处理，并将其从单链表中删除；如果还没有到达执行时间，就设置nextPollTimeoutMillis为下一次等待超时时长，等待下次再次取出判断，可以发现虽然MessageQueue叫消息队列，但它却不是用队列实现的，而是用链表实现的。 通过MessageQueue的postSyncBarrier方法可以添加一个同步屏障，通过removeSyncBarrier方法可以移除相应的同步屏障，在Android，Choreographer机制中就使用到了异步消息，在View树绘制之前，会先往UI线程的MessageQueue添加一个同步屏障，拦截同步消息，然后发送一个异步消息，等待VSYN信号到来，触发View树绘制，这样就可以让绘制任务优先执行。 2、没有消息处理，遍历IdleHandler列表，执行IdleHandler的queueIdle方法： IdleHandler是什么？IdleHandler是一个接口，它里面只有一个queueIdle方法，Idle是空闲的意思，在MessageQueue空闲的时候会执行IdleHandler的queueIdle方法，我们可以通过MessageQueue的addIdleHandler方法添加我们自定义的IdleHandler到mIdleHandlers列表中，如下： 123456//MessageQueue.javaprivate final ArrayList&lt;IdleHandler&gt; mIdleHandlers = new ArrayList&lt;IdleHandler&gt;(); public void addIdleHandler(@NonNull IdleHandler handler) &#123; //... mIdleHandlers.add(handler);&#125; MessageQueue空闲，就代表它处于以下两种情况： (1) mMessages == null，消息队列中没有消息处理； (2) now &lt; msg.when，有消息处理，但是还没有到消息的执行时间. 以上两种情况之一都会触发next方法遍历IdleHandler列表，执行IdleHandler的queueIdle方法的操作。 在Android中，我们平时所说的线程空闲其实就是指线程的MessageQueue空闲，这时就可以执行我们添加的IdleHandler，例如在LeakCanary中，它通过添加IdleHandler，在UI线程空闲时执行内存泄漏的判断逻辑. 4、消息的发送到这里UI线程已经启动了消息循环，那么消息从何而来？消息是由系统产生，然后通过Hanlder发送到MessageQueue中，Handler就是用来处理和发送消息的，应用程序的Handler在ActivityThread中被创建，如下： 12345678910111213141516171819202122//ActivityThread.java final H mH = new H();//H定义如下，继承Hanldler//里面定义了大量的字段，跟Activity的启动，Application的绑定等有关class H extends Handler &#123; public static final int BIND_APPLICATION = 110; public static final int EXIT_APPLICATION = 111; public static final int CREATE_SERVICE = 114; //.... public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case BIND_APPLICATION: //... case EXIT_APPLICATION: //... case CREATE_SERVICE: //... //... &#125; //... &#125; mH就是应用程序内部使用的Handler，我们外部是不可使用的，应用程序通过Handler往MessageQueue中投递消息，并通过Handler的handlerMessage方法处理消息，而我们在外部也可以使用自己创建的Handler往UI线程的MessageQueue投递消息。 既然Handle可以往MessageQueue中投递消息，这说明Handler要和相应的MessageQueue关联，我们看Handler的构造函数，Handler有两种构造函数： 一种是指定Callback的构造函数，Callback默认为null，如下： 12345678910111213141516171819202122232425262728//Handler.javapublic Handler() &#123; this(null, false);&#125;public Handler(Callback callback) &#123; this(callback, false);&#125;public Handler(boolean async) &#123; this(null, async);&#125;public Handler(Callback callback, boolean async) &#123; //... //先通过TLS获取Looper实例，与Looper关联 mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( \"Can't create handler inside thread \" + Thread.currentThread() + \" that has not called Looper.prepare()\"); &#125; //通过Looper获取MessageQueue，与MessageQueue关联 mQueue = mLooper.mQueue; //Callback的作用在消息的分发中会讲到 mCallback = callback; mAsynchronous = async;&#125; 在构造中如果通过Looper.myLooper方法获取不到Looper，就会抛出“Can’t create handler inside threadxx that has not called Looper.prepare()”异常，所以如果我们在子线程中使用Handler的默认构造，没有先调用Looper.prepare方法就创建Handler的话，就会抛出上述异常，但是在UI线程中就不会，因为应用程序启动时就已经调用了Looper的prepareMainLooper方法，在该方法里面已经调用了prepare(false)方法创建了UI线程的Looper实例，无需我们再次调用Looper.prepare方法。 另外一种是指定Looper的构造函数(如果不指定，Looper默认从当前线程的TLS区域获取)，如下： 1234567891011121314151617//Handler.javapublic Handler(Looper looper) &#123; this(looper, null, false);&#125;public Handler(Looper looper, Callback callback) &#123; this(looper, callback, false);&#125;public Handler(Looper looper, Callback callback, boolean async) &#123; //与Looper关联 mLooper = looper; //通过Looper获取MessageQueue，与MessageQueue关联 mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 不管哪一种构造函数，可以看到，在Handler的最终构造中都会和对应线程的Looper、MessageQueue关联，所以就算Hander在子线程创建，我们也可以通过: Handler = new Handler(Looper.getMainLooper)；把Handler关联上UI线程的Looper，并通过Looper关联上UI线程的MessageQueue，这样，就能把Handler运行在UI线程中。 消息的发送可以通过handler的一系列post方法和一系列的send方法，一系列post方法最终通过一系列send方法来实现，一系列send方法最终通过enqueueMessage方法来发送消息，如下： 可以发现Handler所有发送消息的方法，最终都是调用Handler的enqueueMessag方法，该方法源码如下： 12345678//Handler.javaprivate boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; 在该方法中，首先把Message的target字段设置为当前发送消息的Handler, 然后设置Message是否是异步消息，最后把所有逻辑交给MessageQueue的enqueueMessage方法，该方法的相应源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//MessageQueue.javaboolean enqueueMessage(Message msg, long when) &#123; //... synchronized (this) &#123; //正在退出时，回收msg，加入到消息池 if (mQuitting) &#123; //... msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; boolean needWake; //取mMessages链表头部的消息 Message p = mMessages; //满足以下2种情况之一就把msg插入到链表头部： //1、如果p为null，则代表mMessages没有消息 //2、如果when == 0 或 when &lt; p.when, 则代表msg的触发时间是链表中最早的 if (p == null || when == 0 || when &lt; p.when) &#123; msg.next = p; mMessages = msg; needWake = mBlocked;//如果处于阻塞状态，需要唤醒 &#125; else &#123;//3、如果p != null且msg并不是最早触发的，就在链表中找一个位置把msg插进去 //如果处于阻塞状态，并且链表头部是一个同步屏障，并且插入消息是最早的异步消息，需要唤醒 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; //下面是一个链表的插入操作, 将消息按时间顺序插入到mMessages中 for (;;) &#123; prev = p; p = p.next； if (p == null || when &lt; p.when) &#123; break; &#125; //如果在找到插入位置之前，发现了异步消息的存在，不需要唤醒 if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; prev.next = msg; &#125; //nativeWake方法会唤醒当前线程的MessageQueue if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; MessageQueue的enqueueMessage方法主要是一个链表的插入操作，返回true就代表插入成功，返回false就代表插入失败，它主要分为以下3种情况： 1、插入链表头部： mMessages是按照Message触发时间的先后顺序排列的，越早触发的排得越前，头部的消息是将要最早触发的消息，当有消息需要加入mMessages时，如果mMessages为空或这个消息是最早触发的，就会直接插入链表头部； 2、插入链表的中间位置： 如果消息链表不为空并且插入的消息不是最早触发的，就会从链表头部开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序，这一个过程可以理解为插入排序； 3、判断是否调用nativeWake方法 最后，根据needWake是否为true，来决定是否调用nativeWake方法唤醒当前线程的MessageQueue，needWake默认为false，即不需要唤醒，needWake为true就代表此时处于以下2种情况： （1）如果插入消息在链表头部并且mBlocked == true，表示此时nativePollOnce方法进入阻塞状态，等待被唤醒返回； （2）如果插入消息在链表中间，消息链表的头部是一个同步屏障，同时插入的消息是链表中最早的异步消息，需要唤醒，即时处理异步消息。 5、消息的分发在消息循环的运行中，如果loop方法中MessageQueue的next方法返回了Message，那么就会执行到这一句：*msg.target.dispatchMessage(msg)*；Looper会把这条消息交给该Message的target（Handler对象）来处理, 实际上是转了一圈，Handler把消息发送给MessageQueue，Looper又把这个消息给Handler处理，下面来看消息分发逻辑，dispatchMessage()源码如下： 12345678910111213141516//Handler.javapublic void dispatchMessage(Message msg) &#123; //1、检查msg的callback是否为空 if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; //2、Handler的mCallback是否为空 if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; //3、我们平常处理消息的方法，该方法默认为空，Handler子类通过覆写该方法来完成具体的逻辑。 handleMessage(msg); &#125;&#125; 里面代码量很少，分为3步： 1、检查msg.callback是否为空，不为空则执行” handleCallback(msg)”, 源码如下: 1234//Handler.javaprivate static void handleCallback(Message message) &#123; message.callback.run();&#125; msg.callback其实是一个Runnable对象，当我们通过Handler来post一个Runnable消息时，它就不为空，如下： 12345678910//Handler.javapublic final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125;//把Runnable对象包装成Message对象private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125; 可以看到，在post(Runnable r)中，会把Runnable包装成Message对象，并把Runnable设置给Message的callback字段，然后发送此消息。 2、如果msg.callback为空，检查mCallback是否为空，mCallback是一个Callback接口，定义如下： 1234//Handler.javapublic interface Callback &#123; public boolean handleMessage(Message msg);&#125; 当我们这样：Handler handler = new Handler(callback) 来创建Handler时, mCallback就不为空，它的意义是当我们不想派生Handler的子类重写handleMessage()来处理消息时，就可以通过Callback来实现。 3、如果mCallback为空，最后调用Handler的handleMessage方法来处理消息，这就是我们平时熟悉的处理消息的方法。 从1、2、3可以看出，在Handler中，处理消息的回调的优先级为：Message的Callback &gt; Handler的Callback &gt; Handler的handleMessage方法。 6、消息的回收复用1、消息的复用 前面多次提到了Message，当我们通过Handler的obtainMessage()或Message的obtain()获取一个Message对象时，系统并不是每次都new一个出来，而是先从消息池中（sPool）尝试获取一个Message。Handler的obtainMessage()最终是调用了Message的obtain()，Message的obtain方法如下: 123456789101112131415//Message.javapublic static Message obtain() &#123; synchronized (sPoolSync) &#123; //从sPool头部取出一个Message对象返回，并把消息从链表断开（即把sPool指向下一个Message） if (sPool != null) &#123; Message m = sPool; sPool = m.next; m.next = null; m.flags = 0;//清除in-use flag sPoolSize--;//消息池的大小进行减1操作 return m; &#125; &#125; //消息池中没有Message，直接new一个返回 return new Message(); sPool的数据类型为Message，通过next成员变量，维护一个消息池，消息池的默认大小为50。定义如下: 12345678public final class Message implements Parcelable &#123; public static final Object sPoolSync = new Object();//用于在获取Message对象时进行同步锁 private static int sPoolSize = 0;//池的大小 private static final int MAX_POOL_SIZE = 50;//池的可用大小 private static Message sPool; Message next; //...&#125; 虽然叫消息池，其实是通过链表实现的，每个Message都有一个同类型的next字段，这个next就是指向下一个可用的Message，最后一个可用的Message的next为空，这样所有可用的Message对象就通过next串成一个Message池，sPool指向池中的第一个Message，复用消息其实是从链表的头部获取一个Message返回。 2、消息的回收 我们发现在obtain方法中新创建Message对象时，并不会直接把它放到池中再返回，那么Message对象是什么时候被放进消息池中的呢？是在回收Message时把它放入池中，Message中也有类似Bitmap那样的recycler函数，如下： 123456789101112131415161718192021222324252627282930313233343536//Message.javapublic void recycle() &#123; //判断消息是否正在使用 if (isInUse()) &#123; if (gCheckRecycle) &#123;//Android 5.0以后的版本默认为true,之前的版本默认为false. throw new IllegalStateException(\"This message cannot be recycled because it \" + \"is still in use.\"); &#125; return; &#125; recycleUnchecked(); &#125; //对于不再使用的消息，加入到消息池 void recycleUnchecked() &#123; //将消息标示位置为IN_USE，并清空消息所有的参数 flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) &#123; //当消息池没有满时，将Message对象加入消息池（即把Message插入链表头部） if (sPoolSize &lt; MAX_POOL_SIZE) &#123; next = sPool; sPool = this; sPoolSize++;//消息池的可用大小进行加1操作 &#125; &#125; &#125; recycler函数先判断该Message是否还在使用，如果还在使用，就会抛异常，否则就调用recyclerUnchecked函数根据MAX_POOL_SIZE判断是否把该消息回收，回收前还要先清空该消息的各个字段，回收消息就是把自身插入到链表的表头。 通过消息的复用回收，减少Message对象不断创建与销毁的过程，提升了效率。 7、小结1、创建Looper时，只能通过Looper的prepare方法创建，在创建Looper时会在内部创建一个MessageQueue，并把Looper保存在线程的TLS区域中，一个线程只能对应一个Looper，一个Looper只能对应一个MessageQueue； 2、在创建MessageQueue时，MessageQueue与NativeMessageQueue建立连接，NativeMessageQueue存储地址存于MessageQueue的mPtr字段中，java层和native通过mPtr字段进行通信（native端通过Linux的epoll机制建立起消息机制）; 3、由于ThreadLocal的作用，Looper属于某个线程，而MessageQueue存储在Looper中，所以MessageQueue则通过Looper与特定的线程关联上，而Handler在构造中又与Looper和MessageQueue相关联，当我们通过Handler发送消息时，消息就会被插入到Handler关联的MessageQueue中，而Looper会不断的轮询消息，从MessageQueue中取出消息给相应的Handler处理，所以最终通过Handler发送的消息就会被执行到Looper所在线程上，这就是Handler线程切换的原理，无论发送消息的Handler对象处于什么线程，最终处理消息的都是Looper所在线程； 4、Looper从MessageQueue中取出消息后，会交给消息的target(Handler)处理，在Handler中，处理消息的回调的优先级为：Message的Callback &gt; Handler的Callback &gt; Handler的handleMessage方法； 5、因为应用程序启动时在ActivityThread.main方法中的Looper.prepareMainLooper()中已经调用了Looper.prepare(false),所以在主线程中创建Handler无需我们手动调用Looper.prepare()，而在子线程中，如果我们不传递UI线程所属的Looper去创建Handler，那么就需要调用Looper.prepare()后再创建Handle来传递消息，因为Handler要和某个线程中的MessageQueue和Looper关联，只有调用Looper.prepare方法，Looper和MessageQueue才属于某个线程； 6、消息池是一个单链表，复用Message时，从头出取出，如果取不到，则新建返回，回收Message时，也从头插入。 结语本文从Android应用UI线程消息循环的创建，消息循环的启动，Handler与Looper、MessageQueue的关联，消息的发送与分发，还有消息的复用这几个角度来讲解了Message，Handler，MessageQueue，Looper之间是如何配合工作，在你了解java层的消息机制是如何运作后，希望大家去了解一下native的消息机制，例如要想知道为什么loop方法是死循环但却不会消耗性能，这些只有native层的消息机制才能给你答案. 除此之外，我们还知道了MessageQueue的IdleHandler的作用，它会在线程空闲时工作，还有异步消息的处理，它的优先级高于同步消息，会被优先处理，还有它们的应用场景，一般我们是在子线程切换到UI线程时使用Handler机制，但其实我们也可以在子线程使用Handler机制，可以参考Android中的HandlerThread，它的底层就是Handler+Thread. 以上就是本文的全部内容，希望大家有所收获。 参考资料： Android消息机制1-Handler","tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"handler","slug":"handler","permalink":"http://yoursite.com/tags/handler/"}]}]